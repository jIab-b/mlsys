#!/usr/bin/env python3
"""Build submission.py from kernel.cu + bindings.py + ptx_lib/*.cuh, then run Modal CLI.

Expected inputs (relative to repo root by default):
  - kernel.cu
  - bindings.py (must reference CUDA_SRC)
  - ptx_lib/*.cuh

If you want to pass custom Modal CLI args, use "--" and then the normal modal/cli.py args.
Example:
  python run.py -- -t sparse_attn -m benchmark --real 3
"""

from __future__ import annotations

import argparse
import subprocess
import sys
from pathlib import Path

ROOT = Path(__file__).resolve().parent
REPO_ROOT = ROOT.parent
# ptx_lib lives at repo root (not nested under submission/)
PTX_LIB = REPO_ROOT / "ptx_lib"

# Strip local ptx_lib includes since we inline headers into CUDA_SRC.
_PTX_INCLUDE_PREFIXES = (
    '#include "ptx_lib/',
    '#include "ptx_',
    '#include <ptx_',
)


def _strip_ptx_includes(text: str) -> str:
    lines = []
    for line in text.splitlines():
        stripped = line.strip()
        if any(stripped.startswith(prefix) for prefix in _PTX_INCLUDE_PREFIXES):
            continue
        lines.append(line)
    return "\n".join(lines)


def _read_text(path: Path) -> str:
    return path.read_text()


def _build_submission(kernel_path: Path, bindings_path: Path, out_path: Path) -> None:
    if not kernel_path.exists():
        raise FileNotFoundError(f"kernel.cu not found: {kernel_path}")
    if not bindings_path.exists():
        raise FileNotFoundError(f"bindings.py not found: {bindings_path}")
    if not PTX_LIB.exists():
        raise FileNotFoundError(f"ptx_lib not found: {PTX_LIB}")

    ptx_headers = sorted(PTX_LIB.glob("*.cuh"))
    if not ptx_headers:
        raise FileNotFoundError(f"No .cuh files found in {PTX_LIB}")

    # Prefer ptx_common.cuh first if present.
    ptx_headers = sorted(
        ptx_headers,
        key=lambda p: (p.name != "ptx_common.cuh", p.name),
    )

    parts = []
    parts.append("# AUTO-GENERATED by run.py\n")
    parts.append("# Do not edit directly; edit kernel.cu/bindings.py/ptx_lib/*.cuh instead.\n\n")
    parts.append("CUDA_SRC = r'''\n")

    for header in ptx_headers:
        parts.append(f"// ----- {header.name} -----\n")
        parts.append(_read_text(header))
        if not parts[-1].endswith("\n"):
            parts.append("\n")
        parts.append("\n")

    parts.append("// ----- kernel.cu -----\n")
    parts.append(_strip_ptx_includes(_read_text(kernel_path)))
    if not parts[-1].endswith("\n"):
        parts.append("\n")

    parts.append("'''\n\n")

    # Append bindings.py verbatim; it should reference CUDA_SRC
    parts.append(_strip_ptx_includes(_read_text(bindings_path)))
    if not parts[-1].endswith("\n"):
        parts.append("\n")

    out_path.write_text("".join(parts))


def main() -> int:
    parser = argparse.ArgumentParser(description="Build submission.py and run Modal eval")
    parser.add_argument("--kernel", default="kernel.cu", help="Path to kernel.cu")
    parser.add_argument("--bindings", default="bindings.py", help="Path to bindings.py")
    parser.add_argument("--out", default="submission.py", help="Output submission.py path")
    parser.add_argument("--build-only", action="store_true", help="Only build submission.py")
    parser.add_argument("args", nargs=argparse.REMAINDER, help="Arguments after -- are passed to modal/cli.py")
    args = parser.parse_args()

    kernel_path = (ROOT / args.kernel).resolve()
    bindings_path = (ROOT / args.bindings).resolve()
    out_path = (ROOT / args.out).resolve()

    _build_submission(kernel_path, bindings_path, out_path)

    if args.build_only:
        return 0

    modal_args = args.args
    if modal_args and modal_args[0] == "--":
        modal_args = modal_args[1:]

    if not modal_args:
        modal_args = ["-t", "sparse_attn", "-m", "benchmark", "--real", "3"]

    cmd = [sys.executable, str(REPO_ROOT / "modal" / "cli.py"), str(out_path)] + modal_args
    return subprocess.call(cmd)


if __name__ == "__main__":
    raise SystemExit(main())
