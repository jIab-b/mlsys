# CUDA Driver API Reference

This document contains the complete CUDA Driver API reference documentation.

## Table of Contents

- [Driver vs Runtime API](#driver-vs-runtime-api)
- [API Synchronization Behavior](#api-synchronization-behavior)
- [Stream Synchronization Behavior](#stream-synchronization-behavior)
- [Graph Object Thread Safety](#graph-object-thread-safety)
- [Version Mixing Rules](#version-mixing-rules)
- [Data Types](#data-types)
- [Error Handling](#error-handling)
- [Initialization](#initialization)
- [Version Management](#version-management)
- [Device Management](#device-management)
- [Device Management (Deprecated)](#device-management-deprecated)
- [Primary Context Management](#primary-context-management)
- [Context Management](#context-management)
- [Context Management (Deprecated)](#context-management-deprecated)
- [Module Management](#module-management)
- [Module Management (Deprecated)](#module-management-deprecated)
- [Library Management](#library-management)
- [Memory Management](#memory-management)
- [Virtual Memory Management](#virtual-memory-management)
- [Stream Ordered Memory Allocator](#stream-ordered-memory-allocator)
- [Multicast Object Management](#multicast-object-management)
- [Unified Addressing](#unified-addressing)
- [Stream Management](#stream-management)
- [Event Management](#event-management)
- [External Resource Interoperability](#external-resource-interoperability)
- [Stream Memory Operations](#stream-memory-operations)
- [Execution Control](#execution-control)
- [Execution Control (Deprecated)](#execution-control-deprecated)
- [Graph Management](#graph-management)
- [Occupancy](#occupancy)
- [Texture Reference Management](#texture-reference-management)
- [Texture Reference (Deprecated)](#texture-reference-deprecated)
- [Surface Reference Management](#surface-reference-management)
- [Surface Reference (Deprecated)](#surface-reference-deprecated)
- [Texture Object Management](#texture-object-management)
- [Surface Object Management](#surface-object-management)
- [Tensor Map Object Management](#tensor-map-object-management)
- [Peer Context Memory Access](#peer-context-memory-access)
- [Graphics Interoperability](#graphics-interoperability)
- [OpenGL Interoperability](#opengl-interoperability)
- [OpenGL Interoperability (Deprecated)](#opengl-interoperability-deprecated)
- [Direct3D 9 Interoperability](#direct3d-9-interoperability)
- [Direct3D 9 (Deprecated)](#direct3d-9-deprecated)
- [Direct3D 10 Interoperability](#direct3d-10-interoperability)
- [Direct3D 10 (Deprecated)](#direct3d-10-deprecated)
- [Direct3D 11 Interoperability](#direct3d-11-interoperability)
- [Direct3D 11 (Deprecated)](#direct3d-11-deprecated)
- [VDPAU Interoperability](#vdpau-interoperability)
- [EGL Interoperability](#egl-interoperability)
- [Profiler Control](#profiler-control)
- [Green Contexts](#green-contexts)
- [Coredump Attributes Control](#coredump-attributes-control)
- [Data Structures](#data-structures)

---

# Driver vs Runtime API

## 1.Â Difference between the driver and runtime APIs

The driver and runtime APIs are very similar and can for the most part be used interchangeably. However, there are some key differences worth noting between the two.

## Complexity vs. control

The runtime API eases device code management by providing implicit primary context initialization and management, and implicit module management. This leads to simpler code, but it also lacks the level of control that the driver API has.

In comparison, the driver API offers more fine-grained control, especially over module loading. Kernel launches are much more complex to implement, as the execution configuration and kernel parameters must be specified with explicit function calls. However, unlike the runtime, where all the kernels are automatically loaded during initialization and stay loaded for as long as the program runs, with the driver API it is possible to only keep the modules that are currently needed loaded, or even dynamically reload modules. The driver API is also language-independent as it only deals with cubin objects.

## Context management

Unless an execution context cudaExecutionContext_t is specified, the runtime API decides itself which context to use for a thread: if a context has been made current to the calling thread through the driver API, the runtime will use that, but if there is no such context, it uses the device execution context which is a "primary context." Primary contexts are created as needed, one per device per process, are reference-counted, and are then destroyed when there are no more references to them. Within one process, all users of the runtime API will share the primary context, unless a context has been made current to each thread or an explicit execution context is specified to the runtime APIs.

Using the runtime API with primary contexts has its tradeoffs, however. It can cause trouble for users writing plug-ins for larger software packages, for example, because if all plug-ins run in the same process, they will all share a context but will likely have no way to communicate with each other. So, if one of them calls cudaDeviceReset() after finishing all its CUDA work, the other plug-ins will fail because the context they were using was destroyed without their knowledge. To avoid this issue, CUDA clients can use the driver API to create and set the current context, and then use the runtime API to work with it. However, contexts may consume significant resources, such as device memory, extra host threads, and performance costs of context switching on the device. This runtime-driver context sharing is important when using the driver API in conjunction with libraries built on the runtime API, such as cuBLAS or cuFFT.

* * *


---

# API Synchronization Behavior

## 2.Â API synchronization behavior

The API provides memcpy/memset functions in both synchronous and asynchronous forms, the latter having an "Async" suffix. This is a misnomer as each function may exhibit synchronous or asynchronous behavior depending on the arguments passed to the function. The synchronous forms of these APIs issue these copies through the default stream.

Any CUDA API call may block or synchronize for various reasons such as contention for or unavailability of internal resources. Such behavior is subject to change and undocumented behavior should not be relied upon.

## Memcpy

In the reference documentation, each memcpy function is categorized as synchronous or asynchronous, corresponding to the definitions below.

**Synchronous**

  1. For transfers from pageable host memory to device memory, a stream sync is performed before the copy is initiated. The function will return once the pageable buffer has been copied to the staging memory for DMA transfer to device memory, but the DMA to final destination may not have completed.

  2. For transfers from pinned host memory to device memory, the function is synchronous with respect to the host.

  3. For transfers from device to either pageable or pinned host memory, the function returns only once the copy has completed.

  4. For transfers from device memory to device memory, no host-side synchronization is performed.

  5. For transfers from any host memory to any host memory, the function is fully synchronous with respect to the host.


**Asynchronous**

  1. For transfers between device memory and pageable host memory, the function might be synchronous with respect to host.

  2. For transfers from any host memory to any host memory, the function is fully synchronous with respect to the host.

  3. If pageable memory must first be staged to pinned memory, the driver may synchronize with the stream and stage the copy into pinned memory.

  4. For all other transfers, the function should be fully asynchronous.


## Memset

The cudaMemset functions are asynchronous with respect to the host except when the target memory is pinned host memory. The Async versions are always asynchronous with respect to the host.

## Kernel Launches

Kernel launches are asynchronous with respect to the host. Details of concurrent kernel execution and data transfers can be found in the CUDA Programmers Guide.

* * *


---

# Stream Synchronization Behavior

## 3.Â Stream synchronization behavior

## Default stream

The default stream, used when 0 is passed as a cudaStream_t or by APIs that operate on a stream implicitly, can be configured to have either [legacy](<stream-sync-behavior.html#stream-sync-behavior__legacy-default-stream>) or [per-thread](<stream-sync-behavior.html#stream-sync-behavior__per-thread-default-stream>) synchronization behavior as described below.

The behavior can be controlled per compilation unit with the \--default-stream nvcc option. Alternatively, per-thread behavior can be enabled by defining the CUDA_API_PER_THREAD_DEFAULT_STREAM macro before including any CUDA headers. Either way, the CUDA_API_PER_THREAD_DEFAULT_STREAM macro will be defined in compilation units using per-thread synchronization behavior.

## Legacy default stream

The legacy default stream is an implicit stream which synchronizes with all other streams in the same CUcontext except for non-blocking streams, described below. (For applications using the runtime APIs only, there will be one context per device.) When an action is taken in the legacy stream such as a kernel launch or cudaStreamWaitEvent(), the legacy stream first waits on all blocking streams, the action is queued in the legacy stream, and then all blocking streams wait on the legacy stream.

For example, the following code launches a kernel k_1 in stream s, then k_2 in the legacy stream, then k_3 in stream s:


    k_1<<<1, 1, 0, s>>>();
    k_2<<<1, 1>>>();
    k_3<<<1, 1, 0, s>>>();

The resulting behavior is that k_2 will block on k_1 and k_3 will block on k_2.

Non-blocking streams which do not synchronize with the legacy stream can be created using the cudaStreamNonBlocking flag with the stream creation APIs.

The legacy default stream can be used explicitly with the CUstream (cudaStream_t) handle CU_STREAM_LEGACY (cudaStreamLegacy).

## Per-thread default stream

The per-thread default stream is an implicit stream local to both the thread and the CUcontext, and which does not synchronize with other streams (just like explicitly created streams). The per-thread default stream is not a non-blocking stream and will synchronize with the legacy default stream if both are used in a program.

The per-thread default stream can be used explicitly with the CUstream (cudaStream_t) handle CU_STREAM_PER_THREAD (cudaStreamPerThread).

* * *


---

# Graph Object Thread Safety

## 4.Â Graph object thread safety

Graph objects (cudaGraph_t, CUgraph) are not internally synchronized and must not be accessed concurrently from multiple threads. API calls accessing the same graph object must be serialized externally.

Note that **this includes APIs which may appear to be read-only** , such as cudaGraphClone() (cuGraphClone()) and cudaGraphInstantiate() (cuGraphInstantiate()). No API or pair of APIs is guaranteed to be safe to call on the same graph object from two different threads without serialization.

* * *


---

# Version Mixing Rules

## 5.Â Rules for version mixing

  1. Starting with CUDA 11.0, the ABI version for the CUDA runtime is bumped every major release. CUDA-defined types, whether opaque handles or structures like cudaDeviceProp, have their ABI tied to the major release of the CUDA runtime. It is unsafe to pass them from function A to function B if those functions have been compiled with different major versions of the toolkit and linked together into the same device executable.

  2. The CUDA Driver API has a per-function ABI denoted with a _v* extension. CUDA-defined types (e.g structs) should not be passed across different ABI versions. For example, an application calling cuMemcpy2D_v2(const CUDA_MEMCPY2D_v2 *pCopy) and using the older version of the struct CUDA_MEMCPY2D_v1 instead of CUDA_MEMCPY2D_v2.

  3. Users should not arbitrarily mix different API versions during the lifetime of a resource. These resources include IPC handles, memory, streams, contexts, events, etc. For example, a user who wants to allocate CUDA memory using cuMemAlloc_v2 should free the memory using cuMemFree_v2 and not cuMemFree.


* * *


---

# Data Types

## 6.1.Â Data types used by CUDA driver

### Classes

structÂ

[CUDA_ARRAY3D_DESCRIPTOR_v2](<structCUDA__ARRAY3D__DESCRIPTOR__v2.html#structCUDA__ARRAY3D__DESCRIPTOR__v2>)

     [](<structCUDA__ARRAY3D__DESCRIPTOR__v2.html#structCUDA__ARRAY3D__DESCRIPTOR__v2>)
structÂ

[CUDA_ARRAY_DESCRIPTOR_v2](<structCUDA__ARRAY__DESCRIPTOR__v2.html#structCUDA__ARRAY__DESCRIPTOR__v2>)

     [](<structCUDA__ARRAY__DESCRIPTOR__v2.html#structCUDA__ARRAY__DESCRIPTOR__v2>)
structÂ

[CUDA_ARRAY_MEMORY_REQUIREMENTS_v1](<structCUDA__ARRAY__MEMORY__REQUIREMENTS__v1.html#structCUDA__ARRAY__MEMORY__REQUIREMENTS__v1>)

     [](<structCUDA__ARRAY__MEMORY__REQUIREMENTS__v1.html#structCUDA__ARRAY__MEMORY__REQUIREMENTS__v1>)
structÂ

[CUDA_ARRAY_SPARSE_PROPERTIES_v1](<structCUDA__ARRAY__SPARSE__PROPERTIES__v1.html#structCUDA__ARRAY__SPARSE__PROPERTIES__v1>)

     [](<structCUDA__ARRAY__SPARSE__PROPERTIES__v1.html#structCUDA__ARRAY__SPARSE__PROPERTIES__v1>)
structÂ

[CUDA_BATCH_MEM_OP_NODE_PARAMS_v1](<structCUDA__BATCH__MEM__OP__NODE__PARAMS__v1.html#structCUDA__BATCH__MEM__OP__NODE__PARAMS__v1>)

     [](<structCUDA__BATCH__MEM__OP__NODE__PARAMS__v1.html#structCUDA__BATCH__MEM__OP__NODE__PARAMS__v1>)
structÂ

[CUDA_BATCH_MEM_OP_NODE_PARAMS_v2](<structCUDA__BATCH__MEM__OP__NODE__PARAMS__v2.html#structCUDA__BATCH__MEM__OP__NODE__PARAMS__v2>)

    [](<structCUDA__BATCH__MEM__OP__NODE__PARAMS__v2.html#structCUDA__BATCH__MEM__OP__NODE__PARAMS__v2>)
structÂ

[CUDA_CHILD_GRAPH_NODE_PARAMS](<structCUDA__CHILD__GRAPH__NODE__PARAMS.html#structCUDA__CHILD__GRAPH__NODE__PARAMS>)

     [](<structCUDA__CHILD__GRAPH__NODE__PARAMS.html#structCUDA__CHILD__GRAPH__NODE__PARAMS>)
structÂ

[CUDA_CONDITIONAL_NODE_PARAMS](<structCUDA__CONDITIONAL__NODE__PARAMS.html#structCUDA__CONDITIONAL__NODE__PARAMS>)

     [](<structCUDA__CONDITIONAL__NODE__PARAMS.html#structCUDA__CONDITIONAL__NODE__PARAMS>)
structÂ

[CUDA_EVENT_RECORD_NODE_PARAMS](<structCUDA__EVENT__RECORD__NODE__PARAMS.html#structCUDA__EVENT__RECORD__NODE__PARAMS>)

     [](<structCUDA__EVENT__RECORD__NODE__PARAMS.html#structCUDA__EVENT__RECORD__NODE__PARAMS>)
structÂ

[CUDA_EVENT_WAIT_NODE_PARAMS](<structCUDA__EVENT__WAIT__NODE__PARAMS.html#structCUDA__EVENT__WAIT__NODE__PARAMS>)

     [](<structCUDA__EVENT__WAIT__NODE__PARAMS.html#structCUDA__EVENT__WAIT__NODE__PARAMS>)
structÂ

[CUDA_EXTERNAL_MEMORY_BUFFER_DESC_v1](<structCUDA__EXTERNAL__MEMORY__BUFFER__DESC__v1.html#structCUDA__EXTERNAL__MEMORY__BUFFER__DESC__v1>)

     [](<structCUDA__EXTERNAL__MEMORY__BUFFER__DESC__v1.html#structCUDA__EXTERNAL__MEMORY__BUFFER__DESC__v1>)
structÂ

[CUDA_EXTERNAL_MEMORY_HANDLE_DESC_v1](<structCUDA__EXTERNAL__MEMORY__HANDLE__DESC__v1.html#structCUDA__EXTERNAL__MEMORY__HANDLE__DESC__v1>)

     [](<structCUDA__EXTERNAL__MEMORY__HANDLE__DESC__v1.html#structCUDA__EXTERNAL__MEMORY__HANDLE__DESC__v1>)
structÂ

[CUDA_EXTERNAL_MEMORY_MIPMAPPED_ARRAY_DESC_v1](<structCUDA__EXTERNAL__MEMORY__MIPMAPPED__ARRAY__DESC__v1.html#structCUDA__EXTERNAL__MEMORY__MIPMAPPED__ARRAY__DESC__v1>)

     [](<structCUDA__EXTERNAL__MEMORY__MIPMAPPED__ARRAY__DESC__v1.html#structCUDA__EXTERNAL__MEMORY__MIPMAPPED__ARRAY__DESC__v1>)
structÂ

[CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC_v1](<structCUDA__EXTERNAL__SEMAPHORE__HANDLE__DESC__v1.html#structCUDA__EXTERNAL__SEMAPHORE__HANDLE__DESC__v1>)

     [](<structCUDA__EXTERNAL__SEMAPHORE__HANDLE__DESC__v1.html#structCUDA__EXTERNAL__SEMAPHORE__HANDLE__DESC__v1>)
structÂ

[CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_v1](<structCUDA__EXTERNAL__SEMAPHORE__SIGNAL__PARAMS__v1.html#structCUDA__EXTERNAL__SEMAPHORE__SIGNAL__PARAMS__v1>)

     [](<structCUDA__EXTERNAL__SEMAPHORE__SIGNAL__PARAMS__v1.html#structCUDA__EXTERNAL__SEMAPHORE__SIGNAL__PARAMS__v1>)
structÂ

[CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_v1](<structCUDA__EXTERNAL__SEMAPHORE__WAIT__PARAMS__v1.html#structCUDA__EXTERNAL__SEMAPHORE__WAIT__PARAMS__v1>)

     [](<structCUDA__EXTERNAL__SEMAPHORE__WAIT__PARAMS__v1.html#structCUDA__EXTERNAL__SEMAPHORE__WAIT__PARAMS__v1>)
structÂ

[CUDA_EXT_SEM_SIGNAL_NODE_PARAMS_v1](<structCUDA__EXT__SEM__SIGNAL__NODE__PARAMS__v1.html#structCUDA__EXT__SEM__SIGNAL__NODE__PARAMS__v1>)

     [](<structCUDA__EXT__SEM__SIGNAL__NODE__PARAMS__v1.html#structCUDA__EXT__SEM__SIGNAL__NODE__PARAMS__v1>)
structÂ

[CUDA_EXT_SEM_SIGNAL_NODE_PARAMS_v2](<structCUDA__EXT__SEM__SIGNAL__NODE__PARAMS__v2.html#structCUDA__EXT__SEM__SIGNAL__NODE__PARAMS__v2>)

     [](<structCUDA__EXT__SEM__SIGNAL__NODE__PARAMS__v2.html#structCUDA__EXT__SEM__SIGNAL__NODE__PARAMS__v2>)
structÂ

[CUDA_EXT_SEM_WAIT_NODE_PARAMS_v1](<structCUDA__EXT__SEM__WAIT__NODE__PARAMS__v1.html#structCUDA__EXT__SEM__WAIT__NODE__PARAMS__v1>)

     [](<structCUDA__EXT__SEM__WAIT__NODE__PARAMS__v1.html#structCUDA__EXT__SEM__WAIT__NODE__PARAMS__v1>)
structÂ

[CUDA_EXT_SEM_WAIT_NODE_PARAMS_v2](<structCUDA__EXT__SEM__WAIT__NODE__PARAMS__v2.html#structCUDA__EXT__SEM__WAIT__NODE__PARAMS__v2>)

     [](<structCUDA__EXT__SEM__WAIT__NODE__PARAMS__v2.html#structCUDA__EXT__SEM__WAIT__NODE__PARAMS__v2>)
structÂ

[CUDA_GRAPH_INSTANTIATE_PARAMS](<structCUDA__GRAPH__INSTANTIATE__PARAMS.html#structCUDA__GRAPH__INSTANTIATE__PARAMS>)

     [](<structCUDA__GRAPH__INSTANTIATE__PARAMS.html#structCUDA__GRAPH__INSTANTIATE__PARAMS>)
structÂ

[CUDA_HOST_NODE_PARAMS_v1](<structCUDA__HOST__NODE__PARAMS__v1.html#structCUDA__HOST__NODE__PARAMS__v1>)

     [](<structCUDA__HOST__NODE__PARAMS__v1.html#structCUDA__HOST__NODE__PARAMS__v1>)
structÂ

[CUDA_HOST_NODE_PARAMS_v2](<structCUDA__HOST__NODE__PARAMS__v2.html#structCUDA__HOST__NODE__PARAMS__v2>)

     [](<structCUDA__HOST__NODE__PARAMS__v2.html#structCUDA__HOST__NODE__PARAMS__v2>)
structÂ

[CUDA_KERNEL_NODE_PARAMS_v1](<structCUDA__KERNEL__NODE__PARAMS__v1.html#structCUDA__KERNEL__NODE__PARAMS__v1>)

     [](<structCUDA__KERNEL__NODE__PARAMS__v1.html#structCUDA__KERNEL__NODE__PARAMS__v1>)
structÂ

[CUDA_KERNEL_NODE_PARAMS_v2](<structCUDA__KERNEL__NODE__PARAMS__v2.html#structCUDA__KERNEL__NODE__PARAMS__v2>)

     [](<structCUDA__KERNEL__NODE__PARAMS__v2.html#structCUDA__KERNEL__NODE__PARAMS__v2>)
structÂ

[CUDA_KERNEL_NODE_PARAMS_v3](<structCUDA__KERNEL__NODE__PARAMS__v3.html#structCUDA__KERNEL__NODE__PARAMS__v3>)

     [](<structCUDA__KERNEL__NODE__PARAMS__v3.html#structCUDA__KERNEL__NODE__PARAMS__v3>)
structÂ

[CUDA_LAUNCH_PARAMS_v1](<structCUDA__LAUNCH__PARAMS__v1.html#structCUDA__LAUNCH__PARAMS__v1>)

     [](<structCUDA__LAUNCH__PARAMS__v1.html#structCUDA__LAUNCH__PARAMS__v1>)
structÂ

[CUDA_MEMCPY2D_v2](<structCUDA__MEMCPY2D__v2.html#structCUDA__MEMCPY2D__v2>)

     [](<structCUDA__MEMCPY2D__v2.html#structCUDA__MEMCPY2D__v2>)
structÂ

[CUDA_MEMCPY3D_PEER_v1](<structCUDA__MEMCPY3D__PEER__v1.html#structCUDA__MEMCPY3D__PEER__v1>)

     [](<structCUDA__MEMCPY3D__PEER__v1.html#structCUDA__MEMCPY3D__PEER__v1>)
structÂ

[CUDA_MEMCPY3D_v2](<structCUDA__MEMCPY3D__v2.html#structCUDA__MEMCPY3D__v2>)

     [](<structCUDA__MEMCPY3D__v2.html#structCUDA__MEMCPY3D__v2>)
structÂ

[CUDA_MEMCPY_NODE_PARAMS](<structCUDA__MEMCPY__NODE__PARAMS.html#structCUDA__MEMCPY__NODE__PARAMS>)

     [](<structCUDA__MEMCPY__NODE__PARAMS.html#structCUDA__MEMCPY__NODE__PARAMS>)
structÂ

[CUDA_MEMSET_NODE_PARAMS_v1](<structCUDA__MEMSET__NODE__PARAMS__v1.html#structCUDA__MEMSET__NODE__PARAMS__v1>)

     [](<structCUDA__MEMSET__NODE__PARAMS__v1.html#structCUDA__MEMSET__NODE__PARAMS__v1>)
structÂ

[CUDA_MEMSET_NODE_PARAMS_v2](<structCUDA__MEMSET__NODE__PARAMS__v2.html#structCUDA__MEMSET__NODE__PARAMS__v2>)

     [](<structCUDA__MEMSET__NODE__PARAMS__v2.html#structCUDA__MEMSET__NODE__PARAMS__v2>)
structÂ

[CUDA_MEM_ALLOC_NODE_PARAMS_v1](<structCUDA__MEM__ALLOC__NODE__PARAMS__v1.html#structCUDA__MEM__ALLOC__NODE__PARAMS__v1>)

     [](<structCUDA__MEM__ALLOC__NODE__PARAMS__v1.html#structCUDA__MEM__ALLOC__NODE__PARAMS__v1>)
structÂ

[CUDA_MEM_ALLOC_NODE_PARAMS_v2](<structCUDA__MEM__ALLOC__NODE__PARAMS__v2.html#structCUDA__MEM__ALLOC__NODE__PARAMS__v2>)

     [](<structCUDA__MEM__ALLOC__NODE__PARAMS__v2.html#structCUDA__MEM__ALLOC__NODE__PARAMS__v2>)
structÂ

[CUDA_MEM_FREE_NODE_PARAMS](<structCUDA__MEM__FREE__NODE__PARAMS.html#structCUDA__MEM__FREE__NODE__PARAMS>)

     [](<structCUDA__MEM__FREE__NODE__PARAMS.html#structCUDA__MEM__FREE__NODE__PARAMS>)
structÂ

[CUDA_POINTER_ATTRIBUTE_P2P_TOKENS_v1](<structCUDA__POINTER__ATTRIBUTE__P2P__TOKENS__v1.html#structCUDA__POINTER__ATTRIBUTE__P2P__TOKENS__v1>)

     [](<structCUDA__POINTER__ATTRIBUTE__P2P__TOKENS__v1.html#structCUDA__POINTER__ATTRIBUTE__P2P__TOKENS__v1>)
structÂ

[CUDA_RESOURCE_DESC_v1](<structCUDA__RESOURCE__DESC__v1.html#structCUDA__RESOURCE__DESC__v1>)

     [](<structCUDA__RESOURCE__DESC__v1.html#structCUDA__RESOURCE__DESC__v1>)
structÂ

[CUDA_RESOURCE_VIEW_DESC_v1](<structCUDA__RESOURCE__VIEW__DESC__v1.html#structCUDA__RESOURCE__VIEW__DESC__v1>)

     [](<structCUDA__RESOURCE__VIEW__DESC__v1.html#structCUDA__RESOURCE__VIEW__DESC__v1>)
structÂ

[CUDA_TEXTURE_DESC_v1](<structCUDA__TEXTURE__DESC__v1.html#structCUDA__TEXTURE__DESC__v1>)

     [](<structCUDA__TEXTURE__DESC__v1.html#structCUDA__TEXTURE__DESC__v1>)
structÂ

[CUaccessPolicyWindow_v1](<structCUaccessPolicyWindow__v1.html#structCUaccessPolicyWindow__v1>)

     [](<structCUaccessPolicyWindow__v1.html#structCUaccessPolicyWindow__v1>)
structÂ

[CUarrayMapInfo_v1](<structCUarrayMapInfo__v1.html#structCUarrayMapInfo__v1>)

     [](<structCUarrayMapInfo__v1.html#structCUarrayMapInfo__v1>)
structÂ

[CUasyncNotificationInfo](<structCUasyncNotificationInfo.html#structCUasyncNotificationInfo>)

     [](<structCUasyncNotificationInfo.html#structCUasyncNotificationInfo>)
structÂ

[CUcheckpointCheckpointArgs](<structCUcheckpointCheckpointArgs.html#structCUcheckpointCheckpointArgs>)

     [](<structCUcheckpointCheckpointArgs.html#structCUcheckpointCheckpointArgs>)
structÂ

[CUcheckpointGpuPair](<structCUcheckpointGpuPair.html#structCUcheckpointGpuPair>)

     [](<structCUcheckpointGpuPair.html#structCUcheckpointGpuPair>)
structÂ

[CUcheckpointLockArgs](<structCUcheckpointLockArgs.html#structCUcheckpointLockArgs>)

     [](<structCUcheckpointLockArgs.html#structCUcheckpointLockArgs>)
structÂ

[CUcheckpointRestoreArgs](<structCUcheckpointRestoreArgs.html#structCUcheckpointRestoreArgs>)

     [](<structCUcheckpointRestoreArgs.html#structCUcheckpointRestoreArgs>)
structÂ

[CUcheckpointUnlockArgs](<structCUcheckpointUnlockArgs.html#structCUcheckpointUnlockArgs>)

     [](<structCUcheckpointUnlockArgs.html#structCUcheckpointUnlockArgs>)
structÂ

[CUctxCigParam](<structCUctxCigParam.html#structCUctxCigParam>)

     [](<structCUctxCigParam.html#structCUctxCigParam>)
structÂ

[CUctxCreateParams](<structCUctxCreateParams.html#structCUctxCreateParams>)

     [](<structCUctxCreateParams.html#structCUctxCreateParams>)
structÂ

[CUdevprop_v1](<structCUdevprop__v1.html#structCUdevprop__v1>)

     [](<structCUdevprop__v1.html#structCUdevprop__v1>)
structÂ

[CUeglFrame_v1](<structCUeglFrame__v1.html#structCUeglFrame__v1>)

     [](<structCUeglFrame__v1.html#structCUeglFrame__v1>)
structÂ

[CUexecAffinityParam_v1](<structCUexecAffinityParam__v1.html#structCUexecAffinityParam__v1>)

     [](<structCUexecAffinityParam__v1.html#structCUexecAffinityParam__v1>)
structÂ

[CUexecAffinitySmCount_v1](<structCUexecAffinitySmCount__v1.html#structCUexecAffinitySmCount__v1>)

     [](<structCUexecAffinitySmCount__v1.html#structCUexecAffinitySmCount__v1>)
structÂ

[CUextent3D_v1](<structCUextent3D__v1.html#structCUextent3D__v1>)

     [](<structCUextent3D__v1.html#structCUextent3D__v1>)
structÂ

[CUgraphEdgeData](<structCUgraphEdgeData.html#structCUgraphEdgeData>)

     [](<structCUgraphEdgeData.html#structCUgraphEdgeData>)
structÂ

[CUgraphExecUpdateResultInfo_v1](<structCUgraphExecUpdateResultInfo__v1.html#structCUgraphExecUpdateResultInfo__v1>)

     [](<structCUgraphExecUpdateResultInfo__v1.html#structCUgraphExecUpdateResultInfo__v1>)
structÂ

[CUgraphNodeParams](<structCUgraphNodeParams.html#structCUgraphNodeParams>)

     [](<structCUgraphNodeParams.html#structCUgraphNodeParams>)
structÂ

[CUipcEventHandle_v1](<structCUipcEventHandle__v1.html#structCUipcEventHandle__v1>)

     [](<structCUipcEventHandle__v1.html#structCUipcEventHandle__v1>)
structÂ

[CUipcMemHandle_v1](<structCUipcMemHandle__v1.html#structCUipcMemHandle__v1>)

     [](<structCUipcMemHandle__v1.html#structCUipcMemHandle__v1>)
structÂ

[CUlaunchAttribute](<structCUlaunchAttribute.html#structCUlaunchAttribute>)

     [](<structCUlaunchAttribute.html#structCUlaunchAttribute>)
unionÂ

[CUlaunchAttributeValue](<unionCUlaunchAttributeValue.html#unionCUlaunchAttributeValue>)

     [](<unionCUlaunchAttributeValue.html#unionCUlaunchAttributeValue>)
structÂ

[CUlaunchConfig](<structCUlaunchConfig.html#structCUlaunchConfig>)

     [](<structCUlaunchConfig.html#structCUlaunchConfig>)
structÂ

[CUlaunchMemSyncDomainMap](<structCUlaunchMemSyncDomainMap.html#structCUlaunchMemSyncDomainMap>)

     [](<structCUlaunchMemSyncDomainMap.html#structCUlaunchMemSyncDomainMap>)
structÂ

[CUmemAccessDesc_v1](<structCUmemAccessDesc__v1.html#structCUmemAccessDesc__v1>)

     [](<structCUmemAccessDesc__v1.html#structCUmemAccessDesc__v1>)
structÂ

[CUmemAllocationProp_v1](<structCUmemAllocationProp__v1.html#structCUmemAllocationProp__v1>)

     [](<structCUmemAllocationProp__v1.html#structCUmemAllocationProp__v1>)
structÂ

[CUmemFabricHandle_v1](<structCUmemFabricHandle__v1.html#structCUmemFabricHandle__v1>)

     [](<structCUmemFabricHandle__v1.html#structCUmemFabricHandle__v1>)
structÂ

[CUmemLocation_v1](<structCUmemLocation__v1.html#structCUmemLocation__v1>)

     [](<structCUmemLocation__v1.html#structCUmemLocation__v1>)
structÂ

[CUmemPoolProps_v1](<structCUmemPoolProps__v1.html#structCUmemPoolProps__v1>)

     [](<structCUmemPoolProps__v1.html#structCUmemPoolProps__v1>)
structÂ

[CUmemPoolPtrExportData_v1](<structCUmemPoolPtrExportData__v1.html#structCUmemPoolPtrExportData__v1>)

     [](<structCUmemPoolPtrExportData__v1.html#structCUmemPoolPtrExportData__v1>)
structÂ

[CUmemcpy3DOperand_v1](<structCUmemcpy3DOperand__v1.html#structCUmemcpy3DOperand__v1>)

     [](<structCUmemcpy3DOperand__v1.html#structCUmemcpy3DOperand__v1>)
structÂ

[CUmemcpyAttributes_v1](<structCUmemcpyAttributes__v1.html#structCUmemcpyAttributes__v1>)

     [](<structCUmemcpyAttributes__v1.html#structCUmemcpyAttributes__v1>)
structÂ

[CUmulticastObjectProp_v1](<structCUmulticastObjectProp__v1.html#structCUmulticastObjectProp__v1>)

     [](<structCUmulticastObjectProp__v1.html#structCUmulticastObjectProp__v1>)
structÂ

[CUoffset3D_v1](<structCUoffset3D__v1.html#structCUoffset3D__v1>)

     [](<structCUoffset3D__v1.html#structCUoffset3D__v1>)
unionÂ

[CUstreamBatchMemOpParams_v1](<unionCUstreamBatchMemOpParams__v1.html#unionCUstreamBatchMemOpParams__v1>)

     [](<unionCUstreamBatchMemOpParams__v1.html#unionCUstreamBatchMemOpParams__v1>)
structÂ

[CUtensorMap](<structCUtensorMap.html#structCUtensorMap>)

     [](<structCUtensorMap.html#structCUtensorMap>)

### Defines

#defineÂ [CUDA_ARRAY3D_2DARRAY](<#group__CUDA__TYPES_1g2a94f4b9c015417866323e6de0a33cc7>) 0x01

#defineÂ [CUDA_ARRAY3D_COLOR_ATTACHMENT](<#group__CUDA__TYPES_1g26e6ae0e2d1dcef8205a840ebc193022>) 0x20

#defineÂ [CUDA_ARRAY3D_CUBEMAP](<#group__CUDA__TYPES_1gfce9ad9aa3df839571b84b47febfb7ae>) 0x04

#defineÂ [CUDA_ARRAY3D_DEFERRED_MAPPING](<#group__CUDA__TYPES_1g854c29dbc47d04a4e42863cb87487d55>) 0x80

#defineÂ [CUDA_ARRAY3D_DEPTH_TEXTURE](<#group__CUDA__TYPES_1g736b87daaca88e6f4abf2e789395dc60>) 0x10

#defineÂ [CUDA_ARRAY3D_LAYERED](<#group__CUDA__TYPES_1ge4adf555c51852623a3dea962ab8ee85>) 0x01

#defineÂ [CUDA_ARRAY3D_SPARSE](<#group__CUDA__TYPES_1g8e13c9d3ef98d1f3dce95901a115abc2>) 0x40

#defineÂ [CUDA_ARRAY3D_SURFACE_LDST](<#group__CUDA__TYPES_1g7287c43cacf1ed05865d6bcad1a23cd9>) 0x02

#defineÂ [CUDA_ARRAY3D_TEXTURE_GATHER](<#group__CUDA__TYPES_1g0c929c92a91f4d9f9f49bae0131a6ccf>) 0x08

#defineÂ [CUDA_ARRAY3D_VIDEO_ENCODE_DECODE](<#group__CUDA__TYPES_1g3712e55d375dab7b48af32c2a7ffffb2>) 0x100

#defineÂ [CUDA_COOPERATIVE_LAUNCH_MULTI_DEVICE_NO_POST_LAUNCH_SYNC](<#group__CUDA__TYPES_1gb46080444b8784713763d4d0dc4e1c90>) 0x02

#defineÂ [CUDA_COOPERATIVE_LAUNCH_MULTI_DEVICE_NO_PRE_LAUNCH_SYNC](<#group__CUDA__TYPES_1g14fbb447864d154bdd6d82a7af51c5ab>) 0x01

#defineÂ [CUDA_EGL_INFINITE_TIMEOUT](<#group__CUDA__TYPES_1g71b9a58998751468a873848efd699af3>) 0xFFFFFFFF

#defineÂ [CUDA_EXTERNAL_MEMORY_DEDICATED](<#group__CUDA__TYPES_1g7a3c833643e392f32a52c131aa87ccac>) 0x1

#defineÂ [CUDA_EXTERNAL_SEMAPHORE_SIGNAL_SKIP_NVSCIBUF_MEMSYNC](<#group__CUDA__TYPES_1g1a6161a80f60177235f479cd74de7e04>) 0x01

#defineÂ [CUDA_EXTERNAL_SEMAPHORE_WAIT_SKIP_NVSCIBUF_MEMSYNC](<#group__CUDA__TYPES_1gf07a1d15f2696b915c068c892e6f1a35>) 0x02

#defineÂ [CUDA_NVSCISYNC_ATTR_SIGNAL](<#group__CUDA__TYPES_1g8709811eaf5a7849ad235aae65471a06>) 0x1

#defineÂ [CUDA_NVSCISYNC_ATTR_WAIT](<#group__CUDA__TYPES_1gd7a00d09b6061b828e13360b238cf9b4>) 0x2

#defineÂ [CUDA_VERSION](<#group__CUDA__TYPES_1g3c09bba9b1547aa69f1e346b82bcdb50>) 13010

#defineÂ [CU_ARRAY_SPARSE_PROPERTIES_SINGLE_MIPTAIL](<#group__CUDA__TYPES_1g0dcf4ba7e64caa5c1aa4e88caa7f659a>) 0x1

#defineÂ [CU_DEVICE_CPU](<#group__CUDA__TYPES_1g2a24bee5711059aaee8329bdc8799790>) ((CUdevice)-1)

#defineÂ [CU_DEVICE_INVALID](<#group__CUDA__TYPES_1gaf8ef1ee21623d3fdc5add5870df97c7>) ((CUdevice)-2)

#defineÂ [CU_GRAPH_COND_ASSIGN_DEFAULT](<#group__CUDA__TYPES_1g498d9a8bff1f9894bb91c9512acdd92a>) 0x1

#defineÂ [CU_GRAPH_KERNEL_NODE_PORT_DEFAULT](<#group__CUDA__TYPES_1gdbf9fb0120d22d8d27c5a297d45ab73d>) 0

#defineÂ [CU_GRAPH_KERNEL_NODE_PORT_LAUNCH_ORDER](<#group__CUDA__TYPES_1g2ed63d6106e76f6966b52c6a0814e789>) 2

#defineÂ [CU_GRAPH_KERNEL_NODE_PORT_PROGRAMMATIC](<#group__CUDA__TYPES_1g888716de0c02411816a952c8426aef75>) 1

#defineÂ [CU_IPC_HANDLE_SIZE](<#group__CUDA__TYPES_1g3ac9bc9744e4b661dfff569637111e3b>) 64

#defineÂ [CU_LAUNCH_KERNEL_REQUIRED_BLOCK_DIM](<#group__CUDA__TYPES_1g4ed0b2daa543698a316a6b92b661b853>) 1

#defineÂ [CU_LAUNCH_PARAM_BUFFER_POINTER](<#group__CUDA__TYPES_1g36d10d0b40c51372877578a2cffd6acd>)

#defineÂ [CU_LAUNCH_PARAM_BUFFER_POINTER_AS_INT](<#group__CUDA__TYPES_1g0f86d010bdca791f8b9e0e1f0a5dcba8>) 0x01

#defineÂ [CU_LAUNCH_PARAM_BUFFER_SIZE](<#group__CUDA__TYPES_1gf339c057cd94562ead93a192e11c17e9>)

#defineÂ [CU_LAUNCH_PARAM_BUFFER_SIZE_AS_INT](<#group__CUDA__TYPES_1ge10d4042a8544e7690e06f3ea1623810>) 0x02

#defineÂ [CU_LAUNCH_PARAM_END](<#group__CUDA__TYPES_1gd5c11cff5adfa5a69d66829399653532>)

#defineÂ [CU_LAUNCH_PARAM_END_AS_INT](<#group__CUDA__TYPES_1g07a49752218aaefa41292e71773e862a>) 0x00

#defineÂ [CU_MEMHOSTALLOC_DEVICEMAP](<#group__CUDA__TYPES_1g054589ee2a0f188e664d93965d81113d>) 0x02

#defineÂ [CU_MEMHOSTALLOC_PORTABLE](<#group__CUDA__TYPES_1g50f4528d46bda58b592551654a7ee0ff>) 0x01

#defineÂ [CU_MEMHOSTALLOC_WRITECOMBINED](<#group__CUDA__TYPES_1g7361580951deecace15352c97a210038>) 0x04

#defineÂ [CU_MEMHOSTREGISTER_DEVICEMAP](<#group__CUDA__TYPES_1gf1fc8645f0ab5481e7be96c80f6bfa50>) 0x02

#defineÂ [CU_MEMHOSTREGISTER_IOMEMORY](<#group__CUDA__TYPES_1g6a86cf1a826f8da5b01f1b5cd8da2bde>) 0x04

#defineÂ [CU_MEMHOSTREGISTER_PORTABLE](<#group__CUDA__TYPES_1g4f20a39f0a7bddc8ce7d644327a2e7da>) 0x01

#defineÂ [CU_MEMHOSTREGISTER_READ_ONLY](<#group__CUDA__TYPES_1gd870d49634958b801f5c02a6ba459a1a>) 0x08

#defineÂ [CU_MEM_CREATE_USAGE_HW_DECOMPRESS](<#group__CUDA__TYPES_1g8b3b5d15c34f384cd3ada57fe8bb4a57>) 0x2

#defineÂ [CU_MEM_CREATE_USAGE_TILE_POOL](<#group__CUDA__TYPES_1gb445d91d9773d728b1a9962184c05799>) 0x1

#defineÂ [CU_MEM_POOL_CREATE_USAGE_HW_DECOMPRESS](<#group__CUDA__TYPES_1gaba1d50e8fd2014843f97c2758ce9cc9>) 0x2

#defineÂ [CU_PARAM_TR_DEFAULT](<#group__CUDA__TYPES_1g3e9be6955a6a5c311ad5ea2debdd6613>) -1

#defineÂ [CU_STREAM_LEGACY](<#group__CUDA__TYPES_1ga53e8210837f039dd6434a3a4c3324aa>) ((CUstream)0x1)

#defineÂ [CU_STREAM_PER_THREAD](<#group__CUDA__TYPES_1g02e40b82600f62c42ed29abb150f857c>) ((CUstream)0x2)

#defineÂ [CU_TENSOR_MAP_NUM_QWORDS](<#group__CUDA__TYPES_1g95ca56705efb20ae69f019ceb84e41f6>) 16

#defineÂ [CU_TRSA_OVERRIDE_FORMAT](<#group__CUDA__TYPES_1gf9f0c76f9c215b3bdeca06456bec3e68>) 0x01

#defineÂ [CU_TRSF_DISABLE_TRILINEAR_OPTIMIZATION](<#group__CUDA__TYPES_1g9512d7fa0ed8a2da30ef6f4ccc61fa4f>) 0x20

#defineÂ [CU_TRSF_NORMALIZED_COORDINATES](<#group__CUDA__TYPES_1g7a19eb49fd506ecded6e8f314298d486>) 0x02

#defineÂ [CU_TRSF_READ_AS_INTEGER](<#group__CUDA__TYPES_1g6d2387c1b5dd5bc98f5b4c51cefdf41e>) 0x01

#defineÂ [CU_TRSF_SEAMLESS_CUBEMAP](<#group__CUDA__TYPES_1g8517a99047de21e19986531ad3958e22>) 0x40

#defineÂ [CU_TRSF_SRGB](<#group__CUDA__TYPES_1g3c731d32b804fb0ae34b970efdfaf988>) 0x10

#defineÂ [MAX_PLANES](<#group__CUDA__TYPES_1g4269718bae6e29c6059d666ec76df24b>) 3


### Typedefs

typedef struct [CUaccessPolicyWindow_v1](<structCUaccessPolicyWindow__v1.html#structCUaccessPolicyWindow__v1>)Â [CUaccessPolicyWindow](<#group__CUDA__TYPES_1g1838e6438f39944217e384bf2adad477>)

typedef CUarray_st * Â [CUarray](<#group__CUDA__TYPES_1gd550651524a56766b60f10f0e7628042>)

typedef void Â ( *[CUasyncCallback](<#group__CUDA__TYPES_1g466d4731f270b66441a355ddb2c84777>) )( CUasyncNotificationInfo* Â info, void* Â userData, Â CUasyncCallbackHandle callback )

typedef CUasyncCallbackEntry_st * Â [CUasyncCallbackHandle](<#group__CUDA__TYPES_1g0ff5c3d4645d51b02b6d11b8b0c228c5>)

typedef CUctx_st * Â [CUcontext](<#group__CUDA__TYPES_1gf9f5bd81658f866613785b3a0bb7d7d9>)

typedef [CUdevice_v1](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g076bf10c9854909b235da7681f3d7ae7>)Â [CUdevice](<#group__CUDA__TYPES_1g41ca2a24a242b36ef2ca77330b5fb72a>)

typedef int Â [CUdevice_v1](<#group__CUDA__TYPES_1g076bf10c9854909b235da7681f3d7ae7>)

typedef [CUdeviceptr_v2](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gb9e6607b17e7861edc427e4a7070bc3d>)Â [CUdeviceptr](<#group__CUDA__TYPES_1g183f7b0d8ad008ea2a5fd552537ace4e>)

typedef unsigned int Â [CUdeviceptr_v2](<#group__CUDA__TYPES_1gb9e6607b17e7861edc427e4a7070bc3d>)

typedef CUeglStreamConnection_st * Â [CUeglStreamConnection](<#group__CUDA__TYPES_1g60c595264697050bc2bb8e00cf5f86e7>)

typedef CUevent_st * Â [CUevent](<#group__CUDA__TYPES_1g6d740185cf0953636d4ae37f68d7559b>)

typedef struct [CUexecAffinityParam_v1](<structCUexecAffinityParam__v1.html#structCUexecAffinityParam__v1>)Â [CUexecAffinityParam](<#group__CUDA__TYPES_1g4e143c37c68ad44ff2b22922f5cd8341>)

typedef CUextMemory_st * Â [CUexternalMemory](<#group__CUDA__TYPES_1gc9500ef066876b1186f8a54afff900ba>)

typedef CUextSemaphore_st * Â [CUexternalSemaphore](<#group__CUDA__TYPES_1g0bc360152166a414e50a5167250552b8>)

typedef CUfunc_st * Â [CUfunction](<#group__CUDA__TYPES_1gba6128b948022f495706d93bc2cea9c8>)

typedef CUgraph_st * Â [CUgraph](<#group__CUDA__TYPES_1g69f555c38df5b3fa1ed25efef794739a>)

typedef cuuint64_t Â [CUgraphConditionalHandle](<#group__CUDA__TYPES_1gf5f0f00dad6aa27aff480400b77f93ee>)

typedef CUgraphDeviceUpdatableNode_st * Â [CUgraphDeviceNode](<#group__CUDA__TYPES_1g90c635c072ada74bb594cdc06b155b4a>)

typedef CUgraphExec_st * Â [CUgraphExec](<#group__CUDA__TYPES_1gf0abeceeaa9f0a39592fe36a538ea1f0>)

typedef CUgraphNode_st * Â [CUgraphNode](<#group__CUDA__TYPES_1gc72514a94dacc85ed0617f979211079c>)

typedef CUgraphicsResource_st * Â [CUgraphicsResource](<#group__CUDA__TYPES_1gc0c4e1704647178d9c5ba3be46517dcd>)

typedef CUgreenCtx_st * Â [CUgreenCtx](<#group__CUDA__TYPES_1g453cb79a1ceb13bec502a9c5f06a0268>)

typedef void(CUDA_CB* Â [CUhostFn](<#group__CUDA__TYPES_1g262cd3570ff5d396db4e3dabede3c355>) )( void* Â userData )

typedef CUkern_st * Â [CUkernel](<#group__CUDA__TYPES_1g612028921e5736db673e4307589989ed>)

typedef CUlib_st * Â [CUlibrary](<#group__CUDA__TYPES_1gb3c679dac8f1ce28d437bedd0fc907d7>)

typedef CUmemPoolHandle_st * Â [CUmemoryPool](<#group__CUDA__TYPES_1g3b96b1ef79f0cb312b51169e9f50e722>)

typedef CUmipmappedArray_st * Â [CUmipmappedArray](<#group__CUDA__TYPES_1g96db856ab3d2940fb694ce4501d9b583>)

typedef CUmod_st * Â [CUmodule](<#group__CUDA__TYPES_1g9e4ef4dcfba4662b2299acb8d049a1ef>)

typedef size_t(CUDA_CB* Â [CUoccupancyB2DSize](<#group__CUDA__TYPES_1g6cb31f1273726f5567051e3e21607a45>) )( int Â blockSize )

typedef CUstream_st * Â [CUstream](<#group__CUDA__TYPES_1gb946c7f02e09efd788a204718015d88a>)

typedef void(CUDA_CB* Â [CUstreamCallback](<#group__CUDA__TYPES_1ge5743a8c48527f1040107a68205c5ba9>) )( CUstreamÂ hStream, Â CUresult status, void* Â userData )

typedef [CUsurfObject_v1](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g6cce9264e6b40e5c019c54077b2d46af>)Â [CUsurfObject](<#group__CUDA__TYPES_1g4acc685a8412637d05668e30e984e220>)

typedef unsigned long long Â [CUsurfObject_v1](<#group__CUDA__TYPES_1g6cce9264e6b40e5c019c54077b2d46af>)

typedef CUsurfref_st * Â [CUsurfref](<#group__CUDA__TYPES_1g7b99472b414f10b2c04dd2530dc7ea76>)

typedef [CUtexObject_v1](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ga815719584f203b89c497bc2e783c483>)Â [CUtexObject](<#group__CUDA__TYPES_1g65fb6720dea73d56db0b4d4974be052d>)

typedef unsigned long long Â [CUtexObject_v1](<#group__CUDA__TYPES_1ga815719584f203b89c497bc2e783c483>)

typedef CUtexref_st * Â [CUtexref](<#group__CUDA__TYPES_1gec1e8eb9dc48ad748765d1fcc020d6b5>)

typedef CUuserObject_st * Â [CUuserObject](<#group__CUDA__TYPES_1g2578b65c87dc98d336f99edca913e92b>)


### Enumerations

enumÂ [CUDA_POINTER_ATTRIBUTE_ACCESS_FLAGS](<#group__CUDA__TYPES_1g74f899b4840d900fcfbee6a417ad8cc6>)

enumÂ [CUGPUDirectRDMAWritesOrdering](<#group__CUDA__TYPES_1g8d647023012ffc318ce86814fec05376>)

enumÂ [CUaccessProperty](<#group__CUDA__TYPES_1gbf4806140e86865b45fc144941a6ced5>)

enumÂ [CUaddress_mode](<#group__CUDA__TYPES_1gc925457ee7128d6251071f6ff7608887>)

enumÂ [CUarraySparseSubresourceType](<#group__CUDA__TYPES_1gb7f440dccee1200001e4b14f53785d0a>)

enumÂ [CUarray_cubemap_face](<#group__CUDA__TYPES_1g012fda14b50e7db8798a340627c4c330>)

enumÂ [CUarray_format](<#group__CUDA__TYPES_1g9b009d9a6aa4c5765c8a00289b6068f9>)

enumÂ [CUasyncNotificationType](<#group__CUDA__TYPES_1gc53959736ce07af4dbe840a5fd54bfff>)

enumÂ [CUatomicOperation](<#group__CUDA__TYPES_1gfd7012de0abfe50cee089f3f00d6dcf3>)

enumÂ [CUatomicOperationCapability](<#group__CUDA__TYPES_1gf8fbc0f84fd6461c5611b3935b26e22c>)

enumÂ [CUclusterSchedulingPolicy](<#group__CUDA__TYPES_1g2d60fcf51c7e8a70bd27687f19543192>)

enumÂ [CUcomputemode](<#group__CUDA__TYPES_1g637aab2eadb52e1c1c048b8bad9592d1>)

enumÂ [CUctx_flags](<#group__CUDA__TYPES_1g9f889e28a45a295b5c8ce13aa05f6cd4>)

enumÂ [CUdeviceNumaConfig](<#group__CUDA__TYPES_1gbd735e21702c410355167e04d3362eab>)

enumÂ [CUdevice_P2PAttribute](<#group__CUDA__TYPES_1g578d7cf687ce20f7e99468e8c14e22de>)

enumÂ [CUdevice_attribute](<#group__CUDA__TYPES_1ge12b8a782bebe21b1ac0091bf9f4e2a3>)

enumÂ [CUdriverProcAddressQueryResult](<#group__CUDA__TYPES_1g4186e73ff4899ff0f2e750a09c5a9fb1>)

enumÂ [CUdriverProcAddress_flags](<#group__CUDA__TYPES_1gf240acf5ce809c0bbbdfb73916c635bc>)

enumÂ [CUeglColorFormat](<#group__CUDA__TYPES_1g38337000e43e400e77ad36c7e197a9f2>)

enumÂ [CUeglFrameType](<#group__CUDA__TYPES_1gec3f4a4e1a5785b1aa0fcc209cd47c38>)

enumÂ [CUeglResourceLocationFlags](<#group__CUDA__TYPES_1gf2804cd7cda3b8716c31ba620f644cd3>)

enumÂ [CUevent_flags](<#group__CUDA__TYPES_1g5ae04079c671c8e659a3a27c7b23f629>)

enumÂ [CUevent_record_flags](<#group__CUDA__TYPES_1g223a74c96434bb4e1d01c8685cbdef22>)

enumÂ [CUevent_sched_flags](<#group__CUDA__TYPES_1gc767407706ebdb70e2e182eb87e45111>)

enumÂ [CUevent_wait_flags](<#group__CUDA__TYPES_1g0dbe4cec219cab20846e3f269a5440d4>)

enumÂ [CUexecAffinityType](<#group__CUDA__TYPES_1g14e6345acf2bda65be91eda77cf03f5c>)

enumÂ [CUexternalMemoryHandleType](<#group__CUDA__TYPES_1gbca0bdde9a33c47058b5c97f21e2edd8>)

enumÂ [CUexternalSemaphoreHandleType](<#group__CUDA__TYPES_1gfecb27c44dbd154273d24d35896a2920>)

enumÂ [CUfilter_mode](<#group__CUDA__TYPES_1g4fb799d90872f1d6cd074b4349f37c2a>)

enumÂ [CUflushGPUDirectRDMAWritesOptions](<#group__CUDA__TYPES_1gf34334d1d6892847a5d05be7ca8db3c6>)

enumÂ [CUflushGPUDirectRDMAWritesScope](<#group__CUDA__TYPES_1g9eafc4def87e0f6600f905e756ec99d1>)

enumÂ [CUflushGPUDirectRDMAWritesTarget](<#group__CUDA__TYPES_1g01251451232c43bc5c7cb067ed2c28ef>)

enumÂ [CUfunc_cache](<#group__CUDA__TYPES_1g3b9bbcf42528b889e9dbe9cfa2aea3ec>)

enumÂ [CUfunction_attribute](<#group__CUDA__TYPES_1g9d955dde0904a9b43ca4d875ac1551bc>)

enumÂ [CUgraphChildGraphNodeOwnership](<#group__CUDA__TYPES_1g120aa1e0e07e6a5c012651b873732fa8>)

enumÂ [CUgraphConditionalNodeType](<#group__CUDA__TYPES_1g04ade961d0263336423eb216fbe514da>)

enumÂ [CUgraphDebugDot_flags](<#group__CUDA__TYPES_1g5b105736b4941ce6977fcee64a8e719f>)

enumÂ [CUgraphDependencyType](<#group__CUDA__TYPES_1g4ce440cd353e7761fbf7de1ec963c0b2>)

enumÂ [CUgraphExecUpdateResult](<#group__CUDA__TYPES_1g8edc8969ff6ae00b7cd5d7292f812c3c>)

enumÂ [CUgraphInstantiateResult](<#group__CUDA__TYPES_1g863484740f7d9f82c908d228f791cc56>)

enumÂ [CUgraphInstantiate_flags](<#group__CUDA__TYPES_1g070bf5517d3a7915667c256eefce4956>)

enumÂ [CUgraphNodeType](<#group__CUDA__TYPES_1g0731a28f826922120d783d8444e154dc>)

enumÂ [CUgraphicsMapResourceFlags](<#group__CUDA__TYPES_1gc7b51d0dd848c61e45d916a15fed74d3>)

enumÂ [CUgraphicsRegisterFlags](<#group__CUDA__TYPES_1gaa05d87d332515f0fc5faefe147c817d>)

enumÂ [CUipcMem_flags](<#group__CUDA__TYPES_1g871d09eefd2aacd3b10fe4f5f23b1a32>)

enumÂ [CUjitInputType](<#group__CUDA__TYPES_1gc78e5cb421c428676861189048888958>)

enumÂ [CUjit_cacheMode](<#group__CUDA__TYPES_1gce011cfe2d6b1fb734da48a6cf48fd04>)

enumÂ [CUjit_fallback](<#group__CUDA__TYPES_1g4a1a92ea65e18b06907b981848c282f2>)

enumÂ [CUjit_option](<#group__CUDA__TYPES_1g5527fa8030d5cabedc781a04dbd1997d>)

enumÂ [CUjit_target](<#group__CUDA__TYPES_1ge443308cb7ed1d52b85b487305779184>)

enumÂ [CUlaunchAttributeID](<#group__CUDA__TYPES_1g6f6565b334be6bb3134868e10bbdd331>)

enumÂ [CUlaunchMemSyncDomain](<#group__CUDA__TYPES_1g471f645fa24df354626fe8107358e05f>)

enumÂ [CUlibraryOption](<#group__CUDA__TYPES_1g8a1cdb7004bb8a24f1342de9004add23>)

enumÂ [CUlimit](<#group__CUDA__TYPES_1ge24c2d4214af24139020f1aecaf32665>)

enumÂ [CUmemAccess_flags](<#group__CUDA__TYPES_1gfba87b8c4a8cd091554d8e2c3fc9b40a>)

enumÂ [CUmemAllocationCompType](<#group__CUDA__TYPES_1gc29a7f9bb71a4e605e2db54c8821b860>)

enumÂ [CUmemAllocationGranularity_flags](<#group__CUDA__TYPES_1g3a202e4d32ae296db1af7efe75ce365d>)

enumÂ [CUmemAllocationHandleType](<#group__CUDA__TYPES_1g450a23153d86fce0afe30e25d63caef9>)

enumÂ [CUmemAllocationType](<#group__CUDA__TYPES_1g7ed3482e0df8712d79a99bcb3bc4a95b>)

enumÂ [CUmemAttach_flags](<#group__CUDA__TYPES_1g17c5d5f9b585aa2d6f121847d1a78f4c>)

enumÂ [CUmemHandleType](<#group__CUDA__TYPES_1g31a65081da1729d11a1d6f5a433d93b0>)

enumÂ [CUmemLocationType](<#group__CUDA__TYPES_1g75cfd5b9fa5c1c6ee2be2547bfbe882e>)

enumÂ [CUmemOperationType](<#group__CUDA__TYPES_1ge7469bd2e035fc9c937e84490fdcd349>)

enumÂ [CUmemPool_attribute](<#group__CUDA__TYPES_1g5af6ea9ddd7633be98cb7de1bbf1d9f0>)

enumÂ [CUmemRangeFlags](<#group__CUDA__TYPES_1g75c53565b19e5c434edc5a65a6a7ab20>)

enumÂ [CUmemRangeHandleType](<#group__CUDA__TYPES_1g579b315f05d1e65a4f3de7da45013210>)

enumÂ [CUmem_advise](<#group__CUDA__TYPES_1gcfe2ed2d4567745dd4ad41034136fff3>)

enumÂ [CUmemcpy3DOperandType](<#group__CUDA__TYPES_1g507c7c67580a9b998fd8a59ce883c7d4>)

enumÂ [CUmemcpyFlags](<#group__CUDA__TYPES_1g0badb1f4f792793fdcf4a78593b4655a>)

enumÂ [CUmemcpySrcAccessOrder](<#group__CUDA__TYPES_1g88fcbe39c3714884fcd1ca9d3b9e4251>)

enumÂ [CUmemorytype](<#group__CUDA__TYPES_1g8a114cc994ad2e865c44ef3838eaec72>)

enumÂ [CUmulticastGranularity_flags](<#group__CUDA__TYPES_1gcdeff171670a788001418262a0f88378>)

enumÂ [CUoccupancy_flags](<#group__CUDA__TYPES_1g40caa223198d058e073116b6a55eb895>)

enumÂ [CUpointer_attribute](<#group__CUDA__TYPES_1gc2cce590e35080745e72633dfc6e0b60>)

enumÂ [CUprocessState](<#group__CUDA__TYPES_1gc96cdda177a2b8c296144567cbea4f23>)

enumÂ [CUresourceViewFormat](<#group__CUDA__TYPES_1ge7db5e5fe7c197287e55f2e97289dfcf>)

enumÂ [CUresourcetype](<#group__CUDA__TYPES_1g9f0a76c9f6be437e75c8310aea5280f6>)

enumÂ [CUresult](<#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)

enumÂ [CUshared_carveout](<#group__CUDA__TYPES_1g123b546391ea75a75bf284305f300dd6>)

enumÂ [CUsharedconfig](<#group__CUDA__TYPES_1g92d66e95f602cb9fdaf0682c260c241b>)

enumÂ [CUstreamAtomicReductionDataType](<#group__CUDA__TYPES_1g6696baa3803f509177b56cde1f69d1eb>)

enumÂ [CUstreamAtomicReductionOpType](<#group__CUDA__TYPES_1gc47490b10664acc736e08943531a4592>)

enumÂ [CUstreamBatchMemOpType](<#group__CUDA__TYPES_1gb257b534afdb704b6ebdb99c16a5b292>)

enumÂ [CUstreamCaptureMode](<#group__CUDA__TYPES_1gd984ba65031d63f1ed11ec76728c2669>)

enumÂ [CUstreamCaptureStatus](<#group__CUDA__TYPES_1g7480c0f2bd19894e54fcd2c04d6efb91>)

enumÂ [CUstreamMemoryBarrier_flags](<#group__CUDA__TYPES_1gd21e1cc26a66b2451b81bdc9ff88610d>)

enumÂ [CUstreamUpdateCaptureDependencies_flags](<#group__CUDA__TYPES_1gef58550e3d1f6d73c7e326455e744663>)

enumÂ [CUstreamWaitValue_flags](<#group__CUDA__TYPES_1gf16864e8693d888f8178067470001b21>)

enumÂ [CUstreamWriteValue_flags](<#group__CUDA__TYPES_1g57787c039734758648d92109c7373141>)

enumÂ [CUstream_flags](<#group__CUDA__TYPES_1g775cb4ffbb7adf91e190067d9ad1752a>)

enumÂ [CUtensorMapDataType](<#group__CUDA__TYPES_1g42bfc19a0751d7183ee94faf9d9e779d>)

enumÂ [CUtensorMapFloatOOBfill](<#group__CUDA__TYPES_1gde9161158bee466f4f92be353c52480e>)

enumÂ [CUtensorMapIm2ColWideMode](<#group__CUDA__TYPES_1g13a0a2e4907f0ec36e8180230644651b>)

enumÂ [CUtensorMapInterleave](<#group__CUDA__TYPES_1g4af9a09e04bb8fc817eeb7be1c5cea70>)

enumÂ [CUtensorMapL2promotion](<#group__CUDA__TYPES_1ga054bf4ec364bd7bd00966a03cf51fb7>)

enumÂ [CUtensorMapSwizzle](<#group__CUDA__TYPES_1g0bc04417bd8ce2c64d204bc3cbc25b58>)

enumÂ [CUuserObjectRetain_flags](<#group__CUDA__TYPES_1g1649c3055c83c32f812faac63c8da0b1>)

enumÂ [CUuserObject_flags](<#group__CUDA__TYPES_1g11c53cd19ee840b3b0f597d57451e943>)

enumÂ [cl_context_flags](<#group__CUDA__TYPES_1g177539f817e4453fa47e60b431d82ddb>)

enumÂ [cl_event_flags](<#group__CUDA__TYPES_1ged3b1af3c026dd8b2788f81a45ab0fe0>)


### Defines

#define CUDA_ARRAY3D_2DARRAY 0x01


Deprecated, use CUDA_ARRAY3D_LAYERED

#define CUDA_ARRAY3D_COLOR_ATTACHMENT 0x20


This flag indicates that the CUDA array may be bound as a color target in an external graphics API

#define CUDA_ARRAY3D_CUBEMAP 0x04


If set, the CUDA array is a collection of six 2D arrays, representing faces of a cube. The width of such a CUDA array must be equal to its height, and Depth must be six. If [CUDA_ARRAY3D_LAYERED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ge4adf555c51852623a3dea962ab8ee85>) flag is also set, then the CUDA array is a collection of cubemaps and Depth must be a multiple of six.

#define CUDA_ARRAY3D_DEFERRED_MAPPING 0x80


This flag if set indicates that the CUDA array or CUDA mipmapped array will allow deferred memory mapping

#define CUDA_ARRAY3D_DEPTH_TEXTURE 0x10


This flag if set indicates that the CUDA array is a DEPTH_TEXTURE.

#define CUDA_ARRAY3D_LAYERED 0x01


If set, the CUDA array is a collection of layers, where each layer is either a 1D or a 2D array and the Depth member of CUDA_ARRAY3D_DESCRIPTOR specifies the number of layers, not the depth of a 3D array.

#define CUDA_ARRAY3D_SPARSE 0x40


This flag if set indicates that the CUDA array or CUDA mipmapped array is a sparse CUDA array or CUDA mipmapped array respectively

#define CUDA_ARRAY3D_SURFACE_LDST 0x02


This flag must be set in order to bind a surface reference to the CUDA array

#define CUDA_ARRAY3D_TEXTURE_GATHER 0x08


This flag must be set in order to perform texture gather operations on a CUDA array.

#define CUDA_ARRAY3D_VIDEO_ENCODE_DECODE 0x100


This flag indicates that the CUDA array will be used for hardware accelerated video encode/decode operations.

#define CUDA_COOPERATIVE_LAUNCH_MULTI_DEVICE_NO_POST_LAUNCH_SYNC 0x02


If set, any subsequent work pushed in a stream that participated in a call to [cuLaunchCooperativeKernelMultiDevice](<group__CUDA__EXEC.html#group__CUDA__EXEC_1g1d34025bc4f8fcec82fbcfc18d07a6e2> "Launches CUDA functions on multiple devices where thread blocks can cooperate and synchronize as they execute.") will only wait for the kernel launched on the GPU corresponding to that stream to complete before it begins execution.

#define CUDA_COOPERATIVE_LAUNCH_MULTI_DEVICE_NO_PRE_LAUNCH_SYNC 0x01


If set, each kernel launched as part of [cuLaunchCooperativeKernelMultiDevice](<group__CUDA__EXEC.html#group__CUDA__EXEC_1g1d34025bc4f8fcec82fbcfc18d07a6e2> "Launches CUDA functions on multiple devices where thread blocks can cooperate and synchronize as they execute.") only waits for prior work in the stream corresponding to that GPU to complete before the kernel begins execution.

#define CUDA_EGL_INFINITE_TIMEOUT 0xFFFFFFFF


Indicates that timeout for [cuEGLStreamConsumerAcquireFrame](<group__CUDA__EGL.html#group__CUDA__EGL_1g10507a0acb74a90136caacb363a3c6a7> "Acquire an image frame from the EGLStream with CUDA as a consumer.") is infinite.

#define CUDA_EXTERNAL_MEMORY_DEDICATED 0x1


Indicates that the external memory object is a dedicated resource

#define CUDA_EXTERNAL_SEMAPHORE_SIGNAL_SKIP_NVSCIBUF_MEMSYNC 0x01


When the `flags` parameter of CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS contains this flag, it indicates that signaling an external semaphore object should skip performing appropriate memory synchronization operations over all the external memory objects that are imported as [CU_EXTERNAL_MEMORY_HANDLE_TYPE_NVSCIBUF](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggbca0bdde9a33c47058b5c97f21e2edd8adf93206205d155aed8228f4a118d6ee>), which otherwise are performed by default to ensure data coherency with other importers of the same NvSciBuf memory objects.

#define CUDA_EXTERNAL_SEMAPHORE_WAIT_SKIP_NVSCIBUF_MEMSYNC 0x02


When the `flags` parameter of CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS contains this flag, it indicates that waiting on an external semaphore object should skip performing appropriate memory synchronization operations over all the external memory objects that are imported as [CU_EXTERNAL_MEMORY_HANDLE_TYPE_NVSCIBUF](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggbca0bdde9a33c47058b5c97f21e2edd8adf93206205d155aed8228f4a118d6ee>), which otherwise are performed by default to ensure data coherency with other importers of the same NvSciBuf memory objects.

#define CUDA_NVSCISYNC_ATTR_SIGNAL 0x1


When `flags` of [cuDeviceGetNvSciSyncAttributes](<group__CUDA__DEVICE.html#group__CUDA__DEVICE_1g0991e2b2b3cedee1ca77d6376e581335> "Return NvSciSync attributes that this device can support.") is set to this, it indicates that application needs signaler specific NvSciSyncAttr to be filled by [cuDeviceGetNvSciSyncAttributes](<group__CUDA__DEVICE.html#group__CUDA__DEVICE_1g0991e2b2b3cedee1ca77d6376e581335> "Return NvSciSync attributes that this device can support.").

#define CUDA_NVSCISYNC_ATTR_WAIT 0x2


When `flags` of [cuDeviceGetNvSciSyncAttributes](<group__CUDA__DEVICE.html#group__CUDA__DEVICE_1g0991e2b2b3cedee1ca77d6376e581335> "Return NvSciSync attributes that this device can support.") is set to this, it indicates that application needs waiter specific NvSciSyncAttr to be filled by [cuDeviceGetNvSciSyncAttributes](<group__CUDA__DEVICE.html#group__CUDA__DEVICE_1g0991e2b2b3cedee1ca77d6376e581335> "Return NvSciSync attributes that this device can support.").

#define CUDA_VERSION 13010


CUDA API version number

#define CU_ARRAY_SPARSE_PROPERTIES_SINGLE_MIPTAIL 0x1


Indicates that the layered sparse CUDA array or CUDA mipmapped array has a single mip tail region for all layers

#define CU_DEVICE_CPU ((CUdevice)-1)


Device that represents the CPU

#define CU_DEVICE_INVALID ((CUdevice)-2)


Device that represents an invalid device

#define CU_GRAPH_COND_ASSIGN_DEFAULT 0x1


Conditional node handle flags Default value is applied when graph is launched.

#define CU_GRAPH_KERNEL_NODE_PORT_DEFAULT 0


This port activates when the kernel has finished executing.

#define CU_GRAPH_KERNEL_NODE_PORT_LAUNCH_ORDER 2


This port activates when all blocks of the kernel have begun execution. See also [CU_LAUNCH_ATTRIBUTE_LAUNCH_COMPLETION_EVENT](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg6f6565b334be6bb3134868e10bbdd33121248c3419121151076d819052270513>).

#define CU_GRAPH_KERNEL_NODE_PORT_PROGRAMMATIC 1


This port activates when all blocks of the kernel have performed [cudaTriggerProgrammaticLaunchCompletion()](<../cuda-runtime-api/group__CUDART__EXECUTION.html#group__CUDART__EXECUTION_1ge194af462d927583bed3acf60d450218>) or have terminated. It must be used with edge type [CU_GRAPH_DEPENDENCY_TYPE_PROGRAMMATIC](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg4ce440cd353e7761fbf7de1ec963c0b2aa68c8a335b9f623a1004bfc98cf0e2b>). See also [CU_LAUNCH_ATTRIBUTE_PROGRAMMATIC_EVENT](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg6f6565b334be6bb3134868e10bbdd3311667102e857f5d37bb4f460c530dfb13>).

#define CU_IPC_HANDLE_SIZE 64


CUDA IPC handle size

#define CU_LAUNCH_KERNEL_REQUIRED_BLOCK_DIM 1


Launch with the required block dimension.

#define CU_LAUNCH_PARAM_BUFFER_POINTER


Indicator that the next value in the `extra` parameter to [cuLaunchKernel](<group__CUDA__EXEC.html#group__CUDA__EXEC_1gb8f3dc3031b40da29d5f9a7139e52e15> "Launches a CUDA function CUfunction or a CUDA kernel CUkernel.") will be a pointer to a buffer containing all kernel parameters used for launching kernel `f`. This buffer needs to honor all alignment/padding requirements of the individual parameters. If [CU_LAUNCH_PARAM_BUFFER_SIZE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gf339c057cd94562ead93a192e11c17e9>) is not also specified in the `extra` array, then [CU_LAUNCH_PARAM_BUFFER_POINTER](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g36d10d0b40c51372877578a2cffd6acd>) will have no effect.

######  Value

((void*)CU_LAUNCH_PARAM_BUFFER_POINTER_AS_INT)

#define CU_LAUNCH_PARAM_BUFFER_POINTER_AS_INT 0x01


C++ compile time constant for CU_LAUNCH_PARAM_BUFFER_POINTER

#define CU_LAUNCH_PARAM_BUFFER_SIZE


Indicator that the next value in the `extra` parameter to [cuLaunchKernel](<group__CUDA__EXEC.html#group__CUDA__EXEC_1gb8f3dc3031b40da29d5f9a7139e52e15> "Launches a CUDA function CUfunction or a CUDA kernel CUkernel.") will be a pointer to a size_t which contains the size of the buffer specified with [CU_LAUNCH_PARAM_BUFFER_POINTER](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g36d10d0b40c51372877578a2cffd6acd>). It is required that [CU_LAUNCH_PARAM_BUFFER_POINTER](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g36d10d0b40c51372877578a2cffd6acd>) also be specified in the `extra` array if the value associated with [CU_LAUNCH_PARAM_BUFFER_SIZE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gf339c057cd94562ead93a192e11c17e9>) is not zero.

######  Value

((void*)CU_LAUNCH_PARAM_BUFFER_SIZE_AS_INT)

#define CU_LAUNCH_PARAM_BUFFER_SIZE_AS_INT 0x02


C++ compile time constant for CU_LAUNCH_PARAM_BUFFER_SIZE

#define CU_LAUNCH_PARAM_END


End of array terminator for the `extra` parameter to [cuLaunchKernel](<group__CUDA__EXEC.html#group__CUDA__EXEC_1gb8f3dc3031b40da29d5f9a7139e52e15> "Launches a CUDA function CUfunction or a CUDA kernel CUkernel.")

######  Value

((void*)CU_LAUNCH_PARAM_END_AS_INT)

#define CU_LAUNCH_PARAM_END_AS_INT 0x00


C++ compile time constant for CU_LAUNCH_PARAM_END

#define CU_MEMHOSTALLOC_DEVICEMAP 0x02


If set, host memory is mapped into CUDA address space and [cuMemHostGetDevicePointer()](<group__CUDA__MEM.html#group__CUDA__MEM_1g57a39e5cba26af4d06be67fc77cc62f0> "Passes back device pointer of mapped pinned memory.") may be called on the host pointer. Flag for [cuMemHostAlloc()](<group__CUDA__MEM.html#group__CUDA__MEM_1g572ca4011bfcb25034888a14d4e035b9> "Allocates page-locked host memory.")

#define CU_MEMHOSTALLOC_PORTABLE 0x01


If set, host memory is portable between CUDA contexts. Flag for [cuMemHostAlloc()](<group__CUDA__MEM.html#group__CUDA__MEM_1g572ca4011bfcb25034888a14d4e035b9> "Allocates page-locked host memory.")

#define CU_MEMHOSTALLOC_WRITECOMBINED 0x04


If set, host memory is allocated as write-combined - fast to write, faster to DMA, slow to read except via SSE4 streaming load instruction (MOVNTDQA). Flag for [cuMemHostAlloc()](<group__CUDA__MEM.html#group__CUDA__MEM_1g572ca4011bfcb25034888a14d4e035b9> "Allocates page-locked host memory.")

#define CU_MEMHOSTREGISTER_DEVICEMAP 0x02


If set, host memory is mapped into CUDA address space and [cuMemHostGetDevicePointer()](<group__CUDA__MEM.html#group__CUDA__MEM_1g57a39e5cba26af4d06be67fc77cc62f0> "Passes back device pointer of mapped pinned memory.") may be called on the host pointer. Flag for [cuMemHostRegister()](<group__CUDA__MEM.html#group__CUDA__MEM_1gf0a9fe11544326dabd743b7aa6b54223> "Registers an existing host memory range for use by CUDA.")

#define CU_MEMHOSTREGISTER_IOMEMORY 0x04


If set, the passed memory pointer is treated as pointing to some memory-mapped I/O space, e.g. belonging to a third-party PCIe device. On Windows the flag is a no-op. On Linux that memory is marked as non cache-coherent for the GPU and is expected to be physically contiguous. It may return [CUDA_ERROR_NOT_PERMITTED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9e23d0197c490ec332a43e55b167968a3>) if run as an unprivileged user, [CUDA_ERROR_NOT_SUPPORTED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e954756ae7ade0dfd09faeccb513dd831b>) on older Linux kernel versions. On all other platforms, it is not supported and [CUDA_ERROR_NOT_SUPPORTED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e954756ae7ade0dfd09faeccb513dd831b>) is returned. Flag for [cuMemHostRegister()](<group__CUDA__MEM.html#group__CUDA__MEM_1gf0a9fe11544326dabd743b7aa6b54223> "Registers an existing host memory range for use by CUDA.")

#define CU_MEMHOSTREGISTER_PORTABLE 0x01


If set, host memory is portable between CUDA contexts. Flag for [cuMemHostRegister()](<group__CUDA__MEM.html#group__CUDA__MEM_1gf0a9fe11544326dabd743b7aa6b54223> "Registers an existing host memory range for use by CUDA.")

#define CU_MEMHOSTREGISTER_READ_ONLY 0x08


If set, the passed memory pointer is treated as pointing to memory that is considered read-only by the device. On platforms without [CU_DEVICE_ATTRIBUTE_PAGEABLE_MEMORY_ACCESS_USES_HOST_PAGE_TABLES](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gge12b8a782bebe21b1ac0091bf9f4e2a352c58d6fd1d3a72673cce199ab30cd40>), this flag is required in order to register memory mapped to the CPU as read-only. Support for the use of this flag can be queried from the device attribute [CU_DEVICE_ATTRIBUTE_READ_ONLY_HOST_REGISTER_SUPPORTED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gge12b8a782bebe21b1ac0091bf9f4e2a33a3a9091a7991536d507dd5eff146d2b>). Using this flag with a current context associated with a device that does not have this attribute set will cause [cuMemHostRegister](<group__CUDA__MEM.html#group__CUDA__MEM_1gf0a9fe11544326dabd743b7aa6b54223> "Registers an existing host memory range for use by CUDA.") to error with [CUDA_ERROR_NOT_SUPPORTED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e954756ae7ade0dfd09faeccb513dd831b>).

#define CU_MEM_CREATE_USAGE_HW_DECOMPRESS 0x2


This flag, if set, indicates that the memory will be used as a buffer for hardware accelerated decompression.

#define CU_MEM_CREATE_USAGE_TILE_POOL 0x1


This flag if set indicates that the memory will be used as a tile pool.

#define CU_MEM_POOL_CREATE_USAGE_HW_DECOMPRESS 0x2


This flag, if set, indicates that the memory will be used as a buffer for hardware accelerated decompression.

#define CU_PARAM_TR_DEFAULT -1


For texture references loaded into the module, use default texunit from texture reference.

#define CU_STREAM_LEGACY ((CUstream)0x1)


Legacy stream handle

Stream handle that can be passed as a CUstream to use an implicit stream with legacy synchronization behavior.

See details of the [synchronization behavior](<stream-sync-behavior.html#stream-sync-behavior>).

#define CU_STREAM_PER_THREAD ((CUstream)0x2)


Per-thread stream handle

Stream handle that can be passed as a CUstream to use an implicit stream with per-thread synchronization behavior.

See details of the [synchronization behavior](<stream-sync-behavior.html#stream-sync-behavior>).

#define CU_TENSOR_MAP_NUM_QWORDS 16


Size of tensor map descriptor

#define CU_TRSA_OVERRIDE_FORMAT 0x01


Override the texref format with a format inferred from the array. Flag for [cuTexRefSetArray()](<group__CUDA__TEXREF__DEPRECATED.html#group__CUDA__TEXREF__DEPRECATED_1gac3a34b4b10983433865fdadb83b9118> "Binds an array as a texture reference.")

#define CU_TRSF_DISABLE_TRILINEAR_OPTIMIZATION 0x20


Disable any trilinear filtering optimizations. Flag for [cuTexRefSetFlags()](<group__CUDA__TEXREF__DEPRECATED.html#group__CUDA__TEXREF__DEPRECATED_1g9d4816a6561e1d09e0eef9f9c0cdbfa2> "Sets the flags for a texture reference.") and [cuTexObjectCreate()](<group__CUDA__TEXOBJECT.html#group__CUDA__TEXOBJECT_1g1f6dd0f9cbf56db725b1f45aa0a7218a> "Creates a texture object.")

#define CU_TRSF_NORMALIZED_COORDINATES 0x02


Use normalized texture coordinates in the range [0,1) instead of [0,dim). Flag for [cuTexRefSetFlags()](<group__CUDA__TEXREF__DEPRECATED.html#group__CUDA__TEXREF__DEPRECATED_1g9d4816a6561e1d09e0eef9f9c0cdbfa2> "Sets the flags for a texture reference.") and [cuTexObjectCreate()](<group__CUDA__TEXOBJECT.html#group__CUDA__TEXOBJECT_1g1f6dd0f9cbf56db725b1f45aa0a7218a> "Creates a texture object.")

#define CU_TRSF_READ_AS_INTEGER 0x01


Read the texture as integers rather than promoting the values to floats in the range [0,1]. Flag for [cuTexRefSetFlags()](<group__CUDA__TEXREF__DEPRECATED.html#group__CUDA__TEXREF__DEPRECATED_1g9d4816a6561e1d09e0eef9f9c0cdbfa2> "Sets the flags for a texture reference.") and [cuTexObjectCreate()](<group__CUDA__TEXOBJECT.html#group__CUDA__TEXOBJECT_1g1f6dd0f9cbf56db725b1f45aa0a7218a> "Creates a texture object.")

#define CU_TRSF_SEAMLESS_CUBEMAP 0x40


Enable seamless cube map filtering. Flag for [cuTexObjectCreate()](<group__CUDA__TEXOBJECT.html#group__CUDA__TEXOBJECT_1g1f6dd0f9cbf56db725b1f45aa0a7218a> "Creates a texture object.")

#define CU_TRSF_SRGB 0x10


Perform sRGB->linear conversion during texture read. Flag for [cuTexRefSetFlags()](<group__CUDA__TEXREF__DEPRECATED.html#group__CUDA__TEXREF__DEPRECATED_1g9d4816a6561e1d09e0eef9f9c0cdbfa2> "Sets the flags for a texture reference.") and [cuTexObjectCreate()](<group__CUDA__TEXOBJECT.html#group__CUDA__TEXOBJECT_1g1f6dd0f9cbf56db725b1f45aa0a7218a> "Creates a texture object.")

#define MAX_PLANES 3


Maximum number of planes per frame

### Typedefs

typedef struct [CUaccessPolicyWindow_v1](<structCUaccessPolicyWindow__v1.html#structCUaccessPolicyWindow__v1>) CUaccessPolicyWindow


Access policy window

typedef CUarray_st * CUarray


CUDA array

void ( *CUasyncCallback )( CUasyncNotificationInfo* Â info, void* Â userData, Â CUasyncCallbackHandle callback )


CUDA async notification callback

######  Parameters

`info`
    Information describing what actions to take as a result of this notification.
`userData`
    Pointer to user defined data provided at callback registration.
`CUasyncCallbackHandle callback`


typedef CUasyncCallbackEntry_st * CUasyncCallbackHandle


CUDA async notification callback handle

typedef CUctx_st * CUcontext


A regular context handle

typedef [CUdevice_v1](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g076bf10c9854909b235da7681f3d7ae7>) CUdevice


CUDA device

typedef int CUdevice_v1


CUDA device

typedef [CUdeviceptr_v2](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gb9e6607b17e7861edc427e4a7070bc3d>) CUdeviceptr


CUDA device pointer

typedef unsigned int CUdeviceptr_v2


CUDA device pointer CUdeviceptr is defined as an unsigned integer type whose size matches the size of a pointer on the target platform.

typedef CUeglStreamConnection_st * CUeglStreamConnection


CUDA EGLSream Connection

typedef CUevent_st * CUevent


CUDA event

typedef struct [CUexecAffinityParam_v1](<structCUexecAffinityParam__v1.html#structCUexecAffinityParam__v1>) CUexecAffinityParam


Execution Affinity Parameters

typedef CUextMemory_st * CUexternalMemory


CUDA external memory

typedef CUextSemaphore_st * CUexternalSemaphore


CUDA external semaphore

typedef CUfunc_st * CUfunction


CUDA function

typedef CUgraph_st * CUgraph


CUDA graph

typedef cuuint64_t CUgraphConditionalHandle


CUDA graph conditional handle

typedef CUgraphDeviceUpdatableNode_st * CUgraphDeviceNode


CUDA graph device node handle

typedef CUgraphExec_st * CUgraphExec


CUDA executable graph

typedef CUgraphNode_st * CUgraphNode


CUDA graph node

typedef CUgraphicsResource_st * CUgraphicsResource


CUDA graphics interop resource

typedef CUgreenCtx_st * CUgreenCtx


A green context handle. This handle can be used safely from only one CPU thread at a time. Created via [cuGreenCtxCreate](<group__CUDA__GREEN__CONTEXTS.html#group__CUDA__GREEN__CONTEXTS_1ga6da4f9959fd48d1f1a5cbedbec54e65> "Creates a green context with a specified set of resources.")

void(CUDA_CB* CUhostFn )( void* Â userData )


CUDA host function

######  Parameters

`userData`
    Argument value passed to the function

typedef CUkern_st * CUkernel


CUDA kernel

typedef CUlib_st * CUlibrary


CUDA library

typedef CUmemPoolHandle_st * CUmemoryPool


CUDA memory pool

typedef CUmipmappedArray_st * CUmipmappedArray


CUDA mipmapped array

typedef CUmod_st * CUmodule


CUDA module

size_t(CUDA_CB* CUoccupancyB2DSize )( int Â blockSize )


Block size to per-block dynamic shared memory mapping for a certain kernel

######  Parameters

`blockSize`
    Block size of the kernel.

###### Returns

The dynamic shared memory needed by a block.

typedef CUstream_st * CUstream


CUDA stream

void(CUDA_CB* CUstreamCallback )( CUstreamÂ hStream, Â CUresult status, void* Â userData )


CUDA stream callback

######  Parameters

`hStream`
    The stream the callback was added to, as passed to [cuStreamAddCallback](<group__CUDA__STREAM.html#group__CUDA__STREAM_1g613d97a277d7640f4cb1c03bd51c2483> "Add a callback to a compute stream."). May be NULL.
`CUresult status`

`userData`
    User parameter provided at registration.

typedef [CUsurfObject_v1](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g6cce9264e6b40e5c019c54077b2d46af>) CUsurfObject


An opaque value that represents a CUDA surface object

typedef unsigned long long CUsurfObject_v1


An opaque value that represents a CUDA surface object

typedef CUsurfref_st * CUsurfref


CUDA surface reference

typedef [CUtexObject_v1](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ga815719584f203b89c497bc2e783c483>) CUtexObject


An opaque value that represents a CUDA texture object

typedef unsigned long long CUtexObject_v1


An opaque value that represents a CUDA texture object

typedef CUtexref_st * CUtexref


CUDA texture reference

typedef CUuserObject_st * CUuserObject


CUDA user object for graphs

### Enumerations

enum CUDA_POINTER_ATTRIBUTE_ACCESS_FLAGS


Access flags that specify the level of access the current context's device has on the memory referenced.

######  Values

CU_POINTER_ATTRIBUTE_ACCESS_FLAG_NONE = 0x0
    No access, meaning the device cannot access this memory at all, thus must be staged through accessible memory in order to complete certain operations
CU_POINTER_ATTRIBUTE_ACCESS_FLAG_READ = 0x1
    Read-only access, meaning writes to this memory are considered invalid accesses and thus return error in that case.
CU_POINTER_ATTRIBUTE_ACCESS_FLAG_READWRITE = 0x3
    Read-write access, the device has full read-write access to the memory

enum CUGPUDirectRDMAWritesOrdering


Platform native ordering for GPUDirect RDMA writes

######  Values

CU_GPU_DIRECT_RDMA_WRITES_ORDERING_NONE = 0
    The device does not natively support ordering of remote writes. [cuFlushGPUDirectRDMAWrites()](<group__CUDA__DEVICE.html#group__CUDA__DEVICE_1g265e3c82ef0f0fe035f85c4c45a8fbdf> "Blocks until remote writes are visible to the specified scope.") can be leveraged if supported.
CU_GPU_DIRECT_RDMA_WRITES_ORDERING_OWNER = 100
    Natively, the device can consistently consume remote writes, although other CUDA devices may not.
CU_GPU_DIRECT_RDMA_WRITES_ORDERING_ALL_DEVICES = 200
    Any CUDA device in the system can consistently consume remote writes to this device.

enum CUaccessProperty


Specifies performance hint with [CUaccessPolicyWindow](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g1838e6438f39944217e384bf2adad477>) for hitProp and missProp members.

######  Values

CU_ACCESS_PROPERTY_NORMAL = 0
    Normal cache persistence.
CU_ACCESS_PROPERTY_STREAMING = 1
    Streaming access is less likely to persit from cache.
CU_ACCESS_PROPERTY_PERSISTING = 2
    Persisting access is more likely to persist in cache.

enum CUaddress_mode


Texture reference addressing modes

######  Values

CU_TR_ADDRESS_MODE_WRAP = 0
    Wrapping address mode
CU_TR_ADDRESS_MODE_CLAMP = 1
    Clamp to edge address mode
CU_TR_ADDRESS_MODE_MIRROR = 2
    Mirror address mode
CU_TR_ADDRESS_MODE_BORDER = 3
    Border address mode

enum CUarraySparseSubresourceType


Sparse subresource types

######  Values

CU_ARRAY_SPARSE_SUBRESOURCE_TYPE_SPARSE_LEVEL = 0

CU_ARRAY_SPARSE_SUBRESOURCE_TYPE_MIPTAIL = 1


enum CUarray_cubemap_face


Array indices for cube faces

######  Values

CU_CUBEMAP_FACE_POSITIVE_X = 0x00
    Positive X face of cubemap
CU_CUBEMAP_FACE_NEGATIVE_X = 0x01
    Negative X face of cubemap
CU_CUBEMAP_FACE_POSITIVE_Y = 0x02
    Positive Y face of cubemap
CU_CUBEMAP_FACE_NEGATIVE_Y = 0x03
    Negative Y face of cubemap
CU_CUBEMAP_FACE_POSITIVE_Z = 0x04
    Positive Z face of cubemap
CU_CUBEMAP_FACE_NEGATIVE_Z = 0x05
    Negative Z face of cubemap

enum CUarray_format


Array formats

######  Values

CU_AD_FORMAT_UNSIGNED_INT8 = 0x01
    Unsigned 8-bit integers
CU_AD_FORMAT_UNSIGNED_INT16 = 0x02
    Unsigned 16-bit integers
CU_AD_FORMAT_UNSIGNED_INT32 = 0x03
    Unsigned 32-bit integers
CU_AD_FORMAT_SIGNED_INT8 = 0x08
    Signed 8-bit integers
CU_AD_FORMAT_SIGNED_INT16 = 0x09
    Signed 16-bit integers
CU_AD_FORMAT_SIGNED_INT32 = 0x0a
    Signed 32-bit integers
CU_AD_FORMAT_HALF = 0x10
    16-bit floating point
CU_AD_FORMAT_FLOAT = 0x20
    32-bit floating point
CU_AD_FORMAT_NV12 = 0xb0
    8-bit YUV planar format, with 4:2:0 sampling
CU_AD_FORMAT_UNORM_INT8X1 = 0xc0
    1 channel unsigned 8-bit normalized integer
CU_AD_FORMAT_UNORM_INT8X2 = 0xc1
    2 channel unsigned 8-bit normalized integer
CU_AD_FORMAT_UNORM_INT8X4 = 0xc2
    4 channel unsigned 8-bit normalized integer
CU_AD_FORMAT_UNORM_INT16X1 = 0xc3
    1 channel unsigned 16-bit normalized integer
CU_AD_FORMAT_UNORM_INT16X2 = 0xc4
    2 channel unsigned 16-bit normalized integer
CU_AD_FORMAT_UNORM_INT16X4 = 0xc5
    4 channel unsigned 16-bit normalized integer
CU_AD_FORMAT_SNORM_INT8X1 = 0xc6
    1 channel signed 8-bit normalized integer
CU_AD_FORMAT_SNORM_INT8X2 = 0xc7
    2 channel signed 8-bit normalized integer
CU_AD_FORMAT_SNORM_INT8X4 = 0xc8
    4 channel signed 8-bit normalized integer
CU_AD_FORMAT_SNORM_INT16X1 = 0xc9
    1 channel signed 16-bit normalized integer
CU_AD_FORMAT_SNORM_INT16X2 = 0xca
    2 channel signed 16-bit normalized integer
CU_AD_FORMAT_SNORM_INT16X4 = 0xcb
    4 channel signed 16-bit normalized integer
CU_AD_FORMAT_BC1_UNORM = 0x91
    4 channel unsigned normalized block-compressed (BC1 compression) format
CU_AD_FORMAT_BC1_UNORM_SRGB = 0x92
    4 channel unsigned normalized block-compressed (BC1 compression) format with sRGB encoding
CU_AD_FORMAT_BC2_UNORM = 0x93
    4 channel unsigned normalized block-compressed (BC2 compression) format
CU_AD_FORMAT_BC2_UNORM_SRGB = 0x94
    4 channel unsigned normalized block-compressed (BC2 compression) format with sRGB encoding
CU_AD_FORMAT_BC3_UNORM = 0x95
    4 channel unsigned normalized block-compressed (BC3 compression) format
CU_AD_FORMAT_BC3_UNORM_SRGB = 0x96
    4 channel unsigned normalized block-compressed (BC3 compression) format with sRGB encoding
CU_AD_FORMAT_BC4_UNORM = 0x97
    1 channel unsigned normalized block-compressed (BC4 compression) format
CU_AD_FORMAT_BC4_SNORM = 0x98
    1 channel signed normalized block-compressed (BC4 compression) format
CU_AD_FORMAT_BC5_UNORM = 0x99
    2 channel unsigned normalized block-compressed (BC5 compression) format
CU_AD_FORMAT_BC5_SNORM = 0x9a
    2 channel signed normalized block-compressed (BC5 compression) format
CU_AD_FORMAT_BC6H_UF16 = 0x9b
    3 channel unsigned half-float block-compressed (BC6H compression) format
CU_AD_FORMAT_BC6H_SF16 = 0x9c
    3 channel signed half-float block-compressed (BC6H compression) format
CU_AD_FORMAT_BC7_UNORM = 0x9d
    4 channel unsigned normalized block-compressed (BC7 compression) format
CU_AD_FORMAT_BC7_UNORM_SRGB = 0x9e
    4 channel unsigned normalized block-compressed (BC7 compression) format with sRGB encoding
CU_AD_FORMAT_P010 = 0x9f
    10-bit YUV planar format, with 4:2:0 sampling
CU_AD_FORMAT_P016 = 0xa1
    16-bit YUV planar format, with 4:2:0 sampling
CU_AD_FORMAT_NV16 = 0xa2
    8-bit YUV planar format, with 4:2:2 sampling
CU_AD_FORMAT_P210 = 0xa3
    10-bit YUV planar format, with 4:2:2 sampling
CU_AD_FORMAT_P216 = 0xa4
    16-bit YUV planar format, with 4:2:2 sampling
CU_AD_FORMAT_YUY2 = 0xa5
    2 channel, 8-bit YUV packed planar format, with 4:2:2 sampling
CU_AD_FORMAT_Y210 = 0xa6
    2 channel, 10-bit YUV packed planar format, with 4:2:2 sampling
CU_AD_FORMAT_Y216 = 0xa7
    2 channel, 16-bit YUV packed planar format, with 4:2:2 sampling
CU_AD_FORMAT_AYUV = 0xa8
    4 channel, 8-bit YUV packed planar format, with 4:4:4 sampling
CU_AD_FORMAT_Y410 = 0xa9
    10-bit YUV packed planar format, with 4:4:4 sampling
CU_AD_FORMAT_Y416 = 0xb1
    4 channel, 12-bit YUV packed planar format, with 4:4:4 sampling
CU_AD_FORMAT_Y444_PLANAR8 = 0xb2
    3 channel 8-bit YUV planar format, with 4:4:4 sampling
CU_AD_FORMAT_Y444_PLANAR10 = 0xb3
    3 channel 10-bit YUV planar format, with 4:4:4 sampling
CU_AD_FORMAT_YUV444_8bit_SemiPlanar = 0xb4
    3 channel 8-bit YUV semi-planar format, with 4:4:4 sampling
CU_AD_FORMAT_YUV444_16bit_SemiPlanar = 0xb5
    3 channel 16-bit YUV semi-planar format, with 4:4:4 sampling
CU_AD_FORMAT_UNORM_INT_101010_2 = 0x50
    4 channel unorm R10G10B10A2 RGB format
CU_AD_FORMAT_UINT8_PACKED_422 = 0x51
    4 channel unsigned 8-bit YUV packed format, with 4:2:2 sampling
CU_AD_FORMAT_UINT8_PACKED_444 = 0x52
    4 channel unsigned 8-bit YUV packed format, with 4:4:4 sampling
CU_AD_FORMAT_UINT8_SEMIPLANAR_420 = 0x53
    3 channel unsigned 8-bit YUV semi-planar format, with 4:2:0 sampling
CU_AD_FORMAT_UINT16_SEMIPLANAR_420 = 0x54
    3 channel unsigned 16-bit YUV semi-planar format, with 4:2:0 sampling
CU_AD_FORMAT_UINT8_SEMIPLANAR_422 = 0x55
    3 channel unsigned 8-bit YUV semi-planar format, with 4:2:2 sampling
CU_AD_FORMAT_UINT16_SEMIPLANAR_422 = 0x56
    3 channel unsigned 16-bit YUV semi-planar format, with 4:2:2 sampling
CU_AD_FORMAT_UINT8_SEMIPLANAR_444 = 0x57
    3 channel unsigned 8-bit YUV semi-planar format, with 4:4:4 sampling
CU_AD_FORMAT_UINT16_SEMIPLANAR_444 = 0x58
    3 channel unsigned 16-bit YUV semi-planar format, with 4:4:4 sampling
CU_AD_FORMAT_UINT8_PLANAR_420 = 0x59
    3 channel unsigned 8-bit YUV planar format, with 4:2:0 sampling
CU_AD_FORMAT_UINT16_PLANAR_420 = 0x5a
    3 channel unsigned 16-bit YUV planar format, with 4:2:0 sampling
CU_AD_FORMAT_UINT8_PLANAR_422 = 0x5b
    3 channel unsigned 8-bit YUV planar format, with 4:2:2 sampling
CU_AD_FORMAT_UINT16_PLANAR_422 = 0x5c
    3 channel unsigned 16-bit YUV planar format, with 4:2:2 sampling
CU_AD_FORMAT_UINT8_PLANAR_444 = 0x5d
    3 channel unsigned 8-bit YUV planar format, with 4:4:4 sampling
CU_AD_FORMAT_UINT16_PLANAR_444 = 0x5e
    3 channel unsigned 16-bit YUV planar format, with 4:4:4 sampling
CU_AD_FORMAT_MAX = 0x7FFFFFFF


enum CUasyncNotificationType


Types of async notification that can be sent

######  Values

CU_ASYNC_NOTIFICATION_TYPE_OVER_BUDGET = 0x1
    Sent when the process has exceeded its device memory budget

enum CUatomicOperation


CUDA-valid Atomic Operations

######  Values

CU_ATOMIC_OPERATION_INTEGER_ADD = 0

CU_ATOMIC_OPERATION_INTEGER_MIN = 1

CU_ATOMIC_OPERATION_INTEGER_MAX = 2

CU_ATOMIC_OPERATION_INTEGER_INCREMENT = 3

CU_ATOMIC_OPERATION_INTEGER_DECREMENT = 4

CU_ATOMIC_OPERATION_AND = 5

CU_ATOMIC_OPERATION_OR = 6

CU_ATOMIC_OPERATION_XOR = 7

CU_ATOMIC_OPERATION_EXCHANGE = 8

CU_ATOMIC_OPERATION_CAS = 9

CU_ATOMIC_OPERATION_FLOAT_ADD = 10

CU_ATOMIC_OPERATION_FLOAT_MIN = 11

CU_ATOMIC_OPERATION_FLOAT_MAX = 12

CU_ATOMIC_OPERATION_MAX


enum CUatomicOperationCapability


CUDA-valid Atomic Operation capabilities

######  Values

CU_ATOMIC_CAPABILITY_SIGNED = 1u<<0

CU_ATOMIC_CAPABILITY_UNSIGNED = 1u<<1

CU_ATOMIC_CAPABILITY_REDUCTION = 1u<<2

CU_ATOMIC_CAPABILITY_SCALAR_32 = 1u<<3

CU_ATOMIC_CAPABILITY_SCALAR_64 = 1u<<4

CU_ATOMIC_CAPABILITY_SCALAR_128 = 1u<<5

CU_ATOMIC_CAPABILITY_VECTOR_32x4 = 1u<<6


enum CUclusterSchedulingPolicy


Cluster scheduling policies. These may be passed to [cuFuncSetAttribute](<group__CUDA__EXEC.html#group__CUDA__EXEC_1g0e37dce0173bc883aa1e5b14dd747f26> "Sets information about a function.") or [cuKernelSetAttribute](<group__CUDA__LIBRARY.html#group__CUDA__LIBRARY_1g1093ade718915249de3b14320d567067> "Sets information about a kernel.")

######  Values

CU_CLUSTER_SCHEDULING_POLICY_DEFAULT = 0
    the default policy
CU_CLUSTER_SCHEDULING_POLICY_SPREAD = 1
    spread the blocks within a cluster to the SMs
CU_CLUSTER_SCHEDULING_POLICY_LOAD_BALANCING = 2
    allow the hardware to load-balance the blocks in a cluster to the SMs

enum CUcomputemode


Compute Modes

######  Values

CU_COMPUTEMODE_DEFAULT = 0
    Default compute mode (Multiple contexts allowed per device)
CU_COMPUTEMODE_PROHIBITED = 2
    Compute-prohibited mode (No contexts can be created on this device at this time)
CU_COMPUTEMODE_EXCLUSIVE_PROCESS = 3
    Compute-exclusive-process mode (Only one context used by a single process can be present on this device at a time)

enum CUctx_flags


Context creation flags

######  Values

CU_CTX_SCHED_AUTO = 0x00
    Automatic scheduling
CU_CTX_SCHED_SPIN = 0x01
    Set spin as default scheduling
CU_CTX_SCHED_YIELD = 0x02
    Set yield as default scheduling
CU_CTX_SCHED_BLOCKING_SYNC = 0x04
    Set blocking synchronization as default scheduling
CU_CTX_BLOCKING_SYNC = 0x04


###### [Deprecated](<deprecated.html#deprecated__deprecated_1_deprecated000051>)

This flag was deprecated as of CUDA 4.0 and was replaced with [CU_CTX_SCHED_BLOCKING_SYNC](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg9f889e28a45a295b5c8ce13aa05f6cd462aebfe6432ade3feb32f1a409027852>).

Set blocking synchronization as default scheduling

CU_CTX_SCHED_MASK = 0x07

CU_CTX_MAP_HOST = 0x08


###### [Deprecated](<deprecated.html#deprecated__deprecated_1_deprecated000052>)

This flag was deprecated as of CUDA 11.0 and it no longer has any effect. All contexts as of CUDA 3.2 behave as though the flag is enabled.

CU_CTX_LMEM_RESIZE_TO_MAX = 0x10
    Keep local memory allocation after launch
CU_CTX_COREDUMP_ENABLE = 0x20
    Trigger coredumps from exceptions in this context
CU_CTX_USER_COREDUMP_ENABLE = 0x40
    Enable user pipe to trigger coredumps in this context
CU_CTX_SYNC_MEMOPS = 0x80
    Ensure synchronous memory operations on this context will synchronize
CU_CTX_FLAGS_MASK = 0xFF


enum CUdeviceNumaConfig


CUDA device NUMA configuration

######  Values

CU_DEVICE_NUMA_CONFIG_NONE = 0
    The GPU is not a NUMA node
CU_DEVICE_NUMA_CONFIG_NUMA_NODE
    The GPU is a NUMA node, CU_DEVICE_ATTRIBUTE_NUMA_ID contains its NUMA ID

enum CUdevice_P2PAttribute


P2P Attributes

######  Values

CU_DEVICE_P2P_ATTRIBUTE_PERFORMANCE_RANK = 0x01
    A relative value indicating the performance of the link between two devices
CU_DEVICE_P2P_ATTRIBUTE_ACCESS_SUPPORTED = 0x02
    P2P Access is enable
CU_DEVICE_P2P_ATTRIBUTE_NATIVE_ATOMIC_SUPPORTED = 0x03
    All CUDA-valid atomic operation over the link are supported
CU_DEVICE_P2P_ATTRIBUTE_ACCESS_ACCESS_SUPPORTED = 0x04


###### [Deprecated](<deprecated.html#deprecated__deprecated_1_deprecated000069>)

use CU_DEVICE_P2P_ATTRIBUTE_CUDA_ARRAY_ACCESS_SUPPORTED instead

CU_DEVICE_P2P_ATTRIBUTE_CUDA_ARRAY_ACCESS_SUPPORTED = 0x04
    Accessing CUDA arrays over the link supported
CU_DEVICE_P2P_ATTRIBUTE_ONLY_PARTIAL_NATIVE_ATOMIC_SUPPORTED = 0x05
    Only some CUDA-valid atomic operations over the link are supported.

enum CUdevice_attribute


Device properties

######  Values

CU_DEVICE_ATTRIBUTE_MAX_THREADS_PER_BLOCK = 1
    Maximum number of threads per block
CU_DEVICE_ATTRIBUTE_MAX_BLOCK_DIM_X = 2
    Maximum block dimension X
CU_DEVICE_ATTRIBUTE_MAX_BLOCK_DIM_Y = 3
    Maximum block dimension Y
CU_DEVICE_ATTRIBUTE_MAX_BLOCK_DIM_Z = 4
    Maximum block dimension Z
CU_DEVICE_ATTRIBUTE_MAX_GRID_DIM_X = 5
    Maximum grid dimension X
CU_DEVICE_ATTRIBUTE_MAX_GRID_DIM_Y = 6
    Maximum grid dimension Y
CU_DEVICE_ATTRIBUTE_MAX_GRID_DIM_Z = 7
    Maximum grid dimension Z
CU_DEVICE_ATTRIBUTE_MAX_SHARED_MEMORY_PER_BLOCK = 8
    Maximum shared memory available per block in bytes
CU_DEVICE_ATTRIBUTE_SHARED_MEMORY_PER_BLOCK = 8
    Deprecated, use CU_DEVICE_ATTRIBUTE_MAX_SHARED_MEMORY_PER_BLOCK
CU_DEVICE_ATTRIBUTE_TOTAL_CONSTANT_MEMORY = 9
    Memory available on device for __constant__ variables in a CUDA C kernel in bytes
CU_DEVICE_ATTRIBUTE_WARP_SIZE = 10
    Warp size in threads
CU_DEVICE_ATTRIBUTE_MAX_PITCH = 11
    Maximum pitch in bytes allowed by memory copies
CU_DEVICE_ATTRIBUTE_MAX_REGISTERS_PER_BLOCK = 12
    Maximum number of 32-bit registers available per block
CU_DEVICE_ATTRIBUTE_REGISTERS_PER_BLOCK = 12
    Deprecated, use CU_DEVICE_ATTRIBUTE_MAX_REGISTERS_PER_BLOCK
CU_DEVICE_ATTRIBUTE_CLOCK_RATE = 13
    Typical clock frequency in kilohertz
CU_DEVICE_ATTRIBUTE_TEXTURE_ALIGNMENT = 14
    Alignment requirement for textures
CU_DEVICE_ATTRIBUTE_GPU_OVERLAP = 15
    Device can possibly copy memory and execute a kernel concurrently. Deprecated. Use instead CU_DEVICE_ATTRIBUTE_ASYNC_ENGINE_COUNT.
CU_DEVICE_ATTRIBUTE_MULTIPROCESSOR_COUNT = 16
    Number of multiprocessors on device
CU_DEVICE_ATTRIBUTE_KERNEL_EXEC_TIMEOUT = 17
    Specifies whether there is a run time limit on kernels
CU_DEVICE_ATTRIBUTE_INTEGRATED = 18
    Device is integrated with host memory
CU_DEVICE_ATTRIBUTE_CAN_MAP_HOST_MEMORY = 19
    Device can map host memory into CUDA address space
CU_DEVICE_ATTRIBUTE_COMPUTE_MODE = 20
    Compute mode (See [CUcomputemode](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g637aab2eadb52e1c1c048b8bad9592d1>) for details)
CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE1D_WIDTH = 21
    Maximum 1D texture width
CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_WIDTH = 22
    Maximum 2D texture width
CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_HEIGHT = 23
    Maximum 2D texture height
CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE3D_WIDTH = 24
    Maximum 3D texture width
CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE3D_HEIGHT = 25
    Maximum 3D texture height
CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE3D_DEPTH = 26
    Maximum 3D texture depth
CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_LAYERED_WIDTH = 27
    Maximum 2D layered texture width
CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_LAYERED_HEIGHT = 28
    Maximum 2D layered texture height
CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_LAYERED_LAYERS = 29
    Maximum layers in a 2D layered texture
CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_ARRAY_WIDTH = 27
    Deprecated, use CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_LAYERED_WIDTH
CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_ARRAY_HEIGHT = 28
    Deprecated, use CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_LAYERED_HEIGHT
CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_ARRAY_NUMSLICES = 29
    Deprecated, use CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_LAYERED_LAYERS
CU_DEVICE_ATTRIBUTE_SURFACE_ALIGNMENT = 30
    Alignment requirement for surfaces
CU_DEVICE_ATTRIBUTE_CONCURRENT_KERNELS = 31
    Device can possibly execute multiple kernels concurrently
CU_DEVICE_ATTRIBUTE_ECC_ENABLED = 32
    Device has ECC support enabled
CU_DEVICE_ATTRIBUTE_PCI_BUS_ID = 33
    PCI bus ID of the device
CU_DEVICE_ATTRIBUTE_PCI_DEVICE_ID = 34
    PCI device ID of the device
CU_DEVICE_ATTRIBUTE_TCC_DRIVER = 35
    Device is using TCC driver model
CU_DEVICE_ATTRIBUTE_MEMORY_CLOCK_RATE = 36
    Peak memory clock frequency in kilohertz
CU_DEVICE_ATTRIBUTE_GLOBAL_MEMORY_BUS_WIDTH = 37
    Global memory bus width in bits
CU_DEVICE_ATTRIBUTE_L2_CACHE_SIZE = 38
    Size of L2 cache in bytes
CU_DEVICE_ATTRIBUTE_MAX_THREADS_PER_MULTIPROCESSOR = 39
    Maximum resident threads per multiprocessor
CU_DEVICE_ATTRIBUTE_ASYNC_ENGINE_COUNT = 40
    Number of asynchronous engines
CU_DEVICE_ATTRIBUTE_UNIFIED_ADDRESSING = 41
    Device shares a unified address space with the host
CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE1D_LAYERED_WIDTH = 42
    Maximum 1D layered texture width
CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE1D_LAYERED_LAYERS = 43
    Maximum layers in a 1D layered texture
CU_DEVICE_ATTRIBUTE_CAN_TEX2D_GATHER = 44
    Deprecated, do not use.
CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_GATHER_WIDTH = 45
    Maximum 2D texture width if CUDA_ARRAY3D_TEXTURE_GATHER is set
CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_GATHER_HEIGHT = 46
    Maximum 2D texture height if CUDA_ARRAY3D_TEXTURE_GATHER is set
CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE3D_WIDTH_ALTERNATE = 47
    Alternate maximum 3D texture width
CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE3D_HEIGHT_ALTERNATE = 48
    Alternate maximum 3D texture height
CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE3D_DEPTH_ALTERNATE = 49
    Alternate maximum 3D texture depth
CU_DEVICE_ATTRIBUTE_PCI_DOMAIN_ID = 50
    PCI domain ID of the device
CU_DEVICE_ATTRIBUTE_TEXTURE_PITCH_ALIGNMENT = 51
    Pitch alignment requirement for textures
CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURECUBEMAP_WIDTH = 52
    Maximum cubemap texture width/height
CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURECUBEMAP_LAYERED_WIDTH = 53
    Maximum cubemap layered texture width/height
CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURECUBEMAP_LAYERED_LAYERS = 54
    Maximum layers in a cubemap layered texture
CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE1D_WIDTH = 55
    Maximum 1D surface width
CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE2D_WIDTH = 56
    Maximum 2D surface width
CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE2D_HEIGHT = 57
    Maximum 2D surface height
CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE3D_WIDTH = 58
    Maximum 3D surface width
CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE3D_HEIGHT = 59
    Maximum 3D surface height
CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE3D_DEPTH = 60
    Maximum 3D surface depth
CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE1D_LAYERED_WIDTH = 61
    Maximum 1D layered surface width
CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE1D_LAYERED_LAYERS = 62
    Maximum layers in a 1D layered surface
CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE2D_LAYERED_WIDTH = 63
    Maximum 2D layered surface width
CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE2D_LAYERED_HEIGHT = 64
    Maximum 2D layered surface height
CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACE2D_LAYERED_LAYERS = 65
    Maximum layers in a 2D layered surface
CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACECUBEMAP_WIDTH = 66
    Maximum cubemap surface width
CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACECUBEMAP_LAYERED_WIDTH = 67
    Maximum cubemap layered surface width
CU_DEVICE_ATTRIBUTE_MAXIMUM_SURFACECUBEMAP_LAYERED_LAYERS = 68
    Maximum layers in a cubemap layered surface
CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE1D_LINEAR_WIDTH = 69
    Deprecated, do not use. Use [cudaDeviceGetTexture1DLinearMaxWidth()](<../cuda-runtime-api/group__CUDART__DEVICE.html#group__CUDART__DEVICE_1g45f0345fd7a3697d0766596593920f61>) or [cuDeviceGetTexture1DLinearMaxWidth()](<group__CUDA__DEVICE.html#group__CUDA__DEVICE_1gb41b3a675bae9932bffa1c0ae969b1e0> "Returns the maximum number of elements allocatable in a 1D linear texture for a given texture element size.") instead.
CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_LINEAR_WIDTH = 70
    Maximum 2D linear texture width
CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_LINEAR_HEIGHT = 71
    Maximum 2D linear texture height
CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_LINEAR_PITCH = 72
    Maximum 2D linear texture pitch in bytes
CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_MIPMAPPED_WIDTH = 73
    Maximum mipmapped 2D texture width
CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_MIPMAPPED_HEIGHT = 74
    Maximum mipmapped 2D texture height
CU_DEVICE_ATTRIBUTE_COMPUTE_CAPABILITY_MAJOR = 75
    Major compute capability version number
CU_DEVICE_ATTRIBUTE_COMPUTE_CAPABILITY_MINOR = 76
    Minor compute capability version number
CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE1D_MIPMAPPED_WIDTH = 77
    Maximum mipmapped 1D texture width
CU_DEVICE_ATTRIBUTE_STREAM_PRIORITIES_SUPPORTED = 78
    Device supports stream priorities
CU_DEVICE_ATTRIBUTE_GLOBAL_L1_CACHE_SUPPORTED = 79
    Device supports caching globals in L1
CU_DEVICE_ATTRIBUTE_LOCAL_L1_CACHE_SUPPORTED = 80
    Device supports caching locals in L1
CU_DEVICE_ATTRIBUTE_MAX_SHARED_MEMORY_PER_MULTIPROCESSOR = 81
    Maximum shared memory available per multiprocessor in bytes
CU_DEVICE_ATTRIBUTE_MAX_REGISTERS_PER_MULTIPROCESSOR = 82
    Maximum number of 32-bit registers available per multiprocessor
CU_DEVICE_ATTRIBUTE_MANAGED_MEMORY = 83
    Device can allocate managed memory on this system
CU_DEVICE_ATTRIBUTE_MULTI_GPU_BOARD = 84
    Device is on a multi-GPU board
CU_DEVICE_ATTRIBUTE_MULTI_GPU_BOARD_GROUP_ID = 85
    Unique id for a group of devices on the same multi-GPU board
CU_DEVICE_ATTRIBUTE_HOST_NATIVE_ATOMIC_SUPPORTED = 86
    Link between the device and the host supports all native atomic operations
CU_DEVICE_ATTRIBUTE_SINGLE_TO_DOUBLE_PRECISION_PERF_RATIO = 87
    Ratio of single precision performance (in floating-point operations per second) to double precision performance
CU_DEVICE_ATTRIBUTE_PAGEABLE_MEMORY_ACCESS = 88
    Device supports coherently accessing pageable memory without calling cudaHostRegister on it
CU_DEVICE_ATTRIBUTE_CONCURRENT_MANAGED_ACCESS = 89
    Device can coherently access managed memory concurrently with the CPU
CU_DEVICE_ATTRIBUTE_COMPUTE_PREEMPTION_SUPPORTED = 90
    Device supports compute preemption.
CU_DEVICE_ATTRIBUTE_CAN_USE_HOST_POINTER_FOR_REGISTERED_MEM = 91
    Device can access host registered memory at the same virtual address as the CPU
CU_DEVICE_ATTRIBUTE_CAN_USE_STREAM_MEM_OPS_V1 = 92
    Deprecated, along with v1 MemOps API, [cuStreamBatchMemOp](<group__CUDA__MEMOP.html#group__CUDA__MEMOP_1g764c442de9b671f9dec856e8ae531ed1> "Batch operations to synchronize the stream via memory operations.") and related APIs are supported.
CU_DEVICE_ATTRIBUTE_CAN_USE_64_BIT_STREAM_MEM_OPS_V1 = 93
    Deprecated, along with v1 MemOps API, 64-bit operations are supported in [cuStreamBatchMemOp](<group__CUDA__MEMOP.html#group__CUDA__MEMOP_1g764c442de9b671f9dec856e8ae531ed1> "Batch operations to synchronize the stream via memory operations.") and related APIs.
CU_DEVICE_ATTRIBUTE_CAN_USE_STREAM_WAIT_VALUE_NOR_V1 = 94
    Deprecated, along with v1 MemOps API, [CU_STREAM_WAIT_VALUE_NOR](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggf16864e8693d888f8178067470001b212f10c357c1882ae7b0b947225c1a0d55>) is supported.
CU_DEVICE_ATTRIBUTE_COOPERATIVE_LAUNCH = 95
    Device supports launching cooperative kernels via [cuLaunchCooperativeKernel](<group__CUDA__EXEC.html#group__CUDA__EXEC_1g06d753134145c4584c0c62525c1894cb> "Launches a CUDA function CUfunction or a CUDA kernel CUkernel where thread blocks can cooperate and synchronize as they execute.")
CU_DEVICE_ATTRIBUTE_COOPERATIVE_MULTI_DEVICE_LAUNCH = 96
    Deprecated, [cuLaunchCooperativeKernelMultiDevice](<group__CUDA__EXEC.html#group__CUDA__EXEC_1g1d34025bc4f8fcec82fbcfc18d07a6e2> "Launches CUDA functions on multiple devices where thread blocks can cooperate and synchronize as they execute.") is deprecated.
CU_DEVICE_ATTRIBUTE_MAX_SHARED_MEMORY_PER_BLOCK_OPTIN = 97
    Maximum optin shared memory per block
CU_DEVICE_ATTRIBUTE_CAN_FLUSH_REMOTE_WRITES = 98
    The [CU_STREAM_WAIT_VALUE_FLUSH](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggf16864e8693d888f8178067470001b215dd93e7173619c943fae495568f4d771>) flag and the [CU_STREAM_MEM_OP_FLUSH_REMOTE_WRITES](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggb257b534afdb704b6ebdb99c16a5b292d4e126a89b57ebf4a213ee1774ed103f>) MemOp are supported on the device. See [Stream Memory Operations](<group__CUDA__MEMOP.html#group__CUDA__MEMOP>) for additional details.
CU_DEVICE_ATTRIBUTE_HOST_REGISTER_SUPPORTED = 99
    Device supports host memory registration via [cudaHostRegister](<../cuda-runtime-api/group__CUDART__MEMORY.html#group__CUDART__MEMORY_1ge8d5c17670f16ac4fc8fcb4181cb490c>).
CU_DEVICE_ATTRIBUTE_PAGEABLE_MEMORY_ACCESS_USES_HOST_PAGE_TABLES = 100
    Device accesses pageable memory via the host's page tables.
CU_DEVICE_ATTRIBUTE_DIRECT_MANAGED_MEM_ACCESS_FROM_HOST = 101
    The host can directly access managed memory on the device without migration.
CU_DEVICE_ATTRIBUTE_VIRTUAL_ADDRESS_MANAGEMENT_SUPPORTED = 102
    Deprecated, Use CU_DEVICE_ATTRIBUTE_VIRTUAL_MEMORY_MANAGEMENT_SUPPORTED
CU_DEVICE_ATTRIBUTE_VIRTUAL_MEMORY_MANAGEMENT_SUPPORTED = 102
    Device supports virtual memory management APIs like [cuMemAddressReserve](<group__CUDA__VA.html#group__CUDA__VA_1ge489256c107df2a07ddf96d80c86cd9b> "Allocate an address range reservation."), [cuMemCreate](<group__CUDA__VA.html#group__CUDA__VA_1g899d69a862bba36449789c64b430dc7c> "Create a CUDA memory handle representing a memory allocation of a given size described by the given properties."), [cuMemMap](<group__CUDA__VA.html#group__CUDA__VA_1gff1d395423af5c5c75375516959dae56> "Maps an allocation handle to a reserved virtual address range.") and related APIs
CU_DEVICE_ATTRIBUTE_HANDLE_TYPE_POSIX_FILE_DESCRIPTOR_SUPPORTED = 103
    Device supports exporting memory to a posix file descriptor with [cuMemExportToShareableHandle](<group__CUDA__VA.html#group__CUDA__VA_1g633f273b155815f23c1d70e7d9384c56> "Exports an allocation to a requested shareable handle type."), if requested via [cuMemCreate](<group__CUDA__VA.html#group__CUDA__VA_1g899d69a862bba36449789c64b430dc7c> "Create a CUDA memory handle representing a memory allocation of a given size described by the given properties.")
CU_DEVICE_ATTRIBUTE_HANDLE_TYPE_WIN32_HANDLE_SUPPORTED = 104
    Device supports exporting memory to a Win32 NT handle with [cuMemExportToShareableHandle](<group__CUDA__VA.html#group__CUDA__VA_1g633f273b155815f23c1d70e7d9384c56> "Exports an allocation to a requested shareable handle type."), if requested via [cuMemCreate](<group__CUDA__VA.html#group__CUDA__VA_1g899d69a862bba36449789c64b430dc7c> "Create a CUDA memory handle representing a memory allocation of a given size described by the given properties.")
CU_DEVICE_ATTRIBUTE_HANDLE_TYPE_WIN32_KMT_HANDLE_SUPPORTED = 105
    Device supports exporting memory to a Win32 KMT handle with [cuMemExportToShareableHandle](<group__CUDA__VA.html#group__CUDA__VA_1g633f273b155815f23c1d70e7d9384c56> "Exports an allocation to a requested shareable handle type."), if requested via [cuMemCreate](<group__CUDA__VA.html#group__CUDA__VA_1g899d69a862bba36449789c64b430dc7c> "Create a CUDA memory handle representing a memory allocation of a given size described by the given properties.")
CU_DEVICE_ATTRIBUTE_MAX_BLOCKS_PER_MULTIPROCESSOR = 106
    Maximum number of blocks per multiprocessor
CU_DEVICE_ATTRIBUTE_GENERIC_COMPRESSION_SUPPORTED = 107
    Device supports compression of memory
CU_DEVICE_ATTRIBUTE_MAX_PERSISTING_L2_CACHE_SIZE = 108
    Maximum L2 persisting lines capacity setting in bytes.
CU_DEVICE_ATTRIBUTE_MAX_ACCESS_POLICY_WINDOW_SIZE = 109
    Maximum value of [CUaccessPolicyWindow::num_bytes](<structCUaccessPolicyWindow__v1.html#structCUaccessPolicyWindow__v1_179ee4c983788bc68605d42aee2701eec>).
CU_DEVICE_ATTRIBUTE_GPU_DIRECT_RDMA_WITH_CUDA_VMM_SUPPORTED = 110
    Device supports specifying the GPUDirect RDMA flag with [cuMemCreate](<group__CUDA__VA.html#group__CUDA__VA_1g899d69a862bba36449789c64b430dc7c> "Create a CUDA memory handle representing a memory allocation of a given size described by the given properties.")
CU_DEVICE_ATTRIBUTE_RESERVED_SHARED_MEMORY_PER_BLOCK = 111
    Shared memory reserved by CUDA driver per block in bytes
CU_DEVICE_ATTRIBUTE_SPARSE_CUDA_ARRAY_SUPPORTED = 112
    Device supports sparse CUDA arrays and sparse CUDA mipmapped arrays
CU_DEVICE_ATTRIBUTE_READ_ONLY_HOST_REGISTER_SUPPORTED = 113
    Device supports using the [cuMemHostRegister](<group__CUDA__MEM.html#group__CUDA__MEM_1gf0a9fe11544326dabd743b7aa6b54223> "Registers an existing host memory range for use by CUDA.") flag CU_MEMHOSTERGISTER_READ_ONLY to register memory that must be mapped as read-only to the GPU
CU_DEVICE_ATTRIBUTE_TIMELINE_SEMAPHORE_INTEROP_SUPPORTED = 114
    External timeline semaphore interop is supported on the device
CU_DEVICE_ATTRIBUTE_MEMORY_POOLS_SUPPORTED = 115
    Device supports using the [cuMemAllocAsync](<group__CUDA__MALLOC__ASYNC.html#group__CUDA__MALLOC__ASYNC_1g13413273e84a641bce1929eae9e6501f> "Allocates memory with stream ordered semantics.") and cuMemPool family of APIs
CU_DEVICE_ATTRIBUTE_GPU_DIRECT_RDMA_SUPPORTED = 116
    Device supports GPUDirect RDMA APIs, like nvidia_p2p_get_pages (see <https://docs.nvidia.com/cuda/gpudirect-rdma> for more information)
CU_DEVICE_ATTRIBUTE_GPU_DIRECT_RDMA_FLUSH_WRITES_OPTIONS = 117
    The returned attribute shall be interpreted as a bitmask, where the individual bits are described by the [CUflushGPUDirectRDMAWritesOptions](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gf34334d1d6892847a5d05be7ca8db3c6>) enum
CU_DEVICE_ATTRIBUTE_GPU_DIRECT_RDMA_WRITES_ORDERING = 118
    GPUDirect RDMA writes to the device do not need to be flushed for consumers within the scope indicated by the returned attribute. See [CUGPUDirectRDMAWritesOrdering](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g8d647023012ffc318ce86814fec05376>) for the numerical values returned here.
CU_DEVICE_ATTRIBUTE_MEMPOOL_SUPPORTED_HANDLE_TYPES = 119
    Handle types supported with mempool based IPC
CU_DEVICE_ATTRIBUTE_CLUSTER_LAUNCH = 120
    Indicates device supports cluster launch
CU_DEVICE_ATTRIBUTE_DEFERRED_MAPPING_CUDA_ARRAY_SUPPORTED = 121
    Device supports deferred mapping CUDA arrays and CUDA mipmapped arrays
CU_DEVICE_ATTRIBUTE_CAN_USE_64_BIT_STREAM_MEM_OPS = 122
    64-bit operations are supported in [cuStreamBatchMemOp](<group__CUDA__MEMOP.html#group__CUDA__MEMOP_1g764c442de9b671f9dec856e8ae531ed1> "Batch operations to synchronize the stream via memory operations.") and related MemOp APIs.
CU_DEVICE_ATTRIBUTE_CAN_USE_STREAM_WAIT_VALUE_NOR = 123
     [CU_STREAM_WAIT_VALUE_NOR](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggf16864e8693d888f8178067470001b212f10c357c1882ae7b0b947225c1a0d55>) is supported by MemOp APIs.
CU_DEVICE_ATTRIBUTE_DMA_BUF_SUPPORTED = 124
    Device supports buffer sharing with dma_buf mechanism.
CU_DEVICE_ATTRIBUTE_IPC_EVENT_SUPPORTED = 125
    Device supports IPC Events.
CU_DEVICE_ATTRIBUTE_MEM_SYNC_DOMAIN_COUNT = 126
    Number of memory domains the device supports.
CU_DEVICE_ATTRIBUTE_TENSOR_MAP_ACCESS_SUPPORTED = 127
    Device supports accessing memory using Tensor Map.
CU_DEVICE_ATTRIBUTE_HANDLE_TYPE_FABRIC_SUPPORTED = 128
    Device supports exporting memory to a fabric handle with [cuMemExportToShareableHandle()](<group__CUDA__VA.html#group__CUDA__VA_1g633f273b155815f23c1d70e7d9384c56> "Exports an allocation to a requested shareable handle type.") or requested with [cuMemCreate()](<group__CUDA__VA.html#group__CUDA__VA_1g899d69a862bba36449789c64b430dc7c> "Create a CUDA memory handle representing a memory allocation of a given size described by the given properties.")
CU_DEVICE_ATTRIBUTE_UNIFIED_FUNCTION_POINTERS = 129
    Device supports unified function pointers.
CU_DEVICE_ATTRIBUTE_NUMA_CONFIG = 130
    NUMA configuration of a device: value is of type [CUdeviceNumaConfig](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gbd735e21702c410355167e04d3362eab>) enum
CU_DEVICE_ATTRIBUTE_NUMA_ID = 131
    NUMA node ID of the GPU memory
CU_DEVICE_ATTRIBUTE_MULTICAST_SUPPORTED = 132
    Device supports switch multicast and reduction operations.
CU_DEVICE_ATTRIBUTE_MPS_ENABLED = 133
    Indicates if contexts created on this device will be shared via MPS
CU_DEVICE_ATTRIBUTE_HOST_NUMA_ID = 134
    NUMA ID of the host node closest to the device. Returns -1 when system does not support NUMA.
CU_DEVICE_ATTRIBUTE_D3D12_CIG_SUPPORTED = 135
    Device supports CIG with D3D12.
CU_DEVICE_ATTRIBUTE_MEM_DECOMPRESS_ALGORITHM_MASK = 136
    The returned valued shall be interpreted as a bitmask, where the individual bits are described by the [CUmemDecompressAlgorithm](<group__CUDA__MEM.html#group__CUDA__MEM_1g6c015495b909c100e19cd4ddafceee91> "Bitmasks for CU_DEVICE_ATTRIBUTE_MEM_DECOMPRESS_ALGORITHM_MASK.") enum.
CU_DEVICE_ATTRIBUTE_MEM_DECOMPRESS_MAXIMUM_LENGTH = 137
    The returned valued is the maximum length in bytes of a single decompress operation that is allowed.
CU_DEVICE_ATTRIBUTE_VULKAN_CIG_SUPPORTED = 138
    Device supports CIG with Vulkan.
CU_DEVICE_ATTRIBUTE_GPU_PCI_DEVICE_ID = 139
    The combined 16-bit PCI device ID and 16-bit PCI vendor ID.
CU_DEVICE_ATTRIBUTE_GPU_PCI_SUBSYSTEM_ID = 140
    The combined 16-bit PCI subsystem ID and 16-bit PCI subsystem vendor ID.
CU_DEVICE_ATTRIBUTE_HOST_NUMA_VIRTUAL_MEMORY_MANAGEMENT_SUPPORTED = 141
    Device supports HOST_NUMA location with the virtual memory management APIs like [cuMemCreate](<group__CUDA__VA.html#group__CUDA__VA_1g899d69a862bba36449789c64b430dc7c> "Create a CUDA memory handle representing a memory allocation of a given size described by the given properties."), [cuMemMap](<group__CUDA__VA.html#group__CUDA__VA_1gff1d395423af5c5c75375516959dae56> "Maps an allocation handle to a reserved virtual address range.") and related APIs
CU_DEVICE_ATTRIBUTE_HOST_NUMA_MEMORY_POOLS_SUPPORTED = 142
    Device supports HOST_NUMA location with the [cuMemAllocAsync](<group__CUDA__MALLOC__ASYNC.html#group__CUDA__MALLOC__ASYNC_1g13413273e84a641bce1929eae9e6501f> "Allocates memory with stream ordered semantics.") and cuMemPool family of APIs
CU_DEVICE_ATTRIBUTE_HOST_NUMA_MULTINODE_IPC_SUPPORTED = 143
    Device supports HOST_NUMA location IPC between nodes in a multi-node system.
CU_DEVICE_ATTRIBUTE_HOST_MEMORY_POOLS_SUPPORTED = 144
    Device suports HOST location with the [cuMemAllocAsync](<group__CUDA__MALLOC__ASYNC.html#group__CUDA__MALLOC__ASYNC_1g13413273e84a641bce1929eae9e6501f> "Allocates memory with stream ordered semantics.") and cuMemPool family of APIs
CU_DEVICE_ATTRIBUTE_HOST_VIRTUAL_MEMORY_MANAGEMENT_SUPPORTED = 145
    Device supports HOST location with the virtual memory management APIs like [cuMemCreate](<group__CUDA__VA.html#group__CUDA__VA_1g899d69a862bba36449789c64b430dc7c> "Create a CUDA memory handle representing a memory allocation of a given size described by the given properties."), [cuMemMap](<group__CUDA__VA.html#group__CUDA__VA_1gff1d395423af5c5c75375516959dae56> "Maps an allocation handle to a reserved virtual address range.") and related APIs
CU_DEVICE_ATTRIBUTE_HOST_ALLOC_DMA_BUF_SUPPORTED = 146
    Device supports page-locked host memory buffer sharing with dma_buf mechanism.
CU_DEVICE_ATTRIBUTE_ONLY_PARTIAL_HOST_NATIVE_ATOMIC_SUPPORTED = 147
    Link between the device and the host supports only some native atomic operations
CU_DEVICE_ATTRIBUTE_ATOMIC_REDUCTION_SUPPORTED = 148
    Device supports atomic reduction operations in stream batch memory operations
CU_DEVICE_ATTRIBUTE_MAX


enum CUdriverProcAddressQueryResult


Flags to indicate search status. For more details see [cuGetProcAddress](<group__CUDA__DRIVER__ENTRY__POINT.html#group__CUDA__DRIVER__ENTRY__POINT_1gcae5adad00590572ab35b2508c2d6e0d> "Returns the requested driver API function pointer.")

######  Values

CU_GET_PROC_ADDRESS_SUCCESS = 0
    Symbol was succesfully found
CU_GET_PROC_ADDRESS_SYMBOL_NOT_FOUND = 1
    Symbol was not found in search
CU_GET_PROC_ADDRESS_VERSION_NOT_SUFFICIENT = 2
    Symbol was found but version supplied was not sufficient

enum CUdriverProcAddress_flags


Flags to specify search options. For more details see [cuGetProcAddress](<group__CUDA__DRIVER__ENTRY__POINT.html#group__CUDA__DRIVER__ENTRY__POINT_1gcae5adad00590572ab35b2508c2d6e0d> "Returns the requested driver API function pointer.")

######  Values

CU_GET_PROC_ADDRESS_DEFAULT = 0
    Default search mode for driver symbols.
CU_GET_PROC_ADDRESS_LEGACY_STREAM = 1<<0
    Search for legacy versions of driver symbols.
CU_GET_PROC_ADDRESS_PER_THREAD_DEFAULT_STREAM = 1<<1
    Search for per-thread versions of driver symbols.

enum CUeglColorFormat


CUDA EGL Color Format - The different planar and multiplanar formats currently supported for CUDA_EGL interops. Three channel formats are currently not supported for [CU_EGL_FRAME_TYPE_ARRAY](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggec3f4a4e1a5785b1aa0fcc209cd47c38c02019e2bb4a56d31db30925d567d101>)

######  Values

CU_EGL_COLOR_FORMAT_YUV420_PLANAR = 0x00
    Y, U, V in three surfaces, each in a separate surface, U/V width = 1/2 Y width, U/V height = 1/2 Y height.
CU_EGL_COLOR_FORMAT_YUV420_SEMIPLANAR = 0x01
    Y, UV in two surfaces (UV as one surface) with VU byte ordering, width, height ratio same as YUV420Planar.
CU_EGL_COLOR_FORMAT_YUV422_PLANAR = 0x02
    Y, U, V each in a separate surface, U/V width = 1/2 Y width, U/V height = Y height.
CU_EGL_COLOR_FORMAT_YUV422_SEMIPLANAR = 0x03
    Y, UV in two surfaces with VU byte ordering, width, height ratio same as YUV422Planar.
CU_EGL_COLOR_FORMAT_RGB = 0x04
    R/G/B three channels in one surface with BGR byte ordering. Only pitch linear format supported.
CU_EGL_COLOR_FORMAT_BGR = 0x05
    R/G/B three channels in one surface with RGB byte ordering. Only pitch linear format supported.
CU_EGL_COLOR_FORMAT_ARGB = 0x06
    R/G/B/A four channels in one surface with BGRA byte ordering.
CU_EGL_COLOR_FORMAT_RGBA = 0x07
    R/G/B/A four channels in one surface with ABGR byte ordering.
CU_EGL_COLOR_FORMAT_L = 0x08
    single luminance channel in one surface.
CU_EGL_COLOR_FORMAT_R = 0x09
    single color channel in one surface.
CU_EGL_COLOR_FORMAT_YUV444_PLANAR = 0x0A
    Y, U, V in three surfaces, each in a separate surface, U/V width = Y width, U/V height = Y height.
CU_EGL_COLOR_FORMAT_YUV444_SEMIPLANAR = 0x0B
    Y, UV in two surfaces (UV as one surface) with VU byte ordering, width, height ratio same as YUV444Planar.
CU_EGL_COLOR_FORMAT_YUYV_422 = 0x0C
    Y, U, V in one surface, interleaved as UYVY in one channel.
CU_EGL_COLOR_FORMAT_UYVY_422 = 0x0D
    Y, U, V in one surface, interleaved as YUYV in one channel.
CU_EGL_COLOR_FORMAT_ABGR = 0x0E
    R/G/B/A four channels in one surface with RGBA byte ordering.
CU_EGL_COLOR_FORMAT_BGRA = 0x0F
    R/G/B/A four channels in one surface with ARGB byte ordering.
CU_EGL_COLOR_FORMAT_A = 0x10
    Alpha color format - one channel in one surface.
CU_EGL_COLOR_FORMAT_RG = 0x11
    R/G color format - two channels in one surface with GR byte ordering
CU_EGL_COLOR_FORMAT_AYUV = 0x12
    Y, U, V, A four channels in one surface, interleaved as VUYA.
CU_EGL_COLOR_FORMAT_YVU444_SEMIPLANAR = 0x13
    Y, VU in two surfaces (VU as one surface) with UV byte ordering, U/V width = Y width, U/V height = Y height.
CU_EGL_COLOR_FORMAT_YVU422_SEMIPLANAR = 0x14
    Y, VU in two surfaces (VU as one surface) with UV byte ordering, U/V width = 1/2 Y width, U/V height = Y height.
CU_EGL_COLOR_FORMAT_YVU420_SEMIPLANAR = 0x15
    Y, VU in two surfaces (VU as one surface) with UV byte ordering, U/V width = 1/2 Y width, U/V height = 1/2 Y height.
CU_EGL_COLOR_FORMAT_Y10V10U10_444_SEMIPLANAR = 0x16
    Y10, V10U10 in two surfaces (VU as one surface) with UV byte ordering, U/V width = Y width, U/V height = Y height.
CU_EGL_COLOR_FORMAT_Y10V10U10_420_SEMIPLANAR = 0x17
    Y10, V10U10 in two surfaces (VU as one surface) with UV byte ordering, U/V width = 1/2 Y width, U/V height = 1/2 Y height.
CU_EGL_COLOR_FORMAT_Y12V12U12_444_SEMIPLANAR = 0x18
    Y12, V12U12 in two surfaces (VU as one surface) with UV byte ordering, U/V width = Y width, U/V height = Y height.
CU_EGL_COLOR_FORMAT_Y12V12U12_420_SEMIPLANAR = 0x19
    Y12, V12U12 in two surfaces (VU as one surface) with UV byte ordering, U/V width = 1/2 Y width, U/V height = 1/2 Y height.
CU_EGL_COLOR_FORMAT_VYUY_ER = 0x1A
    Extended Range Y, U, V in one surface, interleaved as YVYU in one channel.
CU_EGL_COLOR_FORMAT_UYVY_ER = 0x1B
    Extended Range Y, U, V in one surface, interleaved as YUYV in one channel.
CU_EGL_COLOR_FORMAT_YUYV_ER = 0x1C
    Extended Range Y, U, V in one surface, interleaved as UYVY in one channel.
CU_EGL_COLOR_FORMAT_YVYU_ER = 0x1D
    Extended Range Y, U, V in one surface, interleaved as VYUY in one channel.
CU_EGL_COLOR_FORMAT_YUV_ER = 0x1E
    Extended Range Y, U, V three channels in one surface, interleaved as VUY. Only pitch linear format supported.
CU_EGL_COLOR_FORMAT_YUVA_ER = 0x1F
    Extended Range Y, U, V, A four channels in one surface, interleaved as AVUY.
CU_EGL_COLOR_FORMAT_AYUV_ER = 0x20
    Extended Range Y, U, V, A four channels in one surface, interleaved as VUYA.
CU_EGL_COLOR_FORMAT_YUV444_PLANAR_ER = 0x21
    Extended Range Y, U, V in three surfaces, U/V width = Y width, U/V height = Y height.
CU_EGL_COLOR_FORMAT_YUV422_PLANAR_ER = 0x22
    Extended Range Y, U, V in three surfaces, U/V width = 1/2 Y width, U/V height = Y height.
CU_EGL_COLOR_FORMAT_YUV420_PLANAR_ER = 0x23
    Extended Range Y, U, V in three surfaces, U/V width = 1/2 Y width, U/V height = 1/2 Y height.
CU_EGL_COLOR_FORMAT_YUV444_SEMIPLANAR_ER = 0x24
    Extended Range Y, UV in two surfaces (UV as one surface) with VU byte ordering, U/V width = Y width, U/V height = Y height.
CU_EGL_COLOR_FORMAT_YUV422_SEMIPLANAR_ER = 0x25
    Extended Range Y, UV in two surfaces (UV as one surface) with VU byte ordering, U/V width = 1/2 Y width, U/V height = Y height.
CU_EGL_COLOR_FORMAT_YUV420_SEMIPLANAR_ER = 0x26
    Extended Range Y, UV in two surfaces (UV as one surface) with VU byte ordering, U/V width = 1/2 Y width, U/V height = 1/2 Y height.
CU_EGL_COLOR_FORMAT_YVU444_PLANAR_ER = 0x27
    Extended Range Y, V, U in three surfaces, U/V width = Y width, U/V height = Y height.
CU_EGL_COLOR_FORMAT_YVU422_PLANAR_ER = 0x28
    Extended Range Y, V, U in three surfaces, U/V width = 1/2 Y width, U/V height = Y height.
CU_EGL_COLOR_FORMAT_YVU420_PLANAR_ER = 0x29
    Extended Range Y, V, U in three surfaces, U/V width = 1/2 Y width, U/V height = 1/2 Y height.
CU_EGL_COLOR_FORMAT_YVU444_SEMIPLANAR_ER = 0x2A
    Extended Range Y, VU in two surfaces (VU as one surface) with UV byte ordering, U/V width = Y width, U/V height = Y height.
CU_EGL_COLOR_FORMAT_YVU422_SEMIPLANAR_ER = 0x2B
    Extended Range Y, VU in two surfaces (VU as one surface) with UV byte ordering, U/V width = 1/2 Y width, U/V height = Y height.
CU_EGL_COLOR_FORMAT_YVU420_SEMIPLANAR_ER = 0x2C
    Extended Range Y, VU in two surfaces (VU as one surface) with UV byte ordering, U/V width = 1/2 Y width, U/V height = 1/2 Y height.
CU_EGL_COLOR_FORMAT_BAYER_RGGB = 0x2D
    Bayer format - one channel in one surface with interleaved RGGB ordering.
CU_EGL_COLOR_FORMAT_BAYER_BGGR = 0x2E
    Bayer format - one channel in one surface with interleaved BGGR ordering.
CU_EGL_COLOR_FORMAT_BAYER_GRBG = 0x2F
    Bayer format - one channel in one surface with interleaved GRBG ordering.
CU_EGL_COLOR_FORMAT_BAYER_GBRG = 0x30
    Bayer format - one channel in one surface with interleaved GBRG ordering.
CU_EGL_COLOR_FORMAT_BAYER10_RGGB = 0x31
    Bayer10 format - one channel in one surface with interleaved RGGB ordering. Out of 16 bits, 10 bits used 6 bits No-op.
CU_EGL_COLOR_FORMAT_BAYER10_BGGR = 0x32
    Bayer10 format - one channel in one surface with interleaved BGGR ordering. Out of 16 bits, 10 bits used 6 bits No-op.
CU_EGL_COLOR_FORMAT_BAYER10_GRBG = 0x33
    Bayer10 format - one channel in one surface with interleaved GRBG ordering. Out of 16 bits, 10 bits used 6 bits No-op.
CU_EGL_COLOR_FORMAT_BAYER10_GBRG = 0x34
    Bayer10 format - one channel in one surface with interleaved GBRG ordering. Out of 16 bits, 10 bits used 6 bits No-op.
CU_EGL_COLOR_FORMAT_BAYER12_RGGB = 0x35
    Bayer12 format - one channel in one surface with interleaved RGGB ordering. Out of 16 bits, 12 bits used 4 bits No-op.
CU_EGL_COLOR_FORMAT_BAYER12_BGGR = 0x36
    Bayer12 format - one channel in one surface with interleaved BGGR ordering. Out of 16 bits, 12 bits used 4 bits No-op.
CU_EGL_COLOR_FORMAT_BAYER12_GRBG = 0x37
    Bayer12 format - one channel in one surface with interleaved GRBG ordering. Out of 16 bits, 12 bits used 4 bits No-op.
CU_EGL_COLOR_FORMAT_BAYER12_GBRG = 0x38
    Bayer12 format - one channel in one surface with interleaved GBRG ordering. Out of 16 bits, 12 bits used 4 bits No-op.
CU_EGL_COLOR_FORMAT_BAYER14_RGGB = 0x39
    Bayer14 format - one channel in one surface with interleaved RGGB ordering. Out of 16 bits, 14 bits used 2 bits No-op.
CU_EGL_COLOR_FORMAT_BAYER14_BGGR = 0x3A
    Bayer14 format - one channel in one surface with interleaved BGGR ordering. Out of 16 bits, 14 bits used 2 bits No-op.
CU_EGL_COLOR_FORMAT_BAYER14_GRBG = 0x3B
    Bayer14 format - one channel in one surface with interleaved GRBG ordering. Out of 16 bits, 14 bits used 2 bits No-op.
CU_EGL_COLOR_FORMAT_BAYER14_GBRG = 0x3C
    Bayer14 format - one channel in one surface with interleaved GBRG ordering. Out of 16 bits, 14 bits used 2 bits No-op.
CU_EGL_COLOR_FORMAT_BAYER20_RGGB = 0x3D
    Bayer20 format - one channel in one surface with interleaved RGGB ordering. Out of 32 bits, 20 bits used 12 bits No-op.
CU_EGL_COLOR_FORMAT_BAYER20_BGGR = 0x3E
    Bayer20 format - one channel in one surface with interleaved BGGR ordering. Out of 32 bits, 20 bits used 12 bits No-op.
CU_EGL_COLOR_FORMAT_BAYER20_GRBG = 0x3F
    Bayer20 format - one channel in one surface with interleaved GRBG ordering. Out of 32 bits, 20 bits used 12 bits No-op.
CU_EGL_COLOR_FORMAT_BAYER20_GBRG = 0x40
    Bayer20 format - one channel in one surface with interleaved GBRG ordering. Out of 32 bits, 20 bits used 12 bits No-op.
CU_EGL_COLOR_FORMAT_YVU444_PLANAR = 0x41
    Y, V, U in three surfaces, each in a separate surface, U/V width = Y width, U/V height = Y height.
CU_EGL_COLOR_FORMAT_YVU422_PLANAR = 0x42
    Y, V, U in three surfaces, each in a separate surface, U/V width = 1/2 Y width, U/V height = Y height.
CU_EGL_COLOR_FORMAT_YVU420_PLANAR = 0x43
    Y, V, U in three surfaces, each in a separate surface, U/V width = 1/2 Y width, U/V height = 1/2 Y height.
CU_EGL_COLOR_FORMAT_BAYER_ISP_RGGB = 0x44
    Nvidia proprietary Bayer ISP format - one channel in one surface with interleaved RGGB ordering and mapped to opaque integer datatype.
CU_EGL_COLOR_FORMAT_BAYER_ISP_BGGR = 0x45
    Nvidia proprietary Bayer ISP format - one channel in one surface with interleaved BGGR ordering and mapped to opaque integer datatype.
CU_EGL_COLOR_FORMAT_BAYER_ISP_GRBG = 0x46
    Nvidia proprietary Bayer ISP format - one channel in one surface with interleaved GRBG ordering and mapped to opaque integer datatype.
CU_EGL_COLOR_FORMAT_BAYER_ISP_GBRG = 0x47
    Nvidia proprietary Bayer ISP format - one channel in one surface with interleaved GBRG ordering and mapped to opaque integer datatype.
CU_EGL_COLOR_FORMAT_BAYER_BCCR = 0x48
    Bayer format - one channel in one surface with interleaved BCCR ordering.
CU_EGL_COLOR_FORMAT_BAYER_RCCB = 0x49
    Bayer format - one channel in one surface with interleaved RCCB ordering.
CU_EGL_COLOR_FORMAT_BAYER_CRBC = 0x4A
    Bayer format - one channel in one surface with interleaved CRBC ordering.
CU_EGL_COLOR_FORMAT_BAYER_CBRC = 0x4B
    Bayer format - one channel in one surface with interleaved CBRC ordering.
CU_EGL_COLOR_FORMAT_BAYER10_CCCC = 0x4C
    Bayer10 format - one channel in one surface with interleaved CCCC ordering. Out of 16 bits, 10 bits used 6 bits No-op.
CU_EGL_COLOR_FORMAT_BAYER12_BCCR = 0x4D
    Bayer12 format - one channel in one surface with interleaved BCCR ordering. Out of 16 bits, 12 bits used 4 bits No-op.
CU_EGL_COLOR_FORMAT_BAYER12_RCCB = 0x4E
    Bayer12 format - one channel in one surface with interleaved RCCB ordering. Out of 16 bits, 12 bits used 4 bits No-op.
CU_EGL_COLOR_FORMAT_BAYER12_CRBC = 0x4F
    Bayer12 format - one channel in one surface with interleaved CRBC ordering. Out of 16 bits, 12 bits used 4 bits No-op.
CU_EGL_COLOR_FORMAT_BAYER12_CBRC = 0x50
    Bayer12 format - one channel in one surface with interleaved CBRC ordering. Out of 16 bits, 12 bits used 4 bits No-op.
CU_EGL_COLOR_FORMAT_BAYER12_CCCC = 0x51
    Bayer12 format - one channel in one surface with interleaved CCCC ordering. Out of 16 bits, 12 bits used 4 bits No-op.
CU_EGL_COLOR_FORMAT_Y = 0x52
    Color format for single Y plane.
CU_EGL_COLOR_FORMAT_YUV420_SEMIPLANAR_2020 = 0x53
    Y, UV in two surfaces (UV as one surface) U/V width = 1/2 Y width, U/V height = 1/2 Y height.
CU_EGL_COLOR_FORMAT_YVU420_SEMIPLANAR_2020 = 0x54
    Y, VU in two surfaces (VU as one surface) U/V width = 1/2 Y width, U/V height = 1/2 Y height.
CU_EGL_COLOR_FORMAT_YUV420_PLANAR_2020 = 0x55
    Y, U, V each in a separate surface, U/V width = 1/2 Y width, U/V height= 1/2 Y height.
CU_EGL_COLOR_FORMAT_YVU420_PLANAR_2020 = 0x56
    Y, V, U each in a separate surface, U/V width = 1/2 Y width, U/V height = 1/2 Y height.
CU_EGL_COLOR_FORMAT_YUV420_SEMIPLANAR_709 = 0x57
    Y, UV in two surfaces (UV as one surface) U/V width = 1/2 Y width, U/V height = 1/2 Y height.
CU_EGL_COLOR_FORMAT_YVU420_SEMIPLANAR_709 = 0x58
    Y, VU in two surfaces (VU as one surface) U/V width = 1/2 Y width, U/V height = 1/2 Y height.
CU_EGL_COLOR_FORMAT_YUV420_PLANAR_709 = 0x59
    Y, U, V each in a separate surface, U/V width = 1/2 Y width, U/V height = 1/2 Y height.
CU_EGL_COLOR_FORMAT_YVU420_PLANAR_709 = 0x5A
    Y, V, U each in a separate surface, U/V width = 1/2 Y width, U/V height = 1/2 Y height.
CU_EGL_COLOR_FORMAT_Y10V10U10_420_SEMIPLANAR_709 = 0x5B
    Y10, V10U10 in two surfaces (VU as one surface), U/V width = 1/2 Y width, U/V height = 1/2 Y height.
CU_EGL_COLOR_FORMAT_Y10V10U10_420_SEMIPLANAR_2020 = 0x5C
    Y10, V10U10 in two surfaces (VU as one surface), U/V width = 1/2 Y width, U/V height = 1/2 Y height.
CU_EGL_COLOR_FORMAT_Y10V10U10_422_SEMIPLANAR_2020 = 0x5D
    Y10, V10U10 in two surfaces(VU as one surface) U/V width = 1/2 Y width, U/V height = Y height.
CU_EGL_COLOR_FORMAT_Y10V10U10_422_SEMIPLANAR = 0x5E
    Y10, V10U10 in two surfaces(VU as one surface) U/V width = 1/2 Y width, U/V height = Y height.
CU_EGL_COLOR_FORMAT_Y10V10U10_422_SEMIPLANAR_709 = 0x5F
    Y10, V10U10 in two surfaces(VU as one surface) U/V width = 1/2 Y width, U/V height = Y height.
CU_EGL_COLOR_FORMAT_Y_ER = 0x60
    Extended Range Color format for single Y plane.
CU_EGL_COLOR_FORMAT_Y_709_ER = 0x61
    Extended Range Color format for single Y plane.
CU_EGL_COLOR_FORMAT_Y10_ER = 0x62
    Extended Range Color format for single Y10 plane.
CU_EGL_COLOR_FORMAT_Y10_709_ER = 0x63
    Extended Range Color format for single Y10 plane.
CU_EGL_COLOR_FORMAT_Y12_ER = 0x64
    Extended Range Color format for single Y12 plane.
CU_EGL_COLOR_FORMAT_Y12_709_ER = 0x65
    Extended Range Color format for single Y12 plane.
CU_EGL_COLOR_FORMAT_YUVA = 0x66
    Y, U, V, A four channels in one surface, interleaved as AVUY.
CU_EGL_COLOR_FORMAT_YUV = 0x67
    Y, U, V three channels in one surface, interleaved as VUY. Only pitch linear format supported.
CU_EGL_COLOR_FORMAT_YVYU = 0x68
    Y, U, V in one surface, interleaved as YVYU in one channel.
CU_EGL_COLOR_FORMAT_VYUY = 0x69
    Y, U, V in one surface, interleaved as VYUY in one channel.
CU_EGL_COLOR_FORMAT_Y10V10U10_420_SEMIPLANAR_ER = 0x6A
    Extended Range Y10, V10U10 in two surfaces(VU as one surface) U/V width = 1/2 Y width, U/V height = 1/2 Y height.
CU_EGL_COLOR_FORMAT_Y10V10U10_420_SEMIPLANAR_709_ER = 0x6B
    Extended Range Y10, V10U10 in two surfaces(VU as one surface) U/V width = 1/2 Y width, U/V height = 1/2 Y height.
CU_EGL_COLOR_FORMAT_Y10V10U10_444_SEMIPLANAR_ER = 0x6C
    Extended Range Y10, V10U10 in two surfaces (VU as one surface) U/V width = Y width, U/V height = Y height.
CU_EGL_COLOR_FORMAT_Y10V10U10_444_SEMIPLANAR_709_ER = 0x6D
    Extended Range Y10, V10U10 in two surfaces (VU as one surface) U/V width = Y width, U/V height = Y height.
CU_EGL_COLOR_FORMAT_Y12V12U12_420_SEMIPLANAR_ER = 0x6E
    Extended Range Y12, V12U12 in two surfaces (VU as one surface) U/V width = 1/2 Y width, U/V height = 1/2 Y height.
CU_EGL_COLOR_FORMAT_Y12V12U12_420_SEMIPLANAR_709_ER = 0x6F
    Extended Range Y12, V12U12 in two surfaces (VU as one surface) U/V width = 1/2 Y width, U/V height = 1/2 Y height.
CU_EGL_COLOR_FORMAT_Y12V12U12_444_SEMIPLANAR_ER = 0x70
    Extended Range Y12, V12U12 in two surfaces (VU as one surface) U/V width = Y width, U/V height = Y height.
CU_EGL_COLOR_FORMAT_Y12V12U12_444_SEMIPLANAR_709_ER = 0x71
    Extended Range Y12, V12U12 in two surfaces (VU as one surface) U/V width = Y width, U/V height = Y height.
CU_EGL_COLOR_FORMAT_UYVY_709 = 0x72
    Y, U, V in one surface, interleaved as UYVY in one channel.
CU_EGL_COLOR_FORMAT_UYVY_709_ER = 0x73
    Extended Range Y, U, V in one surface, interleaved as UYVY in one channel.
CU_EGL_COLOR_FORMAT_UYVY_2020 = 0x74
    Y, U, V in one surface, interleaved as UYVY in one channel.
CU_EGL_COLOR_FORMAT_MAX


enum CUeglFrameType


CUDA EglFrame type - array or pointer

######  Values

CU_EGL_FRAME_TYPE_ARRAY = 0
    Frame type CUDA array
CU_EGL_FRAME_TYPE_PITCH = 1
    Frame type pointer

enum CUeglResourceLocationFlags


Resource location flags- sysmem or vidmem

For CUDA context on iGPU, since video and system memory are equivalent - these flags will not have an effect on the execution.

For CUDA context on dGPU, applications can use the flag [CUeglResourceLocationFlags](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gf2804cd7cda3b8716c31ba620f644cd3>) to give a hint about the desired location.

[CU_EGL_RESOURCE_LOCATION_SYSMEM](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggf2804cd7cda3b8716c31ba620f644cd30033e7197256284919d4dd8f8a45482a>) \- the frame data is made resident on the system memory to be accessed by CUDA.

[CU_EGL_RESOURCE_LOCATION_VIDMEM](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggf2804cd7cda3b8716c31ba620f644cd3115dedc3b0a393b00d2c38d996daeedc>) \- the frame data is made resident on the dedicated video memory to be accessed by CUDA.

There may be an additional latency due to new allocation and data migration, if the frame is produced on a different memory.

######  Values

CU_EGL_RESOURCE_LOCATION_SYSMEM = 0x00
    Resource location sysmem
CU_EGL_RESOURCE_LOCATION_VIDMEM = 0x01
    Resource location vidmem

enum CUevent_flags


Event creation flags

######  Values

CU_EVENT_DEFAULT = 0x0
    Default event flag
CU_EVENT_BLOCKING_SYNC = 0x1
    Event uses blocking synchronization
CU_EVENT_DISABLE_TIMING = 0x2
    Event will not record timing data
CU_EVENT_INTERPROCESS = 0x4
    Event is suitable for interprocess use. CU_EVENT_DISABLE_TIMING must be set

enum CUevent_record_flags


Event record flags

######  Values

CU_EVENT_RECORD_DEFAULT = 0x0
    Default event record flag
CU_EVENT_RECORD_EXTERNAL = 0x1
    When using stream capture, create an event record node instead of the default behavior. This flag is invalid when used outside of capture.

enum CUevent_sched_flags


Event sched flags

######  Values

CU_EVENT_SCHED_AUTO = 0x00
    Automatic scheduling
CU_EVENT_SCHED_SPIN = 0x01
    Set spin as default scheduling
CU_EVENT_SCHED_YIELD = 0x02
    Set yield as default scheduling
CU_EVENT_SCHED_BLOCKING_SYNC = 0x04
    Set blocking synchronization as default scheduling

enum CUevent_wait_flags


Event wait flags

######  Values

CU_EVENT_WAIT_DEFAULT = 0x0
    Default event wait flag
CU_EVENT_WAIT_EXTERNAL = 0x1
    When using stream capture, create an event wait node instead of the default behavior. This flag is invalid when used outside of capture.

enum CUexecAffinityType


Execution Affinity Types

######  Values

CU_EXEC_AFFINITY_TYPE_SM_COUNT = 0
    Create a context with limited SMs.
CU_EXEC_AFFINITY_TYPE_MAX


enum CUexternalMemoryHandleType


External memory handle types

######  Values

CU_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_FD = 1
    Handle is an opaque file descriptor
CU_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32 = 2
    Handle is an opaque shared NT handle
CU_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT = 3
    Handle is an opaque, globally shared handle
CU_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_HEAP = 4
    Handle is a D3D12 heap object
CU_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_RESOURCE = 5
    Handle is a D3D12 committed resource
CU_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_RESOURCE = 6
    Handle is a shared NT handle to a D3D11 resource
CU_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_RESOURCE_KMT = 7
    Handle is a globally shared handle to a D3D11 resource
CU_EXTERNAL_MEMORY_HANDLE_TYPE_NVSCIBUF = 8
    Handle is an NvSciBuf object
CU_EXTERNAL_MEMORY_HANDLE_TYPE_DMABUF_FD = 9
    Handle is a dma_buf file descriptor

enum CUexternalSemaphoreHandleType


External semaphore handle types

######  Values

CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_FD = 1
    Handle is an opaque file descriptor
CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32 = 2
    Handle is an opaque shared NT handle
CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_KMT = 3
    Handle is an opaque, globally shared handle
CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D12_FENCE = 4
    Handle is a shared NT handle referencing a D3D12 fence object
CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D11_FENCE = 5
    Handle is a shared NT handle referencing a D3D11 fence object
CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_NVSCISYNC = 6
    Opaque handle to NvSciSync Object
CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D11_KEYED_MUTEX = 7
    Handle is a shared NT handle referencing a D3D11 keyed mutex object
CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D11_KEYED_MUTEX_KMT = 8
    Handle is a globally shared handle referencing a D3D11 keyed mutex object
CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_TIMELINE_SEMAPHORE_FD = 9
    Handle is an opaque file descriptor referencing a timeline semaphore
CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_TIMELINE_SEMAPHORE_WIN32 = 10
    Handle is an opaque shared NT handle referencing a timeline semaphore

enum CUfilter_mode


Texture reference filtering modes

######  Values

CU_TR_FILTER_MODE_POINT = 0
    Point filter mode
CU_TR_FILTER_MODE_LINEAR = 1
    Linear filter mode

enum CUflushGPUDirectRDMAWritesOptions


Bitmasks for [CU_DEVICE_ATTRIBUTE_GPU_DIRECT_RDMA_FLUSH_WRITES_OPTIONS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gge12b8a782bebe21b1ac0091bf9f4e2a33630698407acd57d625667eaa5014f6f>)

######  Values

CU_FLUSH_GPU_DIRECT_RDMA_WRITES_OPTION_HOST = 1<<0
     [cuFlushGPUDirectRDMAWrites()](<group__CUDA__DEVICE.html#group__CUDA__DEVICE_1g265e3c82ef0f0fe035f85c4c45a8fbdf> "Blocks until remote writes are visible to the specified scope.") and its CUDA Runtime API counterpart are supported on the device.
CU_FLUSH_GPU_DIRECT_RDMA_WRITES_OPTION_MEMOPS = 1<<1
    The [CU_STREAM_WAIT_VALUE_FLUSH](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggf16864e8693d888f8178067470001b215dd93e7173619c943fae495568f4d771>) flag and the [CU_STREAM_MEM_OP_FLUSH_REMOTE_WRITES](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggb257b534afdb704b6ebdb99c16a5b292d4e126a89b57ebf4a213ee1774ed103f>) MemOp are supported on the device.

enum CUflushGPUDirectRDMAWritesScope


The scopes for [cuFlushGPUDirectRDMAWrites](<group__CUDA__DEVICE.html#group__CUDA__DEVICE_1g265e3c82ef0f0fe035f85c4c45a8fbdf> "Blocks until remote writes are visible to the specified scope.")

######  Values

CU_FLUSH_GPU_DIRECT_RDMA_WRITES_TO_OWNER = 100
    Blocks until remote writes are visible to the CUDA device context owning the data.
CU_FLUSH_GPU_DIRECT_RDMA_WRITES_TO_ALL_DEVICES = 200
    Blocks until remote writes are visible to all CUDA device contexts.

enum CUflushGPUDirectRDMAWritesTarget


The targets for [cuFlushGPUDirectRDMAWrites](<group__CUDA__DEVICE.html#group__CUDA__DEVICE_1g265e3c82ef0f0fe035f85c4c45a8fbdf> "Blocks until remote writes are visible to the specified scope.")

######  Values

CU_FLUSH_GPU_DIRECT_RDMA_WRITES_TARGET_CURRENT_CTX = 0
    Sets the target for [cuFlushGPUDirectRDMAWrites()](<group__CUDA__DEVICE.html#group__CUDA__DEVICE_1g265e3c82ef0f0fe035f85c4c45a8fbdf> "Blocks until remote writes are visible to the specified scope.") to the currently active CUDA device context.

enum CUfunc_cache


Function cache configurations

######  Values

CU_FUNC_CACHE_PREFER_NONE = 0x00
    no preference for shared memory or L1 (default)
CU_FUNC_CACHE_PREFER_SHARED = 0x01
    prefer larger shared memory and smaller L1 cache
CU_FUNC_CACHE_PREFER_L1 = 0x02
    prefer larger L1 cache and smaller shared memory
CU_FUNC_CACHE_PREFER_EQUAL = 0x03
    prefer equal sized L1 cache and shared memory

enum CUfunction_attribute


Function properties

######  Values

CU_FUNC_ATTRIBUTE_MAX_THREADS_PER_BLOCK = 0
    The maximum number of threads per block, beyond which a launch of the function would fail. This number depends on both the function and the device on which the function is currently loaded.
CU_FUNC_ATTRIBUTE_SHARED_SIZE_BYTES = 1
    The size in bytes of statically-allocated shared memory required by this function. This does not include dynamically-allocated shared memory requested by the user at runtime.
CU_FUNC_ATTRIBUTE_CONST_SIZE_BYTES = 2
    The size in bytes of user-allocated constant memory required by this function.
CU_FUNC_ATTRIBUTE_LOCAL_SIZE_BYTES = 3
    The size in bytes of local memory used by each thread of this function.
CU_FUNC_ATTRIBUTE_NUM_REGS = 4
    The number of registers used by each thread of this function.
CU_FUNC_ATTRIBUTE_PTX_VERSION = 5
    The PTX virtual architecture version for which the function was compiled. This value is the major PTX version * 10 + the minor PTX version, so a PTX version 1.3 function would return the value 13. Note that this may return the undefined value of 0 for cubins compiled prior to CUDA 3.0.
CU_FUNC_ATTRIBUTE_BINARY_VERSION = 6
    The binary architecture version for which the function was compiled. This value is the major binary version * 10 + the minor binary version, so a binary version 1.3 function would return the value 13. Note that this will return a value of 10 for legacy cubins that do not have a properly-encoded binary architecture version.
CU_FUNC_ATTRIBUTE_CACHE_MODE_CA = 7
    The attribute to indicate whether the function has been compiled with user specified option "-Xptxas --dlcm=ca" set .
CU_FUNC_ATTRIBUTE_MAX_DYNAMIC_SHARED_SIZE_BYTES = 8
    The maximum size in bytes of dynamically-allocated shared memory that can be used by this function. If the user-specified dynamic shared memory size is larger than this value, the launch will fail. The default value of this attribute is [CU_DEVICE_ATTRIBUTE_MAX_SHARED_MEMORY_PER_BLOCK](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gge12b8a782bebe21b1ac0091bf9f4e2a3708d91d4570063af37ee8e722d0cf32c>) \- [CU_FUNC_ATTRIBUTE_SHARED_SIZE_BYTES](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg9d955dde0904a9b43ca4d875ac1551bc15651a634781263c9d4ee6070a3991f4>), except when [CU_FUNC_ATTRIBUTE_SHARED_SIZE_BYTES](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg9d955dde0904a9b43ca4d875ac1551bc15651a634781263c9d4ee6070a3991f4>) is greater than [CU_DEVICE_ATTRIBUTE_MAX_SHARED_MEMORY_PER_BLOCK](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gge12b8a782bebe21b1ac0091bf9f4e2a3708d91d4570063af37ee8e722d0cf32c>), then the default value of this attribute is 0. The value can be increased to [CU_DEVICE_ATTRIBUTE_MAX_SHARED_MEMORY_PER_BLOCK_OPTIN](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gge12b8a782bebe21b1ac0091bf9f4e2a3e788564c0a95b866dc624fbc1b49dab3>) \- [CU_FUNC_ATTRIBUTE_SHARED_SIZE_BYTES](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg9d955dde0904a9b43ca4d875ac1551bc15651a634781263c9d4ee6070a3991f4>). See [cuFuncSetAttribute](<group__CUDA__EXEC.html#group__CUDA__EXEC_1g0e37dce0173bc883aa1e5b14dd747f26> "Sets information about a function."), [cuKernelSetAttribute](<group__CUDA__LIBRARY.html#group__CUDA__LIBRARY_1g1093ade718915249de3b14320d567067> "Sets information about a kernel.")
CU_FUNC_ATTRIBUTE_PREFERRED_SHARED_MEMORY_CARVEOUT = 9
    On devices where the L1 cache and shared memory use the same hardware resources, this sets the shared memory carveout preference, in percent of the total shared memory. Refer to [CU_DEVICE_ATTRIBUTE_MAX_SHARED_MEMORY_PER_MULTIPROCESSOR](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gge12b8a782bebe21b1ac0091bf9f4e2a306a33c18889f6fc907412451c95154ed>). This is only a hint, and the driver can choose a different ratio if required to execute the function. See [cuFuncSetAttribute](<group__CUDA__EXEC.html#group__CUDA__EXEC_1g0e37dce0173bc883aa1e5b14dd747f26> "Sets information about a function."), [cuKernelSetAttribute](<group__CUDA__LIBRARY.html#group__CUDA__LIBRARY_1g1093ade718915249de3b14320d567067> "Sets information about a kernel.")
CU_FUNC_ATTRIBUTE_CLUSTER_SIZE_MUST_BE_SET = 10
    If this attribute is set, the kernel must launch with a valid cluster size specified. See [cuFuncSetAttribute](<group__CUDA__EXEC.html#group__CUDA__EXEC_1g0e37dce0173bc883aa1e5b14dd747f26> "Sets information about a function."), [cuKernelSetAttribute](<group__CUDA__LIBRARY.html#group__CUDA__LIBRARY_1g1093ade718915249de3b14320d567067> "Sets information about a kernel.")
CU_FUNC_ATTRIBUTE_REQUIRED_CLUSTER_WIDTH = 11
    The required cluster width in blocks. The values must either all be 0 or all be positive. The validity of the cluster dimensions is otherwise checked at launch time.If the value is set during compile time, it cannot be set at runtime. Setting it at runtime will return CUDA_ERROR_NOT_PERMITTED. See [cuFuncSetAttribute](<group__CUDA__EXEC.html#group__CUDA__EXEC_1g0e37dce0173bc883aa1e5b14dd747f26> "Sets information about a function."), [cuKernelSetAttribute](<group__CUDA__LIBRARY.html#group__CUDA__LIBRARY_1g1093ade718915249de3b14320d567067> "Sets information about a kernel.")
CU_FUNC_ATTRIBUTE_REQUIRED_CLUSTER_HEIGHT = 12
    The required cluster height in blocks. The values must either all be 0 or all be positive. The validity of the cluster dimensions is otherwise checked at launch time.If the value is set during compile time, it cannot be set at runtime. Setting it at runtime should return CUDA_ERROR_NOT_PERMITTED. See [cuFuncSetAttribute](<group__CUDA__EXEC.html#group__CUDA__EXEC_1g0e37dce0173bc883aa1e5b14dd747f26> "Sets information about a function."), [cuKernelSetAttribute](<group__CUDA__LIBRARY.html#group__CUDA__LIBRARY_1g1093ade718915249de3b14320d567067> "Sets information about a kernel.")
CU_FUNC_ATTRIBUTE_REQUIRED_CLUSTER_DEPTH = 13
    The required cluster depth in blocks. The values must either all be 0 or all be positive. The validity of the cluster dimensions is otherwise checked at launch time.If the value is set during compile time, it cannot be set at runtime. Setting it at runtime should return CUDA_ERROR_NOT_PERMITTED. See [cuFuncSetAttribute](<group__CUDA__EXEC.html#group__CUDA__EXEC_1g0e37dce0173bc883aa1e5b14dd747f26> "Sets information about a function."), [cuKernelSetAttribute](<group__CUDA__LIBRARY.html#group__CUDA__LIBRARY_1g1093ade718915249de3b14320d567067> "Sets information about a kernel.")
CU_FUNC_ATTRIBUTE_NON_PORTABLE_CLUSTER_SIZE_ALLOWED = 14
    Whether the function can be launched with non-portable cluster size. 1 is allowed, 0 is disallowed. A non-portable cluster size may only function on the specific SKUs the program is tested on. The launch might fail if the program is run on a different hardware platform.CUDA API provides cudaOccupancyMaxActiveClusters to assist with checking whether the desired size can be launched on the current device.Portable Cluster SizeA portable cluster size is guaranteed to be functional on all compute capabilities higher than the target compute capability. The portable cluster size for sm_90 is 8 blocks per cluster. This value may increase for future compute capabilities.The specific hardware unit may support higher cluster sizes thatâs not guaranteed to be portable. See [cuFuncSetAttribute](<group__CUDA__EXEC.html#group__CUDA__EXEC_1g0e37dce0173bc883aa1e5b14dd747f26> "Sets information about a function."), [cuKernelSetAttribute](<group__CUDA__LIBRARY.html#group__CUDA__LIBRARY_1g1093ade718915249de3b14320d567067> "Sets information about a kernel.")
CU_FUNC_ATTRIBUTE_CLUSTER_SCHEDULING_POLICY_PREFERENCE = 15
    The block scheduling policy of a function. The value type is CUclusterSchedulingPolicy / cudaClusterSchedulingPolicy. See [cuFuncSetAttribute](<group__CUDA__EXEC.html#group__CUDA__EXEC_1g0e37dce0173bc883aa1e5b14dd747f26> "Sets information about a function."), [cuKernelSetAttribute](<group__CUDA__LIBRARY.html#group__CUDA__LIBRARY_1g1093ade718915249de3b14320d567067> "Sets information about a kernel.")
CU_FUNC_ATTRIBUTE_MAX


enum CUgraphChildGraphNodeOwnership


Child graph node ownership

######  Values

CU_GRAPH_CHILD_GRAPH_OWNERSHIP_CLONE = 0
    Default behavior for a child graph node. Child graph is cloned into the parent and memory allocation/free nodes can't be present in the child graph.
CU_GRAPH_CHILD_GRAPH_OWNERSHIP_MOVE = 1
    The child graph is moved to the parent. The handle to the child graph is owned by the parent and will be destroyed when the parent is destroyed.The following restrictions apply to child graphs after they have been moved: Cannot be independently instantiated or destroyed; Cannot be added as a child graph of a separate parent graph; Cannot be used as an argument to cuGraphExecUpdate; Cannot have additional memory allocation or free nodes added.

enum CUgraphConditionalNodeType


Conditional node types

######  Values

CU_GRAPH_COND_TYPE_IF = 0
    Conditional 'if/else' Node. Body[0] executed if condition is non-zero. If `size` == 2, an optional ELSE graph is created and this is executed if the condition is zero.
CU_GRAPH_COND_TYPE_WHILE = 1
    Conditional 'while' Node. Body executed repeatedly while condition value is non-zero.
CU_GRAPH_COND_TYPE_SWITCH = 2
    Conditional 'switch' Node. Body[n] is executed once, where 'n' is the value of the condition. If the condition does not match a body index, no body is launched.

enum CUgraphDebugDot_flags


The additional write options for [cuGraphDebugDotPrint](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1g0fb0c4d319477a0a98da005fcb0dacc4> "Write a DOT file describing graph structure.")

######  Values

CU_GRAPH_DEBUG_DOT_FLAGS_VERBOSE = 1<<0
    Output all debug data as if every debug flag is enabled
CU_GRAPH_DEBUG_DOT_FLAGS_RUNTIME_TYPES = 1<<1
    Use CUDA Runtime structures for output
CU_GRAPH_DEBUG_DOT_FLAGS_KERNEL_NODE_PARAMS = 1<<2
    Adds CUDA_KERNEL_NODE_PARAMS values to output
CU_GRAPH_DEBUG_DOT_FLAGS_MEMCPY_NODE_PARAMS = 1<<3
    Adds CUDA_MEMCPY3D values to output
CU_GRAPH_DEBUG_DOT_FLAGS_MEMSET_NODE_PARAMS = 1<<4
    Adds CUDA_MEMSET_NODE_PARAMS values to output
CU_GRAPH_DEBUG_DOT_FLAGS_HOST_NODE_PARAMS = 1<<5
    Adds CUDA_HOST_NODE_PARAMS values to output
CU_GRAPH_DEBUG_DOT_FLAGS_EVENT_NODE_PARAMS = 1<<6
    Adds CUevent handle from record and wait nodes to output
CU_GRAPH_DEBUG_DOT_FLAGS_EXT_SEMAS_SIGNAL_NODE_PARAMS = 1<<7
    Adds CUDA_EXT_SEM_SIGNAL_NODE_PARAMS values to output
CU_GRAPH_DEBUG_DOT_FLAGS_EXT_SEMAS_WAIT_NODE_PARAMS = 1<<8
    Adds CUDA_EXT_SEM_WAIT_NODE_PARAMS values to output
CU_GRAPH_DEBUG_DOT_FLAGS_KERNEL_NODE_ATTRIBUTES = 1<<9
    Adds CUkernelNodeAttrValue values to output
CU_GRAPH_DEBUG_DOT_FLAGS_HANDLES = 1<<10
    Adds node handles and every kernel function handle to output
CU_GRAPH_DEBUG_DOT_FLAGS_MEM_ALLOC_NODE_PARAMS = 1<<11
    Adds memory alloc node parameters to output
CU_GRAPH_DEBUG_DOT_FLAGS_MEM_FREE_NODE_PARAMS = 1<<12
    Adds memory free node parameters to output
CU_GRAPH_DEBUG_DOT_FLAGS_BATCH_MEM_OP_NODE_PARAMS = 1<<13
    Adds batch mem op node parameters to output
CU_GRAPH_DEBUG_DOT_FLAGS_EXTRA_TOPO_INFO = 1<<14
    Adds edge numbering information
CU_GRAPH_DEBUG_DOT_FLAGS_CONDITIONAL_NODE_PARAMS = 1<<15
    Adds conditional node parameters to output

enum CUgraphDependencyType


Type annotations that can be applied to graph edges as part of [CUgraphEdgeData](<structCUgraphEdgeData.html#structCUgraphEdgeData>).

######  Values

CU_GRAPH_DEPENDENCY_TYPE_DEFAULT = 0
    This is an ordinary dependency.
CU_GRAPH_DEPENDENCY_TYPE_PROGRAMMATIC = 1
    This dependency type allows the downstream node to use [`cudaGridDependencySynchronize()`](<cudaGridDependencySynchronize\(\)>). It may only be used between kernel nodes, and must be used with either the [CU_GRAPH_KERNEL_NODE_PORT_PROGRAMMATIC](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g888716de0c02411816a952c8426aef75>) or [CU_GRAPH_KERNEL_NODE_PORT_LAUNCH_ORDER](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g2ed63d6106e76f6966b52c6a0814e789>) outgoing port.

enum CUgraphExecUpdateResult


CUDA Graph Update error types

######  Values

CU_GRAPH_EXEC_UPDATE_SUCCESS = 0x0
    The update succeeded
CU_GRAPH_EXEC_UPDATE_ERROR = 0x1
    The update failed for an unexpected reason which is described in the return value of the function
CU_GRAPH_EXEC_UPDATE_ERROR_TOPOLOGY_CHANGED = 0x2
    The update failed because the topology changed
CU_GRAPH_EXEC_UPDATE_ERROR_NODE_TYPE_CHANGED = 0x3
    The update failed because a node type changed
CU_GRAPH_EXEC_UPDATE_ERROR_FUNCTION_CHANGED = 0x4
    The update failed because the function of a kernel node changed (CUDA driver < 11.2)
CU_GRAPH_EXEC_UPDATE_ERROR_PARAMETERS_CHANGED = 0x5
    The update failed because the parameters changed in a way that is not supported
CU_GRAPH_EXEC_UPDATE_ERROR_NOT_SUPPORTED = 0x6
    The update failed because something about the node is not supported
CU_GRAPH_EXEC_UPDATE_ERROR_UNSUPPORTED_FUNCTION_CHANGE = 0x7
    The update failed because the function of a kernel node changed in an unsupported way
CU_GRAPH_EXEC_UPDATE_ERROR_ATTRIBUTES_CHANGED = 0x8
    The update failed because the node attributes changed in a way that is not supported

enum CUgraphInstantiateResult


Graph instantiation results

######  Values

CUDA_GRAPH_INSTANTIATE_SUCCESS = 0
    Instantiation succeeded
CUDA_GRAPH_INSTANTIATE_ERROR = 1
    Instantiation failed for an unexpected reason which is described in the return value of the function
CUDA_GRAPH_INSTANTIATE_INVALID_STRUCTURE = 2
    Instantiation failed due to invalid structure, such as cycles
CUDA_GRAPH_INSTANTIATE_NODE_OPERATION_NOT_SUPPORTED = 3
    Instantiation for device launch failed because the graph contained an unsupported operation
CUDA_GRAPH_INSTANTIATE_MULTIPLE_CTXS_NOT_SUPPORTED = 4
    Instantiation for device launch failed due to the nodes belonging to different contexts
CUDA_GRAPH_INSTANTIATE_CONDITIONAL_HANDLE_UNUSED = 5
    One or more conditional handles are not associated with conditional nodes

enum CUgraphInstantiate_flags


Flags for instantiating a graph

######  Values

CUDA_GRAPH_INSTANTIATE_FLAG_AUTO_FREE_ON_LAUNCH = 1
    Automatically free memory allocated in a graph before relaunching.
CUDA_GRAPH_INSTANTIATE_FLAG_UPLOAD = 2
    Automatically upload the graph after instantiation. Only supported by [cuGraphInstantiateWithParams](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1g8d9541e4df43ee8440e794634a0d1af8> "Creates an executable graph from a graph."). The upload will be performed using the stream provided in `instantiateParams`.
CUDA_GRAPH_INSTANTIATE_FLAG_DEVICE_LAUNCH = 4
    Instantiate the graph to be launchable from the device. This flag can only be used on platforms which support unified addressing. This flag cannot be used in conjunction with CUDA_GRAPH_INSTANTIATE_FLAG_AUTO_FREE_ON_LAUNCH.
CUDA_GRAPH_INSTANTIATE_FLAG_USE_NODE_PRIORITY = 8
    Run the graph using the per-node priority attributes rather than the priority of the stream it is launched into.

enum CUgraphNodeType


Graph node types

######  Values

CU_GRAPH_NODE_TYPE_KERNEL = 0
    GPU kernel node
CU_GRAPH_NODE_TYPE_MEMCPY = 1
    Memcpy node
CU_GRAPH_NODE_TYPE_MEMSET = 2
    Memset node
CU_GRAPH_NODE_TYPE_HOST = 3
    Host (executable) node
CU_GRAPH_NODE_TYPE_GRAPH = 4
    Node which executes an embedded graph
CU_GRAPH_NODE_TYPE_EMPTY = 5
    Empty (no-op) node
CU_GRAPH_NODE_TYPE_WAIT_EVENT = 6
    External event wait node
CU_GRAPH_NODE_TYPE_EVENT_RECORD = 7
    External event record node
CU_GRAPH_NODE_TYPE_EXT_SEMAS_SIGNAL = 8
    External semaphore signal node
CU_GRAPH_NODE_TYPE_EXT_SEMAS_WAIT = 9
    External semaphore wait node
CU_GRAPH_NODE_TYPE_MEM_ALLOC = 10
    Memory Allocation Node
CU_GRAPH_NODE_TYPE_MEM_FREE = 11
    Memory Free Node
CU_GRAPH_NODE_TYPE_BATCH_MEM_OP = 12
    Batch MemOp Node See [cuStreamBatchMemOp](<group__CUDA__MEMOP.html#group__CUDA__MEMOP_1g764c442de9b671f9dec856e8ae531ed1> "Batch operations to synchronize the stream via memory operations.") and [CUstreamBatchMemOpType](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gb257b534afdb704b6ebdb99c16a5b292>) for what these nodes can do.
CU_GRAPH_NODE_TYPE_CONDITIONAL = 13
    Conditional NodeMay be used to implement a conditional execution path or loop inside of a graph. The graph(s) contained within the body of the conditional node can be selectively executed or iterated upon based on the value of a conditional variable.Handles must be created in advance of creating the node using [cuGraphConditionalHandleCreate](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1gece6f3b9e85d0edb8484d625fe567376> "Create a conditional handle.").The following restrictions apply to graphs which contain conditional nodes: The graph cannot be used in a child node. Only one instantiation of the graph may exist at any point in time. The graph cannot be cloned.To set the control value, supply a default value when creating the handle and/or call [cudaGraphSetConditional](<../cuda-runtime-api/group__CUDART__GRAPH.html#group__CUDART__GRAPH_1gde392fa316b963233219ab3caac9f1b3>) from device code.

enum CUgraphicsMapResourceFlags


Flags for mapping and unmapping interop resources

######  Values

CU_GRAPHICS_MAP_RESOURCE_FLAGS_NONE = 0x00

CU_GRAPHICS_MAP_RESOURCE_FLAGS_READ_ONLY = 0x01

CU_GRAPHICS_MAP_RESOURCE_FLAGS_WRITE_DISCARD = 0x02


enum CUgraphicsRegisterFlags


Flags to register a graphics resource

######  Values

CU_GRAPHICS_REGISTER_FLAGS_NONE = 0x00

CU_GRAPHICS_REGISTER_FLAGS_READ_ONLY = 0x01

CU_GRAPHICS_REGISTER_FLAGS_WRITE_DISCARD = 0x02

CU_GRAPHICS_REGISTER_FLAGS_SURFACE_LDST = 0x04

CU_GRAPHICS_REGISTER_FLAGS_TEXTURE_GATHER = 0x08


enum CUipcMem_flags


CUDA Ipc Mem Flags

######  Values

CU_IPC_MEM_LAZY_ENABLE_PEER_ACCESS = 0x1
    Automatically enable peer access between remote devices as needed

enum CUjitInputType


Device code formats

######  Values

CU_JIT_INPUT_CUBIN = 0
    Compiled device-class-specific device code Applicable options: none
CU_JIT_INPUT_PTX = 1
    PTX source code Applicable options: PTX compiler options
CU_JIT_INPUT_FATBINARY = 2
    Bundle of multiple cubins and/or PTX of some device code Applicable options: PTX compiler options, [CU_JIT_FALLBACK_STRATEGY](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg5527fa8030d5cabedc781a04dbd1997d23623ac0db90309333207d6c37701602>)
CU_JIT_INPUT_OBJECT = 3
    Host object with embedded device code Applicable options: PTX compiler options, [CU_JIT_FALLBACK_STRATEGY](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg5527fa8030d5cabedc781a04dbd1997d23623ac0db90309333207d6c37701602>)
CU_JIT_INPUT_LIBRARY = 4
    Archive of host objects with embedded device code Applicable options: PTX compiler options, [CU_JIT_FALLBACK_STRATEGY](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg5527fa8030d5cabedc781a04dbd1997d23623ac0db90309333207d6c37701602>)
CU_JIT_INPUT_NVVM = 5


###### [Deprecated](<deprecated.html#deprecated__deprecated_1_deprecated000064>)

High-level intermediate code for link-time optimization Applicable options: NVVM compiler options, PTX compiler options

Only valid with LTO-IR compiled with toolkits prior to CUDA 12.0

CU_JIT_NUM_INPUT_TYPES = 6


enum CUjit_cacheMode


Caching modes for dlcm

######  Values

CU_JIT_CACHE_OPTION_NONE = 0
    Compile with no -dlcm flag specified
CU_JIT_CACHE_OPTION_CG
    Compile with L1 cache disabled
CU_JIT_CACHE_OPTION_CA
    Compile with L1 cache enabled

enum CUjit_fallback


Cubin matching fallback strategies

######  Values

CU_PREFER_PTX = 0
    Prefer to compile ptx if exact binary match not found
CU_PREFER_BINARY
    Prefer to fall back to compatible binary code if exact match not found

enum CUjit_option


Online compiler and linker options

######  Values

CU_JIT_MAX_REGISTERS = 0
    Max number of registers that a thread may use. Option type: unsigned int Applies to: compiler only
CU_JIT_THREADS_PER_BLOCK = 1
    IN: Specifies minimum number of threads per block to target compilation for OUT: Returns the number of threads the compiler actually targeted. This restricts the resource utilization of the compiler (e.g. max registers) such that a block with the given number of threads should be able to launch based on register limitations. Note, this option does not currently take into account any other resource limitations, such as shared memory utilization. Cannot be combined with [CU_JIT_TARGET](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg5527fa8030d5cabedc781a04dbd1997d3bf12ddeaa2a9d64db4d20de537cd596>). Option type: unsigned int Applies to: compiler only
CU_JIT_WALL_TIME = 2
    Overwrites the option value with the total wall clock time, in milliseconds, spent in the compiler and linker Option type: float Applies to: compiler and linker
CU_JIT_INFO_LOG_BUFFER = 3
    Pointer to a buffer in which to print any log messages that are informational in nature (the buffer size is specified via option [CU_JIT_INFO_LOG_BUFFER_SIZE_BYTES](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg5527fa8030d5cabedc781a04dbd1997d8dc284de594cc1504db521869ad47cd9>)) Option type: char * Applies to: compiler and linker
CU_JIT_INFO_LOG_BUFFER_SIZE_BYTES = 4
    IN: Log buffer size in bytes. Log messages will be capped at this size (including null terminator) OUT: Amount of log buffer filled with messages Option type: unsigned int Applies to: compiler and linker
CU_JIT_ERROR_LOG_BUFFER = 5
    Pointer to a buffer in which to print any log messages that reflect errors (the buffer size is specified via option [CU_JIT_ERROR_LOG_BUFFER_SIZE_BYTES](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg5527fa8030d5cabedc781a04dbd1997d4e5c6eb78ba970a0b1683ac040044811>)) Option type: char * Applies to: compiler and linker
CU_JIT_ERROR_LOG_BUFFER_SIZE_BYTES = 6
    IN: Log buffer size in bytes. Log messages will be capped at this size (including null terminator) OUT: Amount of log buffer filled with messages Option type: unsigned int Applies to: compiler and linker
CU_JIT_OPTIMIZATION_LEVEL = 7
    Level of optimizations to apply to generated code (0 - 4), with 4 being the default and highest level of optimizations. Option type: unsigned int Applies to: compiler only
CU_JIT_TARGET_FROM_CUCONTEXT = 8
    No option value required. Determines the target based on the current attached context (default) Option type: No option value needed Applies to: compiler and linker
CU_JIT_TARGET = 9
    Target is chosen based on supplied [CUjit_target](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ge443308cb7ed1d52b85b487305779184>). Cannot be combined with [CU_JIT_THREADS_PER_BLOCK](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg5527fa8030d5cabedc781a04dbd1997de2d4d9ff4fbd21f21039f182616ba1fc>). Option type: unsigned int for enumerated type [CUjit_target](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ge443308cb7ed1d52b85b487305779184>) Applies to: compiler and linker
CU_JIT_FALLBACK_STRATEGY = 10
    Specifies choice of fallback strategy if matching cubin is not found. Choice is based on supplied [CUjit_fallback](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g4a1a92ea65e18b06907b981848c282f2>). This option cannot be used with cuLink* APIs as the linker requires exact matches. Option type: unsigned int for enumerated type [CUjit_fallback](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g4a1a92ea65e18b06907b981848c282f2>) Applies to: compiler only
CU_JIT_GENERATE_DEBUG_INFO = 11
    Specifies whether to create debug information in output (-g) (0: false, default) Option type: int Applies to: compiler and linker
CU_JIT_LOG_VERBOSE = 12
    Generate verbose log messages (0: false, default) Option type: int Applies to: compiler and linker
CU_JIT_GENERATE_LINE_INFO = 13
    Generate line number information (-lineinfo) (0: false, default) Option type: int Applies to: compiler only
CU_JIT_CACHE_MODE = 14
    Specifies whether to enable caching explicitly (-dlcm) Choice is based on supplied CUjit_cacheMode_enum. Option type: unsigned int for enumerated type CUjit_cacheMode_enum Applies to: compiler only
CU_JIT_NEW_SM3X_OPT = 15


###### [Deprecated](<deprecated.html#deprecated__deprecated_1_deprecated000053>)

This jit option is deprecated and should not be used.

CU_JIT_FAST_COMPILE = 16
    This jit option is used for internal purpose only.
CU_JIT_GLOBAL_SYMBOL_NAMES = 17
    Array of device symbol names that will be relocated to the corresponding host addresses stored in [CU_JIT_GLOBAL_SYMBOL_ADDRESSES](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg5527fa8030d5cabedc781a04dbd1997d9ed137c8a50c7fac811ef7a63c5ae74f>). Must contain [CU_JIT_GLOBAL_SYMBOL_COUNT](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg5527fa8030d5cabedc781a04dbd1997dd6274c174e780689d0eeddd0a9ce1073>) entries. When loading a device module, driver will relocate all encountered unresolved symbols to the host addresses. It is only allowed to register symbols that correspond to unresolved global variables. It is illegal to register the same device symbol at multiple addresses. Option type: const char ** Applies to: dynamic linker only
CU_JIT_GLOBAL_SYMBOL_ADDRESSES = 18
    Array of host addresses that will be used to relocate corresponding device symbols stored in [CU_JIT_GLOBAL_SYMBOL_NAMES](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg5527fa8030d5cabedc781a04dbd1997da4942ac1cbfb5b2a43994e2acfe3cce0>). Must contain [CU_JIT_GLOBAL_SYMBOL_COUNT](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg5527fa8030d5cabedc781a04dbd1997dd6274c174e780689d0eeddd0a9ce1073>) entries. Option type: void ** Applies to: dynamic linker only
CU_JIT_GLOBAL_SYMBOL_COUNT = 19
    Number of entries in [CU_JIT_GLOBAL_SYMBOL_NAMES](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg5527fa8030d5cabedc781a04dbd1997da4942ac1cbfb5b2a43994e2acfe3cce0>) and [CU_JIT_GLOBAL_SYMBOL_ADDRESSES](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg5527fa8030d5cabedc781a04dbd1997d9ed137c8a50c7fac811ef7a63c5ae74f>) arrays. Option type: unsigned int Applies to: dynamic linker only
CU_JIT_LTO = 20


###### [Deprecated](<deprecated.html#deprecated__deprecated_1_deprecated000054>)

Enable link-time optimization (-dlto) for device code (Disabled by default). This option is not supported on 32-bit platforms. Option type: int Applies to: compiler and linker

Only valid with LTO-IR compiled with toolkits prior to CUDA 12.0

CU_JIT_FTZ = 21


###### [Deprecated](<deprecated.html#deprecated__deprecated_1_deprecated000055>)

Control single-precision denormals (-ftz) support (0: false, default). 1 : flushes denormal values to zero 0 : preserves denormal values Option type: int Applies to: link-time optimization specified with CU_JIT_LTO

Only valid with LTO-IR compiled with toolkits prior to CUDA 12.0

CU_JIT_PREC_DIV = 22


###### [Deprecated](<deprecated.html#deprecated__deprecated_1_deprecated000056>)

Control single-precision floating-point division and reciprocals (-prec-div) support (1: true, default). 1 : Enables the IEEE round-to-nearest mode 0 : Enables the fast approximation mode Option type: int Applies to: link-time optimization specified with CU_JIT_LTO

Only valid with LTO-IR compiled with toolkits prior to CUDA 12.0

CU_JIT_PREC_SQRT = 23


###### [Deprecated](<deprecated.html#deprecated__deprecated_1_deprecated000057>)

Control single-precision floating-point square root (-prec-sqrt) support (1: true, default). 1 : Enables the IEEE round-to-nearest mode 0 : Enables the fast approximation mode Option type: int Applies to: link-time optimization specified with CU_JIT_LTO

Only valid with LTO-IR compiled with toolkits prior to CUDA 12.0

CU_JIT_FMA = 24


###### [Deprecated](<deprecated.html#deprecated__deprecated_1_deprecated000058>)

Enable/Disable the contraction of floating-point multiplies and adds/subtracts into floating-point multiply-add (-fma) operations (1: Enable, default; 0: Disable). Option type: int Applies to: link-time optimization specified with CU_JIT_LTO

Only valid with LTO-IR compiled with toolkits prior to CUDA 12.0

CU_JIT_REFERENCED_KERNEL_NAMES = 25


###### [Deprecated](<deprecated.html#deprecated__deprecated_1_deprecated000059>)

Array of kernel names that should be preserved at link time while others can be removed. Must contain [CU_JIT_REFERENCED_KERNEL_COUNT](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg5527fa8030d5cabedc781a04dbd1997d70d0672317491b398f27bac394b9f66d>) entries. Note that kernel names can be mangled by the compiler in which case the mangled name needs to be specified. Wildcard "*" can be used to represent zero or more characters instead of specifying the full or mangled name. It is important to note that the wildcard "*" is also added implicitly. For example, specifying "foo" will match "foobaz", "barfoo", "barfoobaz" and thus preserve all kernels with those names. This can be avoided by providing a more specific name like "barfoobaz". Option type: const char ** Applies to: dynamic linker only

Only valid with LTO-IR compiled with toolkits prior to CUDA 12.0

CU_JIT_REFERENCED_KERNEL_COUNT = 26


###### [Deprecated](<deprecated.html#deprecated__deprecated_1_deprecated000060>)

Number of entries in [CU_JIT_REFERENCED_KERNEL_NAMES](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg5527fa8030d5cabedc781a04dbd1997dcccfb079541213dc65880ade3de8e2d5>) array. Option type: unsigned int Applies to: dynamic linker only

Only valid with LTO-IR compiled with toolkits prior to CUDA 12.0

CU_JIT_REFERENCED_VARIABLE_NAMES = 27


###### [Deprecated](<deprecated.html#deprecated__deprecated_1_deprecated000061>)

Array of variable names (__device__ and/or __constant__) that should be preserved at link time while others can be removed. Must contain [CU_JIT_REFERENCED_VARIABLE_COUNT](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg5527fa8030d5cabedc781a04dbd1997dca302462528cbe24cb45574450033a0b>) entries. Note that variable names can be mangled by the compiler in which case the mangled name needs to be specified. Wildcard "*" can be used to represent zero or more characters instead of specifying the full or mangled name. It is important to note that the wildcard "*" is also added implicitly. For example, specifying "foo" will match "foobaz", "barfoo", "barfoobaz" and thus preserve all variables with those names. This can be avoided by providing a more specific name like "barfoobaz". Option type: const char ** Applies to: link-time optimization specified with CU_JIT_LTO

Only valid with LTO-IR compiled with toolkits prior to CUDA 12.0

CU_JIT_REFERENCED_VARIABLE_COUNT = 28


###### [Deprecated](<deprecated.html#deprecated__deprecated_1_deprecated000062>)

Number of entries in [CU_JIT_REFERENCED_VARIABLE_NAMES](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg5527fa8030d5cabedc781a04dbd1997de3b8c7b5417b4c1719a56ecfbed28d08>) array. Option type: unsigned int Applies to: link-time optimization specified with CU_JIT_LTO

Only valid with LTO-IR compiled with toolkits prior to CUDA 12.0

CU_JIT_OPTIMIZE_UNUSED_DEVICE_VARIABLES = 29


###### [Deprecated](<deprecated.html#deprecated__deprecated_1_deprecated000063>)

This option serves as a hint to enable the JIT compiler/linker to remove constant (__constant__) and device (__device__) variables unreferenced in device code (Disabled by default). Note that host references to constant and device variables using APIs like [cuModuleGetGlobal()](<group__CUDA__MODULE.html#group__CUDA__MODULE_1gf3e43672e26073b1081476dbf47a86ab> "Returns a global pointer from a module.") with this option specified may result in undefined behavior unless the variables are explicitly specified using [CU_JIT_REFERENCED_VARIABLE_NAMES](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg5527fa8030d5cabedc781a04dbd1997de3b8c7b5417b4c1719a56ecfbed28d08>). Option type: int Applies to: link-time optimization specified with CU_JIT_LTO

Only valid with LTO-IR compiled with toolkits prior to CUDA 12.0

CU_JIT_POSITION_INDEPENDENT_CODE = 30
    Generate position independent code (0: false) Option type: int Applies to: compiler only
CU_JIT_MIN_CTA_PER_SM = 31
    This option hints to the JIT compiler the minimum number of CTAs from the kernelâs grid to be mapped to a SM. This option is ignored when used together with [CU_JIT_MAX_REGISTERS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg5527fa8030d5cabedc781a04dbd1997d09d22b367aad5ca99cca6fe95043896b>) or [CU_JIT_THREADS_PER_BLOCK](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg5527fa8030d5cabedc781a04dbd1997de2d4d9ff4fbd21f21039f182616ba1fc>). Optimizations based on this option need [CU_JIT_MAX_THREADS_PER_BLOCK](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg5527fa8030d5cabedc781a04dbd1997d8685acb8251abf7b9bed80ff58fd29ca>) to be specified as well. For kernels already using PTX directive .minnctapersm, this option will be ignored by default. Use [CU_JIT_OVERRIDE_DIRECTIVE_VALUES](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg5527fa8030d5cabedc781a04dbd1997d504fc22695a386ac14ee66250bbc3a2d>) to let this option take precedence over the PTX directive. Option type: unsigned int Applies to: compiler only
CU_JIT_MAX_THREADS_PER_BLOCK = 32
    Maximum number threads in a thread block, computed as the product of the maximum extent specifed for each dimension of the block. This limit is guaranteed not to be exeeded in any invocation of the kernel. Exceeding the the maximum number of threads results in runtime error or kernel launch failure. For kernels already using PTX directive .maxntid, this option will be ignored by default. Use [CU_JIT_OVERRIDE_DIRECTIVE_VALUES](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg5527fa8030d5cabedc781a04dbd1997d504fc22695a386ac14ee66250bbc3a2d>) to let this option take precedence over the PTX directive. Option type: int Applies to: compiler only
CU_JIT_OVERRIDE_DIRECTIVE_VALUES = 33
    This option lets the values specified using [CU_JIT_MAX_REGISTERS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg5527fa8030d5cabedc781a04dbd1997d09d22b367aad5ca99cca6fe95043896b>), [CU_JIT_THREADS_PER_BLOCK](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg5527fa8030d5cabedc781a04dbd1997de2d4d9ff4fbd21f21039f182616ba1fc>), [CU_JIT_MAX_THREADS_PER_BLOCK](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg5527fa8030d5cabedc781a04dbd1997d8685acb8251abf7b9bed80ff58fd29ca>) and [CU_JIT_MIN_CTA_PER_SM](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg5527fa8030d5cabedc781a04dbd1997db921437bcce82ccac4b4adcdd9310bd6>) take precedence over any PTX directives. (0: Disable, default; 1: Enable) Option type: int Applies to: compiler only
CU_JIT_SPLIT_COMPILE = 34
    This option specifies the maximum number of concurrent threads to use when running compiler optimizations. If the specified value is 1, the option will be ignored. If the specified value is 0, the number of threads will match the number of CPUs on the underlying machine. Otherwise, if the option is N, then up to N threads will be used. Option type: unsigned int Applies to: compiler only
CU_JIT_BINARY_LOADER_THREAD_COUNT = 35
    This option specifies the maximum number of concurrent threads to use when compiling device code. If the specified value is 1, the option will be ignored. If the specified value is 0, the number of threads will match the number of CPUs on the underlying machine. Otherwise, if the option is N, then up to N threads will be used. This option is ignored if the env var CUDA_BINARY_LOADER_THREAD_COUNT is set. Option type: unsigned int Applies to: compiler and linker
CU_JIT_NUM_OPTIONS


enum CUjit_target


Online compilation targets

######  Values

CU_TARGET_COMPUTE_30 = 30
    Compute device class 3.0
CU_TARGET_COMPUTE_32 = 32
    Compute device class 3.2
CU_TARGET_COMPUTE_35 = 35
    Compute device class 3.5
CU_TARGET_COMPUTE_37 = 37
    Compute device class 3.7
CU_TARGET_COMPUTE_50 = 50
    Compute device class 5.0
CU_TARGET_COMPUTE_52 = 52
    Compute device class 5.2
CU_TARGET_COMPUTE_53 = 53
    Compute device class 5.3
CU_TARGET_COMPUTE_60 = 60
    Compute device class 6.0.
CU_TARGET_COMPUTE_61 = 61
    Compute device class 6.1.
CU_TARGET_COMPUTE_62 = 62
    Compute device class 6.2.
CU_TARGET_COMPUTE_70 = 70
    Compute device class 7.0.
CU_TARGET_COMPUTE_72 = 72
    Compute device class 7.2.
CU_TARGET_COMPUTE_75 = 75
    Compute device class 7.5.
CU_TARGET_COMPUTE_80 = 80
    Compute device class 8.0.
CU_TARGET_COMPUTE_86 = 86
    Compute device class 8.6.
CU_TARGET_COMPUTE_87 = 87
    Compute device class 8.7.
CU_TARGET_COMPUTE_89 = 89
    Compute device class 8.9.
CU_TARGET_COMPUTE_90 = 90
    Compute device class 9.0.
CU_TARGET_COMPUTE_100 = 100
    Compute device class 10.0.
CU_TARGET_COMPUTE_110 = 110
    Compute device class 11.0.
CU_TARGET_COMPUTE_103 = 103
    Compute device class 10.3.
CU_TARGET_COMPUTE_120 = 120
    Compute device class 12.0.
CU_TARGET_COMPUTE_121 = 121
    Compute device class 12.1. Compute device class 9.0. with accelerated features.
CU_TARGET_COMPUTE_90A = CU_COMPUTE_ACCELERATED_TARGET_BASE+CU_TARGET_COMPUTE_90
    Compute device class 10.0. with accelerated features.
CU_TARGET_COMPUTE_100A = CU_COMPUTE_ACCELERATED_TARGET_BASE+CU_TARGET_COMPUTE_100
    Compute device class 11.0 with accelerated features.
CU_TARGET_COMPUTE_110A = CU_COMPUTE_ACCELERATED_TARGET_BASE+CU_TARGET_COMPUTE_110
    Compute device class 10.3. with accelerated features.
CU_TARGET_COMPUTE_103A = CU_COMPUTE_ACCELERATED_TARGET_BASE+CU_TARGET_COMPUTE_103
    Compute device class 12.0. with accelerated features.
CU_TARGET_COMPUTE_120A = CU_COMPUTE_ACCELERATED_TARGET_BASE+CU_TARGET_COMPUTE_120
    Compute device class 12.1. with accelerated features.
CU_TARGET_COMPUTE_121A = CU_COMPUTE_ACCELERATED_TARGET_BASE+CU_TARGET_COMPUTE_121
    Compute device class 10.x with family features.
CU_TARGET_COMPUTE_100F = CU_COMPUTE_FAMILY_TARGET_BASE+CU_TARGET_COMPUTE_100
    Compute device class 11.0 with family features.
CU_TARGET_COMPUTE_110F = CU_COMPUTE_FAMILY_TARGET_BASE+CU_TARGET_COMPUTE_110
    Compute device class 10.3. with family features.
CU_TARGET_COMPUTE_103F = CU_COMPUTE_FAMILY_TARGET_BASE+CU_TARGET_COMPUTE_103
    Compute device class 12.0. with family features.
CU_TARGET_COMPUTE_120F = CU_COMPUTE_FAMILY_TARGET_BASE+CU_TARGET_COMPUTE_120
    Compute device class 12.1. with family features.
CU_TARGET_COMPUTE_121F = CU_COMPUTE_FAMILY_TARGET_BASE+CU_TARGET_COMPUTE_121


enum CUlaunchAttributeID


Launch attributes enum; used as id field of [CUlaunchAttribute](<structCUlaunchAttribute.html#structCUlaunchAttribute>)

######  Values

CU_LAUNCH_ATTRIBUTE_IGNORE = 0
    Ignored entry, for convenient composition
CU_LAUNCH_ATTRIBUTE_ACCESS_POLICY_WINDOW = 1
    Valid for streams, graph nodes, launches. See [CUlaunchAttributeValue::accessPolicyWindow](<unionCUlaunchAttributeValue.html#unionCUlaunchAttributeValue_1154aa6110d2610fb68ec60bc9337073b>).
CU_LAUNCH_ATTRIBUTE_COOPERATIVE = 2
    Valid for graph nodes, launches. See [CUlaunchAttributeValue::cooperative](<unionCUlaunchAttributeValue.html#unionCUlaunchAttributeValue_13015f3dc785dce3a2c250b852457082a>).
CU_LAUNCH_ATTRIBUTE_SYNCHRONIZATION_POLICY = 3
    Valid for streams. See [CUlaunchAttributeValue::syncPolicy](<unionCUlaunchAttributeValue.html#unionCUlaunchAttributeValue_1bfc7b2566d09fbd679636513d5c07cd8>).
CU_LAUNCH_ATTRIBUTE_CLUSTER_DIMENSION = 4
    Valid for graph nodes, launches. See [CUlaunchAttributeValue::clusterDim](<unionCUlaunchAttributeValue.html#unionCUlaunchAttributeValue_171f9182ab9f932025a038def93ce1a94>).
CU_LAUNCH_ATTRIBUTE_CLUSTER_SCHEDULING_POLICY_PREFERENCE = 5
    Valid for graph nodes, launches. See [CUlaunchAttributeValue::clusterSchedulingPolicyPreference](<unionCUlaunchAttributeValue.html#unionCUlaunchAttributeValue_1714fd4571d6ef99a53a20d378eebb2ba>).
CU_LAUNCH_ATTRIBUTE_PROGRAMMATIC_STREAM_SERIALIZATION = 6
    Valid for launches. Setting [CUlaunchAttributeValue::programmaticStreamSerializationAllowed](<unionCUlaunchAttributeValue.html#unionCUlaunchAttributeValue_121590ca9c3de21690d12d9c7f73917ab>) to non-0 signals that the kernel will use programmatic means to resolve its stream dependency, so that the CUDA runtime should opportunistically allow the grid's execution to overlap with the previous kernel in the stream, if that kernel requests the overlap. The dependent launches can choose to wait on the dependency using the programmatic sync ([cudaGridDependencySynchronize()](<../cuda-runtime-api/group__CUDART__EXECUTION.html#group__CUDART__EXECUTION_1g9057f99234a8311c4c5d426cd501d99d>) or equivalent PTX instructions).
CU_LAUNCH_ATTRIBUTE_PROGRAMMATIC_EVENT = 7
    Valid for launches. Set [CUlaunchAttributeValue::programmaticEvent](<unionCUlaunchAttributeValue.html#unionCUlaunchAttributeValue_149992756050c46d440486034949a2c0c>) to record the event. Event recorded through this launch attribute is guaranteed to only trigger after all block in the associated kernel trigger the event. A block can trigger the event through PTX launchdep.release or CUDA builtin function [cudaTriggerProgrammaticLaunchCompletion()](<../cuda-runtime-api/group__CUDART__EXECUTION.html#group__CUDART__EXECUTION_1ge194af462d927583bed3acf60d450218>). A trigger can also be inserted at the beginning of each block's execution if triggerAtBlockStart is set to non-0. The dependent launches can choose to wait on the dependency using the programmatic sync ([cudaGridDependencySynchronize()](<../cuda-runtime-api/group__CUDART__EXECUTION.html#group__CUDART__EXECUTION_1g9057f99234a8311c4c5d426cd501d99d>) or equivalent PTX instructions). Note that dependents (including the CPU thread calling [cuEventSynchronize()](<group__CUDA__EVENT.html#group__CUDA__EVENT_1g9e520d34e51af7f5375610bca4add99c> "Waits for an event to complete.")) are not guaranteed to observe the release precisely when it is released. For example, [cuEventSynchronize()](<group__CUDA__EVENT.html#group__CUDA__EVENT_1g9e520d34e51af7f5375610bca4add99c> "Waits for an event to complete.") may only observe the event trigger long after the associated kernel has completed. This recording type is primarily meant for establishing programmatic dependency between device tasks. Note also this type of dependency allows, but does not guarantee, concurrent execution of tasks. The event supplied must not be an interprocess or interop event. The event must disable timing (i.e. must be created with the [CU_EVENT_DISABLE_TIMING](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg5ae04079c671c8e659a3a27c7b23f629daa5463f64794c10b78c603d23c0bff2>) flag set).
CU_LAUNCH_ATTRIBUTE_PRIORITY = 8
    Valid for streams, graph nodes, launches. See [CUlaunchAttributeValue::priority](<unionCUlaunchAttributeValue.html#unionCUlaunchAttributeValue_18b3a370124a50866fcdb1c9cb5580e96>).
CU_LAUNCH_ATTRIBUTE_MEM_SYNC_DOMAIN_MAP = 9
    Valid for streams, graph nodes, launches. See [CUlaunchAttributeValue::memSyncDomainMap](<unionCUlaunchAttributeValue.html#unionCUlaunchAttributeValue_134552cdc66a0a5373d8515108d9c63d6>).
CU_LAUNCH_ATTRIBUTE_MEM_SYNC_DOMAIN = 10
    Valid for streams, graph nodes, launches. See [CUlaunchAttributeValue::memSyncDomain](<unionCUlaunchAttributeValue.html#unionCUlaunchAttributeValue_168b8301d88ce5c6e69fc5f08734e55a8>).
CU_LAUNCH_ATTRIBUTE_PREFERRED_CLUSTER_DIMENSION = 11
    Valid for graph nodes, launches. Set [CUlaunchAttributeValue::preferredClusterDim](<unionCUlaunchAttributeValue.html#unionCUlaunchAttributeValue_12e4405d769d2302fd8d0f9b7764f3cb3>) to allow the kernel launch to specify a preferred substitute cluster dimension. Blocks may be grouped according to either the dimensions specified with this attribute (grouped into a "preferred substitute cluster"), or the one specified with [CU_LAUNCH_ATTRIBUTE_CLUSTER_DIMENSION](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg6f6565b334be6bb3134868e10bbdd331f1a227eb6283f2a292cf5a38cdceb638>) attribute (grouped into a "regular cluster"). The cluster dimensions of a "preferred substitute cluster" shall be an integer multiple greater than zero of the regular cluster dimensions. The device will attempt - on a best-effort basis - to group thread blocks into preferred clusters over grouping them into regular clusters. When it deems necessary (primarily when the device temporarily runs out of physical resources to launch the larger preferred clusters), the device may switch to launch the regular clusters instead to attempt to utilize as much of the physical device resources as possible. Each type of cluster will have its enumeration / coordinate setup as if the grid consists solely of its type of cluster. For example, if the preferred substitute cluster dimensions double the regular cluster dimensions, there might be simultaneously a regular cluster indexed at (1,0,0), and a preferred cluster indexed at (1,0,0). In this example, the preferred substitute cluster (1,0,0) replaces regular clusters (2,0,0) and (3,0,0) and groups their blocks. This attribute will only take effect when a regular cluster dimension has been specified. The preferred substitute cluster dimension must be an integer multiple greater than zero of the regular cluster dimension and must divide the grid. It must also be no more than `maxBlocksPerCluster`, if it is set in the kernel's `__launch_bounds__`. Otherwise it must be less than the maximum value the driver can support. Otherwise, setting this attribute to a value physically unable to fit on any particular device is permitted.
CU_LAUNCH_ATTRIBUTE_LAUNCH_COMPLETION_EVENT = 12
    Valid for launches. Set [CUlaunchAttributeValue::launchCompletionEvent](<unionCUlaunchAttributeValue.html#unionCUlaunchAttributeValue_1af92a022a05eba8d91f8c6b39c8d3db2>) to record the event. Nominally, the event is triggered once all blocks of the kernel have begun execution. Currently this is a best effort. If a kernel B has a launch completion dependency on a kernel A, B may wait until A is complete. Alternatively, blocks of B may begin before all blocks of A have begun, for example if B can claim execution resources unavailable to A (e.g. they run on different GPUs) or if B is a higher priority than A. Exercise caution if such an ordering inversion could lead to deadlock. A launch completion event is nominally similar to a programmatic event with `triggerAtBlockStart` set except that it is not visible to [`cudaGridDependencySynchronize()`](<cudaGridDependencySynchronize\(\)>) and can be used with compute capability less than 9.0. The event supplied must not be an interprocess or interop event. The event must disable timing (i.e. must be created with the [CU_EVENT_DISABLE_TIMING](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg5ae04079c671c8e659a3a27c7b23f629daa5463f64794c10b78c603d23c0bff2>) flag set).
CU_LAUNCH_ATTRIBUTE_DEVICE_UPDATABLE_KERNEL_NODE = 13
    Valid for graph nodes, launches. This attribute is graphs-only, and passing it to a launch in a non-capturing stream will result in an error. CUlaunchAttributeValue::deviceUpdatableKernelNode::deviceUpdatable can only be set to 0 or 1. Setting the field to 1 indicates that the corresponding kernel node should be device-updatable. On success, a handle will be returned via CUlaunchAttributeValue::deviceUpdatableKernelNode::devNode which can be passed to the various device-side update functions to update the node's kernel parameters from within another kernel. For more information on the types of device updates that can be made, as well as the relevant limitations thereof, see [cudaGraphKernelNodeUpdatesApply](<../cuda-runtime-api/group__CUDART__GRAPH.html#group__CUDART__GRAPH_1g2d558cf37c9616365c67447e61ac0d6a>). Nodes which are device-updatable have additional restrictions compared to regular kernel nodes. Firstly, device-updatable nodes cannot be removed from their graph via [cuGraphDestroyNode](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1g00ed16434d983d8f0011683eacaf19b9> "Remove a node from the graph."). Additionally, once opted-in to this functionality, a node cannot opt out, and any attempt to set the deviceUpdatable attribute to 0 will result in an error. Device-updatable kernel nodes also cannot have their attributes copied to/from another kernel node via [cuGraphKernelNodeCopyAttributes](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1ga5f4e6786704bf710b61a26146c51c9e> "Copies attributes from source node to destination node."). Graphs containing one or more device-updatable nodes also do not allow multiple instantiation, and neither the graph nor its instantiated version can be passed to [cuGraphExecUpdate](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1g96efefc56df46927da7297f122adfb9f> "Check whether an executable graph can be updated with a graph and perform the update if possible."). If a graph contains device-updatable nodes and updates those nodes from the device from within the graph, the graph must be uploaded with [cuGraphUpload](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1ga7eb9849e6e4604864a482b38f25be48> "Uploads an executable graph in a stream.") before it is launched. For such a graph, if host-side executable graph updates are made to the device-updatable nodes, the graph must be uploaded before it is launched again.
CU_LAUNCH_ATTRIBUTE_PREFERRED_SHARED_MEMORY_CARVEOUT = 14
    Valid for launches. On devices where the L1 cache and shared memory use the same hardware resources, setting [CUlaunchAttributeValue::sharedMemCarveout](<unionCUlaunchAttributeValue.html#unionCUlaunchAttributeValue_1b4890866538ded7d27e648d399caaff2>) to a percentage between 0-100 signals the CUDA driver to set the shared memory carveout preference, in percent of the total shared memory for that kernel launch. This attribute takes precedence over [CU_FUNC_ATTRIBUTE_PREFERRED_SHARED_MEMORY_CARVEOUT](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg9d955dde0904a9b43ca4d875ac1551bcc75f6fd470b848653f026b8c82c10ae3>). This is only a hint, and the CUDA driver can choose a different configuration if required for the launch.
CU_LAUNCH_ATTRIBUTE_NVLINK_UTIL_CENTRIC_SCHEDULING = 16
    Valid for streams, graph nodes, launches. This attribute is a hint to the CUDA runtime that the launch should attempt to make the kernel maximize its NVLINK utilization. When possible to honor this hint, CUDA will assume each block in the grid launch will carry out an even amount of NVLINK traffic, and make a best-effort attempt to adjust the kernel launch based on that assumption. This attribute is a hint only. CUDA makes no functional or performance guarantee. Its applicability can be affected by many different factors, including driver version (i.e. CUDA doesn't guarantee the performance characteristics will be maintained between driver versions or a driver update could alter or regress previously observed perf characteristics.) It also doesn't guarantee a successful result, i.e. applying the attribute may not improve the performance of either the targeted kernel or the encapsulating application. Valid values for CUlaunchAttributeValue::nvlinkUtilCentricScheduling are 0 (disabled) and 1 (enabled).

enum CUlaunchMemSyncDomain


Memory Synchronization Domain

A kernel can be launched in a specified memory synchronization domain that affects all memory operations issued by that kernel. A memory barrier issued in one domain will only order memory operations in that domain, thus eliminating latency increase from memory barriers ordering unrelated traffic.

By default, kernels are launched in domain 0. Kernel launched with [CU_LAUNCH_MEM_SYNC_DOMAIN_REMOTE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg471f645fa24df354626fe8107358e05fd06c15e0689a9ec3b9393a32646f5417>) will have a different domain ID. User may also alter the domain ID with [CUlaunchMemSyncDomainMap](<structCUlaunchMemSyncDomainMap.html#structCUlaunchMemSyncDomainMap>) for a specific stream / graph node / kernel launch. See [CU_LAUNCH_ATTRIBUTE_MEM_SYNC_DOMAIN](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg6f6565b334be6bb3134868e10bbdd331b57049dbe6c473013088dbc3cbc41139>), [cuStreamSetAttribute](<group__CUDA__STREAM.html#group__CUDA__STREAM_1ga2c5fc0292861a42f264af6ca48be8c0> "Sets stream attribute."), [cuLaunchKernelEx](<group__CUDA__EXEC.html#group__CUDA__EXEC_1gb9c891eb6bb8f4089758e64c9c976db9> "Launches a CUDA function CUfunction or a CUDA kernel CUkernel with launch-time configuration."), [cuGraphKernelNodeSetAttribute](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1gd888774df6c1d0774bee49ec9442eefc> "Sets node attribute.").

Memory operations done in kernels launched in different domains are considered system-scope distanced. In other words, a GPU scoped memory synchronization is not sufficient for memory order to be observed by kernels in another memory synchronization domain even if they are on the same GPU.

######  Values

CU_LAUNCH_MEM_SYNC_DOMAIN_DEFAULT = 0
    Launch kernels in the default domain
CU_LAUNCH_MEM_SYNC_DOMAIN_REMOTE = 1
    Launch kernels in the remote domain

enum CUlibraryOption


Library options to be specified with [cuLibraryLoadData()](<group__CUDA__LIBRARY.html#group__CUDA__LIBRARY_1g957f12ff5af4166f43c89d17cfb0a74d> "Load a library with specified code and options.") or [cuLibraryLoadFromFile()](<group__CUDA__LIBRARY.html#group__CUDA__LIBRARY_1g88cff489fab37c7fd1985ceb61023205> "Load a library with specified file and options.")

######  Values

CU_LIBRARY_HOST_UNIVERSAL_FUNCTION_AND_DATA_TABLE = 0

CU_LIBRARY_BINARY_IS_PRESERVED = 1
    Specifes that the argument `code` passed to [cuLibraryLoadData()](<group__CUDA__LIBRARY.html#group__CUDA__LIBRARY_1g957f12ff5af4166f43c89d17cfb0a74d> "Load a library with specified code and options.") will be preserved. Specifying this option will let the driver know that `code` can be accessed at any point until [cuLibraryUnload()](<group__CUDA__LIBRARY.html#group__CUDA__LIBRARY_1g24969cb24138171edf465bc8669d5914> "Unloads a library."). The default behavior is for the driver to allocate and maintain its own copy of `code`. Note that this is only a memory usage optimization hint and the driver can choose to ignore it if required. Specifying this option with [cuLibraryLoadFromFile()](<group__CUDA__LIBRARY.html#group__CUDA__LIBRARY_1g88cff489fab37c7fd1985ceb61023205> "Load a library with specified file and options.") is invalid and will return [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>).
CU_LIBRARY_NUM_OPTIONS


enum CUlimit


Limits

######  Values

CU_LIMIT_STACK_SIZE = 0x00
    GPU thread stack size
CU_LIMIT_PRINTF_FIFO_SIZE = 0x01
    GPU printf FIFO size
CU_LIMIT_MALLOC_HEAP_SIZE = 0x02
    GPU malloc heap size
CU_LIMIT_DEV_RUNTIME_SYNC_DEPTH = 0x03
    GPU device runtime launch synchronize depth
CU_LIMIT_DEV_RUNTIME_PENDING_LAUNCH_COUNT = 0x04
    GPU device runtime pending launch count
CU_LIMIT_MAX_L2_FETCH_GRANULARITY = 0x05
    A value between 0 and 128 that indicates the maximum fetch granularity of L2 (in Bytes). This is a hint
CU_LIMIT_PERSISTING_L2_CACHE_SIZE = 0x06
    A size in bytes for L2 persisting lines cache size
CU_LIMIT_SHMEM_SIZE = 0x07
    A maximum size in bytes of shared memory available to CUDA kernels on a CIG context. Can only be queried, cannot be set
CU_LIMIT_CIG_ENABLED = 0x08
    A non-zero value indicates this CUDA context is a CIG-enabled context. Can only be queried, cannot be set
CU_LIMIT_CIG_SHMEM_FALLBACK_ENABLED = 0x09
    When set to zero, CUDA will fail to launch a kernel on a CIG context, instead of using the fallback path, if the kernel uses more shared memory than available
CU_LIMIT_MAX


enum CUmemAccess_flags


Specifies the memory protection flags for mapping.

######  Values

CU_MEM_ACCESS_FLAGS_PROT_NONE = 0x0
    Default, make the address range not accessible
CU_MEM_ACCESS_FLAGS_PROT_READ = 0x1
    Make the address range read accessible
CU_MEM_ACCESS_FLAGS_PROT_READWRITE = 0x3
    Make the address range read-write accessible
CU_MEM_ACCESS_FLAGS_PROT_MAX = 0x7FFFFFFF


enum CUmemAllocationCompType


Specifies compression attribute for an allocation.

######  Values

CU_MEM_ALLOCATION_COMP_NONE = 0x0
    Allocating non-compressible memory
CU_MEM_ALLOCATION_COMP_GENERIC = 0x1
    Allocating compressible memory

enum CUmemAllocationGranularity_flags


Flag for requesting different optimal and required granularities for an allocation.

######  Values

CU_MEM_ALLOC_GRANULARITY_MINIMUM = 0x0
    Minimum required granularity for allocation
CU_MEM_ALLOC_GRANULARITY_RECOMMENDED = 0x1
    Recommended granularity for allocation for best performance

enum CUmemAllocationHandleType


Flags for specifying particular handle types

######  Values

CU_MEM_HANDLE_TYPE_NONE = 0x0
    Does not allow any export mechanism. >
CU_MEM_HANDLE_TYPE_POSIX_FILE_DESCRIPTOR = 0x1
    Allows a file descriptor to be used for exporting. Permitted only on POSIX systems. (int)
CU_MEM_HANDLE_TYPE_WIN32 = 0x2
    Allows a Win32 NT handle to be used for exporting. (HANDLE)
CU_MEM_HANDLE_TYPE_WIN32_KMT = 0x4
    Allows a Win32 KMT handle to be used for exporting. (D3DKMT_HANDLE)
CU_MEM_HANDLE_TYPE_FABRIC = 0x8
    Allows a fabric handle to be used for exporting. (CUmemFabricHandle)
CU_MEM_HANDLE_TYPE_MAX = 0x7FFFFFFF


enum CUmemAllocationType


Defines the allocation types available

######  Values

CU_MEM_ALLOCATION_TYPE_INVALID = 0x0

CU_MEM_ALLOCATION_TYPE_PINNED = 0x1
    This allocation type is 'pinned', i.e. cannot migrate from its current location while the application is actively using it
CU_MEM_ALLOCATION_TYPE_MANAGED = 0x2
    This allocation type is managed memory
CU_MEM_ALLOCATION_TYPE_MAX = 0x7FFFFFFF


enum CUmemAttach_flags


CUDA Mem Attach Flags

######  Values

CU_MEM_ATTACH_GLOBAL = 0x1
    Memory can be accessed by any stream on any device
CU_MEM_ATTACH_HOST = 0x2
    Memory cannot be accessed by any stream on any device
CU_MEM_ATTACH_SINGLE = 0x4
    Memory can only be accessed by a single stream on the associated device

enum CUmemHandleType


Memory handle types

######  Values

CU_MEM_HANDLE_TYPE_GENERIC = 0


enum CUmemLocationType


Specifies the type of location

######  Values

CU_MEM_LOCATION_TYPE_INVALID = 0x0

CU_MEM_LOCATION_TYPE_NONE = 0x0
    Location is unspecified. This is used when creating a managed memory pool to indicate no preferred location for the pool
CU_MEM_LOCATION_TYPE_DEVICE = 0x1
    Location is a device location, thus id is a device ordinal
CU_MEM_LOCATION_TYPE_HOST = 0x2
    Location is host, id is ignored
CU_MEM_LOCATION_TYPE_HOST_NUMA = 0x3
    Location is a host NUMA node, thus id is a host NUMA node id
CU_MEM_LOCATION_TYPE_HOST_NUMA_CURRENT = 0x4
    Location is a host NUMA node of the current thread, id is ignored
CU_MEM_LOCATION_TYPE_MAX = 0x7FFFFFFF


enum CUmemOperationType


Memory operation types

######  Values

CU_MEM_OPERATION_TYPE_MAP = 1

CU_MEM_OPERATION_TYPE_UNMAP = 2


enum CUmemPool_attribute


CUDA memory pool attributes

######  Values

CU_MEMPOOL_ATTR_REUSE_FOLLOW_EVENT_DEPENDENCIES = 1
    (value type = int) Allow cuMemAllocAsync to use memory asynchronously freed in another streams as long as a stream ordering dependency of the allocating stream on the free action exists. Cuda events and null stream interactions can create the required stream ordered dependencies. (default enabled)
CU_MEMPOOL_ATTR_REUSE_ALLOW_OPPORTUNISTIC
    (value type = int) Allow reuse of already completed frees when there is no dependency between the free and allocation. (default enabled)
CU_MEMPOOL_ATTR_REUSE_ALLOW_INTERNAL_DEPENDENCIES
    (value type = int) Allow cuMemAllocAsync to insert new stream dependencies in order to establish the stream ordering required to reuse a piece of memory released by cuMemFreeAsync (default enabled).
CU_MEMPOOL_ATTR_RELEASE_THRESHOLD
    (value type = cuuint64_t) Amount of reserved memory in bytes to hold onto before trying to release memory back to the OS. When more than the release threshold bytes of memory are held by the memory pool, the allocator will try to release memory back to the OS on the next call to stream, event or context synchronize. (default 0)
CU_MEMPOOL_ATTR_RESERVED_MEM_CURRENT
    (value type = cuuint64_t) Amount of backing memory currently allocated for the mempool.
CU_MEMPOOL_ATTR_RESERVED_MEM_HIGH
    (value type = cuuint64_t) High watermark of backing memory allocated for the mempool since the last time it was reset. High watermark can only be reset to zero.
CU_MEMPOOL_ATTR_USED_MEM_CURRENT
    (value type = cuuint64_t) Amount of memory from the pool that is currently in use by the application.
CU_MEMPOOL_ATTR_USED_MEM_HIGH
    (value type = cuuint64_t) High watermark of the amount of memory from the pool that was in use by the application since the last time it was reset. High watermark can only be reset to zero.

enum CUmemRangeFlags


Flag for requesting handle type for address range.

######  Values

CU_MEM_RANGE_FLAG_DMA_BUF_MAPPING_TYPE_PCIE = 0x1
    Indicates that DMA_BUF handle should be mapped via PCIe BAR1

enum CUmemRangeHandleType


Specifies the handle type for address range

######  Values

CU_MEM_RANGE_HANDLE_TYPE_DMA_BUF_FD = 0x1

CU_MEM_RANGE_HANDLE_TYPE_MAX = 0x7FFFFFFF


enum CUmem_advise


Memory advise values

######  Values

CU_MEM_ADVISE_SET_READ_MOSTLY = 1
    Data will mostly be read and only occasionally be written to
CU_MEM_ADVISE_UNSET_READ_MOSTLY = 2
    Undo the effect of [CU_MEM_ADVISE_SET_READ_MOSTLY](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggcfe2ed2d4567745dd4ad41034136fff35a99fb44378c84c56668550b94157fc0>)
CU_MEM_ADVISE_SET_PREFERRED_LOCATION = 3
    Set the preferred location for the data as the specified device
CU_MEM_ADVISE_UNSET_PREFERRED_LOCATION = 4
    Clear the preferred location for the data
CU_MEM_ADVISE_SET_ACCESSED_BY = 5
    Data will be accessed by the specified device, so prevent page faults as much as possible
CU_MEM_ADVISE_UNSET_ACCESSED_BY = 6
    Let the Unified Memory subsystem decide on the page faulting policy for the specified device

enum CUmemcpy3DOperandType


These flags allow applications to convey the operand type for individual copies specified in [cuMemcpy3DBatchAsync](<group__CUDA__MEM.html#group__CUDA__MEM_1g97dd29d0e3490379a5cbdb21deb41f12> "Performs a batch of 3D memory copies asynchronously.").

######  Values

CU_MEMCPY_OPERAND_TYPE_POINTER = 0x1
    Memcpy operand is a valid pointer.
CU_MEMCPY_OPERAND_TYPE_ARRAY = 0x2
    Memcpy operand is a CUarray.
CU_MEMCPY_OPERAND_TYPE_MAX = 0x7FFFFFFF


enum CUmemcpyFlags


Flags to specify for copies within a batch. For more details see [cuMemcpyBatchAsync](<group__CUDA__MEM.html#group__CUDA__MEM_1g6f1ff58e3065df3eb4b573dba77ad31f> "Performs a batch of memory copies asynchronously.").

######  Values

CU_MEMCPY_FLAG_DEFAULT = 0x0

CU_MEMCPY_FLAG_PREFER_OVERLAP_WITH_COMPUTE = 0x1
    Hint to the driver to try and overlap the copy with compute work on the SMs.

enum CUmemcpySrcAccessOrder


These flags allow applications to convey the source access ordering CUDA must maintain. The destination will always be accessed in stream order.

######  Values

CU_MEMCPY_SRC_ACCESS_ORDER_INVALID = 0x0
    Default invalid.
CU_MEMCPY_SRC_ACCESS_ORDER_STREAM = 0x1
    Indicates that access to the source pointer must be in stream order.
CU_MEMCPY_SRC_ACCESS_ORDER_DURING_API_CALL = 0x2
    Indicates that access to the source pointer can be out of stream order and all accesses must be complete before the API call returns. This flag is suited for ephemeral sources (ex., stack variables) when it's known that no prior operations in the stream can be accessing the memory and also that the lifetime of the memory is limited to the scope that the source variable was declared in. Specifying this flag allows the driver to optimize the copy and removes the need for the user to synchronize the stream after the API call.
CU_MEMCPY_SRC_ACCESS_ORDER_ANY = 0x3
    Indicates that access to the source pointer can be out of stream order and the accesses can happen even after the API call returns. This flag is suited for host pointers allocated outside CUDA (ex., via malloc) when it's known that no prior operations in the stream can be accessing the memory. Specifying this flag allows the driver to optimize the copy on certain platforms.
CU_MEMCPY_SRC_ACCESS_ORDER_MAX = 0x7FFFFFFF


enum CUmemorytype


Memory types

######  Values

CU_MEMORYTYPE_HOST = 0x01
    Host memory
CU_MEMORYTYPE_DEVICE = 0x02
    Device memory
CU_MEMORYTYPE_ARRAY = 0x03
    Array memory
CU_MEMORYTYPE_UNIFIED = 0x04
    Unified device or host memory

enum CUmulticastGranularity_flags


Flags for querying different granularities for a multicast object

######  Values

CU_MULTICAST_GRANULARITY_MINIMUM = 0x0
    Minimum required granularity
CU_MULTICAST_GRANULARITY_RECOMMENDED = 0x1
    Recommended granularity for best performance

enum CUoccupancy_flags


Occupancy calculator flag

######  Values

CU_OCCUPANCY_DEFAULT = 0x0
    Default behavior
CU_OCCUPANCY_DISABLE_CACHING_OVERRIDE = 0x1
    Assume global caching is enabled and cannot be automatically turned off

enum CUpointer_attribute


Pointer information

######  Values

CU_POINTER_ATTRIBUTE_CONTEXT = 1
    The [CUcontext](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gf9f5bd81658f866613785b3a0bb7d7d9>) on which a pointer was allocated or registered
CU_POINTER_ATTRIBUTE_MEMORY_TYPE = 2
    The [CUmemorytype](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g8a114cc994ad2e865c44ef3838eaec72>) describing the physical location of a pointer
CU_POINTER_ATTRIBUTE_DEVICE_POINTER = 3
    The address at which a pointer's memory may be accessed on the device
CU_POINTER_ATTRIBUTE_HOST_POINTER = 4
    The address at which a pointer's memory may be accessed on the host
CU_POINTER_ATTRIBUTE_P2P_TOKENS = 5
    A pair of tokens for use with the nv-p2p.h Linux kernel interface
CU_POINTER_ATTRIBUTE_SYNC_MEMOPS = 6
    Synchronize every synchronous memory operation initiated on this region
CU_POINTER_ATTRIBUTE_BUFFER_ID = 7
    A process-wide unique ID for an allocated memory region
CU_POINTER_ATTRIBUTE_IS_MANAGED = 8
    Indicates if the pointer points to managed memory
CU_POINTER_ATTRIBUTE_DEVICE_ORDINAL = 9
    A device ordinal of a device on which a pointer was allocated or registered
CU_POINTER_ATTRIBUTE_IS_LEGACY_CUDA_IPC_CAPABLE = 10
    1 if this pointer maps to an allocation that is suitable for [cudaIpcGetMemHandle](<../cuda-runtime-api/group__CUDART__DEVICE.html#group__CUDART__DEVICE_1g8a37f7dfafaca652391d0758b3667539>), 0 otherwise
CU_POINTER_ATTRIBUTE_RANGE_START_ADDR = 11
    Starting address for this requested pointer
CU_POINTER_ATTRIBUTE_RANGE_SIZE = 12
    Size of the address range for this requested pointer
CU_POINTER_ATTRIBUTE_MAPPED = 13
    1 if this pointer is in a valid address range that is mapped to a backing allocation, 0 otherwise
CU_POINTER_ATTRIBUTE_ALLOWED_HANDLE_TYPES = 14
    Bitmask of allowed [CUmemAllocationHandleType](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g450a23153d86fce0afe30e25d63caef9>) for this allocation
CU_POINTER_ATTRIBUTE_IS_GPU_DIRECT_RDMA_CAPABLE = 15
    1 if the memory this pointer is referencing can be used with the GPUDirect RDMA API
CU_POINTER_ATTRIBUTE_ACCESS_FLAGS = 16
    Returns the access flags the device associated with the current context has on the corresponding memory referenced by the pointer given
CU_POINTER_ATTRIBUTE_MEMPOOL_HANDLE = 17
    Returns the mempool handle for the allocation if it was allocated from a mempool. Otherwise returns NULL.
CU_POINTER_ATTRIBUTE_MAPPING_SIZE = 18
    Size of the actual underlying mapping that the pointer belongs to
CU_POINTER_ATTRIBUTE_MAPPING_BASE_ADDR = 19
    The start address of the mapping that the pointer belongs to
CU_POINTER_ATTRIBUTE_MEMORY_BLOCK_ID = 20
    A process-wide unique id corresponding to the physical allocation the pointer belongs to
CU_POINTER_ATTRIBUTE_IS_HW_DECOMPRESS_CAPABLE = 21
    Returns in `*data` a boolean that indicates whether the pointer points to memory that is capable to be used for hardware accelerated decompression.

enum CUprocessState


CUDA Process States

######  Values

CU_PROCESS_STATE_RUNNING = 0
    Default process state
CU_PROCESS_STATE_LOCKED
    CUDA API locks are taken so further CUDA API calls will block
CU_PROCESS_STATE_CHECKPOINTED
    Application memory contents have been checkpointed and underlying allocations and device handles have been released
CU_PROCESS_STATE_FAILED
    Application entered an uncorrectable error during the checkpoint/restore process

enum CUresourceViewFormat


Resource view format

######  Values

CU_RES_VIEW_FORMAT_NONE = 0x00
    No resource view format (use underlying resource format)
CU_RES_VIEW_FORMAT_UINT_1X8 = 0x01
    1 channel unsigned 8-bit integers
CU_RES_VIEW_FORMAT_UINT_2X8 = 0x02
    2 channel unsigned 8-bit integers
CU_RES_VIEW_FORMAT_UINT_4X8 = 0x03
    4 channel unsigned 8-bit integers
CU_RES_VIEW_FORMAT_SINT_1X8 = 0x04
    1 channel signed 8-bit integers
CU_RES_VIEW_FORMAT_SINT_2X8 = 0x05
    2 channel signed 8-bit integers
CU_RES_VIEW_FORMAT_SINT_4X8 = 0x06
    4 channel signed 8-bit integers
CU_RES_VIEW_FORMAT_UINT_1X16 = 0x07
    1 channel unsigned 16-bit integers
CU_RES_VIEW_FORMAT_UINT_2X16 = 0x08
    2 channel unsigned 16-bit integers
CU_RES_VIEW_FORMAT_UINT_4X16 = 0x09
    4 channel unsigned 16-bit integers
CU_RES_VIEW_FORMAT_SINT_1X16 = 0x0a
    1 channel signed 16-bit integers
CU_RES_VIEW_FORMAT_SINT_2X16 = 0x0b
    2 channel signed 16-bit integers
CU_RES_VIEW_FORMAT_SINT_4X16 = 0x0c
    4 channel signed 16-bit integers
CU_RES_VIEW_FORMAT_UINT_1X32 = 0x0d
    1 channel unsigned 32-bit integers
CU_RES_VIEW_FORMAT_UINT_2X32 = 0x0e
    2 channel unsigned 32-bit integers
CU_RES_VIEW_FORMAT_UINT_4X32 = 0x0f
    4 channel unsigned 32-bit integers
CU_RES_VIEW_FORMAT_SINT_1X32 = 0x10
    1 channel signed 32-bit integers
CU_RES_VIEW_FORMAT_SINT_2X32 = 0x11
    2 channel signed 32-bit integers
CU_RES_VIEW_FORMAT_SINT_4X32 = 0x12
    4 channel signed 32-bit integers
CU_RES_VIEW_FORMAT_FLOAT_1X16 = 0x13
    1 channel 16-bit floating point
CU_RES_VIEW_FORMAT_FLOAT_2X16 = 0x14
    2 channel 16-bit floating point
CU_RES_VIEW_FORMAT_FLOAT_4X16 = 0x15
    4 channel 16-bit floating point
CU_RES_VIEW_FORMAT_FLOAT_1X32 = 0x16
    1 channel 32-bit floating point
CU_RES_VIEW_FORMAT_FLOAT_2X32 = 0x17
    2 channel 32-bit floating point
CU_RES_VIEW_FORMAT_FLOAT_4X32 = 0x18
    4 channel 32-bit floating point
CU_RES_VIEW_FORMAT_UNSIGNED_BC1 = 0x19
    Block compressed 1
CU_RES_VIEW_FORMAT_UNSIGNED_BC2 = 0x1a
    Block compressed 2
CU_RES_VIEW_FORMAT_UNSIGNED_BC3 = 0x1b
    Block compressed 3
CU_RES_VIEW_FORMAT_UNSIGNED_BC4 = 0x1c
    Block compressed 4 unsigned
CU_RES_VIEW_FORMAT_SIGNED_BC4 = 0x1d
    Block compressed 4 signed
CU_RES_VIEW_FORMAT_UNSIGNED_BC5 = 0x1e
    Block compressed 5 unsigned
CU_RES_VIEW_FORMAT_SIGNED_BC5 = 0x1f
    Block compressed 5 signed
CU_RES_VIEW_FORMAT_UNSIGNED_BC6H = 0x20
    Block compressed 6 unsigned half-float
CU_RES_VIEW_FORMAT_SIGNED_BC6H = 0x21
    Block compressed 6 signed half-float
CU_RES_VIEW_FORMAT_UNSIGNED_BC7 = 0x22
    Block compressed 7

enum CUresourcetype


Resource types

######  Values

CU_RESOURCE_TYPE_ARRAY = 0x00
    Array resource
CU_RESOURCE_TYPE_MIPMAPPED_ARRAY = 0x01
    Mipmapped array resource
CU_RESOURCE_TYPE_LINEAR = 0x02
    Linear resource
CU_RESOURCE_TYPE_PITCH2D = 0x03
    Pitch 2D resource

enum CUresult


Error codes

######  Values

CUDA_SUCCESS = 0
    The API call returned with no errors. In the case of query calls, this also means that the operation being queried is complete (see [cuEventQuery()](<group__CUDA__EVENT.html#group__CUDA__EVENT_1g6f0704d755066b0ee705749ae911deef> "Queries an event's status.") and [cuStreamQuery()](<group__CUDA__STREAM.html#group__CUDA__STREAM_1g1b0d24bbe97fa68e4bc511fb6adfeb0b> "Determine status of a compute stream.")).
CUDA_ERROR_INVALID_VALUE = 1
    This indicates that one or more of the parameters passed to the API call is not within an acceptable range of values.
CUDA_ERROR_OUT_OF_MEMORY = 2
    The API call failed because it was unable to allocate enough memory or other resources to perform the requested operation.
CUDA_ERROR_NOT_INITIALIZED = 3
    This indicates that the CUDA driver has not been initialized with [cuInit()](<group__CUDA__INITIALIZE.html#group__CUDA__INITIALIZE_1g0a2f1517e1bd8502c7194c3a8c134bc3> "Initialize the CUDA driver API Initializes the driver API and must be called before any other function from the driver API in the current process. Currently, the Flags parameter must be 0. If cuInit\(\) has not been called, any function from the driver API will return CUDA_ERROR_NOT_INITIALIZED.") or that initialization has failed.
CUDA_ERROR_DEINITIALIZED = 4
    This indicates that the CUDA driver is in the process of shutting down.
CUDA_ERROR_PROFILER_DISABLED = 5
    This indicates profiler is not initialized for this run. This can happen when the application is running with external profiling tools like visual profiler.
CUDA_ERROR_PROFILER_NOT_INITIALIZED = 6


###### [Deprecated](<deprecated.html#deprecated__deprecated_1_deprecated000065>)

This error return is deprecated as of CUDA 5.0. It is no longer an error to attempt to enable/disable the profiling via [cuProfilerStart](<group__CUDA__PROFILER.html#group__CUDA__PROFILER_1g8a5314de2292c2efac83ac7fcfa9190e> "Enable profiling.") or [cuProfilerStop](<group__CUDA__PROFILER.html#group__CUDA__PROFILER_1g4d8edef6174fd90165e6ac838f320a5f> "Disable profiling.") without initialization.

CUDA_ERROR_PROFILER_ALREADY_STARTED = 7


###### [Deprecated](<deprecated.html#deprecated__deprecated_1_deprecated000066>)

This error return is deprecated as of CUDA 5.0. It is no longer an error to call [cuProfilerStart()](<group__CUDA__PROFILER.html#group__CUDA__PROFILER_1g8a5314de2292c2efac83ac7fcfa9190e> "Enable profiling.") when profiling is already enabled.

CUDA_ERROR_PROFILER_ALREADY_STOPPED = 8


###### [Deprecated](<deprecated.html#deprecated__deprecated_1_deprecated000067>)

This error return is deprecated as of CUDA 5.0. It is no longer an error to call [cuProfilerStop()](<group__CUDA__PROFILER.html#group__CUDA__PROFILER_1g4d8edef6174fd90165e6ac838f320a5f> "Disable profiling.") when profiling is already disabled.

CUDA_ERROR_STUB_LIBRARY = 34
    This indicates that the CUDA driver that the application has loaded is a stub library. Applications that run with the stub rather than a real driver loaded will result in CUDA API returning this error.
CUDA_ERROR_CALL_REQUIRES_NEWER_DRIVER = 36
    This indicates that the API call requires a newer CUDA driver than the one currently installed. Users should install an updated NVIDIA CUDA driver to allow the API call to succeed.
CUDA_ERROR_DEVICE_UNAVAILABLE = 46
    This indicates that requested CUDA device is unavailable at the current time. Devices are often unavailable due to use of [CU_COMPUTEMODE_EXCLUSIVE_PROCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg637aab2eadb52e1c1c048b8bad9592d1548bd978657bfc572652dfaf2650209c>) or [CU_COMPUTEMODE_PROHIBITED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg637aab2eadb52e1c1c048b8bad9592d1db8a226241187db3b1f41999bb70eb47>).
CUDA_ERROR_NO_DEVICE = 100
    This indicates that no CUDA-capable devices were detected by the installed CUDA driver.
CUDA_ERROR_INVALID_DEVICE = 101
    This indicates that the device ordinal supplied by the user does not correspond to a valid CUDA device or that the action requested is invalid for the specified device.
CUDA_ERROR_DEVICE_NOT_LICENSED = 102
    This error indicates that the Grid license is not applied.
CUDA_ERROR_INVALID_IMAGE = 200
    This indicates that the device kernel image is invalid. This can also indicate an invalid CUDA module.
CUDA_ERROR_INVALID_CONTEXT = 201
    This most frequently indicates that there is no context bound to the current thread. This can also be returned if the context passed to an API call is not a valid handle (such as a context that has had [cuCtxDestroy()](<group__CUDA__CTX.html#group__CUDA__CTX_1g27a365aebb0eb548166309f58a1e8b8e> "Destroy a CUDA context.") invoked on it). This can also be returned if a user mixes different API versions (i.e. 3010 context with 3020 API calls). See [cuCtxGetApiVersion()](<group__CUDA__CTX.html#group__CUDA__CTX_1g088a90490dafca5893ef6fbebc8de8fb> "Gets the context's API version.") for more details. This can also be returned if the green context passed to an API call was not converted to a [CUcontext](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gf9f5bd81658f866613785b3a0bb7d7d9>) using [cuCtxFromGreenCtx](<group__CUDA__GREEN__CONTEXTS.html#group__CUDA__GREEN__CONTEXTS_1gf0779ec72ce1d5d7eb003d7d9b25afcb> "Converts a green context into the primary context.") API.
CUDA_ERROR_CONTEXT_ALREADY_CURRENT = 202


###### [Deprecated](<deprecated.html#deprecated__deprecated_1_deprecated000068>)

This error return is deprecated as of CUDA 3.2. It is no longer an error to attempt to push the active context via [cuCtxPushCurrent()](<group__CUDA__CTX.html#group__CUDA__CTX_1gb02d4c850eb16f861fe5a29682cc90ba> "Pushes a context on the current CPU thread.").

This indicated that the context being supplied as a parameter to the API call was already the active context.

CUDA_ERROR_MAP_FAILED = 205
    This indicates that a map or register operation has failed.
CUDA_ERROR_UNMAP_FAILED = 206
    This indicates that an unmap or unregister operation has failed.
CUDA_ERROR_ARRAY_IS_MAPPED = 207
    This indicates that the specified array is currently mapped and thus cannot be destroyed.
CUDA_ERROR_ALREADY_MAPPED = 208
    This indicates that the resource is already mapped.
CUDA_ERROR_NO_BINARY_FOR_GPU = 209
    This indicates that there is no kernel image available that is suitable for the device. This can occur when a user specifies code generation options for a particular CUDA source file that do not include the corresponding device configuration.
CUDA_ERROR_ALREADY_ACQUIRED = 210
    This indicates that a resource has already been acquired.
CUDA_ERROR_NOT_MAPPED = 211
    This indicates that a resource is not mapped.
CUDA_ERROR_NOT_MAPPED_AS_ARRAY = 212
    This indicates that a mapped resource is not available for access as an array.
CUDA_ERROR_NOT_MAPPED_AS_POINTER = 213
    This indicates that a mapped resource is not available for access as a pointer.
CUDA_ERROR_ECC_UNCORRECTABLE = 214
    This indicates that an uncorrectable ECC error was detected during execution.
CUDA_ERROR_UNSUPPORTED_LIMIT = 215
    This indicates that the [CUlimit](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ge24c2d4214af24139020f1aecaf32665>) passed to the API call is not supported by the active device.
CUDA_ERROR_CONTEXT_ALREADY_IN_USE = 216
    This indicates that the [CUcontext](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gf9f5bd81658f866613785b3a0bb7d7d9>) passed to the API call can only be bound to a single CPU thread at a time but is already bound to a CPU thread.
CUDA_ERROR_PEER_ACCESS_UNSUPPORTED = 217
    This indicates that peer access is not supported across the given devices.
CUDA_ERROR_INVALID_PTX = 218
    This indicates that a PTX JIT compilation failed.
CUDA_ERROR_INVALID_GRAPHICS_CONTEXT = 219
    This indicates an error with OpenGL or DirectX context.
CUDA_ERROR_NVLINK_UNCORRECTABLE = 220
    This indicates that an uncorrectable NVLink error was detected during the execution.
CUDA_ERROR_JIT_COMPILER_NOT_FOUND = 221
    This indicates that the PTX JIT compiler library was not found.
CUDA_ERROR_UNSUPPORTED_PTX_VERSION = 222
    This indicates that the provided PTX was compiled with an unsupported toolchain.
CUDA_ERROR_JIT_COMPILATION_DISABLED = 223
    This indicates that the PTX JIT compilation was disabled.
CUDA_ERROR_UNSUPPORTED_EXEC_AFFINITY = 224
    This indicates that the [CUexecAffinityType](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g14e6345acf2bda65be91eda77cf03f5c>) passed to the API call is not supported by the active device.
CUDA_ERROR_UNSUPPORTED_DEVSIDE_SYNC = 225
    This indicates that the code to be compiled by the PTX JIT contains unsupported call to cudaDeviceSynchronize.
CUDA_ERROR_CONTAINED = 226
    This indicates that an exception occurred on the device that is now contained by the GPU's error containment capability. Common causes are - a. Certain types of invalid accesses of peer GPU memory over nvlink b. Certain classes of hardware errors This leaves the process in an inconsistent state and any further CUDA work will return the same error. To continue using CUDA, the process must be terminated and relaunched.
CUDA_ERROR_INVALID_SOURCE = 300
    This indicates that the device kernel source is invalid. This includes compilation/linker errors encountered in device code or user error.
CUDA_ERROR_FILE_NOT_FOUND = 301
    This indicates that the file specified was not found.
CUDA_ERROR_SHARED_OBJECT_SYMBOL_NOT_FOUND = 302
    This indicates that a link to a shared object failed to resolve.
CUDA_ERROR_SHARED_OBJECT_INIT_FAILED = 303
    This indicates that initialization of a shared object failed.
CUDA_ERROR_OPERATING_SYSTEM = 304
    This indicates that an OS call failed.
CUDA_ERROR_INVALID_HANDLE = 400
    This indicates that a resource handle passed to the API call was not valid. Resource handles are opaque types like [CUstream](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gb946c7f02e09efd788a204718015d88a>) and [CUevent](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g6d740185cf0953636d4ae37f68d7559b>).
CUDA_ERROR_ILLEGAL_STATE = 401
    This indicates that a resource required by the API call is not in a valid state to perform the requested operation.
CUDA_ERROR_LOSSY_QUERY = 402
    This indicates an attempt was made to introspect an object in a way that would discard semantically important information. This is either due to the object using funtionality newer than the API version used to introspect it or omission of optional return arguments.
CUDA_ERROR_NOT_FOUND = 500
    This indicates that a named symbol was not found. Examples of symbols are global/constant variable names, driver function names, texture names, and surface names.
CUDA_ERROR_NOT_READY = 600
    This indicates that asynchronous operations issued previously have not completed yet. This result is not actually an error, but must be indicated differently than [CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>) (which indicates completion). Calls that may return this value include [cuEventQuery()](<group__CUDA__EVENT.html#group__CUDA__EVENT_1g6f0704d755066b0ee705749ae911deef> "Queries an event's status.") and [cuStreamQuery()](<group__CUDA__STREAM.html#group__CUDA__STREAM_1g1b0d24bbe97fa68e4bc511fb6adfeb0b> "Determine status of a compute stream.").
CUDA_ERROR_ILLEGAL_ADDRESS = 700
    While executing a kernel, the device encountered a load or store instruction on an invalid memory address. This leaves the process in an inconsistent state and any further CUDA work will return the same error. To continue using CUDA, the process must be terminated and relaunched.
CUDA_ERROR_LAUNCH_OUT_OF_RESOURCES = 701
    This indicates that a launch did not occur because it did not have appropriate resources. This error usually indicates that the user has attempted to pass too many arguments to the device kernel, or the kernel launch specifies too many threads for the kernel's register count. Passing arguments of the wrong size (i.e. a 64-bit pointer when a 32-bit int is expected) is equivalent to passing too many arguments and can also result in this error.
CUDA_ERROR_LAUNCH_TIMEOUT = 702
    This indicates that the device kernel took too long to execute. This can only occur if timeouts are enabled - see the device attribute [CU_DEVICE_ATTRIBUTE_KERNEL_EXEC_TIMEOUT](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gge12b8a782bebe21b1ac0091bf9f4e2a3019c82d47b139b18af14b30db46aeccf>) for more information. This leaves the process in an inconsistent state and any further CUDA work will return the same error. To continue using CUDA, the process must be terminated and relaunched.
CUDA_ERROR_LAUNCH_INCOMPATIBLE_TEXTURING = 703
    This error indicates a kernel launch that uses an incompatible texturing mode.
CUDA_ERROR_PEER_ACCESS_ALREADY_ENABLED = 704
    This error indicates that a call to [cuCtxEnablePeerAccess()](<group__CUDA__PEER__ACCESS.html#group__CUDA__PEER__ACCESS_1g0889ec6728e61c05ed359551d67b3f5a> "Enables direct access to memory allocations in a peer context.") is trying to re-enable peer access to a context which has already had peer access to it enabled.
CUDA_ERROR_PEER_ACCESS_NOT_ENABLED = 705
    This error indicates that [cuCtxDisablePeerAccess()](<group__CUDA__PEER__ACCESS.html#group__CUDA__PEER__ACCESS_1g5b4b6936ea868d4954ce4d841a3b4810> "Disables direct access to memory allocations in a peer context and unregisters any registered allocations.") is trying to disable peer access which has not been enabled yet via [cuCtxEnablePeerAccess()](<group__CUDA__PEER__ACCESS.html#group__CUDA__PEER__ACCESS_1g0889ec6728e61c05ed359551d67b3f5a> "Enables direct access to memory allocations in a peer context.").
CUDA_ERROR_PRIMARY_CONTEXT_ACTIVE = 708
    This error indicates that the primary context for the specified device has already been initialized.
CUDA_ERROR_CONTEXT_IS_DESTROYED = 709
    This error indicates that the context current to the calling thread has been destroyed using [cuCtxDestroy](<group__CUDA__CTX.html#group__CUDA__CTX_1g27a365aebb0eb548166309f58a1e8b8e> "Destroy a CUDA context."), or is a primary context which has not yet been initialized.
CUDA_ERROR_ASSERT = 710
    A device-side assert triggered during kernel execution. The context cannot be used anymore, and must be destroyed. All existing device memory allocations from this context are invalid and must be reconstructed if the program is to continue using CUDA.
CUDA_ERROR_TOO_MANY_PEERS = 711
    This error indicates that the hardware resources required to enable peer access have been exhausted for one or more of the devices passed to [cuCtxEnablePeerAccess()](<group__CUDA__PEER__ACCESS.html#group__CUDA__PEER__ACCESS_1g0889ec6728e61c05ed359551d67b3f5a> "Enables direct access to memory allocations in a peer context.").
CUDA_ERROR_HOST_MEMORY_ALREADY_REGISTERED = 712
    This error indicates that the memory range passed to [cuMemHostRegister()](<group__CUDA__MEM.html#group__CUDA__MEM_1gf0a9fe11544326dabd743b7aa6b54223> "Registers an existing host memory range for use by CUDA.") has already been registered.
CUDA_ERROR_HOST_MEMORY_NOT_REGISTERED = 713
    This error indicates that the pointer passed to [cuMemHostUnregister()](<group__CUDA__MEM.html#group__CUDA__MEM_1g63f450c8125359be87b7623b1c0b2a14> "Unregisters a memory range that was registered with cuMemHostRegister.") does not correspond to any currently registered memory region.
CUDA_ERROR_HARDWARE_STACK_ERROR = 714
    While executing a kernel, the device encountered a stack error. This can be due to stack corruption or exceeding the stack size limit. This leaves the process in an inconsistent state and any further CUDA work will return the same error. To continue using CUDA, the process must be terminated and relaunched.
CUDA_ERROR_ILLEGAL_INSTRUCTION = 715
    While executing a kernel, the device encountered an illegal instruction. This leaves the process in an inconsistent state and any further CUDA work will return the same error. To continue using CUDA, the process must be terminated and relaunched.
CUDA_ERROR_MISALIGNED_ADDRESS = 716
    While executing a kernel, the device encountered a load or store instruction on a memory address which is not aligned. This leaves the process in an inconsistent state and any further CUDA work will return the same error. To continue using CUDA, the process must be terminated and relaunched.
CUDA_ERROR_INVALID_ADDRESS_SPACE = 717
    While executing a kernel, the device encountered an instruction which can only operate on memory locations in certain address spaces (global, shared, or local), but was supplied a memory address not belonging to an allowed address space. This leaves the process in an inconsistent state and any further CUDA work will return the same error. To continue using CUDA, the process must be terminated and relaunched.
CUDA_ERROR_INVALID_PC = 718
    While executing a kernel, the device program counter wrapped its address space. This leaves the process in an inconsistent state and any further CUDA work will return the same error. To continue using CUDA, the process must be terminated and relaunched.
CUDA_ERROR_LAUNCH_FAILED = 719
    An exception occurred on the device while executing a kernel. Common causes include dereferencing an invalid device pointer and accessing out of bounds shared memory. Less common cases can be system specific - more information about these cases can be found in the system specific user guide. This leaves the process in an inconsistent state and any further CUDA work will return the same error. To continue using CUDA, the process must be terminated and relaunched.
CUDA_ERROR_COOPERATIVE_LAUNCH_TOO_LARGE = 720
    This error indicates that the number of blocks launched per grid for a kernel that was launched via either [cuLaunchCooperativeKernel](<group__CUDA__EXEC.html#group__CUDA__EXEC_1g06d753134145c4584c0c62525c1894cb> "Launches a CUDA function CUfunction or a CUDA kernel CUkernel where thread blocks can cooperate and synchronize as they execute.") or [cuLaunchCooperativeKernelMultiDevice](<group__CUDA__EXEC.html#group__CUDA__EXEC_1g1d34025bc4f8fcec82fbcfc18d07a6e2> "Launches CUDA functions on multiple devices where thread blocks can cooperate and synchronize as they execute.") exceeds the maximum number of blocks as allowed by [cuOccupancyMaxActiveBlocksPerMultiprocessor](<group__CUDA__OCCUPANCY.html#group__CUDA__OCCUPANCY_1gcc6e1094d05cba2cee17fe33ddd04a98> "Returns occupancy of a function.") or [cuOccupancyMaxActiveBlocksPerMultiprocessorWithFlags](<group__CUDA__OCCUPANCY.html#group__CUDA__OCCUPANCY_1g8f1da4d4983e5c3025447665423ae2c2> "Returns occupancy of a function.") times the number of multiprocessors as specified by the device attribute [CU_DEVICE_ATTRIBUTE_MULTIPROCESSOR_COUNT](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gge12b8a782bebe21b1ac0091bf9f4e2a3b92d0a38a94a3f61d4c53e00114afcaa>).
CUDA_ERROR_TENSOR_MEMORY_LEAK = 721
    An exception occurred on the device while exiting a kernel using tensor memory: the tensor memory was not completely deallocated. This leaves the process in an inconsistent state and any further CUDA work will return the same error. To continue using CUDA, the process must be terminated and relaunched.
CUDA_ERROR_NOT_PERMITTED = 800
    This error indicates that the attempted operation is not permitted.
CUDA_ERROR_NOT_SUPPORTED = 801
    This error indicates that the attempted operation is not supported on the current system or device.
CUDA_ERROR_SYSTEM_NOT_READY = 802
    This error indicates that the system is not yet ready to start any CUDA work. To continue using CUDA, verify the system configuration is in a valid state and all required driver daemons are actively running. More information about this error can be found in the system specific user guide.
CUDA_ERROR_SYSTEM_DRIVER_MISMATCH = 803
    This error indicates that there is a mismatch between the versions of the display driver and the CUDA driver. Refer to the compatibility documentation for supported versions.
CUDA_ERROR_COMPAT_NOT_SUPPORTED_ON_DEVICE = 804
    This error indicates that the system was upgraded to run with forward compatibility but the visible hardware detected by CUDA does not support this configuration. Refer to the compatibility documentation for the supported hardware matrix or ensure that only supported hardware is visible during initialization via the CUDA_VISIBLE_DEVICES environment variable.
CUDA_ERROR_MPS_CONNECTION_FAILED = 805
    This error indicates that the MPS client failed to connect to the MPS control daemon or the MPS server.
CUDA_ERROR_MPS_RPC_FAILURE = 806
    This error indicates that the remote procedural call between the MPS server and the MPS client failed.
CUDA_ERROR_MPS_SERVER_NOT_READY = 807
    This error indicates that the MPS server is not ready to accept new MPS client requests. This error can be returned when the MPS server is in the process of recovering from a fatal failure.
CUDA_ERROR_MPS_MAX_CLIENTS_REACHED = 808
    This error indicates that the hardware resources required to create MPS client have been exhausted.
CUDA_ERROR_MPS_MAX_CONNECTIONS_REACHED = 809
    This error indicates the the hardware resources required to support device connections have been exhausted.
CUDA_ERROR_MPS_CLIENT_TERMINATED = 810
    This error indicates that the MPS client has been terminated by the server. To continue using CUDA, the process must be terminated and relaunched.
CUDA_ERROR_CDP_NOT_SUPPORTED = 811
    This error indicates that the module is using CUDA Dynamic Parallelism, but the current configuration, like MPS, does not support it.
CUDA_ERROR_CDP_VERSION_MISMATCH = 812
    This error indicates that a module contains an unsupported interaction between different versions of CUDA Dynamic Parallelism.
CUDA_ERROR_STREAM_CAPTURE_UNSUPPORTED = 900
    This error indicates that the operation is not permitted when the stream is capturing.
CUDA_ERROR_STREAM_CAPTURE_INVALIDATED = 901
    This error indicates that the current capture sequence on the stream has been invalidated due to a previous error.
CUDA_ERROR_STREAM_CAPTURE_MERGE = 902
    This error indicates that the operation would have resulted in a merge of two independent capture sequences.
CUDA_ERROR_STREAM_CAPTURE_UNMATCHED = 903
    This error indicates that the capture was not initiated in this stream.
CUDA_ERROR_STREAM_CAPTURE_UNJOINED = 904
    This error indicates that the capture sequence contains a fork that was not joined to the primary stream.
CUDA_ERROR_STREAM_CAPTURE_ISOLATION = 905
    This error indicates that a dependency would have been created which crosses the capture sequence boundary. Only implicit in-stream ordering dependencies are allowed to cross the boundary.
CUDA_ERROR_STREAM_CAPTURE_IMPLICIT = 906
    This error indicates a disallowed implicit dependency on a current capture sequence from cudaStreamLegacy.
CUDA_ERROR_CAPTURED_EVENT = 907
    This error indicates that the operation is not permitted on an event which was last recorded in a capturing stream.
CUDA_ERROR_STREAM_CAPTURE_WRONG_THREAD = 908
    A stream capture sequence not initiated with the CU_STREAM_CAPTURE_MODE_RELAXED argument to [cuStreamBeginCapture](<group__CUDA__STREAM.html#group__CUDA__STREAM_1g767167da0bbf07157dc20b6c258a2143> "Begins graph capture on a stream.") was passed to [cuStreamEndCapture](<group__CUDA__STREAM.html#group__CUDA__STREAM_1g03dab8b2ba76b00718955177a929970c> "Ends capture on a stream, returning the captured graph.") in a different thread.
CUDA_ERROR_TIMEOUT = 909
    This error indicates that the timeout specified for the wait operation has lapsed.
CUDA_ERROR_GRAPH_EXEC_UPDATE_FAILURE = 910
    This error indicates that the graph update was not performed because it included changes which violated constraints specific to instantiated graph update.
CUDA_ERROR_EXTERNAL_DEVICE = 911
    This indicates that an async error has occurred in a device outside of CUDA. If CUDA was waiting for an external device's signal before consuming shared data, the external device signaled an error indicating that the data is not valid for consumption. This leaves the process in an inconsistent state and any further CUDA work will return the same error. To continue using CUDA, the process must be terminated and relaunched.
CUDA_ERROR_INVALID_CLUSTER_SIZE = 912
    Indicates a kernel launch error due to cluster misconfiguration.
CUDA_ERROR_FUNCTION_NOT_LOADED = 913
    Indiciates a function handle is not loaded when calling an API that requires a loaded function.
CUDA_ERROR_INVALID_RESOURCE_TYPE = 914
    This error indicates one or more resources passed in are not valid resource types for the operation.
CUDA_ERROR_INVALID_RESOURCE_CONFIGURATION = 915
    This error indicates one or more resources are insufficient or non-applicable for the operation.
CUDA_ERROR_KEY_ROTATION = 916
    This error indicates that an error happened during the key rotation sequence.
CUDA_ERROR_STREAM_DETACHED = 917
    This error indicates that the requested operation is not permitted because the stream is in a detached state. This can occur if the green context associated with the stream has been destroyed, limiting the stream's operational capabilities.
CUDA_ERROR_UNKNOWN = 999
    This indicates that an unknown internal error has occurred.

enum CUshared_carveout


Shared memory carveout configurations. These may be passed to [cuFuncSetAttribute](<group__CUDA__EXEC.html#group__CUDA__EXEC_1g0e37dce0173bc883aa1e5b14dd747f26> "Sets information about a function.") or [cuKernelSetAttribute](<group__CUDA__LIBRARY.html#group__CUDA__LIBRARY_1g1093ade718915249de3b14320d567067> "Sets information about a kernel.")

######  Values

CU_SHAREDMEM_CARVEOUT_DEFAULT = -1
    No preference for shared memory or L1 (default)
CU_SHAREDMEM_CARVEOUT_MAX_SHARED = 100
    Prefer maximum available shared memory, minimum L1 cache
CU_SHAREDMEM_CARVEOUT_MAX_L1 = 0
    Prefer maximum available L1 cache, minimum shared memory

enum CUsharedconfig


###### [Deprecated](<deprecated.html#deprecated__deprecated_1_deprecated000001>)

Shared memory configurations

######  Values

CU_SHARED_MEM_CONFIG_DEFAULT_BANK_SIZE = 0x00
    set default shared memory bank size
CU_SHARED_MEM_CONFIG_FOUR_BYTE_BANK_SIZE = 0x01
    set shared memory bank width to four bytes
CU_SHARED_MEM_CONFIG_EIGHT_BYTE_BANK_SIZE = 0x02
    set shared memory bank width to eight bytes

enum CUstreamAtomicReductionDataType


Atomic reduction data types for CUstreamBatchMemOpParams::atomicReduction::dataType

######  Values

CU_STREAM_ATOMIC_REDUCTION_UNSIGNED_32 = CU_ATOMIC_CAPABILITY_UNSIGNED|CU_ATOMIC_CAPABILITY_SCALAR_32|CU_ATOMIC_CAPABILITY_REDUCTION

CU_STREAM_ATOMIC_REDUCTION_UNSIGNED_64 = CU_ATOMIC_CAPABILITY_UNSIGNED|CU_ATOMIC_CAPABILITY_SCALAR_64|CU_ATOMIC_CAPABILITY_REDUCTION


enum CUstreamAtomicReductionOpType


Atomic reduction operation types for CUstreamBatchMemOpParams::atomicReduction::reductionOp

######  Values

CU_STREAM_ATOMIC_REDUCTION_OP_OR = CU_ATOMIC_OPERATION_OR
    Performs an atomic OR: *(address) = *(address) | value
CU_STREAM_ATOMIC_REDUCTION_OP_AND = CU_ATOMIC_OPERATION_AND
    Performs an atomic AND: *(address) = *(address) & value
CU_STREAM_ATOMIC_REDUCTION_OP_ADD = CU_ATOMIC_OPERATION_INTEGER_ADD
    Performs an atomic ADD: *(address) = *(address) + value

enum CUstreamBatchMemOpType


Operations for [cuStreamBatchMemOp](<group__CUDA__MEMOP.html#group__CUDA__MEMOP_1g764c442de9b671f9dec856e8ae531ed1> "Batch operations to synchronize the stream via memory operations.")

######  Values

CU_STREAM_MEM_OP_WAIT_VALUE_32 = 1
    Represents a [cuStreamWaitValue32](<group__CUDA__MEMOP.html#group__CUDA__MEMOP_1g629856339de7bc6606047385addbb398> "Wait on a memory location.") operation
CU_STREAM_MEM_OP_WRITE_VALUE_32 = 2
    Represents a [cuStreamWriteValue32](<group__CUDA__MEMOP.html#group__CUDA__MEMOP_1g091455366d56dc2f1f69726aafa369b0> "Write a value to memory.") operation
CU_STREAM_MEM_OP_WAIT_VALUE_64 = 4
    Represents a [cuStreamWaitValue64](<group__CUDA__MEMOP.html#group__CUDA__MEMOP_1g6910c1258c5f15aa5d699f0fd60d6933> "Wait on a memory location.") operation
CU_STREAM_MEM_OP_WRITE_VALUE_64 = 5
    Represents a [cuStreamWriteValue64](<group__CUDA__MEMOP.html#group__CUDA__MEMOP_1gc8af1e8b96d7561840affd5217dd6830> "Write a value to memory.") operation
CU_STREAM_MEM_OP_BARRIER = 6
    Insert a memory barrier of the specified type
CU_STREAM_MEM_OP_ATOMIC_REDUCTION = 8
    Perform a atomic reduction. See CUstreamBatchMemOpParams::atomicReduction
CU_STREAM_MEM_OP_FLUSH_REMOTE_WRITES = 3
    This has the same effect as [CU_STREAM_WAIT_VALUE_FLUSH](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggf16864e8693d888f8178067470001b215dd93e7173619c943fae495568f4d771>), but as a standalone operation.

enum CUstreamCaptureMode


Possible modes for stream capture thread interactions. For more details see [cuStreamBeginCapture](<group__CUDA__STREAM.html#group__CUDA__STREAM_1g767167da0bbf07157dc20b6c258a2143> "Begins graph capture on a stream.") and [cuThreadExchangeStreamCaptureMode](<group__CUDA__STREAM.html#group__CUDA__STREAM_1g378135b262f02a43a7caeab239ae493d> "Swaps the stream capture interaction mode for a thread.")

######  Values

CU_STREAM_CAPTURE_MODE_GLOBAL = 0

CU_STREAM_CAPTURE_MODE_THREAD_LOCAL = 1

CU_STREAM_CAPTURE_MODE_RELAXED = 2


enum CUstreamCaptureStatus


Possible stream capture statuses returned by [cuStreamIsCapturing](<group__CUDA__STREAM.html#group__CUDA__STREAM_1g37823c49206e3704ae23c7ad78560bca> "Returns a stream's capture status.")

######  Values

CU_STREAM_CAPTURE_STATUS_NONE = 0
    Stream is not capturing
CU_STREAM_CAPTURE_STATUS_ACTIVE = 1
    Stream is actively capturing
CU_STREAM_CAPTURE_STATUS_INVALIDATED = 2
    Stream is part of a capture sequence that has been invalidated, but not terminated

enum CUstreamMemoryBarrier_flags


Flags for [CUstreamBatchMemOpParams::memoryBarrier](<unionCUstreamBatchMemOpParams__v1.html#unionCUstreamBatchMemOpParams__v1_16133c06182986968a5f5e381194566ef>)

######  Values

CU_STREAM_MEMORY_BARRIER_TYPE_SYS = 0x0
    System-wide memory barrier.
CU_STREAM_MEMORY_BARRIER_TYPE_GPU = 0x1
    Limit memory barrier scope to the GPU.

enum CUstreamUpdateCaptureDependencies_flags


Flags for [cuStreamUpdateCaptureDependencies](<group__CUDA__STREAM.html#group__CUDA__STREAM_1g0cd3210434f3e0796c492cfa0d4b4bd1> "Update the set of dependencies in a capturing stream.")

######  Values

CU_STREAM_ADD_CAPTURE_DEPENDENCIES = 0x0
    Add new nodes to the dependency set
CU_STREAM_SET_CAPTURE_DEPENDENCIES = 0x1
    Replace the dependency set with the new nodes

enum CUstreamWaitValue_flags


Flags for [cuStreamWaitValue32](<group__CUDA__MEMOP.html#group__CUDA__MEMOP_1g629856339de7bc6606047385addbb398> "Wait on a memory location.") and [cuStreamWaitValue64](<group__CUDA__MEMOP.html#group__CUDA__MEMOP_1g6910c1258c5f15aa5d699f0fd60d6933> "Wait on a memory location.")

######  Values

CU_STREAM_WAIT_VALUE_GEQ = 0x0
    Wait until (int32_t)(*addr - value) >= 0 (or int64_t for 64 bit values). Note this is a cyclic comparison which ignores wraparound. (Default behavior.)
CU_STREAM_WAIT_VALUE_EQ = 0x1
    Wait until *addr == value.
CU_STREAM_WAIT_VALUE_AND = 0x2
    Wait until (*addr & value) != 0.
CU_STREAM_WAIT_VALUE_NOR = 0x3
    Wait until ~(*addr | value) != 0. Support for this operation can be queried with [cuDeviceGetAttribute()](<group__CUDA__DEVICE.html#group__CUDA__DEVICE_1g9c3e1414f0ad901d3278a4d6645fc266> "Returns information about the device.") and [CU_DEVICE_ATTRIBUTE_CAN_USE_STREAM_WAIT_VALUE_NOR](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gge12b8a782bebe21b1ac0091bf9f4e2a3be06f9c31c264e0b29be6cc6330b5047>).
CU_STREAM_WAIT_VALUE_FLUSH = 1<<30
    Follow the wait operation with a flush of outstanding remote writes. This means that, if a remote write operation is guaranteed to have reached the device before the wait can be satisfied, that write is guaranteed to be visible to downstream device work. The device is permitted to reorder remote writes internally. For example, this flag would be required if two remote writes arrive in a defined order, the wait is satisfied by the second write, and downstream work needs to observe the first write. Support for this operation is restricted to selected platforms and can be queried with [CU_DEVICE_ATTRIBUTE_CAN_FLUSH_REMOTE_WRITES](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gge12b8a782bebe21b1ac0091bf9f4e2a34c702e528f71bf513ee0f3f32878ce9d>).

enum CUstreamWriteValue_flags


Flags for [cuStreamWriteValue32](<group__CUDA__MEMOP.html#group__CUDA__MEMOP_1g091455366d56dc2f1f69726aafa369b0> "Write a value to memory.")

######  Values

CU_STREAM_WRITE_VALUE_DEFAULT = 0x0
    Default behavior
CU_STREAM_WRITE_VALUE_NO_MEMORY_BARRIER = 0x1
    Permits the write to be reordered with writes which were issued before it, as a performance optimization. Normally, [cuStreamWriteValue32](<group__CUDA__MEMOP.html#group__CUDA__MEMOP_1g091455366d56dc2f1f69726aafa369b0> "Write a value to memory.") will provide a memory fence before the write, which has similar semantics to __threadfence_system() but is scoped to the stream rather than a CUDA thread. This flag is not supported in the v2 API.

enum CUstream_flags


Stream creation flags

######  Values

CU_STREAM_DEFAULT = 0x0
    Default stream flag
CU_STREAM_NON_BLOCKING = 0x1
    Stream does not synchronize with stream 0 (the NULL stream)

enum CUtensorMapDataType


Tensor map data type

######  Values

CU_TENSOR_MAP_DATA_TYPE_UINT8 = 0

CU_TENSOR_MAP_DATA_TYPE_UINT16

CU_TENSOR_MAP_DATA_TYPE_UINT32

CU_TENSOR_MAP_DATA_TYPE_INT32

CU_TENSOR_MAP_DATA_TYPE_UINT64

CU_TENSOR_MAP_DATA_TYPE_INT64

CU_TENSOR_MAP_DATA_TYPE_FLOAT16

CU_TENSOR_MAP_DATA_TYPE_FLOAT32

CU_TENSOR_MAP_DATA_TYPE_FLOAT64

CU_TENSOR_MAP_DATA_TYPE_BFLOAT16

CU_TENSOR_MAP_DATA_TYPE_FLOAT32_FTZ

CU_TENSOR_MAP_DATA_TYPE_TFLOAT32

CU_TENSOR_MAP_DATA_TYPE_TFLOAT32_FTZ

CU_TENSOR_MAP_DATA_TYPE_16U4_ALIGN8B

CU_TENSOR_MAP_DATA_TYPE_16U4_ALIGN16B

CU_TENSOR_MAP_DATA_TYPE_16U6_ALIGN16B


enum CUtensorMapFloatOOBfill


Tensor map out-of-bounds fill type

######  Values

CU_TENSOR_MAP_FLOAT_OOB_FILL_NONE = 0

CU_TENSOR_MAP_FLOAT_OOB_FILL_NAN_REQUEST_ZERO_FMA


enum CUtensorMapIm2ColWideMode


Tensor map Im2Col wide mode

######  Values

CU_TENSOR_MAP_IM2COL_WIDE_MODE_W = 0

CU_TENSOR_MAP_IM2COL_WIDE_MODE_W128


enum CUtensorMapInterleave


Tensor map interleave layout type

######  Values

CU_TENSOR_MAP_INTERLEAVE_NONE = 0

CU_TENSOR_MAP_INTERLEAVE_16B

CU_TENSOR_MAP_INTERLEAVE_32B


enum CUtensorMapL2promotion


Tensor map L2 promotion type

######  Values

CU_TENSOR_MAP_L2_PROMOTION_NONE = 0

CU_TENSOR_MAP_L2_PROMOTION_L2_64B

CU_TENSOR_MAP_L2_PROMOTION_L2_128B

CU_TENSOR_MAP_L2_PROMOTION_L2_256B


enum CUtensorMapSwizzle


Tensor map swizzling mode of shared memory banks

######  Values

CU_TENSOR_MAP_SWIZZLE_NONE = 0

CU_TENSOR_MAP_SWIZZLE_32B

CU_TENSOR_MAP_SWIZZLE_64B

CU_TENSOR_MAP_SWIZZLE_128B

CU_TENSOR_MAP_SWIZZLE_128B_ATOM_32B

CU_TENSOR_MAP_SWIZZLE_128B_ATOM_32B_FLIP_8B

CU_TENSOR_MAP_SWIZZLE_128B_ATOM_64B


enum CUuserObjectRetain_flags


Flags for retaining user object references for graphs

######  Values

CU_GRAPH_USER_OBJECT_MOVE = 1
    Transfer references from the caller rather than creating new references.

enum CUuserObject_flags


Flags for user objects for graphs

######  Values

CU_USER_OBJECT_NO_DESTRUCTOR_SYNC = 1
    Indicates the destructor execution is not synchronized by any CUDA handle.

enum cl_context_flags


NVCL context scheduling flags

######  Values

NVCL_CTX_SCHED_AUTO = 0x00
    Automatic scheduling
NVCL_CTX_SCHED_SPIN = 0x01
    Set spin as default scheduling
NVCL_CTX_SCHED_YIELD = 0x02
    Set yield as default scheduling
NVCL_CTX_SCHED_BLOCKING_SYNC = 0x04
    Set blocking synchronization as default scheduling

enum cl_event_flags


NVCL event scheduling flags

######  Values

NVCL_EVENT_SCHED_AUTO = 0x00
    Automatic scheduling
NVCL_EVENT_SCHED_SPIN = 0x01
    Set spin as default scheduling
NVCL_EVENT_SCHED_YIELD = 0x02
    Set yield as default scheduling
NVCL_EVENT_SCHED_BLOCKING_SYNC = 0x04
    Set blocking synchronization as default scheduling

* * *


---

# Error Handling

## 6.2.Â Error Handling

This section describes the error handling functions of the low-level CUDA driver application programming interface.

### Functions

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuGetErrorName](<#group__CUDA__ERROR_1g2c4ac087113652bb3d1f95bf2513c468>) ( [CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â error, const char**Â pStr )
     Gets the string representation of an error code enum name.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuGetErrorString](<#group__CUDA__ERROR_1g72758fcaf05b5c7fac5c25ead9445ada>) ( [CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â error, const char**Â pStr )
     Gets the string description of an error code.

### Functions

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuGetErrorName ( [CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â error, const char**Â pStr )


Gets the string representation of an error code enum name.

######  Parameters

`error`
    \- Error code to convert to string
`pStr`
    \- Address of the string pointer.

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>)

###### Description

Sets `*pStr` to the address of a NULL-terminated string representation of the name of the enum error code `error`. If the error code is not recognized, [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>) will be returned and `*pStr` will be set to the NULL address.

**See also:**

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>), [cudaGetErrorName](<../cuda-runtime-api/group__CUDART__ERROR.html#group__CUDART__ERROR_1gb3de7da2f23736878270026dcfc70075>)

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuGetErrorString ( [CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â error, const char**Â pStr )


Gets the string description of an error code.

######  Parameters

`error`
    \- Error code to convert to string
`pStr`
    \- Address of the string pointer.

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>)

###### Description

Sets `*pStr` to the address of a NULL-terminated string description of the error code `error`. If the error code is not recognized, [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>) will be returned and `*pStr` will be set to the NULL address.

**See also:**

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>), [cudaGetErrorString](<../cuda-runtime-api/group__CUDART__ERROR.html#group__CUDART__ERROR_1g4bc9e35a618dfd0877c29c8ee45148f1>)

* * *


---

# Initialization

## 6.3.Â Initialization

This section describes the initialization functions of the low-level CUDA driver application programming interface.

### Functions

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuInit](<#group__CUDA__INITIALIZE_1g0a2f1517e1bd8502c7194c3a8c134bc3>) ( unsigned int Â Flags )
     Initialize the CUDA driver API Initializes the driver API and must be called before any other function from the driver API in the current process. Currently, the `Flags` parameter must be 0. If cuInit() has not been called, any function from the driver API will return CUDA_ERROR_NOT_INITIALIZED.

### Functions

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuInit ( unsigned int Â Flags )


Initialize the CUDA driver API Initializes the driver API and must be called before any other function from the driver API in the current process. Currently, the `Flags` parameter must be 0. If cuInit() has not been called, any function from the driver API will return CUDA_ERROR_NOT_INITIALIZED.

######  Parameters

`Flags`
    \- Initialization flag for CUDA.

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>), [CUDA_ERROR_INVALID_DEVICE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e96f047e7215788ca96c81af92a04bfb6c>), [CUDA_ERROR_SYSTEM_DRIVER_MISMATCH](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e978f8d2d38cf4ed97d75127a7b3186d37>), [CUDA_ERROR_COMPAT_NOT_SUPPORTED_ON_DEVICE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e951bd73c67bc75fcb5238e73da64e482f>)

###### Description

Note: cuInit preloads various libraries needed for JIT compilation. To opt-out of this behavior, set the environment variable CUDA_FORCE_PRELOAD_LIBRARIES=0. CUDA will lazily load JIT libraries as needed. To disable JIT entirely, set the environment variable CUDA_DISABLE_JIT=1.

Note:

Note that this function may also return error codes from previous, asynchronous launches.

* * *


---

# Version Management

## 6.4.Â Version Management

This section describes the version management functions of the low-level CUDA driver application programming interface.

### Functions

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuDriverGetVersion](<#group__CUDA__VERSION_1g8b7a10395392e049006e61bcdc8ebe71>) ( int*Â driverVersion )
     Returns the latest CUDA version supported by driver.

### Functions

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuDriverGetVersion ( int*Â driverVersion )


Returns the latest CUDA version supported by driver.

######  Parameters

`driverVersion`
    \- Returns the CUDA driver version

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>)

###### Description

Returns in `*driverVersion` the version of CUDA supported by the driver. The version is returned as (1000 * major + 10 * minor). For example, CUDA 9.2 would be represented by 9020.

This function automatically returns [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>) if `driverVersion` is NULL.

Note:

Note that this function may also return error codes from previous, asynchronous launches.

**See also:**

[cudaDriverGetVersion](<../cuda-runtime-api/group__CUDART____VERSION.html#group__CUDART____VERSION_1g8a06ee14a0551606b7c780084d5564ab>), [cudaRuntimeGetVersion](<../cuda-runtime-api/group__CUDART____VERSION.html#group__CUDART____VERSION_1g0e3952c7802fd730432180f1f4a6cdc6>)

* * *


---

# Device Management

## 6.5.Â Device Management

This section describes the device management functions of the low-level CUDA driver application programming interface.

### Functions

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuDeviceGet](<#group__CUDA__DEVICE_1g8bdd1cc7201304b01357b8034f6587cb>) ( [CUdevice](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g41ca2a24a242b36ef2ca77330b5fb72a>)*Â device, int Â ordinal )
     Returns a handle to a compute device.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuDeviceGetAttribute](<#group__CUDA__DEVICE_1g9c3e1414f0ad901d3278a4d6645fc266>) ( int*Â pi, [CUdevice_attribute](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ge12b8a782bebe21b1ac0091bf9f4e2a3>)Â attrib, [CUdevice](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g41ca2a24a242b36ef2ca77330b5fb72a>)Â dev )
     Returns information about the device.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuDeviceGetCount](<#group__CUDA__DEVICE_1g52b5ce05cb8c5fb6831b2c0ff2887c74>) ( int*Â count )
     Returns the number of compute-capable devices.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuDeviceGetDefaultMemPool](<#group__CUDA__DEVICE_1gc8bca3c97a78816303b8aa5773b741f2>) ( [CUmemoryPool](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g3b96b1ef79f0cb312b51169e9f50e722>)*Â pool_out, [CUdevice](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g41ca2a24a242b36ef2ca77330b5fb72a>)Â dev )
     Returns the default mempool of a device.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuDeviceGetExecAffinitySupport](<#group__CUDA__DEVICE_1g7f0091850e0841f367f13d623456427d>) ( int*Â pi, [CUexecAffinityType](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g14e6345acf2bda65be91eda77cf03f5c>)Â type, [CUdevice](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g41ca2a24a242b36ef2ca77330b5fb72a>)Â dev )
     Returns information about the execution affinity support of the device.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuDeviceGetHostAtomicCapabilities](<#group__CUDA__DEVICE_1g801bf845c6bd488103a2234379b15ce6>) ( unsigned int*Â capabilities, const [CUatomicOperation *](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gfd7012de0abfe50cee089f3f00d6dcf3>)*Â operations, unsigned int Â count, [CUdevice](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g41ca2a24a242b36ef2ca77330b5fb72a>)Â dev )
     Queries details about atomic operations supported between the device and host.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuDeviceGetLuid](<#group__CUDA__DEVICE_1g630073c868f8878e89705ea831c49249>) ( char*Â luid, unsigned int*Â deviceNodeMask, [CUdevice](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g41ca2a24a242b36ef2ca77330b5fb72a>)Â dev )
     Return an LUID and device node mask for the device.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuDeviceGetMemPool](<#group__CUDA__DEVICE_1gdf186e9559d53a5eb18e572d48c1121b>) ( [CUmemoryPool](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g3b96b1ef79f0cb312b51169e9f50e722>)*Â pool, [CUdevice](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g41ca2a24a242b36ef2ca77330b5fb72a>)Â dev )
     Gets the current mempool for a device.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuDeviceGetName](<#group__CUDA__DEVICE_1gef75aa30df95446a845f2a7b9fffbb7f>) ( char*Â name, int Â len, [CUdevice](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g41ca2a24a242b36ef2ca77330b5fb72a>)Â dev )
     Returns an identifier string for the device.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuDeviceGetNvSciSyncAttributes](<#group__CUDA__DEVICE_1g0991e2b2b3cedee1ca77d6376e581335>) ( void*Â nvSciSyncAttrList, [CUdevice](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g41ca2a24a242b36ef2ca77330b5fb72a>)Â dev, int Â flags )
     Return NvSciSync attributes that this device can support.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuDeviceGetTexture1DLinearMaxWidth](<#group__CUDA__DEVICE_1gb41b3a675bae9932bffa1c0ae969b1e0>) ( size_t*Â maxWidthInElements, [CUarray_format](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g9b009d9a6aa4c5765c8a00289b6068f9>)Â format, unsignedÂ numChannels, [CUdevice](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g41ca2a24a242b36ef2ca77330b5fb72a>)Â dev )
     Returns the maximum number of elements allocatable in a 1D linear texture for a given texture element size.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuDeviceGetUuid](<#group__CUDA__DEVICE_1g987b46b884c101ed5be414ab4d9e60e4>) ( CUuuid*Â uuid, [CUdevice](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g41ca2a24a242b36ef2ca77330b5fb72a>)Â dev )
     Return an UUID for the device.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuDeviceSetMemPool](<#group__CUDA__DEVICE_1g4f2f276b84d9c2eaefdc76d6274db4a0>) ( [CUdevice](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g41ca2a24a242b36ef2ca77330b5fb72a>)Â dev, [CUmemoryPool](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g3b96b1ef79f0cb312b51169e9f50e722>)Â pool )
     Sets the current memory pool of a device.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuDeviceTotalMem](<#group__CUDA__DEVICE_1gc6a0d6551335a3780f9f3c967a0fde5d>) ( size_t*Â bytes, [CUdevice](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g41ca2a24a242b36ef2ca77330b5fb72a>)Â dev )
     Returns the total amount of memory on the device.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuFlushGPUDirectRDMAWrites](<#group__CUDA__DEVICE_1g265e3c82ef0f0fe035f85c4c45a8fbdf>) ( [CUflushGPUDirectRDMAWritesTarget](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g01251451232c43bc5c7cb067ed2c28ef>)Â target, [CUflushGPUDirectRDMAWritesScope](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g9eafc4def87e0f6600f905e756ec99d1>)Â scope )
     Blocks until remote writes are visible to the specified scope.

### Functions

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuDeviceGet ( [CUdevice](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g41ca2a24a242b36ef2ca77330b5fb72a>)*Â device, int Â ordinal )


Returns a handle to a compute device.

######  Parameters

`device`
    \- Returned device handle
`ordinal`
    \- Device number to get handle for

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_DEINITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9acf52f132faf29b473cdda6061f0f44a>), [CUDA_ERROR_NOT_INITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e98feb999f0af99b4a25ab26b3866f4df8>), [CUDA_ERROR_INVALID_CONTEXT](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a484e9af32c1e9893ff21f0e0191a12d>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>), [CUDA_ERROR_INVALID_DEVICE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e96f047e7215788ca96c81af92a04bfb6c>)

###### Description

Returns in `*device` a device handle given an ordinal in the range **[0,[cuDeviceGetCount()](<group__CUDA__DEVICE.html#group__CUDA__DEVICE_1g52b5ce05cb8c5fb6831b2c0ff2887c74> "Returns the number of compute-capable devices.")-1]**.

Note:

Note that this function may also return error codes from previous, asynchronous launches.

**See also:**

[cuDeviceGetAttribute](<group__CUDA__DEVICE.html#group__CUDA__DEVICE_1g9c3e1414f0ad901d3278a4d6645fc266> "Returns information about the device."), [cuDeviceGetCount](<group__CUDA__DEVICE.html#group__CUDA__DEVICE_1g52b5ce05cb8c5fb6831b2c0ff2887c74> "Returns the number of compute-capable devices."), [cuDeviceGetName](<group__CUDA__DEVICE.html#group__CUDA__DEVICE_1gef75aa30df95446a845f2a7b9fffbb7f> "Returns an identifier string for the device."), [cuDeviceGetUuid](<group__CUDA__DEVICE.html#group__CUDA__DEVICE_1g987b46b884c101ed5be414ab4d9e60e4> "Return an UUID for the device."), [cuDeviceGetLuid](<group__CUDA__DEVICE.html#group__CUDA__DEVICE_1g630073c868f8878e89705ea831c49249> "Return an LUID and device node mask for the device."), [cuDeviceTotalMem](<group__CUDA__DEVICE.html#group__CUDA__DEVICE_1gc6a0d6551335a3780f9f3c967a0fde5d> "Returns the total amount of memory on the device."), [cuDeviceGetExecAffinitySupport](<group__CUDA__DEVICE.html#group__CUDA__DEVICE_1g7f0091850e0841f367f13d623456427d> "Returns information about the execution affinity support of the device.")

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuDeviceGetAttribute ( int*Â pi, [CUdevice_attribute](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ge12b8a782bebe21b1ac0091bf9f4e2a3>)Â attrib, [CUdevice](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g41ca2a24a242b36ef2ca77330b5fb72a>)Â dev )


Returns information about the device.

######  Parameters

`pi`
    \- Returned device attribute value
`attrib`
    \- Device attribute to query
`dev`
    \- Device handle

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_DEINITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9acf52f132faf29b473cdda6061f0f44a>), [CUDA_ERROR_NOT_INITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e98feb999f0af99b4a25ab26b3866f4df8>), [CUDA_ERROR_INVALID_CONTEXT](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a484e9af32c1e9893ff21f0e0191a12d>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>), [CUDA_ERROR_INVALID_DEVICE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e96f047e7215788ca96c81af92a04bfb6c>)

###### Description

Returns in `*pi` the integer value of the attribute `attrib` on device `dev`.

Note:

Note that this function may also return error codes from previous, asynchronous launches.

**See also:**

[cuDeviceGetCount](<group__CUDA__DEVICE.html#group__CUDA__DEVICE_1g52b5ce05cb8c5fb6831b2c0ff2887c74> "Returns the number of compute-capable devices."), [cuDeviceGetName](<group__CUDA__DEVICE.html#group__CUDA__DEVICE_1gef75aa30df95446a845f2a7b9fffbb7f> "Returns an identifier string for the device."), [cuDeviceGetUuid](<group__CUDA__DEVICE.html#group__CUDA__DEVICE_1g987b46b884c101ed5be414ab4d9e60e4> "Return an UUID for the device."), [cuDeviceGet](<group__CUDA__DEVICE.html#group__CUDA__DEVICE_1g8bdd1cc7201304b01357b8034f6587cb> "Returns a handle to a compute device."), [cuDeviceTotalMem](<group__CUDA__DEVICE.html#group__CUDA__DEVICE_1gc6a0d6551335a3780f9f3c967a0fde5d> "Returns the total amount of memory on the device."), [cuDeviceGetExecAffinitySupport](<group__CUDA__DEVICE.html#group__CUDA__DEVICE_1g7f0091850e0841f367f13d623456427d> "Returns information about the execution affinity support of the device."), [cudaDeviceGetAttribute](<../cuda-runtime-api/group__CUDART__DEVICE.html#group__CUDART__DEVICE_1gb22e8256592b836df9a9cc36c9db7151>), [cudaGetDeviceProperties](<../cuda-runtime-api/group__CUDART__DEVICE.html#group__CUDART__DEVICE_1g1bf9d625a931d657e08db2b4391170f0>)

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuDeviceGetCount ( int*Â count )


Returns the number of compute-capable devices.

######  Parameters

`count`
    \- Returned number of compute-capable devices

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_DEINITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9acf52f132faf29b473cdda6061f0f44a>), [CUDA_ERROR_NOT_INITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e98feb999f0af99b4a25ab26b3866f4df8>), [CUDA_ERROR_INVALID_CONTEXT](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a484e9af32c1e9893ff21f0e0191a12d>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>)

###### Description

Returns in `*count` the number of devices with compute capability greater than or equal to 2.0 that are available for execution. If there is no such device, [cuDeviceGetCount()](<group__CUDA__DEVICE.html#group__CUDA__DEVICE_1g52b5ce05cb8c5fb6831b2c0ff2887c74> "Returns the number of compute-capable devices.") returns 0.

Note:

Note that this function may also return error codes from previous, asynchronous launches.

**See also:**

[cuDeviceGetAttribute](<group__CUDA__DEVICE.html#group__CUDA__DEVICE_1g9c3e1414f0ad901d3278a4d6645fc266> "Returns information about the device."), [cuDeviceGetName](<group__CUDA__DEVICE.html#group__CUDA__DEVICE_1gef75aa30df95446a845f2a7b9fffbb7f> "Returns an identifier string for the device."), [cuDeviceGetUuid](<group__CUDA__DEVICE.html#group__CUDA__DEVICE_1g987b46b884c101ed5be414ab4d9e60e4> "Return an UUID for the device."), [cuDeviceGetLuid](<group__CUDA__DEVICE.html#group__CUDA__DEVICE_1g630073c868f8878e89705ea831c49249> "Return an LUID and device node mask for the device."), [cuDeviceGet](<group__CUDA__DEVICE.html#group__CUDA__DEVICE_1g8bdd1cc7201304b01357b8034f6587cb> "Returns a handle to a compute device."), [cuDeviceTotalMem](<group__CUDA__DEVICE.html#group__CUDA__DEVICE_1gc6a0d6551335a3780f9f3c967a0fde5d> "Returns the total amount of memory on the device."), [cuDeviceGetExecAffinitySupport](<group__CUDA__DEVICE.html#group__CUDA__DEVICE_1g7f0091850e0841f367f13d623456427d> "Returns information about the execution affinity support of the device."), [cudaGetDeviceCount](<../cuda-runtime-api/group__CUDART__DEVICE.html#group__CUDART__DEVICE_1g18808e54893cfcaafefeab31a73cc55f>)

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuDeviceGetDefaultMemPool ( [CUmemoryPool](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g3b96b1ef79f0cb312b51169e9f50e722>)*Â pool_out, [CUdevice](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g41ca2a24a242b36ef2ca77330b5fb72a>)Â dev )


Returns the default mempool of a device.

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_DEINITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9acf52f132faf29b473cdda6061f0f44a>)[CUDA_ERROR_NOT_INITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e98feb999f0af99b4a25ab26b3866f4df8>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>), [CUDA_ERROR_INVALID_DEVICE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e96f047e7215788ca96c81af92a04bfb6c>), [CUDA_ERROR_NOT_SUPPORTED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e954756ae7ade0dfd09faeccb513dd831b>)

###### Description

The default mempool of a device contains device memory from that device.

Note:

Note that this function may also return error codes from previous, asynchronous launches.

**See also:**

[cuMemAllocAsync](<group__CUDA__MALLOC__ASYNC.html#group__CUDA__MALLOC__ASYNC_1g13413273e84a641bce1929eae9e6501f> "Allocates memory with stream ordered semantics."), [cuMemPoolTrimTo](<group__CUDA__MALLOC__ASYNC.html#group__CUDA__MALLOC__ASYNC_1g9c7e267e3460945b0ca76c48314bb669> "Tries to release memory back to the OS."), [cuMemPoolGetAttribute](<group__CUDA__MALLOC__ASYNC.html#group__CUDA__MALLOC__ASYNC_1gd45ea7c43e4a1add4b971d06fa72eda4> "Gets attributes of a memory pool."), [cuMemPoolSetAttribute](<group__CUDA__MALLOC__ASYNC.html#group__CUDA__MALLOC__ASYNC_1g223e786cb217709235a06e41bccaec00> "Sets attributes of a memory pool."), [cuMemPoolSetAccess](<group__CUDA__MALLOC__ASYNC.html#group__CUDA__MALLOC__ASYNC_1gff3ce33e252443f4b087b94e42913406> "Controls visibility of pools between devices."), [cuDeviceGetMemPool](<group__CUDA__DEVICE.html#group__CUDA__DEVICE_1gdf186e9559d53a5eb18e572d48c1121b> "Gets the current mempool for a device."), [cuMemPoolCreate](<group__CUDA__MALLOC__ASYNC.html#group__CUDA__MALLOC__ASYNC_1g8aa4c143dbc20293659cd883232b95f2> "Creates a memory pool.")

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuDeviceGetExecAffinitySupport ( int*Â pi, [CUexecAffinityType](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g14e6345acf2bda65be91eda77cf03f5c>)Â type, [CUdevice](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g41ca2a24a242b36ef2ca77330b5fb72a>)Â dev )


Returns information about the execution affinity support of the device.

######  Parameters

`pi`
    \- 1 if the execution affinity type `type` is supported by the device, or 0 if not
`type`
    \- Execution affinity type to query
`dev`
    \- Device handle

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_DEINITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9acf52f132faf29b473cdda6061f0f44a>), [CUDA_ERROR_NOT_INITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e98feb999f0af99b4a25ab26b3866f4df8>), [CUDA_ERROR_INVALID_CONTEXT](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a484e9af32c1e9893ff21f0e0191a12d>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>), [CUDA_ERROR_INVALID_DEVICE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e96f047e7215788ca96c81af92a04bfb6c>)

###### Description

Returns in `*pi` whether execution affinity type `type` is supported by device `dev`. The supported types are:

  * [CU_EXEC_AFFINITY_TYPE_SM_COUNT](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg14e6345acf2bda65be91eda77cf03f5cc7764c90ce81e15aba5f26a3507cd00c>): 1 if context with limited SMs is supported by the device, or 0 if not;


Note:

Note that this function may also return error codes from previous, asynchronous launches.

**See also:**

[cuDeviceGetAttribute](<group__CUDA__DEVICE.html#group__CUDA__DEVICE_1g9c3e1414f0ad901d3278a4d6645fc266> "Returns information about the device."), [cuDeviceGetCount](<group__CUDA__DEVICE.html#group__CUDA__DEVICE_1g52b5ce05cb8c5fb6831b2c0ff2887c74> "Returns the number of compute-capable devices."), [cuDeviceGetName](<group__CUDA__DEVICE.html#group__CUDA__DEVICE_1gef75aa30df95446a845f2a7b9fffbb7f> "Returns an identifier string for the device."), [cuDeviceGetUuid](<group__CUDA__DEVICE.html#group__CUDA__DEVICE_1g987b46b884c101ed5be414ab4d9e60e4> "Return an UUID for the device."), [cuDeviceGet](<group__CUDA__DEVICE.html#group__CUDA__DEVICE_1g8bdd1cc7201304b01357b8034f6587cb> "Returns a handle to a compute device."), [cuDeviceTotalMem](<group__CUDA__DEVICE.html#group__CUDA__DEVICE_1gc6a0d6551335a3780f9f3c967a0fde5d> "Returns the total amount of memory on the device.")

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuDeviceGetHostAtomicCapabilities ( unsigned int*Â capabilities, const [CUatomicOperation *](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gfd7012de0abfe50cee089f3f00d6dcf3>)*Â operations, unsigned int Â count, [CUdevice](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g41ca2a24a242b36ef2ca77330b5fb72a>)Â dev )


Queries details about atomic operations supported between the device and host.

######  Parameters

`capabilities`
    \- Returned capability details of each requested operation
`operations`
    \- Requested operations
`count`
    \- Count of requested operations and size of capabilities
`dev`
    \- Device handle

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_INVALID_DEVICE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e96f047e7215788ca96c81af92a04bfb6c>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>)

###### Description

Returns in `*capabilities` the details about requested atomic `*operations` over the the link between `dev` and the host. The allocated size of `*operations` and `*capabilities` must be `count`.

For each [CUatomicOperation](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gfd7012de0abfe50cee089f3f00d6dcf3>) in `*operations`, the corresponding result in `*capabilities` will be a bitmask indicating which of [CUatomicOperationCapability](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gf8fbc0f84fd6461c5611b3935b26e22c>) the link supports natively.

Returns [CUDA_ERROR_INVALID_DEVICE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e96f047e7215788ca96c81af92a04bfb6c>) if `dev` is not valid.

Returns [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>) if `*capabilities` or `*operations` is NULL, if `count` is 0, or if any of `*operations` is not valid.

Note:

Note that this function may also return error codes from previous, asynchronous launches.

**See also:**

[cuDeviceGetAttribute](<group__CUDA__DEVICE.html#group__CUDA__DEVICE_1g9c3e1414f0ad901d3278a4d6645fc266> "Returns information about the device."), [cuDeviceGetP2PAtomicCapabilities](<group__CUDA__PEER__ACCESS.html#group__CUDA__PEER__ACCESS_1gfd989876c8fd3291b520c0b561d5282d> "Queries details about atomic operations supported between two devices."), cudaDeviceGeHostAtomicCapabilities

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuDeviceGetLuid ( char*Â luid, unsigned int*Â deviceNodeMask, [CUdevice](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g41ca2a24a242b36ef2ca77330b5fb72a>)Â dev )


Return an LUID and device node mask for the device.

######  Parameters

`luid`
    \- Returned LUID
`deviceNodeMask`
    \- Returned device node mask
`dev`
    \- Device to get identifier string for

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_DEINITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9acf52f132faf29b473cdda6061f0f44a>), [CUDA_ERROR_NOT_INITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e98feb999f0af99b4a25ab26b3866f4df8>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>), [CUDA_ERROR_INVALID_DEVICE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e96f047e7215788ca96c81af92a04bfb6c>)

###### Description

Return identifying information (`luid` and `deviceNodeMask`) to allow matching device with graphics APIs.

Note:

Note that this function may also return error codes from previous, asynchronous launches.

**See also:**

[cuDeviceGetAttribute](<group__CUDA__DEVICE.html#group__CUDA__DEVICE_1g9c3e1414f0ad901d3278a4d6645fc266> "Returns information about the device."), [cuDeviceGetCount](<group__CUDA__DEVICE.html#group__CUDA__DEVICE_1g52b5ce05cb8c5fb6831b2c0ff2887c74> "Returns the number of compute-capable devices."), [cuDeviceGetName](<group__CUDA__DEVICE.html#group__CUDA__DEVICE_1gef75aa30df95446a845f2a7b9fffbb7f> "Returns an identifier string for the device."), [cuDeviceGet](<group__CUDA__DEVICE.html#group__CUDA__DEVICE_1g8bdd1cc7201304b01357b8034f6587cb> "Returns a handle to a compute device."), [cuDeviceTotalMem](<group__CUDA__DEVICE.html#group__CUDA__DEVICE_1gc6a0d6551335a3780f9f3c967a0fde5d> "Returns the total amount of memory on the device."), [cuDeviceGetExecAffinitySupport](<group__CUDA__DEVICE.html#group__CUDA__DEVICE_1g7f0091850e0841f367f13d623456427d> "Returns information about the execution affinity support of the device."), [cudaGetDeviceProperties](<../cuda-runtime-api/group__CUDART__DEVICE.html#group__CUDART__DEVICE_1g1bf9d625a931d657e08db2b4391170f0>)

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuDeviceGetMemPool ( [CUmemoryPool](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g3b96b1ef79f0cb312b51169e9f50e722>)*Â pool, [CUdevice](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g41ca2a24a242b36ef2ca77330b5fb72a>)Â dev )


Gets the current mempool for a device.

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>)

###### Description

Returns the last pool provided to [cuDeviceSetMemPool](<group__CUDA__DEVICE.html#group__CUDA__DEVICE_1g4f2f276b84d9c2eaefdc76d6274db4a0> "Sets the current memory pool of a device.") for this device or the device's default memory pool if [cuDeviceSetMemPool](<group__CUDA__DEVICE.html#group__CUDA__DEVICE_1g4f2f276b84d9c2eaefdc76d6274db4a0> "Sets the current memory pool of a device.") has never been called. By default the current mempool is the default mempool for a device. Otherwise the returned pool must have been set with [cuDeviceSetMemPool](<group__CUDA__DEVICE.html#group__CUDA__DEVICE_1g4f2f276b84d9c2eaefdc76d6274db4a0> "Sets the current memory pool of a device.").

**See also:**

[cuDeviceGetDefaultMemPool](<group__CUDA__DEVICE.html#group__CUDA__DEVICE_1gc8bca3c97a78816303b8aa5773b741f2> "Returns the default mempool of a device."), [cuMemPoolCreate](<group__CUDA__MALLOC__ASYNC.html#group__CUDA__MALLOC__ASYNC_1g8aa4c143dbc20293659cd883232b95f2> "Creates a memory pool."), [cuDeviceSetMemPool](<group__CUDA__DEVICE.html#group__CUDA__DEVICE_1g4f2f276b84d9c2eaefdc76d6274db4a0> "Sets the current memory pool of a device.")

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuDeviceGetName ( char*Â name, int Â len, [CUdevice](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g41ca2a24a242b36ef2ca77330b5fb72a>)Â dev )


Returns an identifier string for the device.

######  Parameters

`name`
    \- Returned identifier string for the device
`len`
    \- Maximum length of string to store in `name`
`dev`
    \- Device to get identifier string for

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_DEINITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9acf52f132faf29b473cdda6061f0f44a>), [CUDA_ERROR_NOT_INITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e98feb999f0af99b4a25ab26b3866f4df8>), [CUDA_ERROR_INVALID_CONTEXT](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a484e9af32c1e9893ff21f0e0191a12d>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>), [CUDA_ERROR_INVALID_DEVICE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e96f047e7215788ca96c81af92a04bfb6c>)

###### Description

Returns an ASCII string identifying the device `dev` in the NULL-terminated string pointed to by `name`. `len` specifies the maximum length of the string that may be returned. `name` is shortened to the specified `len`, if `len` is less than the device name

Note:

Note that this function may also return error codes from previous, asynchronous launches.

**See also:**

[cuDeviceGetAttribute](<group__CUDA__DEVICE.html#group__CUDA__DEVICE_1g9c3e1414f0ad901d3278a4d6645fc266> "Returns information about the device."), [cuDeviceGetUuid](<group__CUDA__DEVICE.html#group__CUDA__DEVICE_1g987b46b884c101ed5be414ab4d9e60e4> "Return an UUID for the device."), [cuDeviceGetLuid](<group__CUDA__DEVICE.html#group__CUDA__DEVICE_1g630073c868f8878e89705ea831c49249> "Return an LUID and device node mask for the device."), [cuDeviceGetCount](<group__CUDA__DEVICE.html#group__CUDA__DEVICE_1g52b5ce05cb8c5fb6831b2c0ff2887c74> "Returns the number of compute-capable devices."), [cuDeviceGet](<group__CUDA__DEVICE.html#group__CUDA__DEVICE_1g8bdd1cc7201304b01357b8034f6587cb> "Returns a handle to a compute device."), [cuDeviceTotalMem](<group__CUDA__DEVICE.html#group__CUDA__DEVICE_1gc6a0d6551335a3780f9f3c967a0fde5d> "Returns the total amount of memory on the device."), [cuDeviceGetExecAffinitySupport](<group__CUDA__DEVICE.html#group__CUDA__DEVICE_1g7f0091850e0841f367f13d623456427d> "Returns information about the execution affinity support of the device."), [cudaGetDeviceProperties](<../cuda-runtime-api/group__CUDART__DEVICE.html#group__CUDART__DEVICE_1g1bf9d625a931d657e08db2b4391170f0>)

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuDeviceGetNvSciSyncAttributes ( void*Â nvSciSyncAttrList, [CUdevice](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g41ca2a24a242b36ef2ca77330b5fb72a>)Â dev, int Â flags )


Return NvSciSync attributes that this device can support.

######  Parameters

`nvSciSyncAttrList`
    \- Return NvSciSync attributes supported.
`dev`
    \- Valid Cuda Device to get NvSciSync attributes for.
`flags`
    \- flags describing NvSciSync usage.

###### Description

Returns in `nvSciSyncAttrList`, the properties of NvSciSync that this CUDA device, `dev` can support. The returned `nvSciSyncAttrList` can be used to create an NvSciSync object that matches this device's capabilities.

If NvSciSyncAttrKey_RequiredPerm field in `nvSciSyncAttrList` is already set this API will return [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>).

The applications should set `nvSciSyncAttrList` to a valid NvSciSyncAttrList failing which this API will return [CUDA_ERROR_INVALID_HANDLE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e90fd2e63260c6317ba943af0f7e4b8d21>).

The `flags` controls how applications intends to use the NvSciSync created from the `nvSciSyncAttrList`. The valid flags are:

  * [CUDA_NVSCISYNC_ATTR_SIGNAL](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g8709811eaf5a7849ad235aae65471a06>), specifies that the applications intends to signal an NvSciSync on this CUDA device.

  * [CUDA_NVSCISYNC_ATTR_WAIT](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gd7a00d09b6061b828e13360b238cf9b4>), specifies that the applications intends to wait on an NvSciSync on this CUDA device.


At least one of these flags must be set, failing which the API returns [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>). Both the flags are orthogonal to one another: a developer may set both these flags that allows to set both wait and signal specific attributes in the same `nvSciSyncAttrList`.

Note that this API updates the input `nvSciSyncAttrList` with values equivalent to the following public attribute key-values: NvSciSyncAttrKey_RequiredPerm is set to

  * NvSciSyncAccessPerm_SignalOnly if [CUDA_NVSCISYNC_ATTR_SIGNAL](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g8709811eaf5a7849ad235aae65471a06>) is set in `flags`.

  * NvSciSyncAccessPerm_WaitOnly if [CUDA_NVSCISYNC_ATTR_WAIT](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gd7a00d09b6061b828e13360b238cf9b4>) is set in `flags`.

  * NvSciSyncAccessPerm_WaitSignal if both [CUDA_NVSCISYNC_ATTR_WAIT](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gd7a00d09b6061b828e13360b238cf9b4>) and [CUDA_NVSCISYNC_ATTR_SIGNAL](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g8709811eaf5a7849ad235aae65471a06>) are set in `flags`. NvSciSyncAttrKey_PrimitiveInfo is set to

  * NvSciSyncAttrValPrimitiveType_SysmemSemaphore on any valid `device`.

  * NvSciSyncAttrValPrimitiveType_Syncpoint if `device` is a Tegra device.

  * NvSciSyncAttrValPrimitiveType_SysmemSemaphorePayload64b if `device` is GA10X+. NvSciSyncAttrKey_GpuId is set to the same UUID that is returned for this `device` from [cuDeviceGetUuid](<group__CUDA__DEVICE.html#group__CUDA__DEVICE_1g987b46b884c101ed5be414ab4d9e60e4> "Return an UUID for the device.").


[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_DEINITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9acf52f132faf29b473cdda6061f0f44a>), [CUDA_ERROR_NOT_INITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e98feb999f0af99b4a25ab26b3866f4df8>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>), [CUDA_ERROR_INVALID_HANDLE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e90fd2e63260c6317ba943af0f7e4b8d21>), [CUDA_ERROR_INVALID_DEVICE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e96f047e7215788ca96c81af92a04bfb6c>), [CUDA_ERROR_NOT_SUPPORTED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e954756ae7ade0dfd09faeccb513dd831b>), [CUDA_ERROR_OUT_OF_MEMORY](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9264c50688ed110e8476b591befe60c02>)

**See also:**

[cuImportExternalSemaphore](<group__CUDA__EXTRES__INTEROP.html#group__CUDA__EXTRES__INTEROP_1ge593134f5f9650474af74db644c4a326> "Imports an external semaphore."), [cuDestroyExternalSemaphore](<group__CUDA__EXTRES__INTEROP.html#group__CUDA__EXTRES__INTEROP_1g7f13444973542fa50b7e75bcfb2f923d> "Destroys an external semaphore."), [cuSignalExternalSemaphoresAsync](<group__CUDA__EXTRES__INTEROP.html#group__CUDA__EXTRES__INTEROP_1g86cd6c4b3f439ba786f4e65d1b8107c3> "Signals a set of external semaphore objects."), [cuWaitExternalSemaphoresAsync](<group__CUDA__EXTRES__INTEROP.html#group__CUDA__EXTRES__INTEROP_1g063f01a524818ac89bacf521c55a39f0> "Waits on a set of external semaphore objects.")

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuDeviceGetTexture1DLinearMaxWidth ( size_t*Â maxWidthInElements, [CUarray_format](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g9b009d9a6aa4c5765c8a00289b6068f9>)Â format, unsignedÂ numChannels, [CUdevice](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g41ca2a24a242b36ef2ca77330b5fb72a>)Â dev )


Returns the maximum number of elements allocatable in a 1D linear texture for a given texture element size.

######  Parameters

`maxWidthInElements`
    \- Returned maximum number of texture elements allocatable for given `format` and `numChannels`.
`format`
    \- Texture format.
`numChannels`
    \- Number of channels per texture element.
`dev`
    \- Device handle.

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_DEINITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9acf52f132faf29b473cdda6061f0f44a>), [CUDA_ERROR_NOT_INITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e98feb999f0af99b4a25ab26b3866f4df8>), [CUDA_ERROR_INVALID_CONTEXT](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a484e9af32c1e9893ff21f0e0191a12d>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>), [CUDA_ERROR_INVALID_DEVICE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e96f047e7215788ca96c81af92a04bfb6c>)

###### Description

Returns in `maxWidthInElements` the maximum number of texture elements allocatable in a 1D linear texture for given `format` and `numChannels`.

Note:

Note that this function may also return error codes from previous, asynchronous launches.

**See also:**

[cuDeviceGetAttribute](<group__CUDA__DEVICE.html#group__CUDA__DEVICE_1g9c3e1414f0ad901d3278a4d6645fc266> "Returns information about the device."), [cuDeviceGetCount](<group__CUDA__DEVICE.html#group__CUDA__DEVICE_1g52b5ce05cb8c5fb6831b2c0ff2887c74> "Returns the number of compute-capable devices."), [cuDeviceGetName](<group__CUDA__DEVICE.html#group__CUDA__DEVICE_1gef75aa30df95446a845f2a7b9fffbb7f> "Returns an identifier string for the device."), [cuDeviceGetUuid](<group__CUDA__DEVICE.html#group__CUDA__DEVICE_1g987b46b884c101ed5be414ab4d9e60e4> "Return an UUID for the device."), [cuDeviceGet](<group__CUDA__DEVICE.html#group__CUDA__DEVICE_1g8bdd1cc7201304b01357b8034f6587cb> "Returns a handle to a compute device."), [cudaMemGetInfo](<../cuda-runtime-api/group__CUDART__MEMORY.html#group__CUDART__MEMORY_1g376b97f5ab20321ca46f7cfa9511b978>), [cuDeviceTotalMem](<group__CUDA__DEVICE.html#group__CUDA__DEVICE_1gc6a0d6551335a3780f9f3c967a0fde5d> "Returns the total amount of memory on the device.")

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuDeviceGetUuid ( CUuuid*Â uuid, [CUdevice](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g41ca2a24a242b36ef2ca77330b5fb72a>)Â dev )


Return an UUID for the device.

######  Parameters

`uuid`
    \- Returned UUID
`dev`
    \- Device to get identifier string for

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_DEINITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9acf52f132faf29b473cdda6061f0f44a>), [CUDA_ERROR_NOT_INITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e98feb999f0af99b4a25ab26b3866f4df8>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>), [CUDA_ERROR_INVALID_DEVICE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e96f047e7215788ca96c81af92a04bfb6c>)

###### Description

Returns 16-octets identifying the device `dev` in the structure pointed by the `uuid`. If the device is in MIG mode, returns its MIG UUID which uniquely identifies the subscribed MIG compute instance.

Note:

Note that this function may also return error codes from previous, asynchronous launches.

**See also:**

[cuDeviceGetAttribute](<group__CUDA__DEVICE.html#group__CUDA__DEVICE_1g9c3e1414f0ad901d3278a4d6645fc266> "Returns information about the device."), [cuDeviceGetCount](<group__CUDA__DEVICE.html#group__CUDA__DEVICE_1g52b5ce05cb8c5fb6831b2c0ff2887c74> "Returns the number of compute-capable devices."), [cuDeviceGetName](<group__CUDA__DEVICE.html#group__CUDA__DEVICE_1gef75aa30df95446a845f2a7b9fffbb7f> "Returns an identifier string for the device."), [cuDeviceGetLuid](<group__CUDA__DEVICE.html#group__CUDA__DEVICE_1g630073c868f8878e89705ea831c49249> "Return an LUID and device node mask for the device."), [cuDeviceGet](<group__CUDA__DEVICE.html#group__CUDA__DEVICE_1g8bdd1cc7201304b01357b8034f6587cb> "Returns a handle to a compute device."), [cuDeviceTotalMem](<group__CUDA__DEVICE.html#group__CUDA__DEVICE_1gc6a0d6551335a3780f9f3c967a0fde5d> "Returns the total amount of memory on the device."), [cudaGetDeviceProperties](<../cuda-runtime-api/group__CUDART__DEVICE.html#group__CUDART__DEVICE_1g1bf9d625a931d657e08db2b4391170f0>)

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuDeviceSetMemPool ( [CUdevice](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g41ca2a24a242b36ef2ca77330b5fb72a>)Â dev, [CUmemoryPool](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g3b96b1ef79f0cb312b51169e9f50e722>)Â pool )


Sets the current memory pool of a device.

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>)

###### Description

The memory pool must be local to the specified device. [cuMemAllocAsync](<group__CUDA__MALLOC__ASYNC.html#group__CUDA__MALLOC__ASYNC_1g13413273e84a641bce1929eae9e6501f> "Allocates memory with stream ordered semantics.") allocates from the current mempool of the provided stream's device. By default, a device's current memory pool is its default memory pool.

Note:

Use [cuMemAllocFromPoolAsync](<group__CUDA__MALLOC__ASYNC.html#group__CUDA__MALLOC__ASYNC_1gf1dd6e1e2e8f767a5e0ea63f38ff260b> "Allocates memory from a specified pool with stream ordered semantics.") to specify asynchronous allocations from a device different than the one the stream runs on.

**See also:**

[cuDeviceGetDefaultMemPool](<group__CUDA__DEVICE.html#group__CUDA__DEVICE_1gc8bca3c97a78816303b8aa5773b741f2> "Returns the default mempool of a device."), [cuDeviceGetMemPool](<group__CUDA__DEVICE.html#group__CUDA__DEVICE_1gdf186e9559d53a5eb18e572d48c1121b> "Gets the current mempool for a device."), [cuMemPoolCreate](<group__CUDA__MALLOC__ASYNC.html#group__CUDA__MALLOC__ASYNC_1g8aa4c143dbc20293659cd883232b95f2> "Creates a memory pool."), [cuMemPoolDestroy](<group__CUDA__MALLOC__ASYNC.html#group__CUDA__MALLOC__ASYNC_1ge0e211115e5ad1c79250b9dd425b77f7> "Destroys the specified memory pool."), [cuMemAllocFromPoolAsync](<group__CUDA__MALLOC__ASYNC.html#group__CUDA__MALLOC__ASYNC_1gf1dd6e1e2e8f767a5e0ea63f38ff260b> "Allocates memory from a specified pool with stream ordered semantics.")

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuDeviceTotalMem ( size_t*Â bytes, [CUdevice](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g41ca2a24a242b36ef2ca77330b5fb72a>)Â dev )


Returns the total amount of memory on the device.

######  Parameters

`bytes`
    \- Returned memory available on device in bytes
`dev`
    \- Device handle

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_DEINITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9acf52f132faf29b473cdda6061f0f44a>), [CUDA_ERROR_NOT_INITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e98feb999f0af99b4a25ab26b3866f4df8>), [CUDA_ERROR_INVALID_CONTEXT](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a484e9af32c1e9893ff21f0e0191a12d>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>), [CUDA_ERROR_INVALID_DEVICE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e96f047e7215788ca96c81af92a04bfb6c>)

###### Description

Returns in `*bytes` the total amount of memory available on the device `dev` in bytes.

Note:

Note that this function may also return error codes from previous, asynchronous launches.

**See also:**

[cuDeviceGetAttribute](<group__CUDA__DEVICE.html#group__CUDA__DEVICE_1g9c3e1414f0ad901d3278a4d6645fc266> "Returns information about the device."), [cuDeviceGetCount](<group__CUDA__DEVICE.html#group__CUDA__DEVICE_1g52b5ce05cb8c5fb6831b2c0ff2887c74> "Returns the number of compute-capable devices."), [cuDeviceGetName](<group__CUDA__DEVICE.html#group__CUDA__DEVICE_1gef75aa30df95446a845f2a7b9fffbb7f> "Returns an identifier string for the device."), [cuDeviceGetUuid](<group__CUDA__DEVICE.html#group__CUDA__DEVICE_1g987b46b884c101ed5be414ab4d9e60e4> "Return an UUID for the device."), [cuDeviceGet](<group__CUDA__DEVICE.html#group__CUDA__DEVICE_1g8bdd1cc7201304b01357b8034f6587cb> "Returns a handle to a compute device."), [cuDeviceGetExecAffinitySupport](<group__CUDA__DEVICE.html#group__CUDA__DEVICE_1g7f0091850e0841f367f13d623456427d> "Returns information about the execution affinity support of the device."), [cudaMemGetInfo](<../cuda-runtime-api/group__CUDART__MEMORY.html#group__CUDART__MEMORY_1g376b97f5ab20321ca46f7cfa9511b978>)

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuFlushGPUDirectRDMAWrites ( [CUflushGPUDirectRDMAWritesTarget](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g01251451232c43bc5c7cb067ed2c28ef>)Â target, [CUflushGPUDirectRDMAWritesScope](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g9eafc4def87e0f6600f905e756ec99d1>)Â scope )


Blocks until remote writes are visible to the specified scope.

######  Parameters

`target`
    \- The target of the operation, see [CUflushGPUDirectRDMAWritesTarget](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g01251451232c43bc5c7cb067ed2c28ef>)
`scope`
    \- The scope of the operation, see [CUflushGPUDirectRDMAWritesScope](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g9eafc4def87e0f6600f905e756ec99d1>)

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_DEINITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9acf52f132faf29b473cdda6061f0f44a>), [CUDA_ERROR_NOT_INITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e98feb999f0af99b4a25ab26b3866f4df8>), [CUDA_ERROR_INVALID_CONTEXT](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a484e9af32c1e9893ff21f0e0191a12d>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>),

###### Description

Blocks until GPUDirect RDMA writes to the target context via mappings created through APIs like nvidia_p2p_get_pages (see <https://docs.nvidia.com/cuda/gpudirect-rdma> for more information), are visible to the specified scope.

If the scope equals or lies within the scope indicated by [CU_DEVICE_ATTRIBUTE_GPU_DIRECT_RDMA_WRITES_ORDERING](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gge12b8a782bebe21b1ac0091bf9f4e2a3dfb3df2c0e9347a7c13f71043e961c50>), the call will be a no-op and can be safely omitted for performance. This can be determined by comparing the numerical values between the two enums, with smaller scopes having smaller values.

On platforms that support GPUDirect RDMA writes via more than one path in hardware (see [CU_MEM_RANGE_FLAG_DMA_BUF_MAPPING_TYPE_PCIE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg75c53565b19e5c434edc5a65a6a7ab20ff810d1182d50bd1385eb543478b99f5>)), the user should consider those paths as belonging to separate ordering domains. Note that in such cases CUDA driver will report both RDMA writes ordering and RDMA write scope as ALL_DEVICES and a call to cuFlushGPUDirectRDMA will be a no-op, but when these multiple paths are used simultaneously, it is the user's responsibility to ensure ordering by using mechanisms outside the scope of CUDA.

Users may query support for this API via CU_DEVICE_ATTRIBUTE_FLUSH_FLUSH_GPU_DIRECT_RDMA_OPTIONS.

Note:

Note that this function may also return error codes from previous, asynchronous launches.

* * *


---

# Device Management (Deprecated)

## 6.6.Â Device Management [DEPRECATED]

This section describes the device management functions of the low-level CUDA driver application programming interface.

### Functions

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuDeviceComputeCapability](<#group__CUDA__DEVICE__DEPRECATED_1gdc50ce6a6e0a593158d4ccb3567e0545>) ( int*Â major, int*Â minor, [CUdevice](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g41ca2a24a242b36ef2ca77330b5fb72a>)Â dev )
     Returns the compute capability of the device.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuDeviceGetProperties](<#group__CUDA__DEVICE__DEPRECATED_1ged20a6d946d0217b3b1e0a40df6a43a6>) ( [CUdevprop](<structCUdevprop__v1.html#structCUdevprop__v1>)*Â prop, [CUdevice](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g41ca2a24a242b36ef2ca77330b5fb72a>)Â dev )
     Returns properties for a selected device.

### Functions

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuDeviceComputeCapability ( int*Â major, int*Â minor, [CUdevice](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g41ca2a24a242b36ef2ca77330b5fb72a>)Â dev )


Returns the compute capability of the device.

######  Parameters

`major`
    \- Major revision number
`minor`
    \- Minor revision number
`dev`
    \- Device handle

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_DEINITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9acf52f132faf29b473cdda6061f0f44a>), [CUDA_ERROR_NOT_INITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e98feb999f0af99b4a25ab26b3866f4df8>), [CUDA_ERROR_INVALID_CONTEXT](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a484e9af32c1e9893ff21f0e0191a12d>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>), [CUDA_ERROR_INVALID_DEVICE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e96f047e7215788ca96c81af92a04bfb6c>)

###### [Deprecated](<deprecated.html#deprecated__deprecated_1_deprecated000003>)

This function was deprecated as of CUDA 5.0 and its functionality superseded by [cuDeviceGetAttribute()](<group__CUDA__DEVICE.html#group__CUDA__DEVICE_1g9c3e1414f0ad901d3278a4d6645fc266> "Returns information about the device.").

###### Description

Returns in `*major` and `*minor` the major and minor revision numbers that define the compute capability of the device `dev`.

Note:

Note that this function may also return error codes from previous, asynchronous launches.

**See also:**

[cuDeviceGetAttribute](<group__CUDA__DEVICE.html#group__CUDA__DEVICE_1g9c3e1414f0ad901d3278a4d6645fc266> "Returns information about the device."), [cuDeviceGetCount](<group__CUDA__DEVICE.html#group__CUDA__DEVICE_1g52b5ce05cb8c5fb6831b2c0ff2887c74> "Returns the number of compute-capable devices."), [cuDeviceGetName](<group__CUDA__DEVICE.html#group__CUDA__DEVICE_1gef75aa30df95446a845f2a7b9fffbb7f> "Returns an identifier string for the device."), [cuDeviceGetUuid](<group__CUDA__DEVICE.html#group__CUDA__DEVICE_1g987b46b884c101ed5be414ab4d9e60e4> "Return an UUID for the device."), [cuDeviceGet](<group__CUDA__DEVICE.html#group__CUDA__DEVICE_1g8bdd1cc7201304b01357b8034f6587cb> "Returns a handle to a compute device."), [cuDeviceTotalMem](<group__CUDA__DEVICE.html#group__CUDA__DEVICE_1gc6a0d6551335a3780f9f3c967a0fde5d> "Returns the total amount of memory on the device.")

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuDeviceGetProperties ( [CUdevprop](<structCUdevprop__v1.html#structCUdevprop__v1>)*Â prop, [CUdevice](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g41ca2a24a242b36ef2ca77330b5fb72a>)Â dev )


Returns properties for a selected device.

######  Parameters

`prop`
    \- Returned properties of device
`dev`
    \- Device to get properties for

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_DEINITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9acf52f132faf29b473cdda6061f0f44a>), [CUDA_ERROR_NOT_INITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e98feb999f0af99b4a25ab26b3866f4df8>), [CUDA_ERROR_INVALID_CONTEXT](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a484e9af32c1e9893ff21f0e0191a12d>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>), [CUDA_ERROR_INVALID_DEVICE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e96f047e7215788ca96c81af92a04bfb6c>)

###### [Deprecated](<deprecated.html#deprecated__deprecated_1_deprecated000002>)

This function was deprecated as of CUDA 5.0 and replaced by [cuDeviceGetAttribute()](<group__CUDA__DEVICE.html#group__CUDA__DEVICE_1g9c3e1414f0ad901d3278a4d6645fc266> "Returns information about the device.").

###### Description

Returns in `*prop` the properties of device `dev`. The CUdevprop structure is defined as:


    â     typedef struct CUdevprop_st {
               int maxThreadsPerBlock;
               int maxThreadsDim[3];
               int maxGridSize[3];
               int sharedMemPerBlock;
               int totalConstantMemory;
               int SIMDWidth;
               int memPitch;
               int regsPerBlock;
               int clockRate;
               int textureAlign
            } [CUdevprop](<structCUdevprop__v1.html#structCUdevprop__v1>);

where:

  * maxThreadsPerBlock is the maximum number of threads per block;

  * maxThreadsDim[3] is the maximum sizes of each dimension of a block;

  * maxGridSize[3] is the maximum sizes of each dimension of a grid;

  * sharedMemPerBlock is the total amount of shared memory available per block in bytes;

  * totalConstantMemory is the total amount of constant memory available on the device in bytes;

  * SIMDWidth is the warp size;

  * memPitch is the maximum pitch allowed by the memory copy functions that involve memory regions allocated through [cuMemAllocPitch()](<group__CUDA__MEM.html#group__CUDA__MEM_1gcbe9b033f6c4de80f63cc6e58ed9a45a> "Allocates pitched device memory.");

  * regsPerBlock is the total number of registers available per block;

  * clockRate is the clock frequency in kilohertz;

  * textureAlign is the alignment requirement; texture base addresses that are aligned to textureAlign bytes do not need an offset applied to texture fetches.


Note:

Note that this function may also return error codes from previous, asynchronous launches.

**See also:**

[cuDeviceGetAttribute](<group__CUDA__DEVICE.html#group__CUDA__DEVICE_1g9c3e1414f0ad901d3278a4d6645fc266> "Returns information about the device."), [cuDeviceGetCount](<group__CUDA__DEVICE.html#group__CUDA__DEVICE_1g52b5ce05cb8c5fb6831b2c0ff2887c74> "Returns the number of compute-capable devices."), [cuDeviceGetName](<group__CUDA__DEVICE.html#group__CUDA__DEVICE_1gef75aa30df95446a845f2a7b9fffbb7f> "Returns an identifier string for the device."), [cuDeviceGetUuid](<group__CUDA__DEVICE.html#group__CUDA__DEVICE_1g987b46b884c101ed5be414ab4d9e60e4> "Return an UUID for the device."), [cuDeviceGet](<group__CUDA__DEVICE.html#group__CUDA__DEVICE_1g8bdd1cc7201304b01357b8034f6587cb> "Returns a handle to a compute device."), [cuDeviceTotalMem](<group__CUDA__DEVICE.html#group__CUDA__DEVICE_1gc6a0d6551335a3780f9f3c967a0fde5d> "Returns the total amount of memory on the device.")

* * *


---

# Primary Context Management

## 6.7.Â Primary Context Management

This section describes the primary context management functions of the low-level CUDA driver application programming interface.

The primary context is unique per device and shared with the CUDA runtime API. These functions allow integration with other libraries using CUDA.

### Functions

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuDevicePrimaryCtxGetState](<#group__CUDA__PRIMARY__CTX_1g65f3e018721b6d90aa05cfb56250f469>) ( [CUdevice](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g41ca2a24a242b36ef2ca77330b5fb72a>)Â dev, unsigned int*Â flags, int*Â active )
     Get the state of the primary context.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuDevicePrimaryCtxRelease](<#group__CUDA__PRIMARY__CTX_1gf2a8bc16f8df0c88031f6a1ba3d6e8ad>) ( [CUdevice](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g41ca2a24a242b36ef2ca77330b5fb72a>)Â dev )
     Release the primary context on the GPU.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuDevicePrimaryCtxReset](<#group__CUDA__PRIMARY__CTX_1g5d38802e8600340283958a117466ce12>) ( [CUdevice](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g41ca2a24a242b36ef2ca77330b5fb72a>)Â dev )
     Destroy all allocations and reset all state on the primary context.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuDevicePrimaryCtxRetain](<#group__CUDA__PRIMARY__CTX_1g9051f2d5c31501997a6cb0530290a300>) ( [CUcontext](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gf9f5bd81658f866613785b3a0bb7d7d9>)*Â pctx, [CUdevice](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g41ca2a24a242b36ef2ca77330b5fb72a>)Â dev )
     Retain the primary context on the GPU.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuDevicePrimaryCtxSetFlags](<#group__CUDA__PRIMARY__CTX_1gd779a84f17acdad0d9143d9fe719cfdf>) ( [CUdevice](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g41ca2a24a242b36ef2ca77330b5fb72a>)Â dev, unsigned int Â flags )
     Set flags for the primary context.

### Functions

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuDevicePrimaryCtxGetState ( [CUdevice](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g41ca2a24a242b36ef2ca77330b5fb72a>)Â dev, unsigned int*Â flags, int*Â active )


Get the state of the primary context.

######  Parameters

`dev`
    \- Device to get primary context flags for
`flags`
    \- Pointer to store flags
`active`
    \- Pointer to store context state; 0 = inactive, 1 = active

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_DEINITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9acf52f132faf29b473cdda6061f0f44a>), [CUDA_ERROR_NOT_INITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e98feb999f0af99b4a25ab26b3866f4df8>), [CUDA_ERROR_INVALID_DEVICE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e96f047e7215788ca96c81af92a04bfb6c>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>),

###### Description

Returns in `*flags` the flags for the primary context of `dev`, and in `*active` whether it is active. See [cuDevicePrimaryCtxSetFlags](<group__CUDA__PRIMARY__CTX.html#group__CUDA__PRIMARY__CTX_1gd779a84f17acdad0d9143d9fe719cfdf> "Set flags for the primary context.") for flag values.

Note:

Note that this function may also return error codes from previous, asynchronous launches.

**See also:**

[cuDevicePrimaryCtxSetFlags](<group__CUDA__PRIMARY__CTX.html#group__CUDA__PRIMARY__CTX_1gd779a84f17acdad0d9143d9fe719cfdf> "Set flags for the primary context."), [cuCtxGetFlags](<group__CUDA__CTX.html#group__CUDA__CTX_1gf81eef983c1e3b2ef4f166d7a930c86d> "Returns the flags for the current context."), [cuCtxSetFlags](<group__CUDA__CTX.html#group__CUDA__CTX_1g66655c37602c8628eae3e40c82619f1e> "Sets the flags for the current context."), [cudaGetDeviceFlags](<../cuda-runtime-api/group__CUDART__DEVICE.html#group__CUDART__DEVICE_1gf830794caf068b71638c6182bba8f77a>)

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuDevicePrimaryCtxRelease ( [CUdevice](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g41ca2a24a242b36ef2ca77330b5fb72a>)Â dev )


Release the primary context on the GPU.

######  Parameters

`dev`
    \- Device which primary context is released

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_DEINITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9acf52f132faf29b473cdda6061f0f44a>), [CUDA_ERROR_NOT_INITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e98feb999f0af99b4a25ab26b3866f4df8>), [CUDA_ERROR_INVALID_DEVICE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e96f047e7215788ca96c81af92a04bfb6c>), [CUDA_ERROR_INVALID_CONTEXT](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a484e9af32c1e9893ff21f0e0191a12d>)

###### Description

Releases the primary context interop on the device. A retained context should always be released once the user is done using it. The context is automatically reset once the last reference to it is released. This behavior is different when the primary context was retained by the CUDA runtime from CUDA 4.0 and earlier. In this case, the primary context remains always active.

Releasing a primary context that has not been previously retained will fail with [CUDA_ERROR_INVALID_CONTEXT](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a484e9af32c1e9893ff21f0e0191a12d>).

Please note that unlike [cuCtxDestroy()](<group__CUDA__CTX.html#group__CUDA__CTX_1g27a365aebb0eb548166309f58a1e8b8e> "Destroy a CUDA context.") this method does not pop the context from stack in any circumstances.

Note:

Note that this function may also return error codes from previous, asynchronous launches.

**See also:**

[cuDevicePrimaryCtxRetain](<group__CUDA__PRIMARY__CTX.html#group__CUDA__PRIMARY__CTX_1g9051f2d5c31501997a6cb0530290a300> "Retain the primary context on the GPU."), [cuCtxDestroy](<group__CUDA__CTX.html#group__CUDA__CTX_1g27a365aebb0eb548166309f58a1e8b8e> "Destroy a CUDA context."), [cuCtxGetApiVersion](<group__CUDA__CTX.html#group__CUDA__CTX_1g088a90490dafca5893ef6fbebc8de8fb> "Gets the context's API version."), [cuCtxGetCacheConfig](<group__CUDA__CTX.html#group__CUDA__CTX_1g40b6b141698f76744dea6e39b9a25360> "Returns the preferred cache configuration for the current context."), [cuCtxGetDevice](<group__CUDA__CTX.html#group__CUDA__CTX_1g4e84b109eba36cdaaade167f34ae881e> "Returns the device handle for the current context."), [cuCtxGetFlags](<group__CUDA__CTX.html#group__CUDA__CTX_1gf81eef983c1e3b2ef4f166d7a930c86d> "Returns the flags for the current context."), [cuCtxGetLimit](<group__CUDA__CTX.html#group__CUDA__CTX_1g9f2d47d1745752aa16da7ed0d111b6a8> "Returns resource limits."), [cuCtxPopCurrent](<group__CUDA__CTX.html#group__CUDA__CTX_1g2fac188026a062d92e91a8687d0a7902> "Pops the current CUDA context from the current CPU thread."), [cuCtxPushCurrent](<group__CUDA__CTX.html#group__CUDA__CTX_1gb02d4c850eb16f861fe5a29682cc90ba> "Pushes a context on the current CPU thread."), [cuCtxSetCacheConfig](<group__CUDA__CTX.html#group__CUDA__CTX_1g54699acf7e2ef27279d013ca2095f4a3> "Sets the preferred cache configuration for the current context."), [cuCtxSetLimit](<group__CUDA__CTX.html#group__CUDA__CTX_1g0651954dfb9788173e60a9af7201e65a> "Set resource limits."), [cuCtxSynchronize](<group__CUDA__CTX.html#group__CUDA__CTX_1g7a54725f28d34b8c6299f0c6ca579616> "Block for the current context's tasks to complete.")

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuDevicePrimaryCtxReset ( [CUdevice](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g41ca2a24a242b36ef2ca77330b5fb72a>)Â dev )


Destroy all allocations and reset all state on the primary context.

######  Parameters

`dev`
    \- Device for which primary context is destroyed

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_DEINITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9acf52f132faf29b473cdda6061f0f44a>), [CUDA_ERROR_NOT_INITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e98feb999f0af99b4a25ab26b3866f4df8>), [CUDA_ERROR_INVALID_DEVICE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e96f047e7215788ca96c81af92a04bfb6c>), [CUDA_ERROR_PRIMARY_CONTEXT_ACTIVE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e90d74711f16f63a410d8d94d02e1f5480>)

###### Description

Explicitly destroys and cleans up all resources associated with the current device in the current process.

Note that it is responsibility of the calling function to ensure that no other module in the process is using the device any more. For that reason it is recommended to use [cuDevicePrimaryCtxRelease()](<group__CUDA__PRIMARY__CTX.html#group__CUDA__PRIMARY__CTX_1gf2a8bc16f8df0c88031f6a1ba3d6e8ad> "Release the primary context on the GPU.") in most cases. However it is safe for other modules to call [cuDevicePrimaryCtxRelease()](<group__CUDA__PRIMARY__CTX.html#group__CUDA__PRIMARY__CTX_1gf2a8bc16f8df0c88031f6a1ba3d6e8ad> "Release the primary context on the GPU.") even after resetting the device. Resetting the primary context does not release it, an application that has retained the primary context should explicitly release its usage.

Note:

Note that this function may also return error codes from previous, asynchronous launches.

**See also:**

[cuDevicePrimaryCtxRetain](<group__CUDA__PRIMARY__CTX.html#group__CUDA__PRIMARY__CTX_1g9051f2d5c31501997a6cb0530290a300> "Retain the primary context on the GPU."), [cuDevicePrimaryCtxRelease](<group__CUDA__PRIMARY__CTX.html#group__CUDA__PRIMARY__CTX_1gf2a8bc16f8df0c88031f6a1ba3d6e8ad> "Release the primary context on the GPU."), [cuCtxGetApiVersion](<group__CUDA__CTX.html#group__CUDA__CTX_1g088a90490dafca5893ef6fbebc8de8fb> "Gets the context's API version."), [cuCtxGetCacheConfig](<group__CUDA__CTX.html#group__CUDA__CTX_1g40b6b141698f76744dea6e39b9a25360> "Returns the preferred cache configuration for the current context."), [cuCtxGetDevice](<group__CUDA__CTX.html#group__CUDA__CTX_1g4e84b109eba36cdaaade167f34ae881e> "Returns the device handle for the current context."), [cuCtxGetFlags](<group__CUDA__CTX.html#group__CUDA__CTX_1gf81eef983c1e3b2ef4f166d7a930c86d> "Returns the flags for the current context."), [cuCtxGetLimit](<group__CUDA__CTX.html#group__CUDA__CTX_1g9f2d47d1745752aa16da7ed0d111b6a8> "Returns resource limits."), [cuCtxPopCurrent](<group__CUDA__CTX.html#group__CUDA__CTX_1g2fac188026a062d92e91a8687d0a7902> "Pops the current CUDA context from the current CPU thread."), [cuCtxPushCurrent](<group__CUDA__CTX.html#group__CUDA__CTX_1gb02d4c850eb16f861fe5a29682cc90ba> "Pushes a context on the current CPU thread."), [cuCtxSetCacheConfig](<group__CUDA__CTX.html#group__CUDA__CTX_1g54699acf7e2ef27279d013ca2095f4a3> "Sets the preferred cache configuration for the current context."), [cuCtxSetLimit](<group__CUDA__CTX.html#group__CUDA__CTX_1g0651954dfb9788173e60a9af7201e65a> "Set resource limits."), [cuCtxSynchronize](<group__CUDA__CTX.html#group__CUDA__CTX_1g7a54725f28d34b8c6299f0c6ca579616> "Block for the current context's tasks to complete."), [cudaDeviceReset](<../cuda-runtime-api/group__CUDART__DEVICE.html#group__CUDART__DEVICE_1gef69dd5c6d0206c2b8d099abac61f217>)

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuDevicePrimaryCtxRetain ( [CUcontext](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gf9f5bd81658f866613785b3a0bb7d7d9>)*Â pctx, [CUdevice](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g41ca2a24a242b36ef2ca77330b5fb72a>)Â dev )


Retain the primary context on the GPU.

######  Parameters

`pctx`
    \- Returned context handle of the new context
`dev`
    \- Device for which primary context is requested

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_DEINITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9acf52f132faf29b473cdda6061f0f44a>), [CUDA_ERROR_NOT_INITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e98feb999f0af99b4a25ab26b3866f4df8>), [CUDA_ERROR_INVALID_CONTEXT](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a484e9af32c1e9893ff21f0e0191a12d>), [CUDA_ERROR_INVALID_DEVICE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e96f047e7215788ca96c81af92a04bfb6c>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>), [CUDA_ERROR_OUT_OF_MEMORY](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9264c50688ed110e8476b591befe60c02>), [CUDA_ERROR_UNKNOWN](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9c5a6ab0245179d297f1fa56ed0097183>)

###### Description

Retains the primary context on the device. Once the user successfully retains the primary context, the primary context will be active and available to the user until the user releases it with [cuDevicePrimaryCtxRelease()](<group__CUDA__PRIMARY__CTX.html#group__CUDA__PRIMARY__CTX_1gf2a8bc16f8df0c88031f6a1ba3d6e8ad> "Release the primary context on the GPU.") or resets it with [cuDevicePrimaryCtxReset()](<group__CUDA__PRIMARY__CTX.html#group__CUDA__PRIMARY__CTX_1g5d38802e8600340283958a117466ce12> "Destroy all allocations and reset all state on the primary context."). Unlike [cuCtxCreate()](<group__CUDA__CTX.html#group__CUDA__CTX_1g77e9fb578caefca5ed15b4acebf35265> "Create a CUDA context.") the newly retained context is not pushed onto the stack.

Retaining the primary context for the first time will fail with [CUDA_ERROR_UNKNOWN](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9c5a6ab0245179d297f1fa56ed0097183>) if the compute mode of the device is [CU_COMPUTEMODE_PROHIBITED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg637aab2eadb52e1c1c048b8bad9592d1db8a226241187db3b1f41999bb70eb47>). The function [cuDeviceGetAttribute()](<group__CUDA__DEVICE.html#group__CUDA__DEVICE_1g9c3e1414f0ad901d3278a4d6645fc266> "Returns information about the device.") can be used with [CU_DEVICE_ATTRIBUTE_COMPUTE_MODE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gge12b8a782bebe21b1ac0091bf9f4e2a3f6669a29a6d42968047747cbfc501289>) to determine the compute mode of the device. The nvidia-smi tool can be used to set the compute mode for devices. Documentation for nvidia-smi can be obtained by passing a -h option to it.

Please note that the primary context always supports pinned allocations. Other flags can be specified by [cuDevicePrimaryCtxSetFlags()](<group__CUDA__PRIMARY__CTX.html#group__CUDA__PRIMARY__CTX_1gd779a84f17acdad0d9143d9fe719cfdf> "Set flags for the primary context.").

Note:

Note that this function may also return error codes from previous, asynchronous launches.

**See also:**

[cuDevicePrimaryCtxRelease](<group__CUDA__PRIMARY__CTX.html#group__CUDA__PRIMARY__CTX_1gf2a8bc16f8df0c88031f6a1ba3d6e8ad> "Release the primary context on the GPU."), [cuDevicePrimaryCtxSetFlags](<group__CUDA__PRIMARY__CTX.html#group__CUDA__PRIMARY__CTX_1gd779a84f17acdad0d9143d9fe719cfdf> "Set flags for the primary context."), [cuCtxCreate](<group__CUDA__CTX.html#group__CUDA__CTX_1g77e9fb578caefca5ed15b4acebf35265> "Create a CUDA context."), [cuCtxGetApiVersion](<group__CUDA__CTX.html#group__CUDA__CTX_1g088a90490dafca5893ef6fbebc8de8fb> "Gets the context's API version."), [cuCtxGetCacheConfig](<group__CUDA__CTX.html#group__CUDA__CTX_1g40b6b141698f76744dea6e39b9a25360> "Returns the preferred cache configuration for the current context."), [cuCtxGetDevice](<group__CUDA__CTX.html#group__CUDA__CTX_1g4e84b109eba36cdaaade167f34ae881e> "Returns the device handle for the current context."), [cuCtxGetFlags](<group__CUDA__CTX.html#group__CUDA__CTX_1gf81eef983c1e3b2ef4f166d7a930c86d> "Returns the flags for the current context."), [cuCtxGetLimit](<group__CUDA__CTX.html#group__CUDA__CTX_1g9f2d47d1745752aa16da7ed0d111b6a8> "Returns resource limits."), [cuCtxPopCurrent](<group__CUDA__CTX.html#group__CUDA__CTX_1g2fac188026a062d92e91a8687d0a7902> "Pops the current CUDA context from the current CPU thread."), [cuCtxPushCurrent](<group__CUDA__CTX.html#group__CUDA__CTX_1gb02d4c850eb16f861fe5a29682cc90ba> "Pushes a context on the current CPU thread."), [cuCtxSetCacheConfig](<group__CUDA__CTX.html#group__CUDA__CTX_1g54699acf7e2ef27279d013ca2095f4a3> "Sets the preferred cache configuration for the current context."), [cuCtxSetLimit](<group__CUDA__CTX.html#group__CUDA__CTX_1g0651954dfb9788173e60a9af7201e65a> "Set resource limits."), [cuCtxSynchronize](<group__CUDA__CTX.html#group__CUDA__CTX_1g7a54725f28d34b8c6299f0c6ca579616> "Block for the current context's tasks to complete.")

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuDevicePrimaryCtxSetFlags ( [CUdevice](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g41ca2a24a242b36ef2ca77330b5fb72a>)Â dev, unsigned int Â flags )


Set flags for the primary context.

######  Parameters

`dev`
    \- Device for which the primary context flags are set
`flags`
    \- New flags for the device

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_DEINITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9acf52f132faf29b473cdda6061f0f44a>), [CUDA_ERROR_NOT_INITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e98feb999f0af99b4a25ab26b3866f4df8>), [CUDA_ERROR_INVALID_DEVICE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e96f047e7215788ca96c81af92a04bfb6c>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>),

###### Description

Sets the flags for the primary context on the device overwriting perviously set ones.

The three LSBs of the `flags` parameter can be used to control how the OS thread, which owns the CUDA context at the time of an API call, interacts with the OS scheduler when waiting for results from the GPU. Only one of the scheduling flags can be set when creating a context.

  * [CU_CTX_SCHED_SPIN](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg9f889e28a45a295b5c8ce13aa05f6cd4331d3ed1e0b55597258bd58346603afc>): Instruct CUDA to actively spin when waiting for results from the GPU. This can decrease latency when waiting for the GPU, but may lower the performance of CPU threads if they are performing work in parallel with the CUDA thread.


  * [CU_CTX_SCHED_YIELD](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg9f889e28a45a295b5c8ce13aa05f6cd44bc43364906d8dd5a7d7c8ad46ccc548>): Instruct CUDA to yield its thread when waiting for results from the GPU. This can increase latency when waiting for the GPU, but can increase the performance of CPU threads performing work in parallel with the GPU.


  * [CU_CTX_SCHED_BLOCKING_SYNC](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg9f889e28a45a295b5c8ce13aa05f6cd462aebfe6432ade3feb32f1a409027852>): Instruct CUDA to block the CPU thread on a synchronization primitive when waiting for the GPU to finish work.


  * [CU_CTX_BLOCKING_SYNC](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg9f889e28a45a295b5c8ce13aa05f6cd4b5bf395cc60a8cbded4c329ae9430b91>): Instruct CUDA to block the CPU thread on a synchronization primitive when waiting for the GPU to finish work.

**Deprecated:** This flag was deprecated as of CUDA 4.0 and was replaced with [CU_CTX_SCHED_BLOCKING_SYNC](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg9f889e28a45a295b5c8ce13aa05f6cd462aebfe6432ade3feb32f1a409027852>).


  * [CU_CTX_SCHED_AUTO](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg9f889e28a45a295b5c8ce13aa05f6cd4d75f4c24f8c35ef2ee9d0793badfd88c>): The default value if the `flags` parameter is zero, uses a heuristic based on the number of active CUDA contexts in the process C and the number of logical processors in the system P. If C > P, then CUDA will yield to other OS threads when waiting for the GPU ([CU_CTX_SCHED_YIELD](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg9f889e28a45a295b5c8ce13aa05f6cd44bc43364906d8dd5a7d7c8ad46ccc548>)), otherwise CUDA will not yield while waiting for results and actively spin on the processor ([CU_CTX_SCHED_SPIN](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg9f889e28a45a295b5c8ce13aa05f6cd4331d3ed1e0b55597258bd58346603afc>)). Additionally, on Tegra devices, [CU_CTX_SCHED_AUTO](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg9f889e28a45a295b5c8ce13aa05f6cd4d75f4c24f8c35ef2ee9d0793badfd88c>) uses a heuristic based on the power profile of the platform and may choose [CU_CTX_SCHED_BLOCKING_SYNC](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg9f889e28a45a295b5c8ce13aa05f6cd462aebfe6432ade3feb32f1a409027852>) for low-powered devices.


  * [CU_CTX_LMEM_RESIZE_TO_MAX](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg9f889e28a45a295b5c8ce13aa05f6cd4b5a83507c2a7e14d301621c40c343a81>): Instruct CUDA to not reduce local memory after resizing local memory for a kernel. This can prevent thrashing by local memory allocations when launching many kernels with high local memory usage at the cost of potentially increased memory usage.

**Deprecated:** This flag is deprecated and the behavior enabled by this flag is now the default and cannot be disabled.


  * [CU_CTX_COREDUMP_ENABLE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg9f889e28a45a295b5c8ce13aa05f6cd44c74aa37941a780fccfbc2aa23e97809>): If GPU coredumps have not been enabled globally with [cuCoredumpSetAttributeGlobal](<group__CUDA__COREDUMP.html#group__CUDA__COREDUMP_1ga7645a8f68dd5379a03852b462727990> "Allows caller to set a coredump attribute value globally.") or environment variables, this flag can be set during context creation to instruct CUDA to create a coredump if this context raises an exception during execution. These environment variables are described in the CUDA-GDB user guide under the "GPU core dump support" section. The initial settings will be taken from the global settings at the time of context creation. The other settings that control coredump output can be modified by calling [cuCoredumpSetAttribute](<group__CUDA__COREDUMP.html#group__CUDA__COREDUMP_1g45b806050f3211e840eb3c8d91e93fcb> "Allows caller to set a coredump attribute value for the current context.") from the created context after it becomes current.


  * [CU_CTX_USER_COREDUMP_ENABLE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg9f889e28a45a295b5c8ce13aa05f6cd40703ba07a50ffbd294cb1122e08370d5>): If user-triggered GPU coredumps have not been enabled globally with [cuCoredumpSetAttributeGlobal](<group__CUDA__COREDUMP.html#group__CUDA__COREDUMP_1ga7645a8f68dd5379a03852b462727990> "Allows caller to set a coredump attribute value globally.") or environment variables, this flag can be set during context creation to instruct CUDA to create a coredump if data is written to a certain pipe that is present in the OS space. These environment variables are described in the CUDA-GDB user guide under the "GPU core dump support" section. It is important to note that the pipe name *must* be set with [cuCoredumpSetAttributeGlobal](<group__CUDA__COREDUMP.html#group__CUDA__COREDUMP_1ga7645a8f68dd5379a03852b462727990> "Allows caller to set a coredump attribute value globally.") before creating the context if this flag is used. Setting this flag implies that [CU_CTX_COREDUMP_ENABLE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg9f889e28a45a295b5c8ce13aa05f6cd44c74aa37941a780fccfbc2aa23e97809>) is set. The initial settings will be taken from the global settings at the time of context creation. The other settings that control coredump output can be modified by calling [cuCoredumpSetAttribute](<group__CUDA__COREDUMP.html#group__CUDA__COREDUMP_1g45b806050f3211e840eb3c8d91e93fcb> "Allows caller to set a coredump attribute value for the current context.") from the created context after it becomes current.


  * [CU_CTX_SYNC_MEMOPS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg9f889e28a45a295b5c8ce13aa05f6cd4e93e3bda3a8e71fe8f4d0de36aa881f0>): Ensures that synchronous memory operations initiated on this context will always synchronize. See further documentation in the section titled "API Synchronization behavior" to learn more about cases when synchronous memory operations can exhibit asynchronous behavior.


Note:

Note that this function may also return error codes from previous, asynchronous launches.

**See also:**

[cuDevicePrimaryCtxRetain](<group__CUDA__PRIMARY__CTX.html#group__CUDA__PRIMARY__CTX_1g9051f2d5c31501997a6cb0530290a300> "Retain the primary context on the GPU."), [cuDevicePrimaryCtxGetState](<group__CUDA__PRIMARY__CTX.html#group__CUDA__PRIMARY__CTX_1g65f3e018721b6d90aa05cfb56250f469> "Get the state of the primary context."), [cuCtxCreate](<group__CUDA__CTX.html#group__CUDA__CTX_1g77e9fb578caefca5ed15b4acebf35265> "Create a CUDA context."), [cuCtxGetFlags](<group__CUDA__CTX.html#group__CUDA__CTX_1gf81eef983c1e3b2ef4f166d7a930c86d> "Returns the flags for the current context."), [cuCtxSetFlags](<group__CUDA__CTX.html#group__CUDA__CTX_1g66655c37602c8628eae3e40c82619f1e> "Sets the flags for the current context."), [cudaSetDeviceFlags](<../cuda-runtime-api/group__CUDART__DEVICE.html#group__CUDART__DEVICE_1g69e73c7dda3fc05306ae7c811a690fac>)

* * *


---

# Context Management

## 6.8.Â Context Management

This section describes the context management functions of the low-level CUDA driver application programming interface.

Please note that some functions are described in [Primary Context Management](<group__CUDA__PRIMARY__CTX.html#group__CUDA__PRIMARY__CTX>) section.

### Functions

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuCtxCreate](<#group__CUDA__CTX_1g77e9fb578caefca5ed15b4acebf35265>) ( [CUcontext](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gf9f5bd81658f866613785b3a0bb7d7d9>)*Â pctx, [CUctxCreateParams](<structCUctxCreateParams.html#structCUctxCreateParams>)*Â ctxCreateParams, unsigned int Â flags, [CUdevice](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g41ca2a24a242b36ef2ca77330b5fb72a>)Â dev )
     Create a CUDA context.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuCtxDestroy](<#group__CUDA__CTX_1g27a365aebb0eb548166309f58a1e8b8e>) ( [CUcontext](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gf9f5bd81658f866613785b3a0bb7d7d9>)Â ctx )
     Destroy a CUDA context.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuCtxGetApiVersion](<#group__CUDA__CTX_1g088a90490dafca5893ef6fbebc8de8fb>) ( [CUcontext](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gf9f5bd81658f866613785b3a0bb7d7d9>)Â ctx, unsigned int*Â version )
     Gets the context's API version.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuCtxGetCacheConfig](<#group__CUDA__CTX_1g40b6b141698f76744dea6e39b9a25360>) ( [CUfunc_cache](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g3b9bbcf42528b889e9dbe9cfa2aea3ec>)*Â pconfig )
     Returns the preferred cache configuration for the current context.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuCtxGetCurrent](<#group__CUDA__CTX_1g8f13165846b73750693640fb3e8380d0>) ( [CUcontext](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gf9f5bd81658f866613785b3a0bb7d7d9>)*Â pctx )
     Returns the CUDA context bound to the calling CPU thread.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuCtxGetDevice](<#group__CUDA__CTX_1g4e84b109eba36cdaaade167f34ae881e>) ( [CUdevice](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g41ca2a24a242b36ef2ca77330b5fb72a>)*Â device )
     Returns the device handle for the current context.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuCtxGetDevice_v2](<#group__CUDA__CTX_1gf0290a2b2de4c567f5c8c8262da58f60>) ( [CUdevice](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g41ca2a24a242b36ef2ca77330b5fb72a>)*Â device, [CUcontext](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gf9f5bd81658f866613785b3a0bb7d7d9>)Â ctx )
     Returns the device handle for the specified context.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuCtxGetExecAffinity](<#group__CUDA__CTX_1g83421924a20536a4df538111cf61b405>) ( [CUexecAffinityParam](<structCUexecAffinityParam__v1.html#structCUexecAffinityParam__v1>)*Â pExecAffinity, [CUexecAffinityType](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g14e6345acf2bda65be91eda77cf03f5c>)Â type )
     Returns the execution affinity setting for the current context.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuCtxGetFlags](<#group__CUDA__CTX_1gf81eef983c1e3b2ef4f166d7a930c86d>) ( unsigned int*Â flags )
     Returns the flags for the current context.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuCtxGetId](<#group__CUDA__CTX_1g32f492cd6c3f90af0d6935b294392db5>) ( [CUcontext](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gf9f5bd81658f866613785b3a0bb7d7d9>)Â ctx, unsigned long long*Â ctxId )
     Returns the unique Id associated with the context supplied.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuCtxGetLimit](<#group__CUDA__CTX_1g9f2d47d1745752aa16da7ed0d111b6a8>) ( size_t*Â pvalue, [CUlimit](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ge24c2d4214af24139020f1aecaf32665>)Â limit )
     Returns resource limits.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuCtxGetStreamPriorityRange](<#group__CUDA__CTX_1g137920ab61a71be6ce67605b9f294091>) ( int*Â leastPriority, int*Â greatestPriority )
     Returns numerical values that correspond to the least and greatest stream priorities.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuCtxPopCurrent](<#group__CUDA__CTX_1g2fac188026a062d92e91a8687d0a7902>) ( [CUcontext](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gf9f5bd81658f866613785b3a0bb7d7d9>)*Â pctx )
     Pops the current CUDA context from the current CPU thread.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuCtxPushCurrent](<#group__CUDA__CTX_1gb02d4c850eb16f861fe5a29682cc90ba>) ( [CUcontext](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gf9f5bd81658f866613785b3a0bb7d7d9>)Â ctx )
     Pushes a context on the current CPU thread.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuCtxRecordEvent](<#group__CUDA__CTX_1gf3ee63561a7a371fa9d4dc0e31f94afd>) ( [CUcontext](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gf9f5bd81658f866613785b3a0bb7d7d9>)Â hCtx, [CUevent](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g6d740185cf0953636d4ae37f68d7559b>)Â hEvent )
     Records an event.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuCtxResetPersistingL2Cache](<#group__CUDA__CTX_1gb529532b5b1aef808295a6d1d18a0823>) ( void )
     Resets all persisting lines in cache to normal status.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuCtxSetCacheConfig](<#group__CUDA__CTX_1g54699acf7e2ef27279d013ca2095f4a3>) ( [CUfunc_cache](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g3b9bbcf42528b889e9dbe9cfa2aea3ec>)Â config )
     Sets the preferred cache configuration for the current context.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuCtxSetCurrent](<#group__CUDA__CTX_1gbe562ee6258b4fcc272ca6478ca2a2f7>) ( [CUcontext](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gf9f5bd81658f866613785b3a0bb7d7d9>)Â ctx )
     Binds the specified CUDA context to the calling CPU thread.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuCtxSetFlags](<#group__CUDA__CTX_1g66655c37602c8628eae3e40c82619f1e>) ( unsigned int Â flags )
     Sets the flags for the current context.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuCtxSetLimit](<#group__CUDA__CTX_1g0651954dfb9788173e60a9af7201e65a>) ( [CUlimit](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ge24c2d4214af24139020f1aecaf32665>)Â limit, size_tÂ value )
     Set resource limits.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuCtxSynchronize](<#group__CUDA__CTX_1g7a54725f28d34b8c6299f0c6ca579616>) ( void )
     Block for the current context's tasks to complete.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuCtxSynchronize_v2](<#group__CUDA__CTX_1g7c57ec88e825af32ef8cc1754d69eca5>) ( [CUcontext](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gf9f5bd81658f866613785b3a0bb7d7d9>)Â ctx )
     Block for the specified context's tasks to complete.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuCtxWaitEvent](<#group__CUDA__CTX_1gcf64e420275a8141b1f12bfce3f478f9>) ( [CUcontext](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gf9f5bd81658f866613785b3a0bb7d7d9>)Â hCtx, [CUevent](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g6d740185cf0953636d4ae37f68d7559b>)Â hEvent )
     Make a context wait on an event.

### Functions

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuCtxCreate ( [CUcontext](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gf9f5bd81658f866613785b3a0bb7d7d9>)*Â pctx, [CUctxCreateParams](<structCUctxCreateParams.html#structCUctxCreateParams>)*Â ctxCreateParams, unsigned int Â flags, [CUdevice](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g41ca2a24a242b36ef2ca77330b5fb72a>)Â dev )


Create a CUDA context.

######  Parameters

`pctx`
    \- Returned context handle of the new context
`ctxCreateParams`
    \- Context creation parameters
`flags`
    \- Context creation flags
`dev`
    \- Device to create context on

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_DEINITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9acf52f132faf29b473cdda6061f0f44a>), [CUDA_ERROR_NOT_INITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e98feb999f0af99b4a25ab26b3866f4df8>), [CUDA_ERROR_INVALID_CONTEXT](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a484e9af32c1e9893ff21f0e0191a12d>), [CUDA_ERROR_INVALID_DEVICE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e96f047e7215788ca96c81af92a04bfb6c>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>), [CUDA_ERROR_NOT_SUPPORTED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e954756ae7ade0dfd09faeccb513dd831b>), [CUDA_ERROR_OUT_OF_MEMORY](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9264c50688ed110e8476b591befe60c02>), [CUDA_ERROR_UNKNOWN](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9c5a6ab0245179d297f1fa56ed0097183>)

###### Description

Creates a new CUDA context and associates it with the calling thread. The `flags` parameter is described below. The context is created with a usage count of 1 and the caller of [cuCtxCreate()](<group__CUDA__CTX.html#group__CUDA__CTX_1g77e9fb578caefca5ed15b4acebf35265> "Create a CUDA context.") must call [cuCtxDestroy()](<group__CUDA__CTX.html#group__CUDA__CTX_1g27a365aebb0eb548166309f58a1e8b8e> "Destroy a CUDA context.") when done using the context. If a context is already current to the thread, it is supplanted by the newly created context and may be restored by a subsequent call to [cuCtxPopCurrent()](<group__CUDA__CTX.html#group__CUDA__CTX_1g2fac188026a062d92e91a8687d0a7902> "Pops the current CUDA context from the current CPU thread.").

CUDA context can be created with execution affinity. The type and the amount of execution resource the context can use is limited by `paramsArray` and `numExecAffinityParams` in `execAffinity`. The `paramsArray` is an array of `CUexecAffinityParam` and the `numExecAffinityParams` describes the size of the paramsArray. If two `CUexecAffinityParam` in the array have the same type, the latter execution affinity parameter overrides the former execution affinity parameter. The supported execution affinity types are:

  * [CU_EXEC_AFFINITY_TYPE_SM_COUNT](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg14e6345acf2bda65be91eda77cf03f5cc7764c90ce81e15aba5f26a3507cd00c>) limits the portion of SMs that the context can use. The portion of SMs is specified as the number of SMs via `CUexecAffinitySmCount`. This limit will be internally rounded up to the next hardware-supported amount. Hence, it is imperative to query the actual execution affinity of the context via `cuCtxGetExecAffinity` after context creation. Currently, this attribute is only supported under Volta+ MPS.


CUDA context can be created in CIG(CUDA in Graphics) mode by setting `cigParams`. Data from graphics client is shared with CUDA via the `sharedData` in `cigParams`. Support for D3D12 graphics client can be determined using [cuDeviceGetAttribute()](<group__CUDA__DEVICE.html#group__CUDA__DEVICE_1g9c3e1414f0ad901d3278a4d6645fc266> "Returns information about the device.") with [CU_DEVICE_ATTRIBUTE_D3D12_CIG_SUPPORTED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gge12b8a782bebe21b1ac0091bf9f4e2a380194e4d9d3af41f1cc828eb54a99f1d>). `sharedData` is a ID3D12CommandQueue handle. Support for Vulkan graphics client can be determined using [cuDeviceGetAttribute()](<group__CUDA__DEVICE.html#group__CUDA__DEVICE_1g9c3e1414f0ad901d3278a4d6645fc266> "Returns information about the device.") with [CU_DEVICE_ATTRIBUTE_VULKAN_CIG_SUPPORTED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gge12b8a782bebe21b1ac0091bf9f4e2a3a3bed53361d118f632efe4776fc90cd3>). `sharedData` is a Nvidia specific data blob populated by calling vkGetExternalComputeQueueDataNV(). Either `execAffinityParams` or `cigParams` can be set to a non-null value. Setting both to a non-null value will result in an undefined behavior.

The three LSBs of the `flags` parameter can be used to control how the OS thread, which owns the CUDA context at the time of an API call, interacts with the OS scheduler when waiting for results from the GPU. Only one of the scheduling flags can be set when creating a context.

  * [CU_CTX_SCHED_SPIN](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg9f889e28a45a295b5c8ce13aa05f6cd4331d3ed1e0b55597258bd58346603afc>): Instruct CUDA to actively spin when waiting for results from the GPU. This can decrease latency when waiting for the GPU, but may lower the performance of CPU threads if they are performing work in parallel with the CUDA thread.


  * [CU_CTX_SCHED_YIELD](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg9f889e28a45a295b5c8ce13aa05f6cd44bc43364906d8dd5a7d7c8ad46ccc548>): Instruct CUDA to yield its thread when waiting for results from the GPU. This can increase latency when waiting for the GPU, but can increase the performance of CPU threads performing work in parallel with the GPU.


  * [CU_CTX_SCHED_BLOCKING_SYNC](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg9f889e28a45a295b5c8ce13aa05f6cd462aebfe6432ade3feb32f1a409027852>): Instruct CUDA to block the CPU thread on a synchronization primitive when waiting for the GPU to finish work.


  * [CU_CTX_BLOCKING_SYNC](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg9f889e28a45a295b5c8ce13aa05f6cd4b5bf395cc60a8cbded4c329ae9430b91>): Instruct CUDA to block the CPU thread on a synchronization primitive when waiting for the GPU to finish work.

**Deprecated:** This flag was deprecated as of CUDA 4.0 and was replaced with [CU_CTX_SCHED_BLOCKING_SYNC](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg9f889e28a45a295b5c8ce13aa05f6cd462aebfe6432ade3feb32f1a409027852>).


  * [CU_CTX_SCHED_AUTO](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg9f889e28a45a295b5c8ce13aa05f6cd4d75f4c24f8c35ef2ee9d0793badfd88c>): The default value if the `flags` parameter is zero, uses a heuristic based on the number of active CUDA contexts in the process C and the number of logical processors in the system P. If C > P, then CUDA will yield to other OS threads when waiting for the GPU ([CU_CTX_SCHED_YIELD](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg9f889e28a45a295b5c8ce13aa05f6cd44bc43364906d8dd5a7d7c8ad46ccc548>)), otherwise CUDA will not yield while waiting for results and actively spin on the processor ([CU_CTX_SCHED_SPIN](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg9f889e28a45a295b5c8ce13aa05f6cd4331d3ed1e0b55597258bd58346603afc>)). Additionally, on Tegra devices, [CU_CTX_SCHED_AUTO](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg9f889e28a45a295b5c8ce13aa05f6cd4d75f4c24f8c35ef2ee9d0793badfd88c>) uses a heuristic based on the power profile of the platform and may choose [CU_CTX_SCHED_BLOCKING_SYNC](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg9f889e28a45a295b5c8ce13aa05f6cd462aebfe6432ade3feb32f1a409027852>) for low-powered devices.


  * [CU_CTX_MAP_HOST](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg9f889e28a45a295b5c8ce13aa05f6cd408c822db270f4322af6e6bb0a7786514>): Instruct CUDA to support mapped pinned allocations. This flag must be set in order to allocate pinned host memory that is accessible to the GPU.


  * [CU_CTX_LMEM_RESIZE_TO_MAX](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg9f889e28a45a295b5c8ce13aa05f6cd4b5a83507c2a7e14d301621c40c343a81>): Instruct CUDA to not reduce local memory after resizing local memory for a kernel. This can prevent thrashing by local memory allocations when launching many kernels with high local memory usage at the cost of potentially increased memory usage.

**Deprecated:** This flag is deprecated and the behavior enabled by this flag is now the default and cannot be disabled. Instead, the per-thread stack size can be controlled with [cuCtxSetLimit()](<group__CUDA__CTX.html#group__CUDA__CTX_1g0651954dfb9788173e60a9af7201e65a> "Set resource limits.").


  * [CU_CTX_COREDUMP_ENABLE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg9f889e28a45a295b5c8ce13aa05f6cd44c74aa37941a780fccfbc2aa23e97809>): If GPU coredumps have not been enabled globally with [cuCoredumpSetAttributeGlobal](<group__CUDA__COREDUMP.html#group__CUDA__COREDUMP_1ga7645a8f68dd5379a03852b462727990> "Allows caller to set a coredump attribute value globally.") or environment variables, this flag can be set during context creation to instruct CUDA to create a coredump if this context raises an exception during execution. These environment variables are described in the CUDA-GDB user guide under the "GPU core dump support" section. The initial attributes will be taken from the global attributes at the time of context creation. The other attributes that control coredump output can be modified by calling [cuCoredumpSetAttribute](<group__CUDA__COREDUMP.html#group__CUDA__COREDUMP_1g45b806050f3211e840eb3c8d91e93fcb> "Allows caller to set a coredump attribute value for the current context.") from the created context after it becomes current. This flag is not supported when CUDA context is created in CIG(CUDA in Graphics) mode.


  * [CU_CTX_USER_COREDUMP_ENABLE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg9f889e28a45a295b5c8ce13aa05f6cd40703ba07a50ffbd294cb1122e08370d5>): If user-triggered GPU coredumps have not been enabled globally with [cuCoredumpSetAttributeGlobal](<group__CUDA__COREDUMP.html#group__CUDA__COREDUMP_1ga7645a8f68dd5379a03852b462727990> "Allows caller to set a coredump attribute value globally.") or environment variables, this flag can be set during context creation to instruct CUDA to create a coredump if data is written to a certain pipe that is present in the OS space. These environment variables are described in the CUDA-GDB user guide under the "GPU core dump support" section. It is important to note that the pipe name *must* be set with [cuCoredumpSetAttributeGlobal](<group__CUDA__COREDUMP.html#group__CUDA__COREDUMP_1ga7645a8f68dd5379a03852b462727990> "Allows caller to set a coredump attribute value globally.") before creating the context if this flag is used. Setting this flag implies that [CU_CTX_COREDUMP_ENABLE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg9f889e28a45a295b5c8ce13aa05f6cd44c74aa37941a780fccfbc2aa23e97809>) is set. The initial attributes will be taken from the global attributes at the time of context creation. The other attributes that control coredump output can be modified by calling [cuCoredumpSetAttribute](<group__CUDA__COREDUMP.html#group__CUDA__COREDUMP_1g45b806050f3211e840eb3c8d91e93fcb> "Allows caller to set a coredump attribute value for the current context.") from the created context after it becomes current. Setting this flag on any context creation is equivalent to setting the CU_COREDUMP_ENABLE_USER_TRIGGER attribute to `true` globally. This flag is not supported when CUDA context is created in CIG(CUDA in Graphics) mode.


  * [CU_CTX_SYNC_MEMOPS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg9f889e28a45a295b5c8ce13aa05f6cd4e93e3bda3a8e71fe8f4d0de36aa881f0>): Ensures that synchronous memory operations initiated on this context will always synchronize. See further documentation in the section titled "API Synchronization behavior" to learn more about cases when synchronous memory operations can exhibit asynchronous behavior.


Context creation will fail with [CUDA_ERROR_UNKNOWN](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9c5a6ab0245179d297f1fa56ed0097183>) if the compute mode of the device is [CU_COMPUTEMODE_PROHIBITED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg637aab2eadb52e1c1c048b8bad9592d1db8a226241187db3b1f41999bb70eb47>). The function [cuDeviceGetAttribute()](<group__CUDA__DEVICE.html#group__CUDA__DEVICE_1g9c3e1414f0ad901d3278a4d6645fc266> "Returns information about the device.") can be used with [CU_DEVICE_ATTRIBUTE_COMPUTE_MODE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gge12b8a782bebe21b1ac0091bf9f4e2a3f6669a29a6d42968047747cbfc501289>) to determine the compute mode of the device. The nvidia-smi tool can be used to set the compute mode for * devices. Documentation for nvidia-smi can be obtained by passing a -h option to it.

Context creation will fail with :: CUDA_ERROR_INVALID_VALUE if invalid parameter was passed by client to create the CUDA context.

Context creation in CIG mode will fail with [CUDA_ERROR_NOT_SUPPORTED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e954756ae7ade0dfd09faeccb513dd831b>) if CIG is not supported by the device or the driver.

Note:

Note that this function may also return error codes from previous, asynchronous launches.

**See also:**

[cuCtxDestroy](<group__CUDA__CTX.html#group__CUDA__CTX_1g27a365aebb0eb548166309f58a1e8b8e> "Destroy a CUDA context."), [cuCtxGetApiVersion](<group__CUDA__CTX.html#group__CUDA__CTX_1g088a90490dafca5893ef6fbebc8de8fb> "Gets the context's API version."), [cuCtxGetCacheConfig](<group__CUDA__CTX.html#group__CUDA__CTX_1g40b6b141698f76744dea6e39b9a25360> "Returns the preferred cache configuration for the current context."), [cuCtxGetDevice](<group__CUDA__CTX.html#group__CUDA__CTX_1g4e84b109eba36cdaaade167f34ae881e> "Returns the device handle for the current context."), [cuCtxGetFlags](<group__CUDA__CTX.html#group__CUDA__CTX_1gf81eef983c1e3b2ef4f166d7a930c86d> "Returns the flags for the current context."), [cuCtxGetLimit](<group__CUDA__CTX.html#group__CUDA__CTX_1g9f2d47d1745752aa16da7ed0d111b6a8> "Returns resource limits."), [cuCtxPopCurrent](<group__CUDA__CTX.html#group__CUDA__CTX_1g2fac188026a062d92e91a8687d0a7902> "Pops the current CUDA context from the current CPU thread."), [cuCtxPushCurrent](<group__CUDA__CTX.html#group__CUDA__CTX_1gb02d4c850eb16f861fe5a29682cc90ba> "Pushes a context on the current CPU thread."), [cuCtxSetCacheConfig](<group__CUDA__CTX.html#group__CUDA__CTX_1g54699acf7e2ef27279d013ca2095f4a3> "Sets the preferred cache configuration for the current context."), [cuCtxSetLimit](<group__CUDA__CTX.html#group__CUDA__CTX_1g0651954dfb9788173e60a9af7201e65a> "Set resource limits."), [cuCoredumpSetAttributeGlobal](<group__CUDA__COREDUMP.html#group__CUDA__COREDUMP_1ga7645a8f68dd5379a03852b462727990> "Allows caller to set a coredump attribute value globally."), [cuCoredumpSetAttribute](<group__CUDA__COREDUMP.html#group__CUDA__COREDUMP_1g45b806050f3211e840eb3c8d91e93fcb> "Allows caller to set a coredump attribute value for the current context."), [cuCtxSynchronize](<group__CUDA__CTX.html#group__CUDA__CTX_1g7a54725f28d34b8c6299f0c6ca579616> "Block for the current context's tasks to complete.")

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuCtxDestroy ( [CUcontext](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gf9f5bd81658f866613785b3a0bb7d7d9>)Â ctx )


Destroy a CUDA context.

######  Parameters

`ctx`
    \- Context to destroy

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_DEINITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9acf52f132faf29b473cdda6061f0f44a>), [CUDA_ERROR_NOT_INITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e98feb999f0af99b4a25ab26b3866f4df8>), [CUDA_ERROR_INVALID_CONTEXT](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a484e9af32c1e9893ff21f0e0191a12d>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>)

###### Description

Destroys the CUDA context specified by `ctx`. The context `ctx` will be destroyed regardless of how many threads it is current to. It is the responsibility of the calling function to ensure that no API call issues using `ctx` while [cuCtxDestroy()](<group__CUDA__CTX.html#group__CUDA__CTX_1g27a365aebb0eb548166309f58a1e8b8e> "Destroy a CUDA context.") is executing.

Destroys and cleans up all resources associated with the context. It is the caller's responsibility to ensure that the context or its resources are not accessed or passed in subsequent API calls and doing so will result in undefined behavior. These resources include CUDA types [CUmodule](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g9e4ef4dcfba4662b2299acb8d049a1ef>), [CUfunction](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gba6128b948022f495706d93bc2cea9c8>), [CUstream](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gb946c7f02e09efd788a204718015d88a>), [CUevent](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g6d740185cf0953636d4ae37f68d7559b>), [CUarray](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gd550651524a56766b60f10f0e7628042>), [CUmipmappedArray](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g96db856ab3d2940fb694ce4501d9b583>), [CUtexObject](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g65fb6720dea73d56db0b4d4974be052d>), [CUsurfObject](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g4acc685a8412637d05668e30e984e220>), [CUtexref](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gec1e8eb9dc48ad748765d1fcc020d6b5>), [CUsurfref](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g7b99472b414f10b2c04dd2530dc7ea76>), [CUgraphicsResource](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc0c4e1704647178d9c5ba3be46517dcd>), CUlinkState, [CUexternalMemory](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc9500ef066876b1186f8a54afff900ba>) and [CUexternalSemaphore](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g0bc360152166a414e50a5167250552b8>). These resources also include memory allocations by [cuMemAlloc()](<group__CUDA__MEM.html#group__CUDA__MEM_1gb82d2a09844a58dd9e744dc31e8aa467> "Allocates device memory."), [cuMemAllocHost()](<group__CUDA__MEM.html#group__CUDA__MEM_1gdd8311286d2c2691605362c689bc64e0> "Allocates page-locked host memory."), [cuMemAllocManaged()](<group__CUDA__MEM.html#group__CUDA__MEM_1gb347ded34dc326af404aa02af5388a32> "Allocates memory that will be automatically managed by the Unified Memory system.") and [cuMemAllocPitch()](<group__CUDA__MEM.html#group__CUDA__MEM_1gcbe9b033f6c4de80f63cc6e58ed9a45a> "Allocates pitched device memory.").

If `ctx` is current to the calling thread then `ctx` will also be popped from the current thread's context stack (as though [cuCtxPopCurrent()](<group__CUDA__CTX.html#group__CUDA__CTX_1g2fac188026a062d92e91a8687d0a7902> "Pops the current CUDA context from the current CPU thread.") were called). If `ctx` is current to other threads, then `ctx` will remain current to those threads, and attempting to access `ctx` from those threads will result in the error [CUDA_ERROR_CONTEXT_IS_DESTROYED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9b27ac43f7ce8446f5c9636dd73fb2139>).

Note:

[cuCtxDestroy()](<group__CUDA__CTX.html#group__CUDA__CTX_1g27a365aebb0eb548166309f58a1e8b8e> "Destroy a CUDA context.") will not destroy memory allocations by [cuMemCreate()](<group__CUDA__VA.html#group__CUDA__VA_1g899d69a862bba36449789c64b430dc7c> "Create a CUDA memory handle representing a memory allocation of a given size described by the given properties."), [cuMemAllocAsync()](<group__CUDA__MALLOC__ASYNC.html#group__CUDA__MALLOC__ASYNC_1g13413273e84a641bce1929eae9e6501f> "Allocates memory with stream ordered semantics.") and [cuMemAllocFromPoolAsync()](<group__CUDA__MALLOC__ASYNC.html#group__CUDA__MALLOC__ASYNC_1gf1dd6e1e2e8f767a5e0ea63f38ff260b> "Allocates memory from a specified pool with stream ordered semantics."). These memory allocations are not associated with any CUDA context and need to be destroyed explicitly.

Note:

Note that this function may also return error codes from previous, asynchronous launches.

**See also:**

[cuCtxCreate](<group__CUDA__CTX.html#group__CUDA__CTX_1g77e9fb578caefca5ed15b4acebf35265> "Create a CUDA context."), [cuCtxGetApiVersion](<group__CUDA__CTX.html#group__CUDA__CTX_1g088a90490dafca5893ef6fbebc8de8fb> "Gets the context's API version."), [cuCtxGetCacheConfig](<group__CUDA__CTX.html#group__CUDA__CTX_1g40b6b141698f76744dea6e39b9a25360> "Returns the preferred cache configuration for the current context."), [cuCtxGetDevice](<group__CUDA__CTX.html#group__CUDA__CTX_1g4e84b109eba36cdaaade167f34ae881e> "Returns the device handle for the current context."), [cuCtxGetFlags](<group__CUDA__CTX.html#group__CUDA__CTX_1gf81eef983c1e3b2ef4f166d7a930c86d> "Returns the flags for the current context."), [cuCtxGetLimit](<group__CUDA__CTX.html#group__CUDA__CTX_1g9f2d47d1745752aa16da7ed0d111b6a8> "Returns resource limits."), [cuCtxPopCurrent](<group__CUDA__CTX.html#group__CUDA__CTX_1g2fac188026a062d92e91a8687d0a7902> "Pops the current CUDA context from the current CPU thread."), [cuCtxPushCurrent](<group__CUDA__CTX.html#group__CUDA__CTX_1gb02d4c850eb16f861fe5a29682cc90ba> "Pushes a context on the current CPU thread."), [cuCtxSetCacheConfig](<group__CUDA__CTX.html#group__CUDA__CTX_1g54699acf7e2ef27279d013ca2095f4a3> "Sets the preferred cache configuration for the current context."), [cuCtxSetLimit](<group__CUDA__CTX.html#group__CUDA__CTX_1g0651954dfb9788173e60a9af7201e65a> "Set resource limits."), [cuCtxSynchronize](<group__CUDA__CTX.html#group__CUDA__CTX_1g7a54725f28d34b8c6299f0c6ca579616> "Block for the current context's tasks to complete.")

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuCtxGetApiVersion ( [CUcontext](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gf9f5bd81658f866613785b3a0bb7d7d9>)Â ctx, unsigned int*Â version )


Gets the context's API version.

######  Parameters

`ctx`
    \- Context to check
`version`
    \- Pointer to version

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_DEINITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9acf52f132faf29b473cdda6061f0f44a>), [CUDA_ERROR_NOT_INITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e98feb999f0af99b4a25ab26b3866f4df8>), [CUDA_ERROR_INVALID_CONTEXT](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a484e9af32c1e9893ff21f0e0191a12d>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>), [CUDA_ERROR_UNKNOWN](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9c5a6ab0245179d297f1fa56ed0097183>)

###### Description

Returns a version number in `version` corresponding to the capabilities of the context (e.g. 3010 or 3020), which library developers can use to direct callers to a specific API version. If `ctx` is NULL, returns the API version used to create the currently bound context.

Note that new API versions are only introduced when context capabilities are changed that break binary compatibility, so the API version and driver version may be different. For example, it is valid for the API version to be 3020 while the driver version is 4020.

Note:

Note that this function may also return error codes from previous, asynchronous launches.

**See also:**

[cuCtxCreate](<group__CUDA__CTX.html#group__CUDA__CTX_1g77e9fb578caefca5ed15b4acebf35265> "Create a CUDA context."), [cuCtxDestroy](<group__CUDA__CTX.html#group__CUDA__CTX_1g27a365aebb0eb548166309f58a1e8b8e> "Destroy a CUDA context."), [cuCtxGetDevice](<group__CUDA__CTX.html#group__CUDA__CTX_1g4e84b109eba36cdaaade167f34ae881e> "Returns the device handle for the current context."), [cuCtxGetFlags](<group__CUDA__CTX.html#group__CUDA__CTX_1gf81eef983c1e3b2ef4f166d7a930c86d> "Returns the flags for the current context."), [cuCtxGetLimit](<group__CUDA__CTX.html#group__CUDA__CTX_1g9f2d47d1745752aa16da7ed0d111b6a8> "Returns resource limits."), [cuCtxPopCurrent](<group__CUDA__CTX.html#group__CUDA__CTX_1g2fac188026a062d92e91a8687d0a7902> "Pops the current CUDA context from the current CPU thread."), [cuCtxPushCurrent](<group__CUDA__CTX.html#group__CUDA__CTX_1gb02d4c850eb16f861fe5a29682cc90ba> "Pushes a context on the current CPU thread."), [cuCtxSetCacheConfig](<group__CUDA__CTX.html#group__CUDA__CTX_1g54699acf7e2ef27279d013ca2095f4a3> "Sets the preferred cache configuration for the current context."), [cuCtxSetLimit](<group__CUDA__CTX.html#group__CUDA__CTX_1g0651954dfb9788173e60a9af7201e65a> "Set resource limits."), [cuCtxSynchronize](<group__CUDA__CTX.html#group__CUDA__CTX_1g7a54725f28d34b8c6299f0c6ca579616> "Block for the current context's tasks to complete.")

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuCtxGetCacheConfig ( [CUfunc_cache](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g3b9bbcf42528b889e9dbe9cfa2aea3ec>)*Â pconfig )


Returns the preferred cache configuration for the current context.

######  Parameters

`pconfig`
    \- Returned cache configuration

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_DEINITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9acf52f132faf29b473cdda6061f0f44a>), [CUDA_ERROR_NOT_INITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e98feb999f0af99b4a25ab26b3866f4df8>), [CUDA_ERROR_INVALID_CONTEXT](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a484e9af32c1e9893ff21f0e0191a12d>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>)

###### Description

On devices where the L1 cache and shared memory use the same hardware resources, this function returns through `pconfig` the preferred cache configuration for the current context. This is only a preference. The driver will use the requested configuration if possible, but it is free to choose a different configuration if required to execute functions.

This will return a `pconfig` of [CU_FUNC_CACHE_PREFER_NONE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg3b9bbcf42528b889e9dbe9cfa2aea3ec47d2f367dc3965c27ff748688229dc22>) on devices where the size of the L1 cache and shared memory are fixed.

The supported cache configurations are:

  * [CU_FUNC_CACHE_PREFER_NONE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg3b9bbcf42528b889e9dbe9cfa2aea3ec47d2f367dc3965c27ff748688229dc22>): no preference for shared memory or L1 (default)

  * [CU_FUNC_CACHE_PREFER_SHARED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg3b9bbcf42528b889e9dbe9cfa2aea3ec712f43defb051d7985317bce426cccc8>): prefer larger shared memory and smaller L1 cache

  * [CU_FUNC_CACHE_PREFER_L1](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg3b9bbcf42528b889e9dbe9cfa2aea3ecb1e6c4e889e1a70ed5283172be08f6a5>): prefer larger L1 cache and smaller shared memory

  * [CU_FUNC_CACHE_PREFER_EQUAL](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg3b9bbcf42528b889e9dbe9cfa2aea3ec4434321280821d844a15b02e4d6c80a9>): prefer equal sized L1 cache and shared memory


Note:

Note that this function may also return error codes from previous, asynchronous launches.

**See also:**

[cuCtxCreate](<group__CUDA__CTX.html#group__CUDA__CTX_1g77e9fb578caefca5ed15b4acebf35265> "Create a CUDA context."), [cuCtxDestroy](<group__CUDA__CTX.html#group__CUDA__CTX_1g27a365aebb0eb548166309f58a1e8b8e> "Destroy a CUDA context."), [cuCtxGetApiVersion](<group__CUDA__CTX.html#group__CUDA__CTX_1g088a90490dafca5893ef6fbebc8de8fb> "Gets the context's API version."), [cuCtxGetDevice](<group__CUDA__CTX.html#group__CUDA__CTX_1g4e84b109eba36cdaaade167f34ae881e> "Returns the device handle for the current context."), [cuCtxGetFlags](<group__CUDA__CTX.html#group__CUDA__CTX_1gf81eef983c1e3b2ef4f166d7a930c86d> "Returns the flags for the current context."), [cuCtxGetLimit](<group__CUDA__CTX.html#group__CUDA__CTX_1g9f2d47d1745752aa16da7ed0d111b6a8> "Returns resource limits."), [cuCtxPopCurrent](<group__CUDA__CTX.html#group__CUDA__CTX_1g2fac188026a062d92e91a8687d0a7902> "Pops the current CUDA context from the current CPU thread."), [cuCtxPushCurrent](<group__CUDA__CTX.html#group__CUDA__CTX_1gb02d4c850eb16f861fe5a29682cc90ba> "Pushes a context on the current CPU thread."), [cuCtxSetCacheConfig](<group__CUDA__CTX.html#group__CUDA__CTX_1g54699acf7e2ef27279d013ca2095f4a3> "Sets the preferred cache configuration for the current context."), [cuCtxSetLimit](<group__CUDA__CTX.html#group__CUDA__CTX_1g0651954dfb9788173e60a9af7201e65a> "Set resource limits."), [cuCtxSynchronize](<group__CUDA__CTX.html#group__CUDA__CTX_1g7a54725f28d34b8c6299f0c6ca579616> "Block for the current context's tasks to complete."), [cuFuncSetCacheConfig](<group__CUDA__EXEC.html#group__CUDA__EXEC_1g40f8c11e81def95dc0072a375f965681> "Sets the preferred cache configuration for a device function."), [cudaDeviceGetCacheConfig](<../cuda-runtime-api/group__CUDART__DEVICE.html#group__CUDART__DEVICE_1gd9bf5eae6d464de05aa3840df9f5deeb>)

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuCtxGetCurrent ( [CUcontext](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gf9f5bd81658f866613785b3a0bb7d7d9>)*Â pctx )


Returns the CUDA context bound to the calling CPU thread.

######  Parameters

`pctx`
    \- Returned context handle

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_DEINITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9acf52f132faf29b473cdda6061f0f44a>), [CUDA_ERROR_NOT_INITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e98feb999f0af99b4a25ab26b3866f4df8>),

###### Description

Returns in `*pctx` the CUDA context bound to the calling CPU thread. If no context is bound to the calling CPU thread then `*pctx` is set to NULL and [CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>) is returned.

Note:

Note that this function may also return error codes from previous, asynchronous launches.

**See also:**

[cuCtxSetCurrent](<group__CUDA__CTX.html#group__CUDA__CTX_1gbe562ee6258b4fcc272ca6478ca2a2f7> "Binds the specified CUDA context to the calling CPU thread."), [cuCtxCreate](<group__CUDA__CTX.html#group__CUDA__CTX_1g77e9fb578caefca5ed15b4acebf35265> "Create a CUDA context."), [cuCtxDestroy](<group__CUDA__CTX.html#group__CUDA__CTX_1g27a365aebb0eb548166309f58a1e8b8e> "Destroy a CUDA context."), [cudaGetDevice](<../cuda-runtime-api/group__CUDART__DEVICE.html#group__CUDART__DEVICE_1g80861db2ce7c29b6e8055af8ae01bc78>)

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuCtxGetDevice ( [CUdevice](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g41ca2a24a242b36ef2ca77330b5fb72a>)*Â device )


Returns the device handle for the current context.

######  Parameters

`device`
    \- Returned device handle for the current context

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_DEINITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9acf52f132faf29b473cdda6061f0f44a>), [CUDA_ERROR_NOT_INITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e98feb999f0af99b4a25ab26b3866f4df8>), [CUDA_ERROR_INVALID_CONTEXT](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a484e9af32c1e9893ff21f0e0191a12d>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>),

###### Description

Returns in `*device` the handle of the current context's device.

Note:

Note that this function may also return error codes from previous, asynchronous launches.

**See also:**

[cuCtxCreate](<group__CUDA__CTX.html#group__CUDA__CTX_1g77e9fb578caefca5ed15b4acebf35265> "Create a CUDA context."), [cuCtxDestroy](<group__CUDA__CTX.html#group__CUDA__CTX_1g27a365aebb0eb548166309f58a1e8b8e> "Destroy a CUDA context."), [cuCtxGetApiVersion](<group__CUDA__CTX.html#group__CUDA__CTX_1g088a90490dafca5893ef6fbebc8de8fb> "Gets the context's API version."), [cuCtxGetCacheConfig](<group__CUDA__CTX.html#group__CUDA__CTX_1g40b6b141698f76744dea6e39b9a25360> "Returns the preferred cache configuration for the current context."), [cuCtxGetFlags](<group__CUDA__CTX.html#group__CUDA__CTX_1gf81eef983c1e3b2ef4f166d7a930c86d> "Returns the flags for the current context."), [cuCtxGetLimit](<group__CUDA__CTX.html#group__CUDA__CTX_1g9f2d47d1745752aa16da7ed0d111b6a8> "Returns resource limits."), [cuCtxPopCurrent](<group__CUDA__CTX.html#group__CUDA__CTX_1g2fac188026a062d92e91a8687d0a7902> "Pops the current CUDA context from the current CPU thread."), [cuCtxPushCurrent](<group__CUDA__CTX.html#group__CUDA__CTX_1gb02d4c850eb16f861fe5a29682cc90ba> "Pushes a context on the current CPU thread."), [cuCtxSetCacheConfig](<group__CUDA__CTX.html#group__CUDA__CTX_1g54699acf7e2ef27279d013ca2095f4a3> "Sets the preferred cache configuration for the current context."), [cuCtxSetLimit](<group__CUDA__CTX.html#group__CUDA__CTX_1g0651954dfb9788173e60a9af7201e65a> "Set resource limits."), [cuCtxSynchronize](<group__CUDA__CTX.html#group__CUDA__CTX_1g7a54725f28d34b8c6299f0c6ca579616> "Block for the current context's tasks to complete."), [cudaGetDevice](<../cuda-runtime-api/group__CUDART__DEVICE.html#group__CUDART__DEVICE_1g80861db2ce7c29b6e8055af8ae01bc78>)

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuCtxGetDevice_v2 ( [CUdevice](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g41ca2a24a242b36ef2ca77330b5fb72a>)*Â device, [CUcontext](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gf9f5bd81658f866613785b3a0bb7d7d9>)Â ctx )


Returns the device handle for the specified context.

######  Parameters

`device`
    \- Returned device handle for the specified context
`ctx`
    \- Context for which to obtain the device

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_DEINITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9acf52f132faf29b473cdda6061f0f44a>), [CUDA_ERROR_NOT_INITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e98feb999f0af99b4a25ab26b3866f4df8>), [CUDA_ERROR_INVALID_CONTEXT](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a484e9af32c1e9893ff21f0e0191a12d>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>)

###### Description

Returns in `*device` the handle of the specified context's device. If the specified context is NULL, the API will return the current context's device.

Note:

Note that this function may also return error codes from previous, asynchronous launches.

**See also:**

[cuCtxGetCurrent](<group__CUDA__CTX.html#group__CUDA__CTX_1g8f13165846b73750693640fb3e8380d0> "Returns the CUDA context bound to the calling CPU thread."), [cuCtxPopCurrent](<group__CUDA__CTX.html#group__CUDA__CTX_1g2fac188026a062d92e91a8687d0a7902> "Pops the current CUDA context from the current CPU thread."), [cuCtxPushCurrent](<group__CUDA__CTX.html#group__CUDA__CTX_1gb02d4c850eb16f861fe5a29682cc90ba> "Pushes a context on the current CPU thread.")

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuCtxGetExecAffinity ( [CUexecAffinityParam](<structCUexecAffinityParam__v1.html#structCUexecAffinityParam__v1>)*Â pExecAffinity, [CUexecAffinityType](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g14e6345acf2bda65be91eda77cf03f5c>)Â type )


Returns the execution affinity setting for the current context.

######  Parameters

`pExecAffinity`
    \- Returned execution affinity
`type`
    \- Execution affinity type to query

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_DEINITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9acf52f132faf29b473cdda6061f0f44a>), [CUDA_ERROR_NOT_INITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e98feb999f0af99b4a25ab26b3866f4df8>), [CUDA_ERROR_INVALID_CONTEXT](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a484e9af32c1e9893ff21f0e0191a12d>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>), [CUDA_ERROR_UNSUPPORTED_EXEC_AFFINITY](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e909b6f0a40c9887de1bcc3ca48a75f1ad>)

###### Description

Returns in `*pExecAffinity` the current value of `type`. The supported [CUexecAffinityType](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g14e6345acf2bda65be91eda77cf03f5c>) values are:

  * [CU_EXEC_AFFINITY_TYPE_SM_COUNT](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg14e6345acf2bda65be91eda77cf03f5cc7764c90ce81e15aba5f26a3507cd00c>): number of SMs the context is limited to use.


Note:

Note that this function may also return error codes from previous, asynchronous launches.

**See also:**

[CUexecAffinityParam](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g4e143c37c68ad44ff2b22922f5cd8341>)

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuCtxGetFlags ( unsigned int*Â flags )


Returns the flags for the current context.

######  Parameters

`flags`
    \- Pointer to store flags of current context

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_DEINITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9acf52f132faf29b473cdda6061f0f44a>), [CUDA_ERROR_NOT_INITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e98feb999f0af99b4a25ab26b3866f4df8>), [CUDA_ERROR_INVALID_CONTEXT](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a484e9af32c1e9893ff21f0e0191a12d>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>),

###### Description

Returns in `*flags` the flags of the current context. See [cuCtxCreate](<group__CUDA__CTX.html#group__CUDA__CTX_1g77e9fb578caefca5ed15b4acebf35265> "Create a CUDA context.") for flag values.

Note:

Note that this function may also return error codes from previous, asynchronous launches.

**See also:**

[cuCtxCreate](<group__CUDA__CTX.html#group__CUDA__CTX_1g77e9fb578caefca5ed15b4acebf35265> "Create a CUDA context."), [cuCtxGetApiVersion](<group__CUDA__CTX.html#group__CUDA__CTX_1g088a90490dafca5893ef6fbebc8de8fb> "Gets the context's API version."), [cuCtxGetCacheConfig](<group__CUDA__CTX.html#group__CUDA__CTX_1g40b6b141698f76744dea6e39b9a25360> "Returns the preferred cache configuration for the current context."), [cuCtxGetCurrent](<group__CUDA__CTX.html#group__CUDA__CTX_1g8f13165846b73750693640fb3e8380d0> "Returns the CUDA context bound to the calling CPU thread."), [cuCtxGetDevice](<group__CUDA__CTX.html#group__CUDA__CTX_1g4e84b109eba36cdaaade167f34ae881e> "Returns the device handle for the current context."), [cuCtxGetLimit](<group__CUDA__CTX.html#group__CUDA__CTX_1g9f2d47d1745752aa16da7ed0d111b6a8> "Returns resource limits."), [cuCtxGetSharedMemConfig](<group__CUDA__CTX__DEPRECATED.html#group__CUDA__CTX__DEPRECATED_1gfac1414497a1a2a40bba474c6b5bf194> "Returns the current shared memory configuration for the current context."), [cuCtxGetStreamPriorityRange](<group__CUDA__CTX.html#group__CUDA__CTX_1g137920ab61a71be6ce67605b9f294091> "Returns numerical values that correspond to the least and greatest stream priorities."), [cuCtxSetFlags](<group__CUDA__CTX.html#group__CUDA__CTX_1g66655c37602c8628eae3e40c82619f1e> "Sets the flags for the current context."), [cudaGetDeviceFlags](<../cuda-runtime-api/group__CUDART__DEVICE.html#group__CUDART__DEVICE_1gf830794caf068b71638c6182bba8f77a>)

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuCtxGetId ( [CUcontext](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gf9f5bd81658f866613785b3a0bb7d7d9>)Â ctx, unsigned long long*Â ctxId )


Returns the unique Id associated with the context supplied.

######  Parameters

`ctx`
    \- Context for which to obtain the Id
`ctxId`
    \- Pointer to store the Id of the context

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_CONTEXT_IS_DESTROYED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9b27ac43f7ce8446f5c9636dd73fb2139>), [CUDA_ERROR_DEINITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9acf52f132faf29b473cdda6061f0f44a>), [CUDA_ERROR_NOT_INITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e98feb999f0af99b4a25ab26b3866f4df8>), [CUDA_ERROR_INVALID_CONTEXT](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a484e9af32c1e9893ff21f0e0191a12d>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>)

###### Description

Returns in `ctxId` the unique Id which is associated with a given context. The Id is unique for the life of the program for this instance of CUDA. If context is supplied as NULL and there is one current, the Id of the current context is returned.

Note:

Note that this function may also return error codes from previous, asynchronous launches.

**See also:**

[cuCtxCreate](<group__CUDA__CTX.html#group__CUDA__CTX_1g77e9fb578caefca5ed15b4acebf35265> "Create a CUDA context."), [cuCtxDestroy](<group__CUDA__CTX.html#group__CUDA__CTX_1g27a365aebb0eb548166309f58a1e8b8e> "Destroy a CUDA context."), [cuCtxGetApiVersion](<group__CUDA__CTX.html#group__CUDA__CTX_1g088a90490dafca5893ef6fbebc8de8fb> "Gets the context's API version."), [cuCtxGetCacheConfig](<group__CUDA__CTX.html#group__CUDA__CTX_1g40b6b141698f76744dea6e39b9a25360> "Returns the preferred cache configuration for the current context."), [cuCtxGetDevice](<group__CUDA__CTX.html#group__CUDA__CTX_1g4e84b109eba36cdaaade167f34ae881e> "Returns the device handle for the current context."), [cuCtxGetFlags](<group__CUDA__CTX.html#group__CUDA__CTX_1gf81eef983c1e3b2ef4f166d7a930c86d> "Returns the flags for the current context."), [cuCtxGetLimit](<group__CUDA__CTX.html#group__CUDA__CTX_1g9f2d47d1745752aa16da7ed0d111b6a8> "Returns resource limits."), [cuCtxPushCurrent](<group__CUDA__CTX.html#group__CUDA__CTX_1gb02d4c850eb16f861fe5a29682cc90ba> "Pushes a context on the current CPU thread.")

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuCtxGetLimit ( size_t*Â pvalue, [CUlimit](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ge24c2d4214af24139020f1aecaf32665>)Â limit )


Returns resource limits.

######  Parameters

`pvalue`
    \- Returned size of limit
`limit`
    \- Limit to query

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>), [CUDA_ERROR_UNSUPPORTED_LIMIT](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9d10e6e6ef4b01290d2202d43c3ca6821>)

###### Description

Returns in `*pvalue` the current size of `limit`. The supported [CUlimit](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ge24c2d4214af24139020f1aecaf32665>) values are:

  * [CU_LIMIT_STACK_SIZE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gge24c2d4214af24139020f1aecaf32665ebe51e384a8b4b79459915bb1c31bc39>): stack size in bytes of each GPU thread.

  * [CU_LIMIT_PRINTF_FIFO_SIZE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gge24c2d4214af24139020f1aecaf3266516f25aa2c37a06580ab533d8ae7db948>): size in bytes of the FIFO used by the printf() device system call.

  * [CU_LIMIT_MALLOC_HEAP_SIZE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gge24c2d4214af24139020f1aecaf3266586d01dbc431b04edd5d618257aaa246b>): size in bytes of the heap used by the malloc() and free() device system calls.

  * [CU_LIMIT_DEV_RUNTIME_SYNC_DEPTH](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gge24c2d4214af24139020f1aecaf32665592fb752cc173ad7a2a4026a40e38079>): maximum grid depth at which a thread can issue the device runtime call [cudaDeviceSynchronize()](<../cuda-runtime-api/group__CUDART__DEVICE.html#group__CUDART__DEVICE_1g10e20b05a95f638a4071a655503df25d>) to wait on child grid launches to complete.

  * [CU_LIMIT_DEV_RUNTIME_PENDING_LAUNCH_COUNT](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gge24c2d4214af24139020f1aecaf32665f79d7134ee03d52c0d8b1aecda1ae446>): maximum number of outstanding device runtime launches that can be made from this context.

  * [CU_LIMIT_MAX_L2_FETCH_GRANULARITY](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gge24c2d4214af24139020f1aecaf32665e75d95ea7dac6821de11d122d77f390b>): L2 cache fetch granularity.

  * [CU_LIMIT_PERSISTING_L2_CACHE_SIZE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gge24c2d4214af24139020f1aecaf3266519ef5d58846147f46cdb4a2a886f3682>): Persisting L2 cache size in bytes


Note:

Note that this function may also return error codes from previous, asynchronous launches.

**See also:**

[cuCtxCreate](<group__CUDA__CTX.html#group__CUDA__CTX_1g77e9fb578caefca5ed15b4acebf35265> "Create a CUDA context."), [cuCtxDestroy](<group__CUDA__CTX.html#group__CUDA__CTX_1g27a365aebb0eb548166309f58a1e8b8e> "Destroy a CUDA context."), [cuCtxGetApiVersion](<group__CUDA__CTX.html#group__CUDA__CTX_1g088a90490dafca5893ef6fbebc8de8fb> "Gets the context's API version."), [cuCtxGetCacheConfig](<group__CUDA__CTX.html#group__CUDA__CTX_1g40b6b141698f76744dea6e39b9a25360> "Returns the preferred cache configuration for the current context."), [cuCtxGetDevice](<group__CUDA__CTX.html#group__CUDA__CTX_1g4e84b109eba36cdaaade167f34ae881e> "Returns the device handle for the current context."), [cuCtxGetFlags](<group__CUDA__CTX.html#group__CUDA__CTX_1gf81eef983c1e3b2ef4f166d7a930c86d> "Returns the flags for the current context."), [cuCtxPopCurrent](<group__CUDA__CTX.html#group__CUDA__CTX_1g2fac188026a062d92e91a8687d0a7902> "Pops the current CUDA context from the current CPU thread."), [cuCtxPushCurrent](<group__CUDA__CTX.html#group__CUDA__CTX_1gb02d4c850eb16f861fe5a29682cc90ba> "Pushes a context on the current CPU thread."), [cuCtxSetCacheConfig](<group__CUDA__CTX.html#group__CUDA__CTX_1g54699acf7e2ef27279d013ca2095f4a3> "Sets the preferred cache configuration for the current context."), [cuCtxSetLimit](<group__CUDA__CTX.html#group__CUDA__CTX_1g0651954dfb9788173e60a9af7201e65a> "Set resource limits."), [cuCtxSynchronize](<group__CUDA__CTX.html#group__CUDA__CTX_1g7a54725f28d34b8c6299f0c6ca579616> "Block for the current context's tasks to complete."), [cudaDeviceGetLimit](<../cuda-runtime-api/group__CUDART__DEVICE.html#group__CUDART__DEVICE_1g720e159aeb125910c22aa20fe9611ec2>)

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuCtxGetStreamPriorityRange ( int*Â leastPriority, int*Â greatestPriority )


Returns numerical values that correspond to the least and greatest stream priorities.

######  Parameters

`leastPriority`
    \- Pointer to an int in which the numerical value for least stream priority is returned
`greatestPriority`
    \- Pointer to an int in which the numerical value for greatest stream priority is returned

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>),

###### Description

Returns in `*leastPriority` and `*greatestPriority` the numerical values that correspond to the least and greatest stream priorities respectively. Stream priorities follow a convention where lower numbers imply greater priorities. The range of meaningful stream priorities is given by [`*greatestPriority`, `*leastPriority`]. If the user attempts to create a stream with a priority value that is outside the meaningful range as specified by this API, the priority is automatically clamped down or up to either `*leastPriority` or `*greatestPriority` respectively. See [cuStreamCreateWithPriority](<group__CUDA__STREAM.html#group__CUDA__STREAM_1g95c1a8c7c3dacb13091692dd9c7f7471> "Create a stream with the given priority.") for details on creating a priority stream. A NULL may be passed in for `*leastPriority` or `*greatestPriority` if the value is not desired.

This function will return '0' in both `*leastPriority` and `*greatestPriority` if the current context's device does not support stream priorities (see [cuDeviceGetAttribute](<group__CUDA__DEVICE.html#group__CUDA__DEVICE_1g9c3e1414f0ad901d3278a4d6645fc266> "Returns information about the device.")).

Note:

Note that this function may also return error codes from previous, asynchronous launches.

**See also:**

[cuStreamCreateWithPriority](<group__CUDA__STREAM.html#group__CUDA__STREAM_1g95c1a8c7c3dacb13091692dd9c7f7471> "Create a stream with the given priority."), [cuStreamGetPriority](<group__CUDA__STREAM.html#group__CUDA__STREAM_1g5bd5cb26915a2ecf1921807339488484> "Query the priority of a given stream."), [cuCtxGetDevice](<group__CUDA__CTX.html#group__CUDA__CTX_1g4e84b109eba36cdaaade167f34ae881e> "Returns the device handle for the current context."), [cuCtxGetFlags](<group__CUDA__CTX.html#group__CUDA__CTX_1gf81eef983c1e3b2ef4f166d7a930c86d> "Returns the flags for the current context."), [cuCtxSetLimit](<group__CUDA__CTX.html#group__CUDA__CTX_1g0651954dfb9788173e60a9af7201e65a> "Set resource limits."), [cuCtxSynchronize](<group__CUDA__CTX.html#group__CUDA__CTX_1g7a54725f28d34b8c6299f0c6ca579616> "Block for the current context's tasks to complete."), [cudaDeviceGetStreamPriorityRange](<../cuda-runtime-api/group__CUDART__DEVICE.html#group__CUDART__DEVICE_1gfdb79818f7c0ee7bc585648c91770275>)

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuCtxPopCurrent ( [CUcontext](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gf9f5bd81658f866613785b3a0bb7d7d9>)*Â pctx )


Pops the current CUDA context from the current CPU thread.

######  Parameters

`pctx`
    \- Returned popped context handle

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_DEINITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9acf52f132faf29b473cdda6061f0f44a>), [CUDA_ERROR_NOT_INITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e98feb999f0af99b4a25ab26b3866f4df8>), [CUDA_ERROR_INVALID_CONTEXT](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a484e9af32c1e9893ff21f0e0191a12d>)

###### Description

Pops the current CUDA context from the CPU thread and passes back the old context handle in `*pctx`. That context may then be made current to a different CPU thread by calling [cuCtxPushCurrent()](<group__CUDA__CTX.html#group__CUDA__CTX_1gb02d4c850eb16f861fe5a29682cc90ba> "Pushes a context on the current CPU thread.").

If a context was current to the CPU thread before [cuCtxCreate()](<group__CUDA__CTX.html#group__CUDA__CTX_1g77e9fb578caefca5ed15b4acebf35265> "Create a CUDA context.") or [cuCtxPushCurrent()](<group__CUDA__CTX.html#group__CUDA__CTX_1gb02d4c850eb16f861fe5a29682cc90ba> "Pushes a context on the current CPU thread.") was called, this function makes that context current to the CPU thread again.

Note:

Note that this function may also return error codes from previous, asynchronous launches.

**See also:**

[cuCtxCreate](<group__CUDA__CTX.html#group__CUDA__CTX_1g77e9fb578caefca5ed15b4acebf35265> "Create a CUDA context."), [cuCtxDestroy](<group__CUDA__CTX.html#group__CUDA__CTX_1g27a365aebb0eb548166309f58a1e8b8e> "Destroy a CUDA context."), [cuCtxGetApiVersion](<group__CUDA__CTX.html#group__CUDA__CTX_1g088a90490dafca5893ef6fbebc8de8fb> "Gets the context's API version."), [cuCtxGetCacheConfig](<group__CUDA__CTX.html#group__CUDA__CTX_1g40b6b141698f76744dea6e39b9a25360> "Returns the preferred cache configuration for the current context."), [cuCtxGetDevice](<group__CUDA__CTX.html#group__CUDA__CTX_1g4e84b109eba36cdaaade167f34ae881e> "Returns the device handle for the current context."), [cuCtxGetFlags](<group__CUDA__CTX.html#group__CUDA__CTX_1gf81eef983c1e3b2ef4f166d7a930c86d> "Returns the flags for the current context."), [cuCtxGetLimit](<group__CUDA__CTX.html#group__CUDA__CTX_1g9f2d47d1745752aa16da7ed0d111b6a8> "Returns resource limits."), [cuCtxPushCurrent](<group__CUDA__CTX.html#group__CUDA__CTX_1gb02d4c850eb16f861fe5a29682cc90ba> "Pushes a context on the current CPU thread."), [cuCtxSetCacheConfig](<group__CUDA__CTX.html#group__CUDA__CTX_1g54699acf7e2ef27279d013ca2095f4a3> "Sets the preferred cache configuration for the current context."), [cuCtxSetLimit](<group__CUDA__CTX.html#group__CUDA__CTX_1g0651954dfb9788173e60a9af7201e65a> "Set resource limits."), [cuCtxSynchronize](<group__CUDA__CTX.html#group__CUDA__CTX_1g7a54725f28d34b8c6299f0c6ca579616> "Block for the current context's tasks to complete.")

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuCtxPushCurrent ( [CUcontext](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gf9f5bd81658f866613785b3a0bb7d7d9>)Â ctx )


Pushes a context on the current CPU thread.

######  Parameters

`ctx`
    \- Context to push

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_DEINITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9acf52f132faf29b473cdda6061f0f44a>), [CUDA_ERROR_NOT_INITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e98feb999f0af99b4a25ab26b3866f4df8>), [CUDA_ERROR_INVALID_CONTEXT](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a484e9af32c1e9893ff21f0e0191a12d>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>)

###### Description

Pushes the given context `ctx` onto the CPU thread's stack of current contexts. The specified context becomes the CPU thread's current context, so all CUDA functions that operate on the current context are affected.

The previous current context may be made current again by calling [cuCtxDestroy()](<group__CUDA__CTX.html#group__CUDA__CTX_1g27a365aebb0eb548166309f58a1e8b8e> "Destroy a CUDA context.") or [cuCtxPopCurrent()](<group__CUDA__CTX.html#group__CUDA__CTX_1g2fac188026a062d92e91a8687d0a7902> "Pops the current CUDA context from the current CPU thread.").

Note:

Note that this function may also return error codes from previous, asynchronous launches.

**See also:**

[cuCtxCreate](<group__CUDA__CTX.html#group__CUDA__CTX_1g77e9fb578caefca5ed15b4acebf35265> "Create a CUDA context."), [cuCtxDestroy](<group__CUDA__CTX.html#group__CUDA__CTX_1g27a365aebb0eb548166309f58a1e8b8e> "Destroy a CUDA context."), [cuCtxGetApiVersion](<group__CUDA__CTX.html#group__CUDA__CTX_1g088a90490dafca5893ef6fbebc8de8fb> "Gets the context's API version."), [cuCtxGetCacheConfig](<group__CUDA__CTX.html#group__CUDA__CTX_1g40b6b141698f76744dea6e39b9a25360> "Returns the preferred cache configuration for the current context."), [cuCtxGetDevice](<group__CUDA__CTX.html#group__CUDA__CTX_1g4e84b109eba36cdaaade167f34ae881e> "Returns the device handle for the current context."), [cuCtxGetFlags](<group__CUDA__CTX.html#group__CUDA__CTX_1gf81eef983c1e3b2ef4f166d7a930c86d> "Returns the flags for the current context."), [cuCtxGetLimit](<group__CUDA__CTX.html#group__CUDA__CTX_1g9f2d47d1745752aa16da7ed0d111b6a8> "Returns resource limits."), [cuCtxPopCurrent](<group__CUDA__CTX.html#group__CUDA__CTX_1g2fac188026a062d92e91a8687d0a7902> "Pops the current CUDA context from the current CPU thread."), [cuCtxSetCacheConfig](<group__CUDA__CTX.html#group__CUDA__CTX_1g54699acf7e2ef27279d013ca2095f4a3> "Sets the preferred cache configuration for the current context."), [cuCtxSetLimit](<group__CUDA__CTX.html#group__CUDA__CTX_1g0651954dfb9788173e60a9af7201e65a> "Set resource limits."), [cuCtxSynchronize](<group__CUDA__CTX.html#group__CUDA__CTX_1g7a54725f28d34b8c6299f0c6ca579616> "Block for the current context's tasks to complete.")

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuCtxRecordEvent ( [CUcontext](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gf9f5bd81658f866613785b3a0bb7d7d9>)Â hCtx, [CUevent](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g6d740185cf0953636d4ae37f68d7559b>)Â hEvent )


Records an event.

######  Parameters

`hCtx`
    \- Context to record event for
`hEvent`
    \- Event to record

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_DEINITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9acf52f132faf29b473cdda6061f0f44a>), [CUDA_ERROR_NOT_INITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e98feb999f0af99b4a25ab26b3866f4df8>), [CUDA_ERROR_INVALID_CONTEXT](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a484e9af32c1e9893ff21f0e0191a12d>), [CUDA_ERROR_INVALID_HANDLE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e90fd2e63260c6317ba943af0f7e4b8d21>), [CUDA_ERROR_STREAM_CAPTURE_UNSUPPORTED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9adf26f72a5e6589c7ade9af3b1b62e3d>)

###### Description

Captures in `hEvent` all the activities of the context `hCtx` at the time of this call. `hEvent` and `hCtx` must be from the same CUDA context, otherwise [CUDA_ERROR_INVALID_HANDLE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e90fd2e63260c6317ba943af0f7e4b8d21>) will be returned. Calls such as [cuEventQuery()](<group__CUDA__EVENT.html#group__CUDA__EVENT_1g6f0704d755066b0ee705749ae911deef> "Queries an event's status.") or [cuCtxWaitEvent()](<group__CUDA__CTX.html#group__CUDA__CTX_1gcf64e420275a8141b1f12bfce3f478f9> "Make a context wait on an event.") will then examine or wait for completion of the work that was captured. Uses of `hCtx` after this call do not modify `hEvent`. If the context passed to `hCtx` is the primary context, `hEvent` will capture all the activities of the primary context and its green contexts. If the context passed to `hCtx` is a context converted from green context via [cuCtxFromGreenCtx()](<group__CUDA__GREEN__CONTEXTS.html#group__CUDA__GREEN__CONTEXTS_1gf0779ec72ce1d5d7eb003d7d9b25afcb> "Converts a green context into the primary context."), `hEvent` will capture only the activities of the green context.

Note:

The API will return [CUDA_ERROR_STREAM_CAPTURE_UNSUPPORTED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9adf26f72a5e6589c7ade9af3b1b62e3d>) if the specified context `hCtx` has a stream in the capture mode. In such a case, the call will invalidate all the conflicting captures.

**See also:**

[cuCtxWaitEvent](<group__CUDA__CTX.html#group__CUDA__CTX_1gcf64e420275a8141b1f12bfce3f478f9> "Make a context wait on an event."), [cuGreenCtxRecordEvent](<group__CUDA__GREEN__CONTEXTS.html#group__CUDA__GREEN__CONTEXTS_1g9dd087071cc217ad7ebda6df96d2ee40> "Records an event."), [cuGreenCtxWaitEvent](<group__CUDA__GREEN__CONTEXTS.html#group__CUDA__GREEN__CONTEXTS_1g6b26172117084fd024f1396fb66a8ffd> "Make a green context wait on an event."), [cuEventRecord](<group__CUDA__EVENT.html#group__CUDA__EVENT_1g95424d3be52c4eb95d83861b70fb89d1> "Records an event.")

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuCtxResetPersistingL2Cache ( void )


Resets all persisting lines in cache to normal status.

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_NOT_SUPPORTED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e954756ae7ade0dfd09faeccb513dd831b>)

###### Description

[cuCtxResetPersistingL2Cache](<group__CUDA__CTX.html#group__CUDA__CTX_1gb529532b5b1aef808295a6d1d18a0823> "Resets all persisting lines in cache to normal status.") Resets all persisting lines in cache to normal status. Takes effect on function return.

Note:

Note that this function may also return error codes from previous, asynchronous launches.

**See also:**

[CUaccessPolicyWindow](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g1838e6438f39944217e384bf2adad477>)

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuCtxSetCacheConfig ( [CUfunc_cache](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g3b9bbcf42528b889e9dbe9cfa2aea3ec>)Â config )


Sets the preferred cache configuration for the current context.

######  Parameters

`config`
    \- Requested cache configuration

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_DEINITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9acf52f132faf29b473cdda6061f0f44a>), [CUDA_ERROR_NOT_INITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e98feb999f0af99b4a25ab26b3866f4df8>), [CUDA_ERROR_INVALID_CONTEXT](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a484e9af32c1e9893ff21f0e0191a12d>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>)

###### Description

On devices where the L1 cache and shared memory use the same hardware resources, this sets through `config` the preferred cache configuration for the current context. This is only a preference. The driver will use the requested configuration if possible, but it is free to choose a different configuration if required to execute the function. Any function preference set via [cuFuncSetCacheConfig()](<group__CUDA__EXEC.html#group__CUDA__EXEC_1g40f8c11e81def95dc0072a375f965681> "Sets the preferred cache configuration for a device function.") or [cuKernelSetCacheConfig()](<group__CUDA__LIBRARY.html#group__CUDA__LIBRARY_1g8490476e5d3573c7ede78f29bd8cde51> "Sets the preferred cache configuration for a device kernel.") will be preferred over this context-wide setting. Setting the context-wide cache configuration to [CU_FUNC_CACHE_PREFER_NONE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg3b9bbcf42528b889e9dbe9cfa2aea3ec47d2f367dc3965c27ff748688229dc22>) will cause subsequent kernel launches to prefer to not change the cache configuration unless required to launch the kernel.

This setting does nothing on devices where the size of the L1 cache and shared memory are fixed.

Launching a kernel with a different preference than the most recent preference setting may insert a device-side synchronization point.

The supported cache configurations are:

  * [CU_FUNC_CACHE_PREFER_NONE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg3b9bbcf42528b889e9dbe9cfa2aea3ec47d2f367dc3965c27ff748688229dc22>): no preference for shared memory or L1 (default)

  * [CU_FUNC_CACHE_PREFER_SHARED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg3b9bbcf42528b889e9dbe9cfa2aea3ec712f43defb051d7985317bce426cccc8>): prefer larger shared memory and smaller L1 cache

  * [CU_FUNC_CACHE_PREFER_L1](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg3b9bbcf42528b889e9dbe9cfa2aea3ecb1e6c4e889e1a70ed5283172be08f6a5>): prefer larger L1 cache and smaller shared memory

  * [CU_FUNC_CACHE_PREFER_EQUAL](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg3b9bbcf42528b889e9dbe9cfa2aea3ec4434321280821d844a15b02e4d6c80a9>): prefer equal sized L1 cache and shared memory


Note:

Note that this function may also return error codes from previous, asynchronous launches.

**See also:**

[cuCtxCreate](<group__CUDA__CTX.html#group__CUDA__CTX_1g77e9fb578caefca5ed15b4acebf35265> "Create a CUDA context."), [cuCtxDestroy](<group__CUDA__CTX.html#group__CUDA__CTX_1g27a365aebb0eb548166309f58a1e8b8e> "Destroy a CUDA context."), [cuCtxGetApiVersion](<group__CUDA__CTX.html#group__CUDA__CTX_1g088a90490dafca5893ef6fbebc8de8fb> "Gets the context's API version."), [cuCtxGetCacheConfig](<group__CUDA__CTX.html#group__CUDA__CTX_1g40b6b141698f76744dea6e39b9a25360> "Returns the preferred cache configuration for the current context."), [cuCtxGetDevice](<group__CUDA__CTX.html#group__CUDA__CTX_1g4e84b109eba36cdaaade167f34ae881e> "Returns the device handle for the current context."), [cuCtxGetFlags](<group__CUDA__CTX.html#group__CUDA__CTX_1gf81eef983c1e3b2ef4f166d7a930c86d> "Returns the flags for the current context."), [cuCtxGetLimit](<group__CUDA__CTX.html#group__CUDA__CTX_1g9f2d47d1745752aa16da7ed0d111b6a8> "Returns resource limits."), [cuCtxPopCurrent](<group__CUDA__CTX.html#group__CUDA__CTX_1g2fac188026a062d92e91a8687d0a7902> "Pops the current CUDA context from the current CPU thread."), [cuCtxPushCurrent](<group__CUDA__CTX.html#group__CUDA__CTX_1gb02d4c850eb16f861fe5a29682cc90ba> "Pushes a context on the current CPU thread."), [cuCtxSetLimit](<group__CUDA__CTX.html#group__CUDA__CTX_1g0651954dfb9788173e60a9af7201e65a> "Set resource limits."), [cuCtxSynchronize](<group__CUDA__CTX.html#group__CUDA__CTX_1g7a54725f28d34b8c6299f0c6ca579616> "Block for the current context's tasks to complete."), [cuFuncSetCacheConfig](<group__CUDA__EXEC.html#group__CUDA__EXEC_1g40f8c11e81def95dc0072a375f965681> "Sets the preferred cache configuration for a device function."), [cudaDeviceSetCacheConfig](<../cuda-runtime-api/group__CUDART__DEVICE.html#group__CUDART__DEVICE_1g6c9cc78ca80490386cf593b4baa35a15>), [cuKernelSetCacheConfig](<group__CUDA__LIBRARY.html#group__CUDA__LIBRARY_1g8490476e5d3573c7ede78f29bd8cde51> "Sets the preferred cache configuration for a device kernel.")

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuCtxSetCurrent ( [CUcontext](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gf9f5bd81658f866613785b3a0bb7d7d9>)Â ctx )


Binds the specified CUDA context to the calling CPU thread.

######  Parameters

`ctx`
    \- Context to bind to the calling CPU thread

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_DEINITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9acf52f132faf29b473cdda6061f0f44a>), [CUDA_ERROR_NOT_INITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e98feb999f0af99b4a25ab26b3866f4df8>), [CUDA_ERROR_INVALID_CONTEXT](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a484e9af32c1e9893ff21f0e0191a12d>)

###### Description

Binds the specified CUDA context to the calling CPU thread. If `ctx` is NULL then the CUDA context previously bound to the calling CPU thread is unbound and [CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>) is returned.

If there exists a CUDA context stack on the calling CPU thread, this will replace the top of that stack with `ctx`. If `ctx` is NULL then this will be equivalent to popping the top of the calling CPU thread's CUDA context stack (or a no-op if the calling CPU thread's CUDA context stack is empty).

Note:

Note that this function may also return error codes from previous, asynchronous launches.

**See also:**

[cuCtxGetCurrent](<group__CUDA__CTX.html#group__CUDA__CTX_1g8f13165846b73750693640fb3e8380d0> "Returns the CUDA context bound to the calling CPU thread."), [cuCtxCreate](<group__CUDA__CTX.html#group__CUDA__CTX_1g77e9fb578caefca5ed15b4acebf35265> "Create a CUDA context."), [cuCtxDestroy](<group__CUDA__CTX.html#group__CUDA__CTX_1g27a365aebb0eb548166309f58a1e8b8e> "Destroy a CUDA context."), [cudaSetDevice](<../cuda-runtime-api/group__CUDART__DEVICE.html#group__CUDART__DEVICE_1g159587909ffa0791bbe4b40187a4c6bb>)

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuCtxSetFlags ( unsigned int Â flags )


Sets the flags for the current context.

######  Parameters

`flags`
    \- Flags to set on the current context

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_DEINITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9acf52f132faf29b473cdda6061f0f44a>), [CUDA_ERROR_NOT_INITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e98feb999f0af99b4a25ab26b3866f4df8>), [CUDA_ERROR_INVALID_CONTEXT](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a484e9af32c1e9893ff21f0e0191a12d>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>),

###### Description

Sets the flags for the current context overwriting previously set ones. See [cuDevicePrimaryCtxSetFlags](<group__CUDA__PRIMARY__CTX.html#group__CUDA__PRIMARY__CTX_1gd779a84f17acdad0d9143d9fe719cfdf> "Set flags for the primary context.") for flag values.

Note:

Note that this function may also return error codes from previous, asynchronous launches.

**See also:**

[cuCtxCreate](<group__CUDA__CTX.html#group__CUDA__CTX_1g77e9fb578caefca5ed15b4acebf35265> "Create a CUDA context."), [cuCtxGetApiVersion](<group__CUDA__CTX.html#group__CUDA__CTX_1g088a90490dafca5893ef6fbebc8de8fb> "Gets the context's API version."), [cuCtxGetCacheConfig](<group__CUDA__CTX.html#group__CUDA__CTX_1g40b6b141698f76744dea6e39b9a25360> "Returns the preferred cache configuration for the current context."), [cuCtxGetCurrent](<group__CUDA__CTX.html#group__CUDA__CTX_1g8f13165846b73750693640fb3e8380d0> "Returns the CUDA context bound to the calling CPU thread."), [cuCtxGetDevice](<group__CUDA__CTX.html#group__CUDA__CTX_1g4e84b109eba36cdaaade167f34ae881e> "Returns the device handle for the current context."), [cuCtxGetLimit](<group__CUDA__CTX.html#group__CUDA__CTX_1g9f2d47d1745752aa16da7ed0d111b6a8> "Returns resource limits."), [cuCtxGetSharedMemConfig](<group__CUDA__CTX__DEPRECATED.html#group__CUDA__CTX__DEPRECATED_1gfac1414497a1a2a40bba474c6b5bf194> "Returns the current shared memory configuration for the current context."), [cuCtxGetStreamPriorityRange](<group__CUDA__CTX.html#group__CUDA__CTX_1g137920ab61a71be6ce67605b9f294091> "Returns numerical values that correspond to the least and greatest stream priorities."), [cuCtxGetFlags](<group__CUDA__CTX.html#group__CUDA__CTX_1gf81eef983c1e3b2ef4f166d7a930c86d> "Returns the flags for the current context."), [cudaGetDeviceFlags](<../cuda-runtime-api/group__CUDART__DEVICE.html#group__CUDART__DEVICE_1gf830794caf068b71638c6182bba8f77a>), [cuDevicePrimaryCtxSetFlags](<group__CUDA__PRIMARY__CTX.html#group__CUDA__PRIMARY__CTX_1gd779a84f17acdad0d9143d9fe719cfdf> "Set flags for the primary context."),

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuCtxSetLimit ( [CUlimit](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ge24c2d4214af24139020f1aecaf32665>)Â limit, size_tÂ value )


Set resource limits.

######  Parameters

`limit`
    \- Limit to set
`value`
    \- Size of limit

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>), [CUDA_ERROR_UNSUPPORTED_LIMIT](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9d10e6e6ef4b01290d2202d43c3ca6821>), [CUDA_ERROR_OUT_OF_MEMORY](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9264c50688ed110e8476b591befe60c02>), [CUDA_ERROR_INVALID_CONTEXT](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a484e9af32c1e9893ff21f0e0191a12d>)

###### Description

Setting `limit` to `value` is a request by the application to update the current limit maintained by the context. The driver is free to modify the requested value to meet h/w requirements (this could be clamping to minimum or maximum values, rounding up to nearest element size, etc). The application can use [cuCtxGetLimit()](<group__CUDA__CTX.html#group__CUDA__CTX_1g9f2d47d1745752aa16da7ed0d111b6a8> "Returns resource limits.") to find out exactly what the limit has been set to.

Setting each [CUlimit](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ge24c2d4214af24139020f1aecaf32665>) has its own specific restrictions, so each is discussed here.

  * [CU_LIMIT_STACK_SIZE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gge24c2d4214af24139020f1aecaf32665ebe51e384a8b4b79459915bb1c31bc39>) controls the stack size in bytes of each GPU thread. The driver automatically increases the per-thread stack size for each kernel launch as needed. This size isn't reset back to the original value after each launch. Setting this value will take effect immediately, and if necessary, the device will block until all preceding requested tasks are complete.


  * [CU_LIMIT_PRINTF_FIFO_SIZE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gge24c2d4214af24139020f1aecaf3266516f25aa2c37a06580ab533d8ae7db948>) controls the size in bytes of the FIFO used by the printf() device system call. Setting [CU_LIMIT_PRINTF_FIFO_SIZE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gge24c2d4214af24139020f1aecaf3266516f25aa2c37a06580ab533d8ae7db948>) must be performed before launching any kernel that uses the printf() device system call, otherwise [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>) will be returned.


  * [CU_LIMIT_MALLOC_HEAP_SIZE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gge24c2d4214af24139020f1aecaf3266586d01dbc431b04edd5d618257aaa246b>) controls the size in bytes of the heap used by the malloc() and free() device system calls. Setting [CU_LIMIT_MALLOC_HEAP_SIZE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gge24c2d4214af24139020f1aecaf3266586d01dbc431b04edd5d618257aaa246b>) must be performed before launching any kernel that uses the malloc() or free() device system calls, otherwise [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>) will be returned.


  * [CU_LIMIT_DEV_RUNTIME_SYNC_DEPTH](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gge24c2d4214af24139020f1aecaf32665592fb752cc173ad7a2a4026a40e38079>) controls the maximum nesting depth of a grid at which a thread can safely call [cudaDeviceSynchronize()](<../cuda-runtime-api/group__CUDART__DEVICE.html#group__CUDART__DEVICE_1g10e20b05a95f638a4071a655503df25d>). Setting this limit must be performed before any launch of a kernel that uses the device runtime and calls [cudaDeviceSynchronize()](<../cuda-runtime-api/group__CUDART__DEVICE.html#group__CUDART__DEVICE_1g10e20b05a95f638a4071a655503df25d>) above the default sync depth, two levels of grids. Calls to [cudaDeviceSynchronize()](<../cuda-runtime-api/group__CUDART__DEVICE.html#group__CUDART__DEVICE_1g10e20b05a95f638a4071a655503df25d>) will fail with error code [cudaErrorSyncDepthExceeded](<../cuda-runtime-api/group__CUDART__TYPES.html#group__CUDART__TYPES_1gg3f51e3575c2178246db0a94a430e0038265dbf94c45903cd582cfc40f93a176a>) if the limitation is violated. This limit can be set smaller than the default or up the maximum launch depth of 24. When setting this limit, keep in mind that additional levels of sync depth require the driver to reserve large amounts of device memory which can no longer be used for user allocations. If these reservations of device memory fail, [cuCtxSetLimit()](<group__CUDA__CTX.html#group__CUDA__CTX_1g0651954dfb9788173e60a9af7201e65a> "Set resource limits.") will return [CUDA_ERROR_OUT_OF_MEMORY](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9264c50688ed110e8476b591befe60c02>), and the limit can be reset to a lower value. This limit is only applicable to devices of compute capability < 9.0. Attempting to set this limit on devices of other compute capability versions will result in the error [CUDA_ERROR_UNSUPPORTED_LIMIT](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9d10e6e6ef4b01290d2202d43c3ca6821>) being returned.


  * [CU_LIMIT_DEV_RUNTIME_PENDING_LAUNCH_COUNT](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gge24c2d4214af24139020f1aecaf32665f79d7134ee03d52c0d8b1aecda1ae446>) controls the maximum number of outstanding device runtime launches that can be made from the current context. A grid is outstanding from the point of launch up until the grid is known to have been completed. Device runtime launches which violate this limitation fail and return [cudaErrorLaunchPendingCountExceeded](<../cuda-runtime-api/group__CUDART__TYPES.html#group__CUDART__TYPES_1gg3f51e3575c2178246db0a94a430e00382372902b9ffd65825d138e16125b1376>) when [cudaGetLastError()](<../cuda-runtime-api/group__CUDART__ERROR.html#group__CUDART__ERROR_1g3529f94cb530a83a76613616782bd233>) is called after launch. If more pending launches than the default (2048 launches) are needed for a module using the device runtime, this limit can be increased. Keep in mind that being able to sustain additional pending launches will require the driver to reserve larger amounts of device memory upfront which can no longer be used for allocations. If these reservations fail, [cuCtxSetLimit()](<group__CUDA__CTX.html#group__CUDA__CTX_1g0651954dfb9788173e60a9af7201e65a> "Set resource limits.") will return [CUDA_ERROR_OUT_OF_MEMORY](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9264c50688ed110e8476b591befe60c02>), and the limit can be reset to a lower value. This limit is only applicable to devices of compute capability 3.5 and higher. Attempting to set this limit on devices of compute capability less than 3.5 will result in the error [CUDA_ERROR_UNSUPPORTED_LIMIT](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9d10e6e6ef4b01290d2202d43c3ca6821>) being returned.


  * [CU_LIMIT_MAX_L2_FETCH_GRANULARITY](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gge24c2d4214af24139020f1aecaf32665e75d95ea7dac6821de11d122d77f390b>) controls the L2 cache fetch granularity. Values can range from 0B to 128B. This is purely a performance hint and it can be ignored or clamped depending on the platform.


  * [CU_LIMIT_PERSISTING_L2_CACHE_SIZE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gge24c2d4214af24139020f1aecaf3266519ef5d58846147f46cdb4a2a886f3682>) controls size in bytes available for persisting L2 cache. This is purely a performance hint and it can be ignored or clamped depending on the platform.


Note:

Note that this function may also return error codes from previous, asynchronous launches.

**See also:**

[cuCtxCreate](<group__CUDA__CTX.html#group__CUDA__CTX_1g77e9fb578caefca5ed15b4acebf35265> "Create a CUDA context."), [cuCtxDestroy](<group__CUDA__CTX.html#group__CUDA__CTX_1g27a365aebb0eb548166309f58a1e8b8e> "Destroy a CUDA context."), [cuCtxGetApiVersion](<group__CUDA__CTX.html#group__CUDA__CTX_1g088a90490dafca5893ef6fbebc8de8fb> "Gets the context's API version."), [cuCtxGetCacheConfig](<group__CUDA__CTX.html#group__CUDA__CTX_1g40b6b141698f76744dea6e39b9a25360> "Returns the preferred cache configuration for the current context."), [cuCtxGetDevice](<group__CUDA__CTX.html#group__CUDA__CTX_1g4e84b109eba36cdaaade167f34ae881e> "Returns the device handle for the current context."), [cuCtxGetFlags](<group__CUDA__CTX.html#group__CUDA__CTX_1gf81eef983c1e3b2ef4f166d7a930c86d> "Returns the flags for the current context."), [cuCtxGetLimit](<group__CUDA__CTX.html#group__CUDA__CTX_1g9f2d47d1745752aa16da7ed0d111b6a8> "Returns resource limits."), [cuCtxPopCurrent](<group__CUDA__CTX.html#group__CUDA__CTX_1g2fac188026a062d92e91a8687d0a7902> "Pops the current CUDA context from the current CPU thread."), [cuCtxPushCurrent](<group__CUDA__CTX.html#group__CUDA__CTX_1gb02d4c850eb16f861fe5a29682cc90ba> "Pushes a context on the current CPU thread."), [cuCtxSetCacheConfig](<group__CUDA__CTX.html#group__CUDA__CTX_1g54699acf7e2ef27279d013ca2095f4a3> "Sets the preferred cache configuration for the current context."), [cuCtxSynchronize](<group__CUDA__CTX.html#group__CUDA__CTX_1g7a54725f28d34b8c6299f0c6ca579616> "Block for the current context's tasks to complete."), [cudaDeviceSetLimit](<../cuda-runtime-api/group__CUDART__DEVICE.html#group__CUDART__DEVICE_1g05956f16eaa47ef3a4efee84563ccb7d>)

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuCtxSynchronize ( void )


Block for the current context's tasks to complete.

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_DEINITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9acf52f132faf29b473cdda6061f0f44a>), [CUDA_ERROR_NOT_INITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e98feb999f0af99b4a25ab26b3866f4df8>), [CUDA_ERROR_INVALID_CONTEXT](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a484e9af32c1e9893ff21f0e0191a12d>), [CUDA_ERROR_STREAM_CAPTURE_UNSUPPORTED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9adf26f72a5e6589c7ade9af3b1b62e3d>)

###### Description

Blocks until the current context has completed all preceding requested tasks. If the current context is the primary context, green contexts that have been created will also be synchronized. [cuCtxSynchronize()](<group__CUDA__CTX.html#group__CUDA__CTX_1g7a54725f28d34b8c6299f0c6ca579616> "Block for the current context's tasks to complete.") returns an error if one of the preceding tasks failed. If the context was created with the [CU_CTX_SCHED_BLOCKING_SYNC](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg9f889e28a45a295b5c8ce13aa05f6cd462aebfe6432ade3feb32f1a409027852>) flag, the CPU thread will block until the GPU context has finished its work.

Note:

Note that this function may also return error codes from previous, asynchronous launches.

**See also:**

[cuCtxCreate](<group__CUDA__CTX.html#group__CUDA__CTX_1g77e9fb578caefca5ed15b4acebf35265> "Create a CUDA context."), [cuCtxDestroy](<group__CUDA__CTX.html#group__CUDA__CTX_1g27a365aebb0eb548166309f58a1e8b8e> "Destroy a CUDA context."), [cuCtxGetApiVersion](<group__CUDA__CTX.html#group__CUDA__CTX_1g088a90490dafca5893ef6fbebc8de8fb> "Gets the context's API version."), [cuCtxGetCacheConfig](<group__CUDA__CTX.html#group__CUDA__CTX_1g40b6b141698f76744dea6e39b9a25360> "Returns the preferred cache configuration for the current context."), [cuCtxGetDevice](<group__CUDA__CTX.html#group__CUDA__CTX_1g4e84b109eba36cdaaade167f34ae881e> "Returns the device handle for the current context."), [cuCtxGetFlags](<group__CUDA__CTX.html#group__CUDA__CTX_1gf81eef983c1e3b2ef4f166d7a930c86d> "Returns the flags for the current context."), [cuCtxGetLimit](<group__CUDA__CTX.html#group__CUDA__CTX_1g9f2d47d1745752aa16da7ed0d111b6a8> "Returns resource limits."), [cuCtxPopCurrent](<group__CUDA__CTX.html#group__CUDA__CTX_1g2fac188026a062d92e91a8687d0a7902> "Pops the current CUDA context from the current CPU thread."), [cuCtxPushCurrent](<group__CUDA__CTX.html#group__CUDA__CTX_1gb02d4c850eb16f861fe5a29682cc90ba> "Pushes a context on the current CPU thread."), [cuCtxSetCacheConfig](<group__CUDA__CTX.html#group__CUDA__CTX_1g54699acf7e2ef27279d013ca2095f4a3> "Sets the preferred cache configuration for the current context."), [cuCtxSetLimit](<group__CUDA__CTX.html#group__CUDA__CTX_1g0651954dfb9788173e60a9af7201e65a> "Set resource limits."), [cudaDeviceSynchronize](<../cuda-runtime-api/group__CUDART__DEVICE.html#group__CUDART__DEVICE_1g10e20b05a95f638a4071a655503df25d>)

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuCtxSynchronize_v2 ( [CUcontext](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gf9f5bd81658f866613785b3a0bb7d7d9>)Â ctx )


Block for the specified context's tasks to complete.

######  Parameters

`ctx`
    \- Context to synchronize

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_DEINITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9acf52f132faf29b473cdda6061f0f44a>), [CUDA_ERROR_NOT_INITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e98feb999f0af99b4a25ab26b3866f4df8>), [CUDA_ERROR_INVALID_CONTEXT](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a484e9af32c1e9893ff21f0e0191a12d>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>), [CUDA_ERROR_STREAM_CAPTURE_UNSUPPORTED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9adf26f72a5e6589c7ade9af3b1b62e3d>)

###### Description

Blocks until the specified context has completed all preceding requested tasks. If the specified context is the primary context, green contexts that have been created will also be synchronized. The API returns an error if one of the preceding tasks failed.

If the context was created with the [CU_CTX_SCHED_BLOCKING_SYNC](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg9f889e28a45a295b5c8ce13aa05f6cd462aebfe6432ade3feb32f1a409027852>) flag, the CPU thread will block until the GPU context has finished its work.

If the specified context is NULL, the API will operate on the current context.

Note:

Note that this function may also return error codes from previous, asynchronous launches.

**See also:**

[cuCtxGetCurrent](<group__CUDA__CTX.html#group__CUDA__CTX_1g8f13165846b73750693640fb3e8380d0> "Returns the CUDA context bound to the calling CPU thread."), [cuCtxPopCurrent](<group__CUDA__CTX.html#group__CUDA__CTX_1g2fac188026a062d92e91a8687d0a7902> "Pops the current CUDA context from the current CPU thread."), [cuCtxPushCurrent](<group__CUDA__CTX.html#group__CUDA__CTX_1gb02d4c850eb16f861fe5a29682cc90ba> "Pushes a context on the current CPU thread."), [cuGreenCtxCreate](<group__CUDA__GREEN__CONTEXTS.html#group__CUDA__GREEN__CONTEXTS_1ga6da4f9959fd48d1f1a5cbedbec54e65> "Creates a green context with a specified set of resources."), [cuCtxFromGreenCtx](<group__CUDA__GREEN__CONTEXTS.html#group__CUDA__GREEN__CONTEXTS_1gf0779ec72ce1d5d7eb003d7d9b25afcb> "Converts a green context into the primary context."), [cudaDeviceSynchronize](<../cuda-runtime-api/group__CUDART__DEVICE.html#group__CUDART__DEVICE_1g10e20b05a95f638a4071a655503df25d>)

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuCtxWaitEvent ( [CUcontext](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gf9f5bd81658f866613785b3a0bb7d7d9>)Â hCtx, [CUevent](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g6d740185cf0953636d4ae37f68d7559b>)Â hEvent )


Make a context wait on an event.

######  Parameters

`hCtx`
    \- Context to wait
`hEvent`
    \- Event to wait on

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_DEINITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9acf52f132faf29b473cdda6061f0f44a>), [CUDA_ERROR_NOT_INITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e98feb999f0af99b4a25ab26b3866f4df8>), [CUDA_ERROR_INVALID_CONTEXT](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a484e9af32c1e9893ff21f0e0191a12d>), [CUDA_ERROR_INVALID_HANDLE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e90fd2e63260c6317ba943af0f7e4b8d21>), [CUDA_ERROR_STREAM_CAPTURE_UNSUPPORTED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9adf26f72a5e6589c7ade9af3b1b62e3d>)

###### Description

Makes all future work submitted to context `hCtx` wait for all work captured in `hEvent`. The synchronization will be performed on the device and will not block the calling CPU thread. See [cuCtxRecordEvent()](<group__CUDA__CTX.html#group__CUDA__CTX_1gf3ee63561a7a371fa9d4dc0e31f94afd> "Records an event.") for details on what is captured by an event. If the context passed to `hCtx` is the primary context, the primary context and its green contexts will wait for `hEvent`. If the context passed to `hCtx` is a context converted from green context via [cuCtxFromGreenCtx()](<group__CUDA__GREEN__CONTEXTS.html#group__CUDA__GREEN__CONTEXTS_1gf0779ec72ce1d5d7eb003d7d9b25afcb> "Converts a green context into the primary context."), the green context will wait for `hEvent`.

Note:

  * `hEvent` may be from a different context or device than `hCtx`.

  * The API will return [CUDA_ERROR_STREAM_CAPTURE_UNSUPPORTED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9adf26f72a5e6589c7ade9af3b1b62e3d>) and invalidate the capture if the specified event `hEvent` is part of an ongoing capture sequence or if the specified context `hCtx` has a stream in the capture mode.


**See also:**

[cuCtxRecordEvent](<group__CUDA__CTX.html#group__CUDA__CTX_1gf3ee63561a7a371fa9d4dc0e31f94afd> "Records an event."), [cuGreenCtxRecordEvent](<group__CUDA__GREEN__CONTEXTS.html#group__CUDA__GREEN__CONTEXTS_1g9dd087071cc217ad7ebda6df96d2ee40> "Records an event."), [cuGreenCtxWaitEvent](<group__CUDA__GREEN__CONTEXTS.html#group__CUDA__GREEN__CONTEXTS_1g6b26172117084fd024f1396fb66a8ffd> "Make a green context wait on an event."), [cuStreamWaitEvent](<group__CUDA__STREAM.html#group__CUDA__STREAM_1g6a898b652dfc6aa1d5c8d97062618b2f> "Make a compute stream wait on an event.")

* * *


---

# Context Management (Deprecated)

## 6.9.Â Context Management [DEPRECATED]

This section describes the deprecated context management functions of the low-level CUDA driver application programming interface.

### Functions

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuCtxAttach](<#group__CUDA__CTX__DEPRECATED_1g3c9b7c5833d57e7ccea5aeaba6009f5d>) ( [CUcontext](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gf9f5bd81658f866613785b3a0bb7d7d9>)*Â pctx, unsigned int Â flags )
     Increment a context's usage-count.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuCtxDetach](<#group__CUDA__CTX__DEPRECATED_1g2da7d6b2651b46896871a068e2860551>) ( [CUcontext](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gf9f5bd81658f866613785b3a0bb7d7d9>)Â ctx )
     Decrement a context's usage-count.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuCtxGetSharedMemConfig](<#group__CUDA__CTX__DEPRECATED_1gfac1414497a1a2a40bba474c6b5bf194>) ( [CUsharedconfig](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g92d66e95f602cb9fdaf0682c260c241b>)*Â pConfig )
     Returns the current shared memory configuration for the current context.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuCtxSetSharedMemConfig](<#group__CUDA__CTX__DEPRECATED_1gb1fef6f9fd5c252245214f85ae01ec23>) ( [CUsharedconfig](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g92d66e95f602cb9fdaf0682c260c241b>)Â config )
     Sets the shared memory configuration for the current context.

### Functions

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuCtxAttach ( [CUcontext](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gf9f5bd81658f866613785b3a0bb7d7d9>)*Â pctx, unsigned int Â flags )


Increment a context's usage-count.

######  Parameters

`pctx`
    \- Returned context handle of the current context
`flags`
    \- Context attach flags (must be 0)

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_DEINITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9acf52f132faf29b473cdda6061f0f44a>), [CUDA_ERROR_NOT_INITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e98feb999f0af99b4a25ab26b3866f4df8>), [CUDA_ERROR_INVALID_CONTEXT](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a484e9af32c1e9893ff21f0e0191a12d>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>)

###### [Deprecated](<deprecated.html#deprecated__deprecated_1_deprecated000004>)

Note that this function is deprecated and should not be used.

###### Description

Increments the usage count of the context and passes back a context handle in `*pctx` that must be passed to [cuCtxDetach()](<group__CUDA__CTX__DEPRECATED.html#group__CUDA__CTX__DEPRECATED_1g2da7d6b2651b46896871a068e2860551> "Decrement a context's usage-count.") when the application is done with the context. [cuCtxAttach()](<group__CUDA__CTX__DEPRECATED.html#group__CUDA__CTX__DEPRECATED_1g3c9b7c5833d57e7ccea5aeaba6009f5d> "Increment a context's usage-count.") fails if there is no context current to the thread.

Currently, the `flags` parameter must be 0.

Note:

Note that this function may also return error codes from previous, asynchronous launches.

**See also:**

[cuCtxCreate](<group__CUDA__CTX.html#group__CUDA__CTX_1g77e9fb578caefca5ed15b4acebf35265> "Create a CUDA context."), [cuCtxDestroy](<group__CUDA__CTX.html#group__CUDA__CTX_1g27a365aebb0eb548166309f58a1e8b8e> "Destroy a CUDA context."), [cuCtxDetach](<group__CUDA__CTX__DEPRECATED.html#group__CUDA__CTX__DEPRECATED_1g2da7d6b2651b46896871a068e2860551> "Decrement a context's usage-count."), [cuCtxGetApiVersion](<group__CUDA__CTX.html#group__CUDA__CTX_1g088a90490dafca5893ef6fbebc8de8fb> "Gets the context's API version."), [cuCtxGetCacheConfig](<group__CUDA__CTX.html#group__CUDA__CTX_1g40b6b141698f76744dea6e39b9a25360> "Returns the preferred cache configuration for the current context."), [cuCtxGetDevice](<group__CUDA__CTX.html#group__CUDA__CTX_1g4e84b109eba36cdaaade167f34ae881e> "Returns the device handle for the current context."), [cuCtxGetFlags](<group__CUDA__CTX.html#group__CUDA__CTX_1gf81eef983c1e3b2ef4f166d7a930c86d> "Returns the flags for the current context."), [cuCtxGetLimit](<group__CUDA__CTX.html#group__CUDA__CTX_1g9f2d47d1745752aa16da7ed0d111b6a8> "Returns resource limits."), [cuCtxPopCurrent](<group__CUDA__CTX.html#group__CUDA__CTX_1g2fac188026a062d92e91a8687d0a7902> "Pops the current CUDA context from the current CPU thread."), [cuCtxPushCurrent](<group__CUDA__CTX.html#group__CUDA__CTX_1gb02d4c850eb16f861fe5a29682cc90ba> "Pushes a context on the current CPU thread."), [cuCtxSetCacheConfig](<group__CUDA__CTX.html#group__CUDA__CTX_1g54699acf7e2ef27279d013ca2095f4a3> "Sets the preferred cache configuration for the current context."), [cuCtxSetLimit](<group__CUDA__CTX.html#group__CUDA__CTX_1g0651954dfb9788173e60a9af7201e65a> "Set resource limits."), [cuCtxSynchronize](<group__CUDA__CTX.html#group__CUDA__CTX_1g7a54725f28d34b8c6299f0c6ca579616> "Block for the current context's tasks to complete.")

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuCtxDetach ( [CUcontext](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gf9f5bd81658f866613785b3a0bb7d7d9>)Â ctx )


Decrement a context's usage-count.

######  Parameters

`ctx`
    \- Context to destroy

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_DEINITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9acf52f132faf29b473cdda6061f0f44a>), [CUDA_ERROR_NOT_INITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e98feb999f0af99b4a25ab26b3866f4df8>), [CUDA_ERROR_INVALID_CONTEXT](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a484e9af32c1e9893ff21f0e0191a12d>)

###### [Deprecated](<deprecated.html#deprecated__deprecated_1_deprecated000005>)

Note that this function is deprecated and should not be used.

###### Description

Decrements the usage count of the context `ctx`, and destroys the context if the usage count goes to 0. The context must be a handle that was passed back by [cuCtxCreate()](<group__CUDA__CTX.html#group__CUDA__CTX_1g77e9fb578caefca5ed15b4acebf35265> "Create a CUDA context.") or [cuCtxAttach()](<group__CUDA__CTX__DEPRECATED.html#group__CUDA__CTX__DEPRECATED_1g3c9b7c5833d57e7ccea5aeaba6009f5d> "Increment a context's usage-count."), and must be current to the calling thread.

Note:

Note that this function may also return error codes from previous, asynchronous launches.

**See also:**

[cuCtxCreate](<group__CUDA__CTX.html#group__CUDA__CTX_1g77e9fb578caefca5ed15b4acebf35265> "Create a CUDA context."), [cuCtxDestroy](<group__CUDA__CTX.html#group__CUDA__CTX_1g27a365aebb0eb548166309f58a1e8b8e> "Destroy a CUDA context."), [cuCtxGetApiVersion](<group__CUDA__CTX.html#group__CUDA__CTX_1g088a90490dafca5893ef6fbebc8de8fb> "Gets the context's API version."), [cuCtxGetCacheConfig](<group__CUDA__CTX.html#group__CUDA__CTX_1g40b6b141698f76744dea6e39b9a25360> "Returns the preferred cache configuration for the current context."), [cuCtxGetDevice](<group__CUDA__CTX.html#group__CUDA__CTX_1g4e84b109eba36cdaaade167f34ae881e> "Returns the device handle for the current context."), [cuCtxGetFlags](<group__CUDA__CTX.html#group__CUDA__CTX_1gf81eef983c1e3b2ef4f166d7a930c86d> "Returns the flags for the current context."), [cuCtxGetLimit](<group__CUDA__CTX.html#group__CUDA__CTX_1g9f2d47d1745752aa16da7ed0d111b6a8> "Returns resource limits."), [cuCtxPopCurrent](<group__CUDA__CTX.html#group__CUDA__CTX_1g2fac188026a062d92e91a8687d0a7902> "Pops the current CUDA context from the current CPU thread."), [cuCtxPushCurrent](<group__CUDA__CTX.html#group__CUDA__CTX_1gb02d4c850eb16f861fe5a29682cc90ba> "Pushes a context on the current CPU thread."), [cuCtxSetCacheConfig](<group__CUDA__CTX.html#group__CUDA__CTX_1g54699acf7e2ef27279d013ca2095f4a3> "Sets the preferred cache configuration for the current context."), [cuCtxSetLimit](<group__CUDA__CTX.html#group__CUDA__CTX_1g0651954dfb9788173e60a9af7201e65a> "Set resource limits."), [cuCtxSynchronize](<group__CUDA__CTX.html#group__CUDA__CTX_1g7a54725f28d34b8c6299f0c6ca579616> "Block for the current context's tasks to complete.")

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuCtxGetSharedMemConfig ( [CUsharedconfig](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g92d66e95f602cb9fdaf0682c260c241b>)*Â pConfig )


Returns the current shared memory configuration for the current context.

######  Parameters

`pConfig`
    \- returned shared memory configuration

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_DEINITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9acf52f132faf29b473cdda6061f0f44a>), [CUDA_ERROR_NOT_INITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e98feb999f0af99b4a25ab26b3866f4df8>), [CUDA_ERROR_INVALID_CONTEXT](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a484e9af32c1e9893ff21f0e0191a12d>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>)

###### [Deprecated](<deprecated.html#deprecated__deprecated_1_deprecated000006>)

###### Description

This function will return in `pConfig` the current size of shared memory banks in the current context. On devices with configurable shared memory banks, [cuCtxSetSharedMemConfig](<group__CUDA__CTX__DEPRECATED.html#group__CUDA__CTX__DEPRECATED_1gb1fef6f9fd5c252245214f85ae01ec23> "Sets the shared memory configuration for the current context.") can be used to change this setting, so that all subsequent kernel launches will by default use the new bank size. When [cuCtxGetSharedMemConfig](<group__CUDA__CTX__DEPRECATED.html#group__CUDA__CTX__DEPRECATED_1gfac1414497a1a2a40bba474c6b5bf194> "Returns the current shared memory configuration for the current context.") is called on devices without configurable shared memory, it will return the fixed bank size of the hardware.

The returned bank configurations can be either:

  * [CU_SHARED_MEM_CONFIG_FOUR_BYTE_BANK_SIZE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg92d66e95f602cb9fdaf0682c260c241b18d5d945c971d5d288d2693cbaa4d7dc>): shared memory bank width is four bytes.

  * [CU_SHARED_MEM_CONFIG_EIGHT_BYTE_BANK_SIZE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg92d66e95f602cb9fdaf0682c260c241b081c400b814b9832b8a934ad2934985c>): shared memory bank width will eight bytes.


Note:

Note that this function may also return error codes from previous, asynchronous launches.

**See also:**

[cuCtxCreate](<group__CUDA__CTX.html#group__CUDA__CTX_1g77e9fb578caefca5ed15b4acebf35265> "Create a CUDA context."), [cuCtxDestroy](<group__CUDA__CTX.html#group__CUDA__CTX_1g27a365aebb0eb548166309f58a1e8b8e> "Destroy a CUDA context."), [cuCtxGetApiVersion](<group__CUDA__CTX.html#group__CUDA__CTX_1g088a90490dafca5893ef6fbebc8de8fb> "Gets the context's API version."), [cuCtxGetCacheConfig](<group__CUDA__CTX.html#group__CUDA__CTX_1g40b6b141698f76744dea6e39b9a25360> "Returns the preferred cache configuration for the current context."), [cuCtxGetDevice](<group__CUDA__CTX.html#group__CUDA__CTX_1g4e84b109eba36cdaaade167f34ae881e> "Returns the device handle for the current context."), [cuCtxGetFlags](<group__CUDA__CTX.html#group__CUDA__CTX_1gf81eef983c1e3b2ef4f166d7a930c86d> "Returns the flags for the current context."), [cuCtxGetLimit](<group__CUDA__CTX.html#group__CUDA__CTX_1g9f2d47d1745752aa16da7ed0d111b6a8> "Returns resource limits."), [cuCtxPopCurrent](<group__CUDA__CTX.html#group__CUDA__CTX_1g2fac188026a062d92e91a8687d0a7902> "Pops the current CUDA context from the current CPU thread."), [cuCtxPushCurrent](<group__CUDA__CTX.html#group__CUDA__CTX_1gb02d4c850eb16f861fe5a29682cc90ba> "Pushes a context on the current CPU thread."), [cuCtxSetLimit](<group__CUDA__CTX.html#group__CUDA__CTX_1g0651954dfb9788173e60a9af7201e65a> "Set resource limits."), [cuCtxSynchronize](<group__CUDA__CTX.html#group__CUDA__CTX_1g7a54725f28d34b8c6299f0c6ca579616> "Block for the current context's tasks to complete."), [cuCtxGetSharedMemConfig](<group__CUDA__CTX__DEPRECATED.html#group__CUDA__CTX__DEPRECATED_1gfac1414497a1a2a40bba474c6b5bf194> "Returns the current shared memory configuration for the current context."), [cuFuncSetCacheConfig](<group__CUDA__EXEC.html#group__CUDA__EXEC_1g40f8c11e81def95dc0072a375f965681> "Sets the preferred cache configuration for a device function."), [cudaDeviceGetSharedMemConfig](<../cuda-runtime-api/group__CUDART__DEVICE__DEPRECATED.html#group__CUDART__DEVICE__DEPRECATED_1g542246258996a39a3ce2bc311bbb2421>)

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuCtxSetSharedMemConfig ( [CUsharedconfig](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g92d66e95f602cb9fdaf0682c260c241b>)Â config )


Sets the shared memory configuration for the current context.

######  Parameters

`config`
    \- requested shared memory configuration

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_DEINITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9acf52f132faf29b473cdda6061f0f44a>), [CUDA_ERROR_NOT_INITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e98feb999f0af99b4a25ab26b3866f4df8>), [CUDA_ERROR_INVALID_CONTEXT](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a484e9af32c1e9893ff21f0e0191a12d>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>)

###### [Deprecated](<deprecated.html#deprecated__deprecated_1_deprecated000007>)

###### Description

On devices with configurable shared memory banks, this function will set the context's shared memory bank size which is used for subsequent kernel launches.

Changed the shared memory configuration between launches may insert a device side synchronization point between those launches.

Changing the shared memory bank size will not increase shared memory usage or affect occupancy of kernels, but may have major effects on performance. Larger bank sizes will allow for greater potential bandwidth to shared memory, but will change what kinds of accesses to shared memory will result in bank conflicts.

This function will do nothing on devices with fixed shared memory bank size.

The supported bank configurations are:

  * [CU_SHARED_MEM_CONFIG_DEFAULT_BANK_SIZE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg92d66e95f602cb9fdaf0682c260c241bd65d166d885bd3f41bf1ced4ab8e044e>): set bank width to the default initial setting (currently, four bytes).

  * [CU_SHARED_MEM_CONFIG_FOUR_BYTE_BANK_SIZE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg92d66e95f602cb9fdaf0682c260c241b18d5d945c971d5d288d2693cbaa4d7dc>): set shared memory bank width to be natively four bytes.

  * [CU_SHARED_MEM_CONFIG_EIGHT_BYTE_BANK_SIZE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg92d66e95f602cb9fdaf0682c260c241b081c400b814b9832b8a934ad2934985c>): set shared memory bank width to be natively eight bytes.


Note:

Note that this function may also return error codes from previous, asynchronous launches.

**See also:**

[cuCtxCreate](<group__CUDA__CTX.html#group__CUDA__CTX_1g77e9fb578caefca5ed15b4acebf35265> "Create a CUDA context."), [cuCtxDestroy](<group__CUDA__CTX.html#group__CUDA__CTX_1g27a365aebb0eb548166309f58a1e8b8e> "Destroy a CUDA context."), [cuCtxGetApiVersion](<group__CUDA__CTX.html#group__CUDA__CTX_1g088a90490dafca5893ef6fbebc8de8fb> "Gets the context's API version."), [cuCtxGetCacheConfig](<group__CUDA__CTX.html#group__CUDA__CTX_1g40b6b141698f76744dea6e39b9a25360> "Returns the preferred cache configuration for the current context."), [cuCtxGetDevice](<group__CUDA__CTX.html#group__CUDA__CTX_1g4e84b109eba36cdaaade167f34ae881e> "Returns the device handle for the current context."), [cuCtxGetFlags](<group__CUDA__CTX.html#group__CUDA__CTX_1gf81eef983c1e3b2ef4f166d7a930c86d> "Returns the flags for the current context."), [cuCtxGetLimit](<group__CUDA__CTX.html#group__CUDA__CTX_1g9f2d47d1745752aa16da7ed0d111b6a8> "Returns resource limits."), [cuCtxPopCurrent](<group__CUDA__CTX.html#group__CUDA__CTX_1g2fac188026a062d92e91a8687d0a7902> "Pops the current CUDA context from the current CPU thread."), [cuCtxPushCurrent](<group__CUDA__CTX.html#group__CUDA__CTX_1gb02d4c850eb16f861fe5a29682cc90ba> "Pushes a context on the current CPU thread."), [cuCtxSetLimit](<group__CUDA__CTX.html#group__CUDA__CTX_1g0651954dfb9788173e60a9af7201e65a> "Set resource limits."), [cuCtxSynchronize](<group__CUDA__CTX.html#group__CUDA__CTX_1g7a54725f28d34b8c6299f0c6ca579616> "Block for the current context's tasks to complete."), [cuCtxGetSharedMemConfig](<group__CUDA__CTX__DEPRECATED.html#group__CUDA__CTX__DEPRECATED_1gfac1414497a1a2a40bba474c6b5bf194> "Returns the current shared memory configuration for the current context."), [cuFuncSetCacheConfig](<group__CUDA__EXEC.html#group__CUDA__EXEC_1g40f8c11e81def95dc0072a375f965681> "Sets the preferred cache configuration for a device function."), [cudaDeviceSetSharedMemConfig](<../cuda-runtime-api/group__CUDART__DEVICE__DEPRECATED.html#group__CUDART__DEVICE__DEPRECATED_1g76cb4f94c7af96c1247dfc7f105eabae>)

* * *


---

# Module Management

## 6.10.Â Module Management

This section describes the module management functions of the low-level CUDA driver application programming interface.

### Enumerations

enumÂ [CUmoduleLoadingMode](<#group__CUDA__MODULE_1g0e7bf7ad0d578861e15678997f74f789>)


### Functions

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuLinkAddData](<#group__CUDA__MODULE_1g3ebcd2ccb772ba9c120937a2d2831b77>) ( CUlinkStateÂ state, [CUjitInputType](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc78e5cb421c428676861189048888958>)Â type, void*Â data, size_tÂ size, const char*Â name, unsigned int Â numOptions, [CUjit_option](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g5527fa8030d5cabedc781a04dbd1997d>)*Â options, void**Â optionValues )
     Add an input to a pending linker invocation.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuLinkAddFile](<#group__CUDA__MODULE_1g1224c0fd48d4a683f3ce19997f200a8c>) ( CUlinkStateÂ state, [CUjitInputType](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc78e5cb421c428676861189048888958>)Â type, const char*Â path, unsigned int Â numOptions, [CUjit_option](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g5527fa8030d5cabedc781a04dbd1997d>)*Â options, void**Â optionValues )
     Add a file input to a pending linker invocation.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuLinkComplete](<#group__CUDA__MODULE_1g818fcd84a4150a997c0bba76fef4e716>) ( CUlinkStateÂ state, void**Â cubinOut, size_t*Â sizeOut )
     Complete a pending linker invocation.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuLinkCreate](<#group__CUDA__MODULE_1g86ca4052a2fab369cb943523908aa80d>) ( unsigned int Â numOptions, [CUjit_option](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g5527fa8030d5cabedc781a04dbd1997d>)*Â options, void**Â optionValues, CUlinkState*Â stateOut )
     Creates a pending JIT linker invocation.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuLinkDestroy](<#group__CUDA__MODULE_1g01b7ae2a34047b05716969af245ce2d9>) ( CUlinkStateÂ state )
     Destroys state for a JIT linker invocation.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuModuleEnumerateFunctions](<#group__CUDA__MODULE_1g6bdb22a7d9cacf7df5bda2a18082ec50>) ( [CUfunction](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gba6128b948022f495706d93bc2cea9c8>)*Â functions, unsigned int Â numFunctions, [CUmodule](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g9e4ef4dcfba4662b2299acb8d049a1ef>)Â mod )
     Returns the function handles within a module.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuModuleGetFunction](<#group__CUDA__MODULE_1ga52be009b0d4045811b30c965e1cb2cf>) ( [CUfunction](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gba6128b948022f495706d93bc2cea9c8>)*Â hfunc, [CUmodule](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g9e4ef4dcfba4662b2299acb8d049a1ef>)Â hmod, const char*Â name )
     Returns a function handle.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuModuleGetFunctionCount](<#group__CUDA__MODULE_1gecc8fb61eca765cb0f1eb32f00cf3b49>) ( unsigned int*Â count, [CUmodule](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g9e4ef4dcfba4662b2299acb8d049a1ef>)Â mod )
     Returns the number of functions within a module.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuModuleGetGlobal](<#group__CUDA__MODULE_1gf3e43672e26073b1081476dbf47a86ab>) ( [CUdeviceptr](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g183f7b0d8ad008ea2a5fd552537ace4e>)*Â dptr, size_t*Â bytes, [CUmodule](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g9e4ef4dcfba4662b2299acb8d049a1ef>)Â hmod, const char*Â name )
     Returns a global pointer from a module.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuModuleGetLoadingMode](<#group__CUDA__MODULE_1g96de378a738ec46d9277c9c9df8f6fd6>) ( [CUmoduleLoadingMode](<group__CUDA__MODULE.html#group__CUDA__MODULE_1g0e7bf7ad0d578861e15678997f74f789>)*Â mode )
     Query lazy loading mode.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuModuleLoad](<#group__CUDA__MODULE_1g366093bd269dafd0af21f1c7d18115d3>) ( [CUmodule](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g9e4ef4dcfba4662b2299acb8d049a1ef>)*Â module, const char*Â fname )
     Loads a compute module.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuModuleLoadData](<#group__CUDA__MODULE_1g04ce266ce03720f479eab76136b90c0b>) ( [CUmodule](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g9e4ef4dcfba4662b2299acb8d049a1ef>)*Â module, const void*Â image )
     Load a module's data.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuModuleLoadDataEx](<#group__CUDA__MODULE_1g9e8047e9dbf725f0cd7cafd18bfd4d12>) ( [CUmodule](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g9e4ef4dcfba4662b2299acb8d049a1ef>)*Â module, const void*Â image, unsigned int Â numOptions, [CUjit_option](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g5527fa8030d5cabedc781a04dbd1997d>)*Â options, void**Â optionValues )
     Load a module's data with options.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuModuleLoadFatBinary](<#group__CUDA__MODULE_1g13a2292b6819f8f86127768334436c3b>) ( [CUmodule](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g9e4ef4dcfba4662b2299acb8d049a1ef>)*Â module, const void*Â fatCubin )
     Load a module's data.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuModuleUnload](<#group__CUDA__MODULE_1g8ea3d716524369de3763104ced4ea57b>) ( [CUmodule](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g9e4ef4dcfba4662b2299acb8d049a1ef>)Â hmod )
     Unloads a module.

### Enumerations

enum CUmoduleLoadingMode


CUDA Lazy Loading status

######  Values

CU_MODULE_EAGER_LOADING = 0x1
    Lazy Kernel Loading is not enabled
CU_MODULE_LAZY_LOADING = 0x2
    Lazy Kernel Loading is enabled

### Functions

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuLinkAddData ( CUlinkStateÂ state, [CUjitInputType](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc78e5cb421c428676861189048888958>)Â type, void*Â data, size_tÂ size, const char*Â name, unsigned int Â numOptions, [CUjit_option](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g5527fa8030d5cabedc781a04dbd1997d>)*Â options, void**Â optionValues )


Add an input to a pending linker invocation.

######  Parameters

`state`
    A pending linker action.
`type`
    The type of the input data.
`data`
    The input data. PTX must be NULL-terminated.
`size`
    The length of the input data.
`name`
    An optional name for this input in log messages.
`numOptions`
    Size of options.
`options`
    Options to be applied only for this input (overrides options from [cuLinkCreate](<group__CUDA__MODULE.html#group__CUDA__MODULE_1g86ca4052a2fab369cb943523908aa80d> "Creates a pending JIT linker invocation.")).
`optionValues`
    Array of option values, each cast to void *.

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_INVALID_HANDLE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e90fd2e63260c6317ba943af0f7e4b8d21>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>), [CUDA_ERROR_INVALID_IMAGE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e90b7bd1dd2fb3491c588ce569c02d1a2f>), [CUDA_ERROR_INVALID_PTX](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a5bb7f216af3efbea2116ff18253b1a3>), [CUDA_ERROR_UNSUPPORTED_PTX_VERSION](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e98381092e26bfe660cef4a755bb549610>), [CUDA_ERROR_OUT_OF_MEMORY](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9264c50688ed110e8476b591befe60c02>), [CUDA_ERROR_NO_BINARY_FOR_GPU](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e94ef545ed5f461db9351f98de98497abf>)

###### Description

Ownership of `data` is retained by the caller. No reference is retained to any inputs after this call returns.

This method accepts only compiler options, which are used if the data must be compiled from PTX, and does not accept any of [CU_JIT_WALL_TIME](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg5527fa8030d5cabedc781a04dbd1997df326f19e67f00768bff8849a8dc5def5>), [CU_JIT_INFO_LOG_BUFFER](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg5527fa8030d5cabedc781a04dbd1997d0cfba79ec44e0480a78b132ff158c0ae>), [CU_JIT_ERROR_LOG_BUFFER](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg5527fa8030d5cabedc781a04dbd1997da770301a8ec6fdfb9abcbd60100beb3c>), [CU_JIT_TARGET_FROM_CUCONTEXT](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg5527fa8030d5cabedc781a04dbd1997d8e9b9dfcc1ad8fb0f89bbfb04f46e988>), or [CU_JIT_TARGET](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg5527fa8030d5cabedc781a04dbd1997d3bf12ddeaa2a9d64db4d20de537cd596>).

Note:

For LTO-IR input, only LTO-IR compiled with toolkits prior to CUDA 12.0 will be accepted

**See also:**

[cuLinkCreate](<group__CUDA__MODULE.html#group__CUDA__MODULE_1g86ca4052a2fab369cb943523908aa80d> "Creates a pending JIT linker invocation."), [cuLinkAddFile](<group__CUDA__MODULE.html#group__CUDA__MODULE_1g1224c0fd48d4a683f3ce19997f200a8c> "Add a file input to a pending linker invocation."), [cuLinkComplete](<group__CUDA__MODULE.html#group__CUDA__MODULE_1g818fcd84a4150a997c0bba76fef4e716> "Complete a pending linker invocation."), [cuLinkDestroy](<group__CUDA__MODULE.html#group__CUDA__MODULE_1g01b7ae2a34047b05716969af245ce2d9> "Destroys state for a JIT linker invocation.")

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuLinkAddFile ( CUlinkStateÂ state, [CUjitInputType](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc78e5cb421c428676861189048888958>)Â type, const char*Â path, unsigned int Â numOptions, [CUjit_option](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g5527fa8030d5cabedc781a04dbd1997d>)*Â options, void**Â optionValues )


Add a file input to a pending linker invocation.

######  Parameters

`state`
    A pending linker action
`type`
    The type of the input data
`path`
    Path to the input file
`numOptions`
    Size of options
`options`
    Options to be applied only for this input (overrides options from [cuLinkCreate](<group__CUDA__MODULE.html#group__CUDA__MODULE_1g86ca4052a2fab369cb943523908aa80d> "Creates a pending JIT linker invocation."))
`optionValues`
    Array of option values, each cast to void *

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_FILE_NOT_FOUND](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e93c20ccb3e24d5bf65625b1212fd8f4aa>)[CUDA_ERROR_INVALID_HANDLE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e90fd2e63260c6317ba943af0f7e4b8d21>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>), [CUDA_ERROR_INVALID_IMAGE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e90b7bd1dd2fb3491c588ce569c02d1a2f>), [CUDA_ERROR_INVALID_PTX](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a5bb7f216af3efbea2116ff18253b1a3>), [CUDA_ERROR_UNSUPPORTED_PTX_VERSION](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e98381092e26bfe660cef4a755bb549610>), [CUDA_ERROR_OUT_OF_MEMORY](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9264c50688ed110e8476b591befe60c02>), [CUDA_ERROR_NO_BINARY_FOR_GPU](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e94ef545ed5f461db9351f98de98497abf>)

###### Description

No reference is retained to any inputs after this call returns.

This method accepts only compiler options, which are used if the input must be compiled from PTX, and does not accept any of [CU_JIT_WALL_TIME](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg5527fa8030d5cabedc781a04dbd1997df326f19e67f00768bff8849a8dc5def5>), [CU_JIT_INFO_LOG_BUFFER](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg5527fa8030d5cabedc781a04dbd1997d0cfba79ec44e0480a78b132ff158c0ae>), [CU_JIT_ERROR_LOG_BUFFER](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg5527fa8030d5cabedc781a04dbd1997da770301a8ec6fdfb9abcbd60100beb3c>), [CU_JIT_TARGET_FROM_CUCONTEXT](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg5527fa8030d5cabedc781a04dbd1997d8e9b9dfcc1ad8fb0f89bbfb04f46e988>), or [CU_JIT_TARGET](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg5527fa8030d5cabedc781a04dbd1997d3bf12ddeaa2a9d64db4d20de537cd596>).

This method is equivalent to invoking [cuLinkAddData](<group__CUDA__MODULE.html#group__CUDA__MODULE_1g3ebcd2ccb772ba9c120937a2d2831b77> "Add an input to a pending linker invocation.") on the contents of the file.

Note:

For LTO-IR input, only LTO-IR compiled with toolkits prior to CUDA 12.0 will be accepted

**See also:**

[cuLinkCreate](<group__CUDA__MODULE.html#group__CUDA__MODULE_1g86ca4052a2fab369cb943523908aa80d> "Creates a pending JIT linker invocation."), [cuLinkAddData](<group__CUDA__MODULE.html#group__CUDA__MODULE_1g3ebcd2ccb772ba9c120937a2d2831b77> "Add an input to a pending linker invocation."), [cuLinkComplete](<group__CUDA__MODULE.html#group__CUDA__MODULE_1g818fcd84a4150a997c0bba76fef4e716> "Complete a pending linker invocation."), [cuLinkDestroy](<group__CUDA__MODULE.html#group__CUDA__MODULE_1g01b7ae2a34047b05716969af245ce2d9> "Destroys state for a JIT linker invocation.")

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuLinkComplete ( CUlinkStateÂ state, void**Â cubinOut, size_t*Â sizeOut )


Complete a pending linker invocation.

######  Parameters

`state`
    A pending linker invocation
`cubinOut`
    On success, this will point to the output image
`sizeOut`
    Optional parameter to receive the size of the generated image

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_INVALID_HANDLE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e90fd2e63260c6317ba943af0f7e4b8d21>), [CUDA_ERROR_OUT_OF_MEMORY](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9264c50688ed110e8476b591befe60c02>)

###### Description

Completes the pending linker action and returns the cubin image for the linked device code, which can be used with [cuModuleLoadData](<group__CUDA__MODULE.html#group__CUDA__MODULE_1g04ce266ce03720f479eab76136b90c0b> "Load a module's data."). The cubin is owned by `state`, so it should be loaded before `state` is destroyed via [cuLinkDestroy](<group__CUDA__MODULE.html#group__CUDA__MODULE_1g01b7ae2a34047b05716969af245ce2d9> "Destroys state for a JIT linker invocation."). This call does not destroy `state`.

**See also:**

[cuLinkCreate](<group__CUDA__MODULE.html#group__CUDA__MODULE_1g86ca4052a2fab369cb943523908aa80d> "Creates a pending JIT linker invocation."), [cuLinkAddData](<group__CUDA__MODULE.html#group__CUDA__MODULE_1g3ebcd2ccb772ba9c120937a2d2831b77> "Add an input to a pending linker invocation."), [cuLinkAddFile](<group__CUDA__MODULE.html#group__CUDA__MODULE_1g1224c0fd48d4a683f3ce19997f200a8c> "Add a file input to a pending linker invocation."), [cuLinkDestroy](<group__CUDA__MODULE.html#group__CUDA__MODULE_1g01b7ae2a34047b05716969af245ce2d9> "Destroys state for a JIT linker invocation."), [cuModuleLoadData](<group__CUDA__MODULE.html#group__CUDA__MODULE_1g04ce266ce03720f479eab76136b90c0b> "Load a module's data.")

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuLinkCreate ( unsigned int Â numOptions, [CUjit_option](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g5527fa8030d5cabedc781a04dbd1997d>)*Â options, void**Â optionValues, CUlinkState*Â stateOut )


Creates a pending JIT linker invocation.

######  Parameters

`numOptions`
    Size of options arrays
`options`
    Array of linker and compiler options
`optionValues`
    Array of option values, each cast to void *
`stateOut`
    On success, this will contain a CUlinkState to specify and complete this action

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_DEINITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9acf52f132faf29b473cdda6061f0f44a>), [CUDA_ERROR_NOT_INITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e98feb999f0af99b4a25ab26b3866f4df8>), [CUDA_ERROR_INVALID_CONTEXT](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a484e9af32c1e9893ff21f0e0191a12d>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>), [CUDA_ERROR_OUT_OF_MEMORY](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9264c50688ed110e8476b591befe60c02>), [CUDA_ERROR_JIT_COMPILER_NOT_FOUND](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e91e1b93d0f27e74d6a9e9e16f410542c6>)

###### Description

If the call is successful, the caller owns the returned CUlinkState, which should eventually be destroyed with [cuLinkDestroy](<group__CUDA__MODULE.html#group__CUDA__MODULE_1g01b7ae2a34047b05716969af245ce2d9> "Destroys state for a JIT linker invocation."). The device code machine size (32 or 64 bit) will match the calling application.

Both linker and compiler options may be specified. Compiler options will be applied to inputs to this linker action which must be compiled from PTX. The options [CU_JIT_WALL_TIME](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg5527fa8030d5cabedc781a04dbd1997df326f19e67f00768bff8849a8dc5def5>), [CU_JIT_INFO_LOG_BUFFER_SIZE_BYTES](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg5527fa8030d5cabedc781a04dbd1997d8dc284de594cc1504db521869ad47cd9>), and [CU_JIT_ERROR_LOG_BUFFER_SIZE_BYTES](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg5527fa8030d5cabedc781a04dbd1997d4e5c6eb78ba970a0b1683ac040044811>) will accumulate data until the CUlinkState is destroyed.

The data passed in via [cuLinkAddData](<group__CUDA__MODULE.html#group__CUDA__MODULE_1g3ebcd2ccb772ba9c120937a2d2831b77> "Add an input to a pending linker invocation.") and [cuLinkAddFile](<group__CUDA__MODULE.html#group__CUDA__MODULE_1g1224c0fd48d4a683f3ce19997f200a8c> "Add a file input to a pending linker invocation.") will be treated as relocatable (-rdc=true to nvcc) when linking the final cubin during [cuLinkComplete](<group__CUDA__MODULE.html#group__CUDA__MODULE_1g818fcd84a4150a997c0bba76fef4e716> "Complete a pending linker invocation.") and will have similar consequences as offline relocatable device code linking.

`optionValues` must remain valid for the life of the CUlinkState if output options are used. No other references to inputs are maintained after this call returns.

Note:

For LTO-IR input, only LTO-IR compiled with toolkits prior to CUDA 12.0 will be accepted

Note:

Note that this function may also return error codes from previous, asynchronous launches.

**See also:**

[cuLinkAddData](<group__CUDA__MODULE.html#group__CUDA__MODULE_1g3ebcd2ccb772ba9c120937a2d2831b77> "Add an input to a pending linker invocation."), [cuLinkAddFile](<group__CUDA__MODULE.html#group__CUDA__MODULE_1g1224c0fd48d4a683f3ce19997f200a8c> "Add a file input to a pending linker invocation."), [cuLinkComplete](<group__CUDA__MODULE.html#group__CUDA__MODULE_1g818fcd84a4150a997c0bba76fef4e716> "Complete a pending linker invocation."), [cuLinkDestroy](<group__CUDA__MODULE.html#group__CUDA__MODULE_1g01b7ae2a34047b05716969af245ce2d9> "Destroys state for a JIT linker invocation.")

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuLinkDestroy ( CUlinkStateÂ state )


Destroys state for a JIT linker invocation.

######  Parameters

`state`
    State object for the linker invocation

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_INVALID_HANDLE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e90fd2e63260c6317ba943af0f7e4b8d21>)

###### Description

**See also:**

[cuLinkCreate](<group__CUDA__MODULE.html#group__CUDA__MODULE_1g86ca4052a2fab369cb943523908aa80d> "Creates a pending JIT linker invocation.")

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuModuleEnumerateFunctions ( [CUfunction](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gba6128b948022f495706d93bc2cea9c8>)*Â functions, unsigned int Â numFunctions, [CUmodule](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g9e4ef4dcfba4662b2299acb8d049a1ef>)Â mod )


Returns the function handles within a module.

######  Parameters

`functions`
    \- Buffer where the function handles are returned to
`numFunctions`
    \- Maximum number of function handles may be returned to the buffer
`mod`
    \- Module to query from

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_INVALID_CONTEXT](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a484e9af32c1e9893ff21f0e0191a12d>), [CUDA_ERROR_INVALID_HANDLE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e90fd2e63260c6317ba943af0f7e4b8d21>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>)

###### Description

Returns in `functions` a maximum number of `numFunctions` function handles within `mod`. When function loading mode is set to LAZY the function retrieved may be partially loaded. The loading state of a function can be queried using cuFunctionIsLoaded. CUDA APIs may load the function automatically when called with partially loaded function handle which may incur additional latency. Alternatively, cuFunctionLoad can be used to explicitly load a function. The returned function handles become invalid when the module is unloaded.

**See also:**

[cuModuleGetFunction](<group__CUDA__MODULE.html#group__CUDA__MODULE_1ga52be009b0d4045811b30c965e1cb2cf> "Returns a function handle."), [cuModuleGetFunctionCount](<group__CUDA__MODULE.html#group__CUDA__MODULE_1gecc8fb61eca765cb0f1eb32f00cf3b49> "Returns the number of functions within a module."), [cuFuncIsLoaded](<group__CUDA__EXEC.html#group__CUDA__EXEC_1gfc6fed4bbe6c35e0445a49396774aa96> "Returns if the function is loaded."), [cuFuncLoad](<group__CUDA__EXEC.html#group__CUDA__EXEC_1g3b67024e8875bfd155534785708093ab> "Loads a function.")

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuModuleGetFunction ( [CUfunction](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gba6128b948022f495706d93bc2cea9c8>)*Â hfunc, [CUmodule](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g9e4ef4dcfba4662b2299acb8d049a1ef>)Â hmod, const char*Â name )


Returns a function handle.

######  Parameters

`hfunc`
    \- Returned function handle
`hmod`
    \- Module to retrieve function from
`name`
    \- Name of function to retrieve

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_DEINITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9acf52f132faf29b473cdda6061f0f44a>), [CUDA_ERROR_NOT_INITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e98feb999f0af99b4a25ab26b3866f4df8>), [CUDA_ERROR_INVALID_CONTEXT](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a484e9af32c1e9893ff21f0e0191a12d>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>), [CUDA_ERROR_NOT_FOUND](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9af1cadbeb21d3a78115ca211ba44c053>)

###### Description

Returns in `*hfunc` the handle of the function of name `name` located in module `hmod`. If no function of that name exists, [cuModuleGetFunction()](<group__CUDA__MODULE.html#group__CUDA__MODULE_1ga52be009b0d4045811b30c965e1cb2cf> "Returns a function handle.") returns [CUDA_ERROR_NOT_FOUND](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9af1cadbeb21d3a78115ca211ba44c053>).

Note:

Note that this function may also return error codes from previous, asynchronous launches.

**See also:**

[cuModuleGetGlobal](<group__CUDA__MODULE.html#group__CUDA__MODULE_1gf3e43672e26073b1081476dbf47a86ab> "Returns a global pointer from a module."), [cuModuleGetTexRef](<group__CUDA__MODULE__DEPRECATED.html#group__CUDA__MODULE__DEPRECATED_1g9965d238143354d573ef5789057be561> "Returns a handle to a texture reference."), [cuModuleLoad](<group__CUDA__MODULE.html#group__CUDA__MODULE_1g366093bd269dafd0af21f1c7d18115d3> "Loads a compute module."), [cuModuleLoadData](<group__CUDA__MODULE.html#group__CUDA__MODULE_1g04ce266ce03720f479eab76136b90c0b> "Load a module's data."), [cuModuleLoadDataEx](<group__CUDA__MODULE.html#group__CUDA__MODULE_1g9e8047e9dbf725f0cd7cafd18bfd4d12> "Load a module's data with options."), [cuModuleLoadFatBinary](<group__CUDA__MODULE.html#group__CUDA__MODULE_1g13a2292b6819f8f86127768334436c3b> "Load a module's data."), [cuModuleUnload](<group__CUDA__MODULE.html#group__CUDA__MODULE_1g8ea3d716524369de3763104ced4ea57b> "Unloads a module.")

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuModuleGetFunctionCount ( unsigned int*Â count, [CUmodule](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g9e4ef4dcfba4662b2299acb8d049a1ef>)Â mod )


Returns the number of functions within a module.

######  Parameters

`count`
    \- Number of functions found within the module
`mod`
    \- Module to query

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_INVALID_HANDLE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e90fd2e63260c6317ba943af0f7e4b8d21>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>)

###### Description

Returns in `count` the number of functions in `mod`.

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuModuleGetGlobal ( [CUdeviceptr](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g183f7b0d8ad008ea2a5fd552537ace4e>)*Â dptr, size_t*Â bytes, [CUmodule](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g9e4ef4dcfba4662b2299acb8d049a1ef>)Â hmod, const char*Â name )


Returns a global pointer from a module.

######  Parameters

`dptr`
    \- Returned global device pointer
`bytes`
    \- Returned global size in bytes
`hmod`
    \- Module to retrieve global from
`name`
    \- Name of global to retrieve

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_DEINITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9acf52f132faf29b473cdda6061f0f44a>), [CUDA_ERROR_NOT_INITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e98feb999f0af99b4a25ab26b3866f4df8>), [CUDA_ERROR_INVALID_CONTEXT](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a484e9af32c1e9893ff21f0e0191a12d>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>), [CUDA_ERROR_NOT_FOUND](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9af1cadbeb21d3a78115ca211ba44c053>)

###### Description

Returns in `*dptr` and `*bytes` the base pointer and size of the global of name `name` located in module `hmod`. If no variable of that name exists, [cuModuleGetGlobal()](<group__CUDA__MODULE.html#group__CUDA__MODULE_1gf3e43672e26073b1081476dbf47a86ab> "Returns a global pointer from a module.") returns [CUDA_ERROR_NOT_FOUND](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9af1cadbeb21d3a78115ca211ba44c053>). One of the parameters `dptr` or `bytes` (not both) can be NULL in which case it is ignored.

Note:

Note that this function may also return error codes from previous, asynchronous launches.

**See also:**

[cuModuleGetFunction](<group__CUDA__MODULE.html#group__CUDA__MODULE_1ga52be009b0d4045811b30c965e1cb2cf> "Returns a function handle."), [cuModuleGetTexRef](<group__CUDA__MODULE__DEPRECATED.html#group__CUDA__MODULE__DEPRECATED_1g9965d238143354d573ef5789057be561> "Returns a handle to a texture reference."), [cuModuleLoad](<group__CUDA__MODULE.html#group__CUDA__MODULE_1g366093bd269dafd0af21f1c7d18115d3> "Loads a compute module."), [cuModuleLoadData](<group__CUDA__MODULE.html#group__CUDA__MODULE_1g04ce266ce03720f479eab76136b90c0b> "Load a module's data."), [cuModuleLoadDataEx](<group__CUDA__MODULE.html#group__CUDA__MODULE_1g9e8047e9dbf725f0cd7cafd18bfd4d12> "Load a module's data with options."), [cuModuleLoadFatBinary](<group__CUDA__MODULE.html#group__CUDA__MODULE_1g13a2292b6819f8f86127768334436c3b> "Load a module's data."), [cuModuleUnload](<group__CUDA__MODULE.html#group__CUDA__MODULE_1g8ea3d716524369de3763104ced4ea57b> "Unloads a module."), [cudaGetSymbolAddress](<../cuda-runtime-api/group__CUDART__HIGHLEVEL.html#group__CUDART__HIGHLEVEL_1g3a0f010e70a3343db18227cec9615177>), [cudaGetSymbolSize](<../cuda-runtime-api/group__CUDART__HIGHLEVEL.html#group__CUDART__HIGHLEVEL_1g0561c8ffee270bff0bbb7deb81ad865c>)

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuModuleGetLoadingMode ( [CUmoduleLoadingMode](<group__CUDA__MODULE.html#group__CUDA__MODULE_1g0e7bf7ad0d578861e15678997f74f789>)*Â mode )


Query lazy loading mode.

######  Parameters

`mode`
    \- Returns the lazy loading mode

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>),

###### Description

Returns lazy loading mode Module loading mode is controlled by CUDA_MODULE_LOADING env variable

Note:

Note that this function may also return error codes from previous, asynchronous launches.

**See also:**

[cuModuleLoad](<group__CUDA__MODULE.html#group__CUDA__MODULE_1g366093bd269dafd0af21f1c7d18115d3> "Loads a compute module."),

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuModuleLoad ( [CUmodule](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g9e4ef4dcfba4662b2299acb8d049a1ef>)*Â module, const char*Â fname )


Loads a compute module.

######  Parameters

`module`
    \- Returned module
`fname`
    \- Filename of module to load

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_DEINITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9acf52f132faf29b473cdda6061f0f44a>), [CUDA_ERROR_NOT_INITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e98feb999f0af99b4a25ab26b3866f4df8>), [CUDA_ERROR_INVALID_CONTEXT](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a484e9af32c1e9893ff21f0e0191a12d>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>), [CUDA_ERROR_INVALID_PTX](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a5bb7f216af3efbea2116ff18253b1a3>), [CUDA_ERROR_UNSUPPORTED_PTX_VERSION](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e98381092e26bfe660cef4a755bb549610>), [CUDA_ERROR_NOT_FOUND](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9af1cadbeb21d3a78115ca211ba44c053>), [CUDA_ERROR_OUT_OF_MEMORY](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9264c50688ed110e8476b591befe60c02>), [CUDA_ERROR_FILE_NOT_FOUND](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e93c20ccb3e24d5bf65625b1212fd8f4aa>), [CUDA_ERROR_NO_BINARY_FOR_GPU](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e94ef545ed5f461db9351f98de98497abf>), [CUDA_ERROR_SHARED_OBJECT_SYMBOL_NOT_FOUND](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e95ab6c0086a6130b5b895ff15ce841ee6>), [CUDA_ERROR_SHARED_OBJECT_INIT_FAILED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9d8a149ebc98aa90f6417e531fa645043>), [CUDA_ERROR_JIT_COMPILER_NOT_FOUND](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e91e1b93d0f27e74d6a9e9e16f410542c6>)

###### Description

Takes a filename `fname` and loads the corresponding module `module` into the current context. The CUDA driver API does not attempt to lazily allocate the resources needed by a module; if the memory for functions and data (constant and global) needed by the module cannot be allocated, [cuModuleLoad()](<group__CUDA__MODULE.html#group__CUDA__MODULE_1g366093bd269dafd0af21f1c7d18115d3> "Loads a compute module.") fails. The file should be a cubin file as output by **nvcc** , or a PTX file either as output by **nvcc** or handwritten, or a fatbin file as output by **nvcc** from toolchain 4.0 or later, or a Tile IR file.

Note:

Note that this function may also return error codes from previous, asynchronous launches.

**See also:**

[cuModuleGetFunction](<group__CUDA__MODULE.html#group__CUDA__MODULE_1ga52be009b0d4045811b30c965e1cb2cf> "Returns a function handle."), [cuModuleGetGlobal](<group__CUDA__MODULE.html#group__CUDA__MODULE_1gf3e43672e26073b1081476dbf47a86ab> "Returns a global pointer from a module."), [cuModuleGetTexRef](<group__CUDA__MODULE__DEPRECATED.html#group__CUDA__MODULE__DEPRECATED_1g9965d238143354d573ef5789057be561> "Returns a handle to a texture reference."), [cuModuleLoadData](<group__CUDA__MODULE.html#group__CUDA__MODULE_1g04ce266ce03720f479eab76136b90c0b> "Load a module's data."), [cuModuleLoadDataEx](<group__CUDA__MODULE.html#group__CUDA__MODULE_1g9e8047e9dbf725f0cd7cafd18bfd4d12> "Load a module's data with options."), [cuModuleLoadFatBinary](<group__CUDA__MODULE.html#group__CUDA__MODULE_1g13a2292b6819f8f86127768334436c3b> "Load a module's data."), [cuModuleUnload](<group__CUDA__MODULE.html#group__CUDA__MODULE_1g8ea3d716524369de3763104ced4ea57b> "Unloads a module.")

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuModuleLoadData ( [CUmodule](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g9e4ef4dcfba4662b2299acb8d049a1ef>)*Â module, const void*Â image )


Load a module's data.

######  Parameters

`module`
    \- Returned module
`image`
    \- Module data to load

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_DEINITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9acf52f132faf29b473cdda6061f0f44a>), [CUDA_ERROR_NOT_INITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e98feb999f0af99b4a25ab26b3866f4df8>), [CUDA_ERROR_INVALID_CONTEXT](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a484e9af32c1e9893ff21f0e0191a12d>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>), [CUDA_ERROR_INVALID_PTX](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a5bb7f216af3efbea2116ff18253b1a3>), [CUDA_ERROR_UNSUPPORTED_PTX_VERSION](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e98381092e26bfe660cef4a755bb549610>), [CUDA_ERROR_OUT_OF_MEMORY](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9264c50688ed110e8476b591befe60c02>), [CUDA_ERROR_NO_BINARY_FOR_GPU](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e94ef545ed5f461db9351f98de98497abf>), [CUDA_ERROR_SHARED_OBJECT_SYMBOL_NOT_FOUND](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e95ab6c0086a6130b5b895ff15ce841ee6>), [CUDA_ERROR_SHARED_OBJECT_INIT_FAILED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9d8a149ebc98aa90f6417e531fa645043>), [CUDA_ERROR_JIT_COMPILER_NOT_FOUND](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e91e1b93d0f27e74d6a9e9e16f410542c6>)

###### Description

Takes a pointer `image` and loads the corresponding module `module` into the current context. The `image` may be a cubin or fatbin as output by **nvcc** , or a NULL-terminated PTX, either as output by **nvcc** or hand-written, or Tile IR data.

Note:

Note that this function may also return error codes from previous, asynchronous launches.

**See also:**

[cuModuleGetFunction](<group__CUDA__MODULE.html#group__CUDA__MODULE_1ga52be009b0d4045811b30c965e1cb2cf> "Returns a function handle."), [cuModuleGetGlobal](<group__CUDA__MODULE.html#group__CUDA__MODULE_1gf3e43672e26073b1081476dbf47a86ab> "Returns a global pointer from a module."), [cuModuleGetTexRef](<group__CUDA__MODULE__DEPRECATED.html#group__CUDA__MODULE__DEPRECATED_1g9965d238143354d573ef5789057be561> "Returns a handle to a texture reference."), [cuModuleLoad](<group__CUDA__MODULE.html#group__CUDA__MODULE_1g366093bd269dafd0af21f1c7d18115d3> "Loads a compute module."), [cuModuleLoadDataEx](<group__CUDA__MODULE.html#group__CUDA__MODULE_1g9e8047e9dbf725f0cd7cafd18bfd4d12> "Load a module's data with options."), [cuModuleLoadFatBinary](<group__CUDA__MODULE.html#group__CUDA__MODULE_1g13a2292b6819f8f86127768334436c3b> "Load a module's data."), [cuModuleUnload](<group__CUDA__MODULE.html#group__CUDA__MODULE_1g8ea3d716524369de3763104ced4ea57b> "Unloads a module.")

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuModuleLoadDataEx ( [CUmodule](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g9e4ef4dcfba4662b2299acb8d049a1ef>)*Â module, const void*Â image, unsigned int Â numOptions, [CUjit_option](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g5527fa8030d5cabedc781a04dbd1997d>)*Â options, void**Â optionValues )


Load a module's data with options.

######  Parameters

`module`
    \- Returned module
`image`
    \- Module data to load
`numOptions`
    \- Number of options
`options`
    \- Options for JIT
`optionValues`
    \- Option values for JIT

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_DEINITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9acf52f132faf29b473cdda6061f0f44a>), [CUDA_ERROR_NOT_INITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e98feb999f0af99b4a25ab26b3866f4df8>), [CUDA_ERROR_INVALID_CONTEXT](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a484e9af32c1e9893ff21f0e0191a12d>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>), [CUDA_ERROR_INVALID_PTX](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a5bb7f216af3efbea2116ff18253b1a3>), [CUDA_ERROR_UNSUPPORTED_PTX_VERSION](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e98381092e26bfe660cef4a755bb549610>), [CUDA_ERROR_OUT_OF_MEMORY](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9264c50688ed110e8476b591befe60c02>), [CUDA_ERROR_NO_BINARY_FOR_GPU](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e94ef545ed5f461db9351f98de98497abf>), [CUDA_ERROR_SHARED_OBJECT_SYMBOL_NOT_FOUND](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e95ab6c0086a6130b5b895ff15ce841ee6>), [CUDA_ERROR_SHARED_OBJECT_INIT_FAILED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9d8a149ebc98aa90f6417e531fa645043>), [CUDA_ERROR_JIT_COMPILER_NOT_FOUND](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e91e1b93d0f27e74d6a9e9e16f410542c6>)

###### Description

Takes a pointer `image` and loads the corresponding module `module` into the current context. The `image` may be a cubin or fatbin as output by **nvcc** , or a NULL-terminated PTX, either as output by **nvcc** or hand-written, or Tile IR data.

Note:

Note that this function may also return error codes from previous, asynchronous launches.

**See also:**

[cuModuleGetFunction](<group__CUDA__MODULE.html#group__CUDA__MODULE_1ga52be009b0d4045811b30c965e1cb2cf> "Returns a function handle."), [cuModuleGetGlobal](<group__CUDA__MODULE.html#group__CUDA__MODULE_1gf3e43672e26073b1081476dbf47a86ab> "Returns a global pointer from a module."), [cuModuleGetTexRef](<group__CUDA__MODULE__DEPRECATED.html#group__CUDA__MODULE__DEPRECATED_1g9965d238143354d573ef5789057be561> "Returns a handle to a texture reference."), [cuModuleLoad](<group__CUDA__MODULE.html#group__CUDA__MODULE_1g366093bd269dafd0af21f1c7d18115d3> "Loads a compute module."), [cuModuleLoadData](<group__CUDA__MODULE.html#group__CUDA__MODULE_1g04ce266ce03720f479eab76136b90c0b> "Load a module's data."), [cuModuleLoadFatBinary](<group__CUDA__MODULE.html#group__CUDA__MODULE_1g13a2292b6819f8f86127768334436c3b> "Load a module's data."), [cuModuleUnload](<group__CUDA__MODULE.html#group__CUDA__MODULE_1g8ea3d716524369de3763104ced4ea57b> "Unloads a module.")

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuModuleLoadFatBinary ( [CUmodule](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g9e4ef4dcfba4662b2299acb8d049a1ef>)*Â module, const void*Â fatCubin )


Load a module's data.

######  Parameters

`module`
    \- Returned module
`fatCubin`
    \- Fat binary to load

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_DEINITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9acf52f132faf29b473cdda6061f0f44a>), [CUDA_ERROR_NOT_INITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e98feb999f0af99b4a25ab26b3866f4df8>), [CUDA_ERROR_INVALID_CONTEXT](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a484e9af32c1e9893ff21f0e0191a12d>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>), [CUDA_ERROR_INVALID_PTX](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a5bb7f216af3efbea2116ff18253b1a3>), [CUDA_ERROR_UNSUPPORTED_PTX_VERSION](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e98381092e26bfe660cef4a755bb549610>), [CUDA_ERROR_NOT_FOUND](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9af1cadbeb21d3a78115ca211ba44c053>), [CUDA_ERROR_OUT_OF_MEMORY](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9264c50688ed110e8476b591befe60c02>), [CUDA_ERROR_NO_BINARY_FOR_GPU](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e94ef545ed5f461db9351f98de98497abf>), [CUDA_ERROR_SHARED_OBJECT_SYMBOL_NOT_FOUND](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e95ab6c0086a6130b5b895ff15ce841ee6>), [CUDA_ERROR_SHARED_OBJECT_INIT_FAILED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9d8a149ebc98aa90f6417e531fa645043>), [CUDA_ERROR_JIT_COMPILER_NOT_FOUND](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e91e1b93d0f27e74d6a9e9e16f410542c6>)

###### Description

Takes a pointer `fatCubin` and loads the corresponding module `module` into the current context. The pointer represents a fat binary object, which is a collection of different cubin and/or PTX files, all representing the same device code, but compiled and optimized for different architectures.

Prior to CUDA 4.0, there was no documented API for constructing and using fat binary objects by programmers. Starting with CUDA 4.0, fat binary objects can be constructed by providing the -fatbin option to **nvcc**. More information can be found in the **nvcc** document.

Note:

Note that this function may also return error codes from previous, asynchronous launches.

**See also:**

[cuModuleGetFunction](<group__CUDA__MODULE.html#group__CUDA__MODULE_1ga52be009b0d4045811b30c965e1cb2cf> "Returns a function handle."), [cuModuleGetGlobal](<group__CUDA__MODULE.html#group__CUDA__MODULE_1gf3e43672e26073b1081476dbf47a86ab> "Returns a global pointer from a module."), [cuModuleGetTexRef](<group__CUDA__MODULE__DEPRECATED.html#group__CUDA__MODULE__DEPRECATED_1g9965d238143354d573ef5789057be561> "Returns a handle to a texture reference."), [cuModuleLoad](<group__CUDA__MODULE.html#group__CUDA__MODULE_1g366093bd269dafd0af21f1c7d18115d3> "Loads a compute module."), [cuModuleLoadData](<group__CUDA__MODULE.html#group__CUDA__MODULE_1g04ce266ce03720f479eab76136b90c0b> "Load a module's data."), [cuModuleLoadDataEx](<group__CUDA__MODULE.html#group__CUDA__MODULE_1g9e8047e9dbf725f0cd7cafd18bfd4d12> "Load a module's data with options."), [cuModuleUnload](<group__CUDA__MODULE.html#group__CUDA__MODULE_1g8ea3d716524369de3763104ced4ea57b> "Unloads a module.")

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuModuleUnload ( [CUmodule](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g9e4ef4dcfba4662b2299acb8d049a1ef>)Â hmod )


Unloads a module.

######  Parameters

`hmod`
    \- Module to unload

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_DEINITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9acf52f132faf29b473cdda6061f0f44a>), [CUDA_ERROR_NOT_INITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e98feb999f0af99b4a25ab26b3866f4df8>), [CUDA_ERROR_INVALID_CONTEXT](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a484e9af32c1e9893ff21f0e0191a12d>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>), [CUDA_ERROR_NOT_PERMITTED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9e23d0197c490ec332a43e55b167968a3>)

###### Description

Unloads a module `hmod` from the current context. Attempting to unload a module which was obtained from the Library Management API such as [cuLibraryGetModule](<group__CUDA__LIBRARY.html#group__CUDA__LIBRARY_1g0d439597c77b64cf247de33f0609a5d8> "Returns a module handle.") will return [CUDA_ERROR_NOT_PERMITTED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9e23d0197c490ec332a43e55b167968a3>).

Note:

  * Note that this function may also return error codes from previous, asynchronous launches.

  * Use of the handle after this call is undefined behavior.


**See also:**

[cuModuleGetFunction](<group__CUDA__MODULE.html#group__CUDA__MODULE_1ga52be009b0d4045811b30c965e1cb2cf> "Returns a function handle."), [cuModuleGetGlobal](<group__CUDA__MODULE.html#group__CUDA__MODULE_1gf3e43672e26073b1081476dbf47a86ab> "Returns a global pointer from a module."), [cuModuleGetTexRef](<group__CUDA__MODULE__DEPRECATED.html#group__CUDA__MODULE__DEPRECATED_1g9965d238143354d573ef5789057be561> "Returns a handle to a texture reference."), [cuModuleLoad](<group__CUDA__MODULE.html#group__CUDA__MODULE_1g366093bd269dafd0af21f1c7d18115d3> "Loads a compute module."), [cuModuleLoadData](<group__CUDA__MODULE.html#group__CUDA__MODULE_1g04ce266ce03720f479eab76136b90c0b> "Load a module's data."), [cuModuleLoadDataEx](<group__CUDA__MODULE.html#group__CUDA__MODULE_1g9e8047e9dbf725f0cd7cafd18bfd4d12> "Load a module's data with options."), [cuModuleLoadFatBinary](<group__CUDA__MODULE.html#group__CUDA__MODULE_1g13a2292b6819f8f86127768334436c3b> "Load a module's data.")

* * *


---

# Module Management (Deprecated)

## 6.11.Â Module Management [DEPRECATED]

This section describes the deprecated module management functions of the low-level CUDA driver application programming interface.

### Functions

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuModuleGetSurfRef](<#group__CUDA__MODULE__DEPRECATED_1g3c9cccfdfa65d6cf492b7ce1b93a4596>) ( [CUsurfref](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g7b99472b414f10b2c04dd2530dc7ea76>)*Â pSurfRef, [CUmodule](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g9e4ef4dcfba4662b2299acb8d049a1ef>)Â hmod, const char*Â name )
     Returns a handle to a surface reference.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuModuleGetTexRef](<#group__CUDA__MODULE__DEPRECATED_1g9965d238143354d573ef5789057be561>) ( [CUtexref](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gec1e8eb9dc48ad748765d1fcc020d6b5>)*Â pTexRef, [CUmodule](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g9e4ef4dcfba4662b2299acb8d049a1ef>)Â hmod, const char*Â name )
     Returns a handle to a texture reference.

### Functions

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuModuleGetSurfRef ( [CUsurfref](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g7b99472b414f10b2c04dd2530dc7ea76>)*Â pSurfRef, [CUmodule](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g9e4ef4dcfba4662b2299acb8d049a1ef>)Â hmod, const char*Â name )


Returns a handle to a surface reference.

######  Parameters

`pSurfRef`
    \- Returned surface reference
`hmod`
    \- Module to retrieve surface reference from
`name`
    \- Name of surface reference to retrieve

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_DEINITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9acf52f132faf29b473cdda6061f0f44a>), [CUDA_ERROR_NOT_INITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e98feb999f0af99b4a25ab26b3866f4df8>), [CUDA_ERROR_INVALID_CONTEXT](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a484e9af32c1e9893ff21f0e0191a12d>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>), [CUDA_ERROR_NOT_FOUND](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9af1cadbeb21d3a78115ca211ba44c053>)

###### [Deprecated](<deprecated.html#deprecated__deprecated_1_deprecated000009>)

###### Description

Returns in `*pSurfRef` the handle of the surface reference of name `name` in the module `hmod`. If no surface reference of that name exists, [cuModuleGetSurfRef()](<group__CUDA__MODULE__DEPRECATED.html#group__CUDA__MODULE__DEPRECATED_1g3c9cccfdfa65d6cf492b7ce1b93a4596> "Returns a handle to a surface reference.") returns [CUDA_ERROR_NOT_FOUND](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9af1cadbeb21d3a78115ca211ba44c053>).

Note:

Note that this function may also return error codes from previous, asynchronous launches.

**See also:**

[cuModuleGetFunction](<group__CUDA__MODULE.html#group__CUDA__MODULE_1ga52be009b0d4045811b30c965e1cb2cf> "Returns a function handle."), [cuModuleGetGlobal](<group__CUDA__MODULE.html#group__CUDA__MODULE_1gf3e43672e26073b1081476dbf47a86ab> "Returns a global pointer from a module."), [cuModuleGetTexRef](<group__CUDA__MODULE__DEPRECATED.html#group__CUDA__MODULE__DEPRECATED_1g9965d238143354d573ef5789057be561> "Returns a handle to a texture reference."), [cuModuleLoad](<group__CUDA__MODULE.html#group__CUDA__MODULE_1g366093bd269dafd0af21f1c7d18115d3> "Loads a compute module."), [cuModuleLoadData](<group__CUDA__MODULE.html#group__CUDA__MODULE_1g04ce266ce03720f479eab76136b90c0b> "Load a module's data."), [cuModuleLoadDataEx](<group__CUDA__MODULE.html#group__CUDA__MODULE_1g9e8047e9dbf725f0cd7cafd18bfd4d12> "Load a module's data with options."), [cuModuleLoadFatBinary](<group__CUDA__MODULE.html#group__CUDA__MODULE_1g13a2292b6819f8f86127768334436c3b> "Load a module's data."), [cuModuleUnload](<group__CUDA__MODULE.html#group__CUDA__MODULE_1g8ea3d716524369de3763104ced4ea57b> "Unloads a module.")

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuModuleGetTexRef ( [CUtexref](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gec1e8eb9dc48ad748765d1fcc020d6b5>)*Â pTexRef, [CUmodule](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g9e4ef4dcfba4662b2299acb8d049a1ef>)Â hmod, const char*Â name )


Returns a handle to a texture reference.

######  Parameters

`pTexRef`
    \- Returned texture reference
`hmod`
    \- Module to retrieve texture reference from
`name`
    \- Name of texture reference to retrieve

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_DEINITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9acf52f132faf29b473cdda6061f0f44a>), [CUDA_ERROR_NOT_INITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e98feb999f0af99b4a25ab26b3866f4df8>), [CUDA_ERROR_INVALID_CONTEXT](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a484e9af32c1e9893ff21f0e0191a12d>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>), [CUDA_ERROR_NOT_FOUND](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9af1cadbeb21d3a78115ca211ba44c053>)

###### [Deprecated](<deprecated.html#deprecated__deprecated_1_deprecated000008>)

###### Description

Returns in `*pTexRef` the handle of the texture reference of name `name` in the module `hmod`. If no texture reference of that name exists, [cuModuleGetTexRef()](<group__CUDA__MODULE__DEPRECATED.html#group__CUDA__MODULE__DEPRECATED_1g9965d238143354d573ef5789057be561> "Returns a handle to a texture reference.") returns [CUDA_ERROR_NOT_FOUND](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9af1cadbeb21d3a78115ca211ba44c053>). This texture reference handle should not be destroyed, since it will be destroyed when the module is unloaded.

Note:

Note that this function may also return error codes from previous, asynchronous launches.

**See also:**

[cuModuleGetFunction](<group__CUDA__MODULE.html#group__CUDA__MODULE_1ga52be009b0d4045811b30c965e1cb2cf> "Returns a function handle."), [cuModuleGetGlobal](<group__CUDA__MODULE.html#group__CUDA__MODULE_1gf3e43672e26073b1081476dbf47a86ab> "Returns a global pointer from a module."), [cuModuleGetSurfRef](<group__CUDA__MODULE__DEPRECATED.html#group__CUDA__MODULE__DEPRECATED_1g3c9cccfdfa65d6cf492b7ce1b93a4596> "Returns a handle to a surface reference."), [cuModuleLoad](<group__CUDA__MODULE.html#group__CUDA__MODULE_1g366093bd269dafd0af21f1c7d18115d3> "Loads a compute module."), [cuModuleLoadData](<group__CUDA__MODULE.html#group__CUDA__MODULE_1g04ce266ce03720f479eab76136b90c0b> "Load a module's data."), [cuModuleLoadDataEx](<group__CUDA__MODULE.html#group__CUDA__MODULE_1g9e8047e9dbf725f0cd7cafd18bfd4d12> "Load a module's data with options."), [cuModuleLoadFatBinary](<group__CUDA__MODULE.html#group__CUDA__MODULE_1g13a2292b6819f8f86127768334436c3b> "Load a module's data."), [cuModuleUnload](<group__CUDA__MODULE.html#group__CUDA__MODULE_1g8ea3d716524369de3763104ced4ea57b> "Unloads a module.")

* * *


---

# Library Management

## 6.12.Â Library Management

This section describes the library management functions of the low-level CUDA driver application programming interface.

### Functions

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuKernelGetAttribute](<#group__CUDA__LIBRARY_1gd98317cb151b99fbd95767418122071f>) ( int*Â pi, [CUfunction_attribute](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g9d955dde0904a9b43ca4d875ac1551bc>)Â attrib, [CUkernel](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g612028921e5736db673e4307589989ed>)Â kernel, [CUdevice](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g41ca2a24a242b36ef2ca77330b5fb72a>)Â dev )
     Returns information about a kernel.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuKernelGetFunction](<#group__CUDA__LIBRARY_1ge4cf9abafaba338acb977585b0d7374a>) ( [CUfunction](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gba6128b948022f495706d93bc2cea9c8>)*Â pFunc, [CUkernel](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g612028921e5736db673e4307589989ed>)Â kernel )
     Returns a function handle.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuKernelGetLibrary](<#group__CUDA__LIBRARY_1g10ca8b20e237abbf3cf5a070d70b9cb3>) ( [CUlibrary](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gb3c679dac8f1ce28d437bedd0fc907d7>)*Â pLib, [CUkernel](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g612028921e5736db673e4307589989ed>)Â kernel )
     Returns a library handle.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuKernelGetName](<#group__CUDA__LIBRARY_1ge758151073b777ef3ba11a45f7d22adf>) ( const char**Â name, [CUkernel](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g612028921e5736db673e4307589989ed>)Â hfunc )
     Returns the function name for a CUkernel handle.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuKernelGetParamInfo](<#group__CUDA__LIBRARY_1ga61653c9f13f713527e189fb0c2fe235>) ( [CUkernel](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g612028921e5736db673e4307589989ed>)Â kernel, size_tÂ paramIndex, size_t*Â paramOffset, size_t*Â paramSize )
     Returns the offset and size of a kernel parameter in the device-side parameter layout.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuKernelSetAttribute](<#group__CUDA__LIBRARY_1g1093ade718915249de3b14320d567067>) ( [CUfunction_attribute](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g9d955dde0904a9b43ca4d875ac1551bc>)Â attrib, int Â val, [CUkernel](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g612028921e5736db673e4307589989ed>)Â kernel, [CUdevice](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g41ca2a24a242b36ef2ca77330b5fb72a>)Â dev )
     Sets information about a kernel.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuKernelSetCacheConfig](<#group__CUDA__LIBRARY_1g8490476e5d3573c7ede78f29bd8cde51>) ( [CUkernel](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g612028921e5736db673e4307589989ed>)Â kernel, [CUfunc_cache](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g3b9bbcf42528b889e9dbe9cfa2aea3ec>)Â config, [CUdevice](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g41ca2a24a242b36ef2ca77330b5fb72a>)Â dev )
     Sets the preferred cache configuration for a device kernel.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuLibraryEnumerateKernels](<#group__CUDA__LIBRARY_1ga8ae2f42ab3a8fe789ac2dced8219608>) ( [CUkernel](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g612028921e5736db673e4307589989ed>)*Â kernels, unsigned int Â numKernels, [CUlibrary](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gb3c679dac8f1ce28d437bedd0fc907d7>)Â lib )
     Retrieve the kernel handles within a library.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuLibraryGetGlobal](<#group__CUDA__LIBRARY_1g98708b50c11bc1c0addd6ecab96ae4ab>) ( [CUdeviceptr](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g183f7b0d8ad008ea2a5fd552537ace4e>)*Â dptr, size_t*Â bytes, [CUlibrary](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gb3c679dac8f1ce28d437bedd0fc907d7>)Â library, const char*Â name )
     Returns a global device pointer.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuLibraryGetKernel](<#group__CUDA__LIBRARY_1g15336d865f5abd63e3dc6004d5bc037a>) ( [CUkernel](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g612028921e5736db673e4307589989ed>)*Â pKernel, [CUlibrary](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gb3c679dac8f1ce28d437bedd0fc907d7>)Â library, const char*Â name )
     Returns a kernel handle.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuLibraryGetKernelCount](<#group__CUDA__LIBRARY_1g142732b1c9afaa662f21cae9a558d2d4>) ( unsigned int*Â count, [CUlibrary](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gb3c679dac8f1ce28d437bedd0fc907d7>)Â lib )
     Returns the number of kernels within a library.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuLibraryGetManaged](<#group__CUDA__LIBRARY_1ga03f44378227ea68e6decd9d11c28fdf>) ( [CUdeviceptr](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g183f7b0d8ad008ea2a5fd552537ace4e>)*Â dptr, size_t*Â bytes, [CUlibrary](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gb3c679dac8f1ce28d437bedd0fc907d7>)Â library, const char*Â name )
     Returns a pointer to managed memory.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuLibraryGetModule](<#group__CUDA__LIBRARY_1g0d439597c77b64cf247de33f0609a5d8>) ( [CUmodule](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g9e4ef4dcfba4662b2299acb8d049a1ef>)*Â pMod, [CUlibrary](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gb3c679dac8f1ce28d437bedd0fc907d7>)Â library )
     Returns a module handle.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuLibraryGetUnifiedFunction](<#group__CUDA__LIBRARY_1gb1b0ea992d64345562b694fdcd2c0334>) ( void**Â fptr, [CUlibrary](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gb3c679dac8f1ce28d437bedd0fc907d7>)Â library, const char*Â symbol )
     Returns a pointer to a unified function.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuLibraryLoadData](<#group__CUDA__LIBRARY_1g957f12ff5af4166f43c89d17cfb0a74d>) ( [CUlibrary](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gb3c679dac8f1ce28d437bedd0fc907d7>)*Â library, const void*Â code, [CUjit_option](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g5527fa8030d5cabedc781a04dbd1997d>)*Â jitOptions, void**Â jitOptionsValues, unsigned int Â numJitOptions, [CUlibraryOption](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g8a1cdb7004bb8a24f1342de9004add23>)*Â libraryOptions, void**Â libraryOptionValues, unsigned int Â numLibraryOptions )
     Load a library with specified code and options.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuLibraryLoadFromFile](<#group__CUDA__LIBRARY_1g88cff489fab37c7fd1985ceb61023205>) ( [CUlibrary](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gb3c679dac8f1ce28d437bedd0fc907d7>)*Â library, const char*Â fileName, [CUjit_option](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g5527fa8030d5cabedc781a04dbd1997d>)*Â jitOptions, void**Â jitOptionsValues, unsigned int Â numJitOptions, [CUlibraryOption](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g8a1cdb7004bb8a24f1342de9004add23>)*Â libraryOptions, void**Â libraryOptionValues, unsigned int Â numLibraryOptions )
     Load a library with specified file and options.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuLibraryUnload](<#group__CUDA__LIBRARY_1g24969cb24138171edf465bc8669d5914>) ( [CUlibrary](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gb3c679dac8f1ce28d437bedd0fc907d7>)Â library )
     Unloads a library.

### Functions

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuKernelGetAttribute ( int*Â pi, [CUfunction_attribute](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g9d955dde0904a9b43ca4d875ac1551bc>)Â attrib, [CUkernel](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g612028921e5736db673e4307589989ed>)Â kernel, [CUdevice](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g41ca2a24a242b36ef2ca77330b5fb72a>)Â dev )


Returns information about a kernel.

######  Parameters

`pi`
    \- Returned attribute value
`attrib`
    \- Attribute requested
`kernel`
    \- Kernel to query attribute of
`dev`
    \- Device to query attribute of

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_DEINITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9acf52f132faf29b473cdda6061f0f44a>), [CUDA_ERROR_NOT_INITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e98feb999f0af99b4a25ab26b3866f4df8>), [CUDA_ERROR_INVALID_HANDLE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e90fd2e63260c6317ba943af0f7e4b8d21>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>), [CUDA_ERROR_INVALID_DEVICE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e96f047e7215788ca96c81af92a04bfb6c>)

###### Description

Returns in `*pi` the integer value of the attribute `attrib` for the kernel `kernel` for the requested device `dev`. The supported attributes are:

  * [CU_FUNC_ATTRIBUTE_MAX_THREADS_PER_BLOCK](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg9d955dde0904a9b43ca4d875ac1551bca244b9a52d7426e6684acebf4c9e24b8>): The maximum number of threads per block, beyond which a launch of the kernel would fail. This number depends on both the kernel and the requested device.

  * [CU_FUNC_ATTRIBUTE_SHARED_SIZE_BYTES](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg9d955dde0904a9b43ca4d875ac1551bc15651a634781263c9d4ee6070a3991f4>): The size in bytes of statically-allocated shared memory per block required by this kernel. This does not include dynamically-allocated shared memory requested by the user at runtime.

  * [CU_FUNC_ATTRIBUTE_CONST_SIZE_BYTES](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg9d955dde0904a9b43ca4d875ac1551bc4a255dc4e2b8542e84c9431c1953a952>): The size in bytes of user-allocated constant memory required by this kernel.

  * [CU_FUNC_ATTRIBUTE_LOCAL_SIZE_BYTES](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg9d955dde0904a9b43ca4d875ac1551bc0318e60c17eb22c70ffb59f610c504dd>): The size in bytes of local memory used by each thread of this kernel.

  * [CU_FUNC_ATTRIBUTE_NUM_REGS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg9d955dde0904a9b43ca4d875ac1551bc217730c04b1edbc80bb1772c1d6a7752>): The number of registers used by each thread of this kernel.

  * [CU_FUNC_ATTRIBUTE_PTX_VERSION](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg9d955dde0904a9b43ca4d875ac1551bccbd28200668ad2de39035446a89bf930>): The PTX virtual architecture version for which the kernel was compiled. This value is the major PTX version * 10 + the minor PTX version, so a PTX version 1.3 function would return the value 13. Note that this may return the undefined value of 0 for cubins compiled prior to CUDA 3.0.

  * [CU_FUNC_ATTRIBUTE_BINARY_VERSION](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg9d955dde0904a9b43ca4d875ac1551bcc4f70f5d16889d0b75c3bf7a303eb437>): The binary architecture version for which the kernel was compiled. This value is the major binary version * 10 + the minor binary version, so a binary version 1.3 function would return the value 13. Note that this will return a value of 10 for legacy cubins that do not have a properly-encoded binary architecture version.

  * CU_FUNC_CACHE_MODE_CA: The attribute to indicate whether the kernel has been compiled with user specified option "-Xptxas \--dlcm=ca" set.

  * [CU_FUNC_ATTRIBUTE_MAX_DYNAMIC_SHARED_SIZE_BYTES](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg9d955dde0904a9b43ca4d875ac1551bc75b33d145e83462ef7292575015be03e>): The maximum size in bytes of dynamically-allocated shared memory.

  * [CU_FUNC_ATTRIBUTE_PREFERRED_SHARED_MEMORY_CARVEOUT](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg9d955dde0904a9b43ca4d875ac1551bcc75f6fd470b848653f026b8c82c10ae3>): Preferred shared memory-L1 cache split ratio in percent of total shared memory.

  * [CU_FUNC_ATTRIBUTE_CLUSTER_SIZE_MUST_BE_SET](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg9d955dde0904a9b43ca4d875ac1551bc8bd0417b504a8006cc6f57c023b54c2b>): If this attribute is set, the kernel must launch with a valid cluster size specified.

  * [CU_FUNC_ATTRIBUTE_REQUIRED_CLUSTER_WIDTH](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg9d955dde0904a9b43ca4d875ac1551bc1c83b56a254f78ddd5bf75ccfd15f0cb>): The required cluster width in blocks.

  * [CU_FUNC_ATTRIBUTE_REQUIRED_CLUSTER_HEIGHT](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg9d955dde0904a9b43ca4d875ac1551bc0c3f2eb7eaea02e3c85a4bedd02be331>): The required cluster height in blocks.

  * [CU_FUNC_ATTRIBUTE_REQUIRED_CLUSTER_DEPTH](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg9d955dde0904a9b43ca4d875ac1551bc4ab3672ad6476ad4bfa973e3083cdb32>): The required cluster depth in blocks.

  * [CU_FUNC_ATTRIBUTE_NON_PORTABLE_CLUSTER_SIZE_ALLOWED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg9d955dde0904a9b43ca4d875ac1551bce5ea0cdab1af87e68ac45e19e4c52c5d>): Indicates whether the function can be launched with non-portable cluster size. 1 is allowed, 0 is disallowed. A non-portable cluster size may only function on the specific SKUs the program is tested on. The launch might fail if the program is run on a different hardware platform. CUDA API provides cudaOccupancyMaxActiveClusters to assist with checking whether the desired size can be launched on the current device. A portable cluster size is guaranteed to be functional on all compute capabilities higher than the target compute capability. The portable cluster size for sm_90 is 8 blocks per cluster. This value may increase for future compute capabilities. The specific hardware unit may support higher cluster sizes thatâs not guaranteed to be portable.

  * [CU_FUNC_ATTRIBUTE_CLUSTER_SCHEDULING_POLICY_PREFERENCE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg9d955dde0904a9b43ca4d875ac1551bcad30df41ca0cac5046c58a75d91326a6>): The block scheduling policy of a function. The value type is CUclusterSchedulingPolicy.


Note:

If another thread is trying to set the same attribute on the same device using [cuKernelSetAttribute()](<group__CUDA__LIBRARY.html#group__CUDA__LIBRARY_1g1093ade718915249de3b14320d567067> "Sets information about a kernel.") simultaneously, the attribute query will give the old or new value depending on the interleavings chosen by the OS scheduler and memory consistency.

**See also:**

[cuLibraryLoadData](<group__CUDA__LIBRARY.html#group__CUDA__LIBRARY_1g957f12ff5af4166f43c89d17cfb0a74d> "Load a library with specified code and options."), [cuLibraryLoadFromFile](<group__CUDA__LIBRARY.html#group__CUDA__LIBRARY_1g88cff489fab37c7fd1985ceb61023205> "Load a library with specified file and options."), [cuLibraryUnload](<group__CUDA__LIBRARY.html#group__CUDA__LIBRARY_1g24969cb24138171edf465bc8669d5914> "Unloads a library."), [cuKernelSetAttribute](<group__CUDA__LIBRARY.html#group__CUDA__LIBRARY_1g1093ade718915249de3b14320d567067> "Sets information about a kernel."), [cuLibraryGetKernel](<group__CUDA__LIBRARY.html#group__CUDA__LIBRARY_1g15336d865f5abd63e3dc6004d5bc037a> "Returns a kernel handle."), [cuLaunchKernel](<group__CUDA__EXEC.html#group__CUDA__EXEC_1gb8f3dc3031b40da29d5f9a7139e52e15> "Launches a CUDA function CUfunction or a CUDA kernel CUkernel."), [cuKernelGetFunction](<group__CUDA__LIBRARY.html#group__CUDA__LIBRARY_1ge4cf9abafaba338acb977585b0d7374a> "Returns a function handle."), [cuLibraryGetModule](<group__CUDA__LIBRARY.html#group__CUDA__LIBRARY_1g0d439597c77b64cf247de33f0609a5d8> "Returns a module handle."), [cuModuleGetFunction](<group__CUDA__MODULE.html#group__CUDA__MODULE_1ga52be009b0d4045811b30c965e1cb2cf> "Returns a function handle."), [cuFuncGetAttribute](<group__CUDA__EXEC.html#group__CUDA__EXEC_1g5e92a1b0d8d1b82cb00dcfb2de15961b> "Returns information about a function.")

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuKernelGetFunction ( [CUfunction](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gba6128b948022f495706d93bc2cea9c8>)*Â pFunc, [CUkernel](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g612028921e5736db673e4307589989ed>)Â kernel )


Returns a function handle.

######  Parameters

`pFunc`
    \- Returned function handle
`kernel`
    \- Kernel to retrieve function for the requested context

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_DEINITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9acf52f132faf29b473cdda6061f0f44a>), [CUDA_ERROR_NOT_INITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e98feb999f0af99b4a25ab26b3866f4df8>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>), [CUDA_ERROR_INVALID_HANDLE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e90fd2e63260c6317ba943af0f7e4b8d21>), [CUDA_ERROR_NOT_FOUND](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9af1cadbeb21d3a78115ca211ba44c053>), [CUDA_ERROR_INVALID_CONTEXT](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a484e9af32c1e9893ff21f0e0191a12d>), [CUDA_ERROR_CONTEXT_IS_DESTROYED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9b27ac43f7ce8446f5c9636dd73fb2139>)

###### Description

Returns in `pFunc` the handle of the function for the requested kernel `kernel` and the current context. If function handle is not found, the call returns [CUDA_ERROR_NOT_FOUND](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9af1cadbeb21d3a78115ca211ba44c053>).

**See also:**

[cuLibraryLoadData](<group__CUDA__LIBRARY.html#group__CUDA__LIBRARY_1g957f12ff5af4166f43c89d17cfb0a74d> "Load a library with specified code and options."), [cuLibraryLoadFromFile](<group__CUDA__LIBRARY.html#group__CUDA__LIBRARY_1g88cff489fab37c7fd1985ceb61023205> "Load a library with specified file and options."), [cuLibraryUnload](<group__CUDA__LIBRARY.html#group__CUDA__LIBRARY_1g24969cb24138171edf465bc8669d5914> "Unloads a library."), [cuLibraryGetKernel](<group__CUDA__LIBRARY.html#group__CUDA__LIBRARY_1g15336d865f5abd63e3dc6004d5bc037a> "Returns a kernel handle."), [cuLibraryGetModule](<group__CUDA__LIBRARY.html#group__CUDA__LIBRARY_1g0d439597c77b64cf247de33f0609a5d8> "Returns a module handle."), [cuModuleGetFunction](<group__CUDA__MODULE.html#group__CUDA__MODULE_1ga52be009b0d4045811b30c965e1cb2cf> "Returns a function handle.")

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuKernelGetLibrary ( [CUlibrary](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gb3c679dac8f1ce28d437bedd0fc907d7>)*Â pLib, [CUkernel](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g612028921e5736db673e4307589989ed>)Â kernel )


Returns a library handle.

######  Parameters

`pLib`
    \- Returned library handle
`kernel`
    \- Kernel to retrieve library handle

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_DEINITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9acf52f132faf29b473cdda6061f0f44a>), [CUDA_ERROR_NOT_INITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e98feb999f0af99b4a25ab26b3866f4df8>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>), [CUDA_ERROR_INVALID_HANDLE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e90fd2e63260c6317ba943af0f7e4b8d21>), [CUDA_ERROR_NOT_FOUND](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9af1cadbeb21d3a78115ca211ba44c053>)

###### Description

Returns in `pLib` the handle of the library for the requested kernel `kernel`

**See also:**

[cuLibraryLoadData](<group__CUDA__LIBRARY.html#group__CUDA__LIBRARY_1g957f12ff5af4166f43c89d17cfb0a74d> "Load a library with specified code and options."), [cuLibraryLoadFromFile](<group__CUDA__LIBRARY.html#group__CUDA__LIBRARY_1g88cff489fab37c7fd1985ceb61023205> "Load a library with specified file and options."), [cuLibraryUnload](<group__CUDA__LIBRARY.html#group__CUDA__LIBRARY_1g24969cb24138171edf465bc8669d5914> "Unloads a library."), [cuLibraryGetKernel](<group__CUDA__LIBRARY.html#group__CUDA__LIBRARY_1g15336d865f5abd63e3dc6004d5bc037a> "Returns a kernel handle.")

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuKernelGetName ( const char**Â name, [CUkernel](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g612028921e5736db673e4307589989ed>)Â hfunc )


Returns the function name for a CUkernel handle.

######  Parameters

`name`
    \- The returned name of the function
`hfunc`
    \- The function handle to retrieve the name for

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>)

###### Description

Returns in `**name` the function name associated with the kernel handle `hfunc` . The function name is returned as a null-terminated string. The returned name is only valid when the kernel handle is valid. If the library is unloaded or reloaded, one must call the API again to get the updated name. This API may return a mangled name if the function is not declared as having C linkage. If either `**name` or `hfunc` is NULL, [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>) is returned.

Note:

Note that this function may also return error codes from previous, asynchronous launches.

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuKernelGetParamInfo ( [CUkernel](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g612028921e5736db673e4307589989ed>)Â kernel, size_tÂ paramIndex, size_t*Â paramOffset, size_t*Â paramSize )


Returns the offset and size of a kernel parameter in the device-side parameter layout.

######  Parameters

`kernel`
    \- The kernel to query
`paramIndex`
    \- The parameter index to query
`paramOffset`
    \- Returns the offset into the device-side parameter layout at which the parameter resides
`paramSize`
    \- Optionally returns the size of the parameter in the device-side parameter layout

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>),

###### Description

Queries the kernel parameter at `paramIndex` into `kernel's` list of parameters, and returns in `paramOffset` and `paramSize` the offset and size, respectively, where the parameter will reside in the device-side parameter layout. This information can be used to update kernel node parameters from the device via [cudaGraphKernelNodeSetParam()](<../cuda-runtime-api/group__CUDART__GRAPH.html#group__CUDART__GRAPH_1g0c2bd161eff1e47531eedce282e66d21>) and [cudaGraphKernelNodeUpdatesApply()](<../cuda-runtime-api/group__CUDART__GRAPH.html#group__CUDART__GRAPH_1g2d558cf37c9616365c67447e61ac0d6a>). `paramIndex` must be less than the number of parameters that `kernel` takes. `paramSize` can be set to NULL if only the parameter offset is desired.

Note:

Note that this function may also return error codes from previous, asynchronous launches.

**See also:**

[cuFuncGetParamInfo](<group__CUDA__EXEC.html#group__CUDA__EXEC_1g6874b82bcf2803902085645e46e0ca0e> "Returns the offset and size of a kernel parameter in the device-side parameter layout.")

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuKernelSetAttribute ( [CUfunction_attribute](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g9d955dde0904a9b43ca4d875ac1551bc>)Â attrib, int Â val, [CUkernel](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g612028921e5736db673e4307589989ed>)Â kernel, [CUdevice](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g41ca2a24a242b36ef2ca77330b5fb72a>)Â dev )


Sets information about a kernel.

######  Parameters

`attrib`
    \- Attribute requested
`val`
    \- Value to set
`kernel`
    \- Kernel to set attribute of
`dev`
    \- Device to set attribute of

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_DEINITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9acf52f132faf29b473cdda6061f0f44a>), [CUDA_ERROR_NOT_INITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e98feb999f0af99b4a25ab26b3866f4df8>), [CUDA_ERROR_INVALID_HANDLE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e90fd2e63260c6317ba943af0f7e4b8d21>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>), [CUDA_ERROR_INVALID_DEVICE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e96f047e7215788ca96c81af92a04bfb6c>), [CUDA_ERROR_OUT_OF_MEMORY](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9264c50688ed110e8476b591befe60c02>)

###### Description

This call sets the value of a specified attribute `attrib` on the kernel `kernel` for the requested device `dev` to an integer value specified by `val`. This function returns CUDA_SUCCESS if the new value of the attribute could be successfully set. If the set fails, this call will return an error. Not all attributes can have values set. Attempting to set a value on a read-only attribute will result in an error (CUDA_ERROR_INVALID_VALUE)

Note that attributes set using [cuFuncSetAttribute()](<group__CUDA__EXEC.html#group__CUDA__EXEC_1g0e37dce0173bc883aa1e5b14dd747f26> "Sets information about a function.") will override the attribute set by this API irrespective of whether the call to [cuFuncSetAttribute()](<group__CUDA__EXEC.html#group__CUDA__EXEC_1g0e37dce0173bc883aa1e5b14dd747f26> "Sets information about a function.") is made before or after this API call. However, [cuKernelGetAttribute()](<group__CUDA__LIBRARY.html#group__CUDA__LIBRARY_1gd98317cb151b99fbd95767418122071f> "Returns information about a kernel.") will always return the attribute value set by this API.

Supported attributes are:

  * [CU_FUNC_ATTRIBUTE_MAX_DYNAMIC_SHARED_SIZE_BYTES](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg9d955dde0904a9b43ca4d875ac1551bc75b33d145e83462ef7292575015be03e>): This is the maximum size in bytes of dynamically-allocated shared memory. The value should contain the requested maximum size of dynamically-allocated shared memory. The sum of this value and the function attribute [CU_FUNC_ATTRIBUTE_SHARED_SIZE_BYTES](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg9d955dde0904a9b43ca4d875ac1551bc15651a634781263c9d4ee6070a3991f4>) cannot exceed the device attribute [CU_DEVICE_ATTRIBUTE_MAX_SHARED_MEMORY_PER_BLOCK_OPTIN](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gge12b8a782bebe21b1ac0091bf9f4e2a3e788564c0a95b866dc624fbc1b49dab3>). The maximal size of requestable dynamic shared memory may differ by GPU architecture.

  * [CU_FUNC_ATTRIBUTE_PREFERRED_SHARED_MEMORY_CARVEOUT](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg9d955dde0904a9b43ca4d875ac1551bcc75f6fd470b848653f026b8c82c10ae3>): On devices where the L1 cache and shared memory use the same hardware resources, this sets the shared memory carveout preference, in percent of the total shared memory. See [CU_DEVICE_ATTRIBUTE_MAX_SHARED_MEMORY_PER_MULTIPROCESSOR](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gge12b8a782bebe21b1ac0091bf9f4e2a306a33c18889f6fc907412451c95154ed>) This is only a hint, and the driver can choose a different ratio if required to execute the function.

  * [CU_FUNC_ATTRIBUTE_REQUIRED_CLUSTER_WIDTH](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg9d955dde0904a9b43ca4d875ac1551bc1c83b56a254f78ddd5bf75ccfd15f0cb>): The required cluster width in blocks. The width, height, and depth values must either all be 0 or all be positive. The validity of the cluster dimensions is checked at launch time. If the value is set during compile time, it cannot be set at runtime. Setting it at runtime will return CUDA_ERROR_NOT_PERMITTED.

  * [CU_FUNC_ATTRIBUTE_REQUIRED_CLUSTER_HEIGHT](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg9d955dde0904a9b43ca4d875ac1551bc0c3f2eb7eaea02e3c85a4bedd02be331>): The required cluster height in blocks. The width, height, and depth values must either all be 0 or all be positive. The validity of the cluster dimensions is checked at launch time. If the value is set during compile time, it cannot be set at runtime. Setting it at runtime will return CUDA_ERROR_NOT_PERMITTED.

  * [CU_FUNC_ATTRIBUTE_REQUIRED_CLUSTER_DEPTH](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg9d955dde0904a9b43ca4d875ac1551bc4ab3672ad6476ad4bfa973e3083cdb32>): The required cluster depth in blocks. The width, height, and depth values must either all be 0 or all be positive. The validity of the cluster dimensions is checked at launch time. If the value is set during compile time, it cannot be set at runtime. Setting it at runtime will return CUDA_ERROR_NOT_PERMITTED.

  * [CU_FUNC_ATTRIBUTE_NON_PORTABLE_CLUSTER_SIZE_ALLOWED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg9d955dde0904a9b43ca4d875ac1551bce5ea0cdab1af87e68ac45e19e4c52c5d>): Indicates whether the function can be launched with non-portable cluster size. 1 is allowed, 0 is disallowed.

  * [CU_FUNC_ATTRIBUTE_CLUSTER_SCHEDULING_POLICY_PREFERENCE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg9d955dde0904a9b43ca4d875ac1551bcad30df41ca0cac5046c58a75d91326a6>): The block scheduling policy of a function. The value type is CUclusterSchedulingPolicy.


Note:

The API has stricter locking requirements in comparison to its legacy counterpart [cuFuncSetAttribute()](<group__CUDA__EXEC.html#group__CUDA__EXEC_1g0e37dce0173bc883aa1e5b14dd747f26> "Sets information about a function.") due to device-wide semantics. If multiple threads are trying to set the same attribute on the same device simultaneously, the attribute setting will depend on the interleavings chosen by the OS scheduler and memory consistency.

**See also:**

[cuLibraryLoadData](<group__CUDA__LIBRARY.html#group__CUDA__LIBRARY_1g957f12ff5af4166f43c89d17cfb0a74d> "Load a library with specified code and options."), [cuLibraryLoadFromFile](<group__CUDA__LIBRARY.html#group__CUDA__LIBRARY_1g88cff489fab37c7fd1985ceb61023205> "Load a library with specified file and options."), [cuLibraryUnload](<group__CUDA__LIBRARY.html#group__CUDA__LIBRARY_1g24969cb24138171edf465bc8669d5914> "Unloads a library."), [cuKernelGetAttribute](<group__CUDA__LIBRARY.html#group__CUDA__LIBRARY_1gd98317cb151b99fbd95767418122071f> "Returns information about a kernel."), [cuLibraryGetKernel](<group__CUDA__LIBRARY.html#group__CUDA__LIBRARY_1g15336d865f5abd63e3dc6004d5bc037a> "Returns a kernel handle."), [cuLaunchKernel](<group__CUDA__EXEC.html#group__CUDA__EXEC_1gb8f3dc3031b40da29d5f9a7139e52e15> "Launches a CUDA function CUfunction or a CUDA kernel CUkernel."), [cuKernelGetFunction](<group__CUDA__LIBRARY.html#group__CUDA__LIBRARY_1ge4cf9abafaba338acb977585b0d7374a> "Returns a function handle."), [cuLibraryGetModule](<group__CUDA__LIBRARY.html#group__CUDA__LIBRARY_1g0d439597c77b64cf247de33f0609a5d8> "Returns a module handle."), [cuModuleGetFunction](<group__CUDA__MODULE.html#group__CUDA__MODULE_1ga52be009b0d4045811b30c965e1cb2cf> "Returns a function handle."), [cuFuncSetAttribute](<group__CUDA__EXEC.html#group__CUDA__EXEC_1g0e37dce0173bc883aa1e5b14dd747f26> "Sets information about a function.")

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuKernelSetCacheConfig ( [CUkernel](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g612028921e5736db673e4307589989ed>)Â kernel, [CUfunc_cache](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g3b9bbcf42528b889e9dbe9cfa2aea3ec>)Â config, [CUdevice](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g41ca2a24a242b36ef2ca77330b5fb72a>)Â dev )


Sets the preferred cache configuration for a device kernel.

######  Parameters

`kernel`
    \- Kernel to configure cache for
`config`
    \- Requested cache configuration
`dev`
    \- Device to set attribute of

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_DEINITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9acf52f132faf29b473cdda6061f0f44a>), [CUDA_ERROR_NOT_INITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e98feb999f0af99b4a25ab26b3866f4df8>), [CUDA_ERROR_INVALID_HANDLE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e90fd2e63260c6317ba943af0f7e4b8d21>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>), [CUDA_ERROR_INVALID_DEVICE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e96f047e7215788ca96c81af92a04bfb6c>), [CUDA_ERROR_OUT_OF_MEMORY](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9264c50688ed110e8476b591befe60c02>)

###### Description

On devices where the L1 cache and shared memory use the same hardware resources, this sets through `config` the preferred cache configuration for the device kernel `kernel` on the requested device `dev`. This is only a preference. The driver will use the requested configuration if possible, but it is free to choose a different configuration if required to execute `kernel`. Any context-wide preference set via [cuCtxSetCacheConfig()](<group__CUDA__CTX.html#group__CUDA__CTX_1g54699acf7e2ef27279d013ca2095f4a3> "Sets the preferred cache configuration for the current context.") will be overridden by this per-kernel setting.

Note that attributes set using [cuFuncSetCacheConfig()](<group__CUDA__EXEC.html#group__CUDA__EXEC_1g40f8c11e81def95dc0072a375f965681> "Sets the preferred cache configuration for a device function.") will override the attribute set by this API irrespective of whether the call to [cuFuncSetCacheConfig()](<group__CUDA__EXEC.html#group__CUDA__EXEC_1g40f8c11e81def95dc0072a375f965681> "Sets the preferred cache configuration for a device function.") is made before or after this API call.

This setting does nothing on devices where the size of the L1 cache and shared memory are fixed.

Launching a kernel with a different preference than the most recent preference setting may insert a device-side synchronization point.

The supported cache configurations are:

  * [CU_FUNC_CACHE_PREFER_NONE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg3b9bbcf42528b889e9dbe9cfa2aea3ec47d2f367dc3965c27ff748688229dc22>): no preference for shared memory or L1 (default)

  * [CU_FUNC_CACHE_PREFER_SHARED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg3b9bbcf42528b889e9dbe9cfa2aea3ec712f43defb051d7985317bce426cccc8>): prefer larger shared memory and smaller L1 cache

  * [CU_FUNC_CACHE_PREFER_L1](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg3b9bbcf42528b889e9dbe9cfa2aea3ecb1e6c4e889e1a70ed5283172be08f6a5>): prefer larger L1 cache and smaller shared memory

  * [CU_FUNC_CACHE_PREFER_EQUAL](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg3b9bbcf42528b889e9dbe9cfa2aea3ec4434321280821d844a15b02e4d6c80a9>): prefer equal sized L1 cache and shared memory


Note:

The API has stricter locking requirements in comparison to its legacy counterpart [cuFuncSetCacheConfig()](<group__CUDA__EXEC.html#group__CUDA__EXEC_1g40f8c11e81def95dc0072a375f965681> "Sets the preferred cache configuration for a device function.") due to device-wide semantics. If multiple threads are trying to set a config on the same device simultaneously, the cache config setting will depend on the interleavings chosen by the OS scheduler and memory consistency.

**See also:**

[cuLibraryLoadData](<group__CUDA__LIBRARY.html#group__CUDA__LIBRARY_1g957f12ff5af4166f43c89d17cfb0a74d> "Load a library with specified code and options."), [cuLibraryLoadFromFile](<group__CUDA__LIBRARY.html#group__CUDA__LIBRARY_1g88cff489fab37c7fd1985ceb61023205> "Load a library with specified file and options."), [cuLibraryUnload](<group__CUDA__LIBRARY.html#group__CUDA__LIBRARY_1g24969cb24138171edf465bc8669d5914> "Unloads a library."), [cuLibraryGetKernel](<group__CUDA__LIBRARY.html#group__CUDA__LIBRARY_1g15336d865f5abd63e3dc6004d5bc037a> "Returns a kernel handle."), [cuKernelGetFunction](<group__CUDA__LIBRARY.html#group__CUDA__LIBRARY_1ge4cf9abafaba338acb977585b0d7374a> "Returns a function handle."), [cuLibraryGetModule](<group__CUDA__LIBRARY.html#group__CUDA__LIBRARY_1g0d439597c77b64cf247de33f0609a5d8> "Returns a module handle."), [cuModuleGetFunction](<group__CUDA__MODULE.html#group__CUDA__MODULE_1ga52be009b0d4045811b30c965e1cb2cf> "Returns a function handle."), [cuFuncSetCacheConfig](<group__CUDA__EXEC.html#group__CUDA__EXEC_1g40f8c11e81def95dc0072a375f965681> "Sets the preferred cache configuration for a device function."), [cuCtxSetCacheConfig](<group__CUDA__CTX.html#group__CUDA__CTX_1g54699acf7e2ef27279d013ca2095f4a3> "Sets the preferred cache configuration for the current context."), [cuLaunchKernel](<group__CUDA__EXEC.html#group__CUDA__EXEC_1gb8f3dc3031b40da29d5f9a7139e52e15> "Launches a CUDA function CUfunction or a CUDA kernel CUkernel.")

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuLibraryEnumerateKernels ( [CUkernel](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g612028921e5736db673e4307589989ed>)*Â kernels, unsigned int Â numKernels, [CUlibrary](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gb3c679dac8f1ce28d437bedd0fc907d7>)Â lib )


Retrieve the kernel handles within a library.

######  Parameters

`kernels`
    \- Buffer where the kernel handles are returned to
`numKernels`
    \- Maximum number of kernel handles may be returned to the buffer
`lib`
    \- Library to query from

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_INVALID_HANDLE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e90fd2e63260c6317ba943af0f7e4b8d21>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>)

###### Description

Returns in `kernels` a maximum number of `numKernels` kernel handles within `lib`. The returned kernel handle becomes invalid when the library is unloaded.

**See also:**

[cuLibraryGetKernelCount](<group__CUDA__LIBRARY.html#group__CUDA__LIBRARY_1g142732b1c9afaa662f21cae9a558d2d4> "Returns the number of kernels within a library.")

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuLibraryGetGlobal ( [CUdeviceptr](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g183f7b0d8ad008ea2a5fd552537ace4e>)*Â dptr, size_t*Â bytes, [CUlibrary](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gb3c679dac8f1ce28d437bedd0fc907d7>)Â library, const char*Â name )


Returns a global device pointer.

######  Parameters

`dptr`
    \- Returned global device pointer for the requested context
`bytes`
    \- Returned global size in bytes
`library`
    \- Library to retrieve global from
`name`
    \- Name of global to retrieve

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_DEINITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9acf52f132faf29b473cdda6061f0f44a>), [CUDA_ERROR_NOT_INITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e98feb999f0af99b4a25ab26b3866f4df8>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>), [CUDA_ERROR_INVALID_HANDLE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e90fd2e63260c6317ba943af0f7e4b8d21>), [CUDA_ERROR_NOT_FOUND](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9af1cadbeb21d3a78115ca211ba44c053>), [CUDA_ERROR_INVALID_CONTEXT](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a484e9af32c1e9893ff21f0e0191a12d>), [CUDA_ERROR_CONTEXT_IS_DESTROYED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9b27ac43f7ce8446f5c9636dd73fb2139>)

###### Description

Returns in `*dptr` and `*bytes` the base pointer and size of the global with name `name` for the requested library `library` and the current context. If no global for the requested name `name` exists, the call returns [CUDA_ERROR_NOT_FOUND](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9af1cadbeb21d3a78115ca211ba44c053>). One of the parameters `dptr` or `bytes` (not both) can be NULL in which case it is ignored.

**See also:**

[cuLibraryLoadData](<group__CUDA__LIBRARY.html#group__CUDA__LIBRARY_1g957f12ff5af4166f43c89d17cfb0a74d> "Load a library with specified code and options."), [cuLibraryLoadFromFile](<group__CUDA__LIBRARY.html#group__CUDA__LIBRARY_1g88cff489fab37c7fd1985ceb61023205> "Load a library with specified file and options."), [cuLibraryUnload](<group__CUDA__LIBRARY.html#group__CUDA__LIBRARY_1g24969cb24138171edf465bc8669d5914> "Unloads a library."), [cuLibraryGetModule](<group__CUDA__LIBRARY.html#group__CUDA__LIBRARY_1g0d439597c77b64cf247de33f0609a5d8> "Returns a module handle."), [cuModuleGetGlobal](<group__CUDA__MODULE.html#group__CUDA__MODULE_1gf3e43672e26073b1081476dbf47a86ab> "Returns a global pointer from a module.")

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuLibraryGetKernel ( [CUkernel](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g612028921e5736db673e4307589989ed>)*Â pKernel, [CUlibrary](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gb3c679dac8f1ce28d437bedd0fc907d7>)Â library, const char*Â name )


Returns a kernel handle.

######  Parameters

`pKernel`
    \- Returned kernel handle
`library`
    \- Library to retrieve kernel from
`name`
    \- Name of kernel to retrieve

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_DEINITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9acf52f132faf29b473cdda6061f0f44a>), [CUDA_ERROR_NOT_INITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e98feb999f0af99b4a25ab26b3866f4df8>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>), [CUDA_ERROR_INVALID_HANDLE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e90fd2e63260c6317ba943af0f7e4b8d21>), [CUDA_ERROR_NOT_FOUND](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9af1cadbeb21d3a78115ca211ba44c053>)

###### Description

Returns in `pKernel` the handle of the kernel with name `name` located in library `library`. If kernel handle is not found, the call returns [CUDA_ERROR_NOT_FOUND](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9af1cadbeb21d3a78115ca211ba44c053>).

**See also:**

[cuLibraryLoadData](<group__CUDA__LIBRARY.html#group__CUDA__LIBRARY_1g957f12ff5af4166f43c89d17cfb0a74d> "Load a library with specified code and options."), [cuLibraryLoadFromFile](<group__CUDA__LIBRARY.html#group__CUDA__LIBRARY_1g88cff489fab37c7fd1985ceb61023205> "Load a library with specified file and options."), [cuLibraryUnload](<group__CUDA__LIBRARY.html#group__CUDA__LIBRARY_1g24969cb24138171edf465bc8669d5914> "Unloads a library."), [cuKernelGetFunction](<group__CUDA__LIBRARY.html#group__CUDA__LIBRARY_1ge4cf9abafaba338acb977585b0d7374a> "Returns a function handle."), [cuLibraryGetModule](<group__CUDA__LIBRARY.html#group__CUDA__LIBRARY_1g0d439597c77b64cf247de33f0609a5d8> "Returns a module handle."), [cuModuleGetFunction](<group__CUDA__MODULE.html#group__CUDA__MODULE_1ga52be009b0d4045811b30c965e1cb2cf> "Returns a function handle.")

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuLibraryGetKernelCount ( unsigned int*Â count, [CUlibrary](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gb3c679dac8f1ce28d437bedd0fc907d7>)Â lib )


Returns the number of kernels within a library.

######  Parameters

`count`
    \- Number of kernels found within the library
`lib`
    \- Library to query

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_INVALID_HANDLE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e90fd2e63260c6317ba943af0f7e4b8d21>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>)

###### Description

Returns in `count` the number of kernels in `lib`.

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuLibraryGetManaged ( [CUdeviceptr](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g183f7b0d8ad008ea2a5fd552537ace4e>)*Â dptr, size_t*Â bytes, [CUlibrary](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gb3c679dac8f1ce28d437bedd0fc907d7>)Â library, const char*Â name )


Returns a pointer to managed memory.

######  Parameters

`dptr`
    \- Returned pointer to the managed memory
`bytes`
    \- Returned memory size in bytes
`library`
    \- Library to retrieve managed memory from
`name`
    \- Name of managed memory to retrieve

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_DEINITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9acf52f132faf29b473cdda6061f0f44a>), [CUDA_ERROR_NOT_INITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e98feb999f0af99b4a25ab26b3866f4df8>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>), [CUDA_ERROR_INVALID_HANDLE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e90fd2e63260c6317ba943af0f7e4b8d21>), [CUDA_ERROR_NOT_FOUND](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9af1cadbeb21d3a78115ca211ba44c053>)

###### Description

Returns in `*dptr` and `*bytes` the base pointer and size of the managed memory with name `name` for the requested library `library`. If no managed memory with the requested name `name` exists, the call returns [CUDA_ERROR_NOT_FOUND](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9af1cadbeb21d3a78115ca211ba44c053>). One of the parameters `dptr` or `bytes` (not both) can be NULL in which case it is ignored. Note that managed memory for library `library` is shared across devices and is registered when the library is loaded into atleast one context.

**See also:**

[cuLibraryLoadData](<group__CUDA__LIBRARY.html#group__CUDA__LIBRARY_1g957f12ff5af4166f43c89d17cfb0a74d> "Load a library with specified code and options."), [cuLibraryLoadFromFile](<group__CUDA__LIBRARY.html#group__CUDA__LIBRARY_1g88cff489fab37c7fd1985ceb61023205> "Load a library with specified file and options."), [cuLibraryUnload](<group__CUDA__LIBRARY.html#group__CUDA__LIBRARY_1g24969cb24138171edf465bc8669d5914> "Unloads a library.")

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuLibraryGetModule ( [CUmodule](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g9e4ef4dcfba4662b2299acb8d049a1ef>)*Â pMod, [CUlibrary](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gb3c679dac8f1ce28d437bedd0fc907d7>)Â library )


Returns a module handle.

######  Parameters

`pMod`
    \- Returned module handle
`library`
    \- Library to retrieve module from

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_DEINITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9acf52f132faf29b473cdda6061f0f44a>), [CUDA_ERROR_NOT_INITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e98feb999f0af99b4a25ab26b3866f4df8>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>), [CUDA_ERROR_INVALID_HANDLE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e90fd2e63260c6317ba943af0f7e4b8d21>), [CUDA_ERROR_NOT_FOUND](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9af1cadbeb21d3a78115ca211ba44c053>), [CUDA_ERROR_INVALID_CONTEXT](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a484e9af32c1e9893ff21f0e0191a12d>), [CUDA_ERROR_CONTEXT_IS_DESTROYED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9b27ac43f7ce8446f5c9636dd73fb2139>)

###### Description

Returns in `pMod` the module handle associated with the current context located in library `library`. If module handle is not found, the call returns [CUDA_ERROR_NOT_FOUND](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9af1cadbeb21d3a78115ca211ba44c053>).

**See also:**

[cuLibraryLoadData](<group__CUDA__LIBRARY.html#group__CUDA__LIBRARY_1g957f12ff5af4166f43c89d17cfb0a74d> "Load a library with specified code and options."), [cuLibraryLoadFromFile](<group__CUDA__LIBRARY.html#group__CUDA__LIBRARY_1g88cff489fab37c7fd1985ceb61023205> "Load a library with specified file and options."), [cuLibraryUnload](<group__CUDA__LIBRARY.html#group__CUDA__LIBRARY_1g24969cb24138171edf465bc8669d5914> "Unloads a library."), [cuModuleGetFunction](<group__CUDA__MODULE.html#group__CUDA__MODULE_1ga52be009b0d4045811b30c965e1cb2cf> "Returns a function handle.")

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuLibraryGetUnifiedFunction ( void**Â fptr, [CUlibrary](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gb3c679dac8f1ce28d437bedd0fc907d7>)Â library, const char*Â symbol )


Returns a pointer to a unified function.

######  Parameters

`fptr`
    \- Returned pointer to a unified function
`library`
    \- Library to retrieve function pointer memory from
`symbol`
    \- Name of function pointer to retrieve

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_DEINITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9acf52f132faf29b473cdda6061f0f44a>), [CUDA_ERROR_NOT_INITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e98feb999f0af99b4a25ab26b3866f4df8>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>), [CUDA_ERROR_INVALID_HANDLE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e90fd2e63260c6317ba943af0f7e4b8d21>), [CUDA_ERROR_NOT_FOUND](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9af1cadbeb21d3a78115ca211ba44c053>)

###### Description

Returns in `*fptr` the function pointer to a unified function denoted by `symbol`. If no unified function with name `symbol` exists, the call returns [CUDA_ERROR_NOT_FOUND](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9af1cadbeb21d3a78115ca211ba44c053>). If there is no device with attribute [CU_DEVICE_ATTRIBUTE_UNIFIED_FUNCTION_POINTERS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gge12b8a782bebe21b1ac0091bf9f4e2a3f64e13496d96670082083817ba6c6266>) present in the system, the call may return [CUDA_ERROR_NOT_FOUND](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9af1cadbeb21d3a78115ca211ba44c053>).

**See also:**

[cuLibraryLoadData](<group__CUDA__LIBRARY.html#group__CUDA__LIBRARY_1g957f12ff5af4166f43c89d17cfb0a74d> "Load a library with specified code and options."), [cuLibraryLoadFromFile](<group__CUDA__LIBRARY.html#group__CUDA__LIBRARY_1g88cff489fab37c7fd1985ceb61023205> "Load a library with specified file and options."), [cuLibraryUnload](<group__CUDA__LIBRARY.html#group__CUDA__LIBRARY_1g24969cb24138171edf465bc8669d5914> "Unloads a library.")

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuLibraryLoadData ( [CUlibrary](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gb3c679dac8f1ce28d437bedd0fc907d7>)*Â library, const void*Â code, [CUjit_option](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g5527fa8030d5cabedc781a04dbd1997d>)*Â jitOptions, void**Â jitOptionsValues, unsigned int Â numJitOptions, [CUlibraryOption](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g8a1cdb7004bb8a24f1342de9004add23>)*Â libraryOptions, void**Â libraryOptionValues, unsigned int Â numLibraryOptions )


Load a library with specified code and options.

######  Parameters

`library`
    \- Returned library
`code`
    \- Code to load
`jitOptions`
    \- Options for JIT
`jitOptionsValues`
    \- Option values for JIT
`numJitOptions`
    \- Number of options
`libraryOptions`
    \- Options for loading
`libraryOptionValues`
    \- Option values for loading
`numLibraryOptions`
    \- Number of options for loading

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_DEINITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9acf52f132faf29b473cdda6061f0f44a>), [CUDA_ERROR_NOT_INITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e98feb999f0af99b4a25ab26b3866f4df8>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>), [CUDA_ERROR_INVALID_PTX](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a5bb7f216af3efbea2116ff18253b1a3>), [CUDA_ERROR_UNSUPPORTED_PTX_VERSION](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e98381092e26bfe660cef4a755bb549610>), [CUDA_ERROR_OUT_OF_MEMORY](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9264c50688ed110e8476b591befe60c02>), [CUDA_ERROR_NO_BINARY_FOR_GPU](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e94ef545ed5f461db9351f98de98497abf>), [CUDA_ERROR_SHARED_OBJECT_SYMBOL_NOT_FOUND](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e95ab6c0086a6130b5b895ff15ce841ee6>), [CUDA_ERROR_SHARED_OBJECT_INIT_FAILED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9d8a149ebc98aa90f6417e531fa645043>), [CUDA_ERROR_JIT_COMPILER_NOT_FOUND](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e91e1b93d0f27e74d6a9e9e16f410542c6>), [CUDA_ERROR_NOT_SUPPORTED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e954756ae7ade0dfd09faeccb513dd831b>)

###### Description

Takes a pointer `code` and loads the corresponding library `library` based on the application defined library loading mode:

  * If module loading is set to EAGER, via the environment variables described in "Module loading", `library` is loaded eagerly into all contexts at the time of the call and future contexts at the time of creation until the library is unloaded with [cuLibraryUnload()](<group__CUDA__LIBRARY.html#group__CUDA__LIBRARY_1g24969cb24138171edf465bc8669d5914> "Unloads a library.").

  * If the environment variables are set to LAZY, `library` is not immediately loaded onto all existent contexts and will only be loaded when a function is needed for that context, such as a kernel launch.


These environment variables are described in the CUDA programming guide under the "CUDA environment variables" section.

The `code` may be a cubin or fatbin as output by **nvcc** , or a NULL-terminated PTX, either as output by **nvcc** or hand-written, or Tile IR data. A fatbin should also contain relocatable code when doing separate compilation.

Options are passed as an array via `jitOptions` and any corresponding parameters are passed in `jitOptionsValues`. The number of total JIT options is supplied via `numJitOptions`. Any outputs will be returned via `jitOptionsValues`.

Library load options are passed as an array via `libraryOptions` and any corresponding parameters are passed in `libraryOptionValues`. The number of total library load options is supplied via `numLibraryOptions`.

Note:

If the library contains managed variables and no device in the system supports managed variables this call is expected to return [CUDA_ERROR_NOT_SUPPORTED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e954756ae7ade0dfd09faeccb513dd831b>)

**See also:**

[cuLibraryLoadFromFile](<group__CUDA__LIBRARY.html#group__CUDA__LIBRARY_1g88cff489fab37c7fd1985ceb61023205> "Load a library with specified file and options."), [cuLibraryUnload](<group__CUDA__LIBRARY.html#group__CUDA__LIBRARY_1g24969cb24138171edf465bc8669d5914> "Unloads a library."), [cuModuleLoad](<group__CUDA__MODULE.html#group__CUDA__MODULE_1g366093bd269dafd0af21f1c7d18115d3> "Loads a compute module."), [cuModuleLoadData](<group__CUDA__MODULE.html#group__CUDA__MODULE_1g04ce266ce03720f479eab76136b90c0b> "Load a module's data."), [cuModuleLoadDataEx](<group__CUDA__MODULE.html#group__CUDA__MODULE_1g9e8047e9dbf725f0cd7cafd18bfd4d12> "Load a module's data with options.")

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuLibraryLoadFromFile ( [CUlibrary](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gb3c679dac8f1ce28d437bedd0fc907d7>)*Â library, const char*Â fileName, [CUjit_option](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g5527fa8030d5cabedc781a04dbd1997d>)*Â jitOptions, void**Â jitOptionsValues, unsigned int Â numJitOptions, [CUlibraryOption](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g8a1cdb7004bb8a24f1342de9004add23>)*Â libraryOptions, void**Â libraryOptionValues, unsigned int Â numLibraryOptions )


Load a library with specified file and options.

######  Parameters

`library`
    \- Returned library
`fileName`
    \- File to load from
`jitOptions`
    \- Options for JIT
`jitOptionsValues`
    \- Option values for JIT
`numJitOptions`
    \- Number of options
`libraryOptions`
    \- Options for loading
`libraryOptionValues`
    \- Option values for loading
`numLibraryOptions`
    \- Number of options for loading

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_DEINITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9acf52f132faf29b473cdda6061f0f44a>), [CUDA_ERROR_NOT_INITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e98feb999f0af99b4a25ab26b3866f4df8>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>), [CUDA_ERROR_INVALID_PTX](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a5bb7f216af3efbea2116ff18253b1a3>), [CUDA_ERROR_UNSUPPORTED_PTX_VERSION](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e98381092e26bfe660cef4a755bb549610>), [CUDA_ERROR_OUT_OF_MEMORY](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9264c50688ed110e8476b591befe60c02>), [CUDA_ERROR_NO_BINARY_FOR_GPU](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e94ef545ed5f461db9351f98de98497abf>), [CUDA_ERROR_SHARED_OBJECT_SYMBOL_NOT_FOUND](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e95ab6c0086a6130b5b895ff15ce841ee6>), [CUDA_ERROR_SHARED_OBJECT_INIT_FAILED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9d8a149ebc98aa90f6417e531fa645043>), [CUDA_ERROR_JIT_COMPILER_NOT_FOUND](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e91e1b93d0f27e74d6a9e9e16f410542c6>), [CUDA_ERROR_NOT_SUPPORTED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e954756ae7ade0dfd09faeccb513dd831b>)

###### Description

Takes a pointer `code` and loads the corresponding library `library` based on the application defined library loading mode:

  * If module loading is set to EAGER, via the environment variables described in "Module loading", `library` is loaded eagerly into all contexts at the time of the call and future contexts at the time of creation until the library is unloaded with [cuLibraryUnload()](<group__CUDA__LIBRARY.html#group__CUDA__LIBRARY_1g24969cb24138171edf465bc8669d5914> "Unloads a library.").

  * If the environment variables are set to LAZY, `library` is not immediately loaded onto all existent contexts and will only be loaded when a function is needed for that context, such as a kernel launch.


These environment variables are described in the CUDA programming guide under the "CUDA environment variables" section.

The file should be a cubin file as output by **nvcc** , or a PTX file either as output by **nvcc** or handwritten, or a fatbin file as output by **nvcc** or hand-written, or Tile IR file. A fatbin should also contain relocatable code when doing separate compilation.

Options are passed as an array via `jitOptions` and any corresponding parameters are passed in `jitOptionsValues`. The number of total options is supplied via `numJitOptions`. Any outputs will be returned via `jitOptionsValues`.

Library load options are passed as an array via `libraryOptions` and any corresponding parameters are passed in `libraryOptionValues`. The number of total library load options is supplied via `numLibraryOptions`.

Note:

If the library contains managed variables and no device in the system supports managed variables this call is expected to return [CUDA_ERROR_NOT_SUPPORTED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e954756ae7ade0dfd09faeccb513dd831b>)

**See also:**

[cuLibraryLoadData](<group__CUDA__LIBRARY.html#group__CUDA__LIBRARY_1g957f12ff5af4166f43c89d17cfb0a74d> "Load a library with specified code and options."), [cuLibraryUnload](<group__CUDA__LIBRARY.html#group__CUDA__LIBRARY_1g24969cb24138171edf465bc8669d5914> "Unloads a library."), [cuModuleLoad](<group__CUDA__MODULE.html#group__CUDA__MODULE_1g366093bd269dafd0af21f1c7d18115d3> "Loads a compute module."), [cuModuleLoadData](<group__CUDA__MODULE.html#group__CUDA__MODULE_1g04ce266ce03720f479eab76136b90c0b> "Load a module's data."), [cuModuleLoadDataEx](<group__CUDA__MODULE.html#group__CUDA__MODULE_1g9e8047e9dbf725f0cd7cafd18bfd4d12> "Load a module's data with options.")

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuLibraryUnload ( [CUlibrary](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gb3c679dac8f1ce28d437bedd0fc907d7>)Â library )


Unloads a library.

######  Parameters

`library`
    \- Library to unload

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_DEINITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9acf52f132faf29b473cdda6061f0f44a>), [CUDA_ERROR_NOT_INITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e98feb999f0af99b4a25ab26b3866f4df8>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>)

###### Description

Unloads the library specified with `library`

**See also:**

[cuLibraryLoadData](<group__CUDA__LIBRARY.html#group__CUDA__LIBRARY_1g957f12ff5af4166f43c89d17cfb0a74d> "Load a library with specified code and options."), [cuLibraryLoadFromFile](<group__CUDA__LIBRARY.html#group__CUDA__LIBRARY_1g88cff489fab37c7fd1985ceb61023205> "Load a library with specified file and options."), [cuModuleUnload](<group__CUDA__MODULE.html#group__CUDA__MODULE_1g8ea3d716524369de3763104ced4ea57b> "Unloads a module.")

* * *


---

# Memory Management

## 6.13.Â Memory Management

This section describes the memory management functions of the low-level CUDA driver application programming interface.

### Classes

structÂ

[CUmemDecompressParams](<structCUmemDecompressParams.html#structCUmemDecompressParams> "Structure describing the parameters that compose a single decompression operation.")

     Structure describing the parameters that compose a single decompression operation. [](<structCUmemDecompressParams.html#structCUmemDecompressParams> "Structure describing the parameters that compose a single decompression operation.")

### Enumerations

enumÂ [CUmemDecompressAlgorithm](<#group__CUDA__MEM_1g6c015495b909c100e19cd4ddafceee91>)
     Bitmasks for CU_DEVICE_ATTRIBUTE_MEM_DECOMPRESS_ALGORITHM_MASK.

### Functions

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuArray3DCreate](<#group__CUDA__MEM_1gc2322c70b38c2984536c90ed118bb1d7>) ( [CUarray](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gd550651524a56766b60f10f0e7628042>)*Â pHandle, const [CUDA_ARRAY3D_DESCRIPTOR](<structCUDA__ARRAY3D__DESCRIPTOR__v2.html#structCUDA__ARRAY3D__DESCRIPTOR__v2>)*Â pAllocateArray )
     Creates a 3D CUDA array.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuArray3DGetDescriptor](<#group__CUDA__MEM_1gb58549f2f3f390b9e0e7c8f3acd53857>) ( [CUDA_ARRAY3D_DESCRIPTOR](<structCUDA__ARRAY3D__DESCRIPTOR__v2.html#structCUDA__ARRAY3D__DESCRIPTOR__v2>)*Â pArrayDescriptor, [CUarray](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gd550651524a56766b60f10f0e7628042>)Â hArray )
     Get a 3D CUDA array descriptor.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuArrayCreate](<#group__CUDA__MEM_1g4192ff387a81c3bd5ed8c391ed62ca24>) ( [CUarray](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gd550651524a56766b60f10f0e7628042>)*Â pHandle, const [CUDA_ARRAY_DESCRIPTOR](<structCUDA__ARRAY__DESCRIPTOR__v2.html#structCUDA__ARRAY__DESCRIPTOR__v2>)*Â pAllocateArray )
     Creates a 1D or 2D CUDA array.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuArrayDestroy](<#group__CUDA__MEM_1g982878affbbc023de84874faac838b0b>) ( [CUarray](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gd550651524a56766b60f10f0e7628042>)Â hArray )
     Destroys a CUDA array.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuArrayGetDescriptor](<#group__CUDA__MEM_1g661fe823dbd37bf11f82a71bd4762acf>) ( [CUDA_ARRAY_DESCRIPTOR](<structCUDA__ARRAY__DESCRIPTOR__v2.html#structCUDA__ARRAY__DESCRIPTOR__v2>)*Â pArrayDescriptor, [CUarray](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gd550651524a56766b60f10f0e7628042>)Â hArray )
     Get a 1D or 2D CUDA array descriptor.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuArrayGetMemoryRequirements](<#group__CUDA__MEM_1gac8761ced0fa462e4762f6528073d9f4>) ( [CUDA_ARRAY_MEMORY_REQUIREMENTS](<structCUDA__ARRAY__MEMORY__REQUIREMENTS__v1.html#structCUDA__ARRAY__MEMORY__REQUIREMENTS__v1>)*Â memoryRequirements, [CUarray](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gd550651524a56766b60f10f0e7628042>)Â array, [CUdevice](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g41ca2a24a242b36ef2ca77330b5fb72a>)Â device )
     Returns the memory requirements of a CUDA array.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuArrayGetPlane](<#group__CUDA__MEM_1ge66ce245a1e3802f9ccc3583cec6b71f>) ( [CUarray](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gd550651524a56766b60f10f0e7628042>)*Â pPlaneArray, [CUarray](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gd550651524a56766b60f10f0e7628042>)Â hArray, unsigned int Â planeIdx )
     Gets a CUDA array plane from a CUDA array.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuArrayGetSparseProperties](<#group__CUDA__MEM_1gf74df88a07404ee051f0e5b36647d8c7>) ( [CUDA_ARRAY_SPARSE_PROPERTIES](<structCUDA__ARRAY__SPARSE__PROPERTIES__v1.html#structCUDA__ARRAY__SPARSE__PROPERTIES__v1>)*Â sparseProperties, [CUarray](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gd550651524a56766b60f10f0e7628042>)Â array )
     Returns the layout properties of a sparse CUDA array.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuDeviceGetByPCIBusId](<#group__CUDA__MEM_1ga89cd3fa06334ba7853ed1232c5ebe2a>) ( [CUdevice](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g41ca2a24a242b36ef2ca77330b5fb72a>)*Â dev, const char*Â pciBusId )
     Returns a handle to a compute device.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuDeviceGetPCIBusId](<#group__CUDA__MEM_1g85295e7d9745ab8f0aa80dd1e172acfc>) ( char*Â pciBusId, int Â len, [CUdevice](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g41ca2a24a242b36ef2ca77330b5fb72a>)Â dev )
     Returns a PCI Bus Id string for the device.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuDeviceRegisterAsyncNotification](<#group__CUDA__MEM_1g4325f3e53f7817c93b37f12da91ed199>) ( [CUdevice](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g41ca2a24a242b36ef2ca77330b5fb72a>)Â device, [CUasyncCallback](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g466d4731f270b66441a355ddb2c84777>)Â callbackFunc, void*Â userData, [CUasyncCallbackHandle](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g0ff5c3d4645d51b02b6d11b8b0c228c5>)*Â callback )
     Registers a callback function to receive async notifications.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuDeviceUnregisterAsyncNotification](<#group__CUDA__MEM_1gc0ae698fd18cbc2c395c9140e28e83ca>) ( [CUdevice](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g41ca2a24a242b36ef2ca77330b5fb72a>)Â device, [CUasyncCallbackHandle](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g0ff5c3d4645d51b02b6d11b8b0c228c5>)Â callback )
     Unregisters an async notification callback.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuIpcCloseMemHandle](<#group__CUDA__MEM_1gd6f5d5bcf6376c6853b64635b0157b9e>) ( [CUdeviceptr](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g183f7b0d8ad008ea2a5fd552537ace4e>)Â dptr )
     Attempts to close memory mapped with cuIpcOpenMemHandle.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuIpcGetEventHandle](<#group__CUDA__MEM_1gea02eadd12483de5305878b13288a86c>) ( [CUipcEventHandle](<structCUipcEventHandle__v1.html#structCUipcEventHandle__v1>)*Â pHandle, [CUevent](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g6d740185cf0953636d4ae37f68d7559b>)Â event )
     Gets an interprocess handle for a previously allocated event.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuIpcGetMemHandle](<#group__CUDA__MEM_1g6f1b5be767b275f016523b2ac49ebec1>) ( [CUipcMemHandle](<structCUipcMemHandle__v1.html#structCUipcMemHandle__v1>)*Â pHandle, [CUdeviceptr](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g183f7b0d8ad008ea2a5fd552537ace4e>)Â dptr )
     Gets an interprocess memory handle for an existing device memory allocation.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuIpcOpenEventHandle](<#group__CUDA__MEM_1gf1d525918b6c643b99ca8c8e42e36c2e>) ( [CUevent](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g6d740185cf0953636d4ae37f68d7559b>)*Â phEvent, [CUipcEventHandle](<structCUipcEventHandle__v1.html#structCUipcEventHandle__v1>)Â handle )
     Opens an interprocess event handle for use in the current process.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuIpcOpenMemHandle](<#group__CUDA__MEM_1ga8bd126fcff919a0c996b7640f197b79>) ( [CUdeviceptr](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g183f7b0d8ad008ea2a5fd552537ace4e>)*Â pdptr, [CUipcMemHandle](<structCUipcMemHandle__v1.html#structCUipcMemHandle__v1>)Â handle, unsigned int Â Flags )
     Opens an interprocess memory handle exported from another process and returns a device pointer usable in the local process.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuMemAlloc](<#group__CUDA__MEM_1gb82d2a09844a58dd9e744dc31e8aa467>) ( [CUdeviceptr](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g183f7b0d8ad008ea2a5fd552537ace4e>)*Â dptr, size_tÂ bytesize )
     Allocates device memory.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuMemAllocHost](<#group__CUDA__MEM_1gdd8311286d2c2691605362c689bc64e0>) ( void**Â pp, size_tÂ bytesize )
     Allocates page-locked host memory.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuMemAllocManaged](<#group__CUDA__MEM_1gb347ded34dc326af404aa02af5388a32>) ( [CUdeviceptr](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g183f7b0d8ad008ea2a5fd552537ace4e>)*Â dptr, size_tÂ bytesize, unsigned int Â flags )
     Allocates memory that will be automatically managed by the Unified Memory system.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuMemAllocPitch](<#group__CUDA__MEM_1gcbe9b033f6c4de80f63cc6e58ed9a45a>) ( [CUdeviceptr](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g183f7b0d8ad008ea2a5fd552537ace4e>)*Â dptr, size_t*Â pPitch, size_tÂ WidthInBytes, size_tÂ Height, unsigned int Â ElementSizeBytes )
     Allocates pitched device memory.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuMemBatchDecompressAsync](<#group__CUDA__MEM_1g51e9452797573fa7597f2896182c8826>) ( [CUmemDecompressParams](<structCUmemDecompressParams.html#structCUmemDecompressParams> "Structure describing the parameters that compose a single decompression operation. ")*Â paramsArray, size_tÂ count, unsigned int Â flags, size_t*Â errorIndex, [CUstream](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gb946c7f02e09efd788a204718015d88a>)Â stream )
     Submit a batch of `count` independent decompression operations.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuMemFree](<#group__CUDA__MEM_1g89b3f154e17cc89b6eea277dbdf5c93a>) ( [CUdeviceptr](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g183f7b0d8ad008ea2a5fd552537ace4e>)Â dptr )
     Frees device memory.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuMemFreeHost](<#group__CUDA__MEM_1g62e0fdbe181dab6b1c90fa1a51c7b92c>) ( void*Â p )
     Frees page-locked host memory.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuMemGetAddressRange](<#group__CUDA__MEM_1g64fee5711274a2a0573a789c94d8299b>) ( [CUdeviceptr](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g183f7b0d8ad008ea2a5fd552537ace4e>)*Â pbase, size_t*Â psize, [CUdeviceptr](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g183f7b0d8ad008ea2a5fd552537ace4e>)Â dptr )
     Get information on memory allocations.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuMemGetHandleForAddressRange](<#group__CUDA__MEM_1g51e719462c04ee90a6b0f8b2a75fe031>) ( void*Â handle, [CUdeviceptr](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g183f7b0d8ad008ea2a5fd552537ace4e>)Â dptr, size_tÂ size, [CUmemRangeHandleType](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g579b315f05d1e65a4f3de7da45013210>)Â handleType, unsigned long longÂ flags )
     Retrieve handle for an address range.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuMemGetInfo](<#group__CUDA__MEM_1g808f555540d0143a331cc42aa98835c0>) ( size_t*Â free, size_t*Â total )
     Gets free and total memory.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuMemHostAlloc](<#group__CUDA__MEM_1g572ca4011bfcb25034888a14d4e035b9>) ( void**Â pp, size_tÂ bytesize, unsigned int Â Flags )
     Allocates page-locked host memory.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuMemHostGetDevicePointer](<#group__CUDA__MEM_1g57a39e5cba26af4d06be67fc77cc62f0>) ( [CUdeviceptr](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g183f7b0d8ad008ea2a5fd552537ace4e>)*Â pdptr, void*Â p, unsigned int Â Flags )
     Passes back device pointer of mapped pinned memory.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuMemHostGetFlags](<#group__CUDA__MEM_1g42066246915fcb0400df2a17a851b35f>) ( unsigned int*Â pFlags, void*Â p )
     Passes back flags that were used for a pinned allocation.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuMemHostRegister](<#group__CUDA__MEM_1gf0a9fe11544326dabd743b7aa6b54223>) ( void*Â p, size_tÂ bytesize, unsigned int Â Flags )
     Registers an existing host memory range for use by CUDA.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuMemHostUnregister](<#group__CUDA__MEM_1g63f450c8125359be87b7623b1c0b2a14>) ( void*Â p )
     Unregisters a memory range that was registered with cuMemHostRegister.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuMemcpy](<#group__CUDA__MEM_1g8d0ff510f26d4b87bd3a51e731e7f698>) ( [CUdeviceptr](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g183f7b0d8ad008ea2a5fd552537ace4e>)Â dst, [CUdeviceptr](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g183f7b0d8ad008ea2a5fd552537ace4e>)Â src, size_tÂ ByteCount )
     Copies memory.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuMemcpy2D](<#group__CUDA__MEM_1g27f885b30c34cc20a663a671dbf6fc27>) ( const [CUDA_MEMCPY2D](<structCUDA__MEMCPY2D__v2.html#structCUDA__MEMCPY2D__v2>)*Â pCopy )
     Copies memory for 2D arrays.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuMemcpy2DAsync](<#group__CUDA__MEM_1g4acf155faeb969d9d21f5433d3d0f274>) ( const [CUDA_MEMCPY2D](<structCUDA__MEMCPY2D__v2.html#structCUDA__MEMCPY2D__v2>)*Â pCopy, [CUstream](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gb946c7f02e09efd788a204718015d88a>)Â hStream )
     Copies memory for 2D arrays.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuMemcpy2DUnaligned](<#group__CUDA__MEM_1g2fa285d47fd7020e596bfeab3deb651b>) ( const [CUDA_MEMCPY2D](<structCUDA__MEMCPY2D__v2.html#structCUDA__MEMCPY2D__v2>)*Â pCopy )
     Copies memory for 2D arrays.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuMemcpy3D](<#group__CUDA__MEM_1g4b5238975579f002c0199a3800ca44df>) ( const [CUDA_MEMCPY3D](<structCUDA__MEMCPY3D__v2.html#structCUDA__MEMCPY3D__v2>)*Â pCopy )
     Copies memory for 3D arrays.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuMemcpy3DAsync](<#group__CUDA__MEM_1g79f4f3fde6ae0f529568d881d9e11987>) ( const [CUDA_MEMCPY3D](<structCUDA__MEMCPY3D__v2.html#structCUDA__MEMCPY3D__v2>)*Â pCopy, [CUstream](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gb946c7f02e09efd788a204718015d88a>)Â hStream )
     Copies memory for 3D arrays.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuMemcpy3DBatchAsync](<#group__CUDA__MEM_1g97dd29d0e3490379a5cbdb21deb41f12>) ( size_tÂ numOps, CUDA_MEMCPY3D_BATCH_OP*Â opList, unsigned long longÂ flags, [CUstream](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gb946c7f02e09efd788a204718015d88a>)Â hStream )
     Performs a batch of 3D memory copies asynchronously.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuMemcpy3DPeer](<#group__CUDA__MEM_1g11466fd70cde9329a4e16eb1f258c433>) ( const [CUDA_MEMCPY3D_PEER](<structCUDA__MEMCPY3D__PEER__v1.html#structCUDA__MEMCPY3D__PEER__v1>)*Â pCopy )
     Copies memory between contexts.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuMemcpy3DPeerAsync](<#group__CUDA__MEM_1gc4e4bfd9f627d3aa3695979e058f1bb8>) ( const [CUDA_MEMCPY3D_PEER](<structCUDA__MEMCPY3D__PEER__v1.html#structCUDA__MEMCPY3D__PEER__v1>)*Â pCopy, [CUstream](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gb946c7f02e09efd788a204718015d88a>)Â hStream )
     Copies memory between contexts asynchronously.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuMemcpyAsync](<#group__CUDA__MEM_1g5f26aaf5582ade791e5688727a178d78>) ( [CUdeviceptr](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g183f7b0d8ad008ea2a5fd552537ace4e>)Â dst, [CUdeviceptr](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g183f7b0d8ad008ea2a5fd552537ace4e>)Â src, size_tÂ ByteCount, [CUstream](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gb946c7f02e09efd788a204718015d88a>)Â hStream )
     Copies memory asynchronously.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuMemcpyAtoA](<#group__CUDA__MEM_1gf81b218c984a31436ec9e23a85fb604a>) ( [CUarray](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gd550651524a56766b60f10f0e7628042>)Â dstArray, size_tÂ dstOffset, [CUarray](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gd550651524a56766b60f10f0e7628042>)Â srcArray, size_tÂ srcOffset, size_tÂ ByteCount )
     Copies memory from Array to Array.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuMemcpyAtoD](<#group__CUDA__MEM_1g825b3f037f7f51382cae991bae8173fd>) ( [CUdeviceptr](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g183f7b0d8ad008ea2a5fd552537ace4e>)Â dstDevice, [CUarray](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gd550651524a56766b60f10f0e7628042>)Â srcArray, size_tÂ srcOffset, size_tÂ ByteCount )
     Copies memory from Array to Device.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuMemcpyAtoH](<#group__CUDA__MEM_1gf7ad1edb2539cccc352c6b8b76f657f4>) ( void*Â dstHost, [CUarray](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gd550651524a56766b60f10f0e7628042>)Â srcArray, size_tÂ srcOffset, size_tÂ ByteCount )
     Copies memory from Array to Host.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuMemcpyAtoHAsync](<#group__CUDA__MEM_1g64cbd2e60436699aebdd0bdbf14d0f01>) ( void*Â dstHost, [CUarray](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gd550651524a56766b60f10f0e7628042>)Â srcArray, size_tÂ srcOffset, size_tÂ ByteCount, [CUstream](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gb946c7f02e09efd788a204718015d88a>)Â hStream )
     Copies memory from Array to Host.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuMemcpyBatchAsync](<#group__CUDA__MEM_1g6f1ff58e3065df3eb4b573dba77ad31f>) ( [CUdeviceptr](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g183f7b0d8ad008ea2a5fd552537ace4e>)*Â dsts, [CUdeviceptr](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g183f7b0d8ad008ea2a5fd552537ace4e>)*Â srcs, size_t*Â sizes, size_tÂ count, [CUmemcpyAttributes](<structCUmemcpyAttributes__v1.html#structCUmemcpyAttributes__v1>)*Â attrs, size_t*Â attrsIdxs, size_tÂ numAttrs, [CUstream](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gb946c7f02e09efd788a204718015d88a>)Â hStream )
     Performs a batch of memory copies asynchronously.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuMemcpyDtoA](<#group__CUDA__MEM_1gad6827247af91600b56ce6e2ddb802e1>) ( [CUarray](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gd550651524a56766b60f10f0e7628042>)Â dstArray, size_tÂ dstOffset, [CUdeviceptr](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g183f7b0d8ad008ea2a5fd552537ace4e>)Â srcDevice, size_tÂ ByteCount )
     Copies memory from Device to Array.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuMemcpyDtoD](<#group__CUDA__MEM_1g1725774abf8b51b91945f3336b778c8b>) ( [CUdeviceptr](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g183f7b0d8ad008ea2a5fd552537ace4e>)Â dstDevice, [CUdeviceptr](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g183f7b0d8ad008ea2a5fd552537ace4e>)Â srcDevice, size_tÂ ByteCount )
     Copies memory from Device to Device.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuMemcpyDtoDAsync](<#group__CUDA__MEM_1g39ea09ba682b8eccc9c3e0c04319b5c8>) ( [CUdeviceptr](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g183f7b0d8ad008ea2a5fd552537ace4e>)Â dstDevice, [CUdeviceptr](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g183f7b0d8ad008ea2a5fd552537ace4e>)Â srcDevice, size_tÂ ByteCount, [CUstream](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gb946c7f02e09efd788a204718015d88a>)Â hStream )
     Copies memory from Device to Device.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuMemcpyDtoH](<#group__CUDA__MEM_1g3480368ee0208a98f75019c9a8450893>) ( void*Â dstHost, [CUdeviceptr](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g183f7b0d8ad008ea2a5fd552537ace4e>)Â srcDevice, size_tÂ ByteCount )
     Copies memory from Device to Host.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuMemcpyDtoHAsync](<#group__CUDA__MEM_1g56f30236c7c5247f8e061b59d3268362>) ( void*Â dstHost, [CUdeviceptr](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g183f7b0d8ad008ea2a5fd552537ace4e>)Â srcDevice, size_tÂ ByteCount, [CUstream](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gb946c7f02e09efd788a204718015d88a>)Â hStream )
     Copies memory from Device to Host.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuMemcpyHtoA](<#group__CUDA__MEM_1g57d3d780d165ecc0e3b3ce08e141cd89>) ( [CUarray](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gd550651524a56766b60f10f0e7628042>)Â dstArray, size_tÂ dstOffset, const void*Â srcHost, size_tÂ ByteCount )
     Copies memory from Host to Array.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuMemcpyHtoAAsync](<#group__CUDA__MEM_1gb5c4863f64f132b4bc2661818b3fd188>) ( [CUarray](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gd550651524a56766b60f10f0e7628042>)Â dstArray, size_tÂ dstOffset, const void*Â srcHost, size_tÂ ByteCount, [CUstream](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gb946c7f02e09efd788a204718015d88a>)Â hStream )
     Copies memory from Host to Array.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuMemcpyHtoD](<#group__CUDA__MEM_1g4d32266788c440b0220b1a9ba5795169>) ( [CUdeviceptr](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g183f7b0d8ad008ea2a5fd552537ace4e>)Â dstDevice, const void*Â srcHost, size_tÂ ByteCount )
     Copies memory from Host to Device.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuMemcpyHtoDAsync](<#group__CUDA__MEM_1g1572263fe2597d7ba4f6964597a354a3>) ( [CUdeviceptr](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g183f7b0d8ad008ea2a5fd552537ace4e>)Â dstDevice, const void*Â srcHost, size_tÂ ByteCount, [CUstream](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gb946c7f02e09efd788a204718015d88a>)Â hStream )
     Copies memory from Host to Device.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuMemcpyPeer](<#group__CUDA__MEM_1ge1f5c7771544fee150ada8853c7cbf4a>) ( [CUdeviceptr](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g183f7b0d8ad008ea2a5fd552537ace4e>)Â dstDevice, [CUcontext](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gf9f5bd81658f866613785b3a0bb7d7d9>)Â dstContext, [CUdeviceptr](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g183f7b0d8ad008ea2a5fd552537ace4e>)Â srcDevice, [CUcontext](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gf9f5bd81658f866613785b3a0bb7d7d9>)Â srcContext, size_tÂ ByteCount )
     Copies device memory between two contexts.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuMemcpyPeerAsync](<#group__CUDA__MEM_1g82fcecb38018e64b98616a8ac30112f2>) ( [CUdeviceptr](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g183f7b0d8ad008ea2a5fd552537ace4e>)Â dstDevice, [CUcontext](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gf9f5bd81658f866613785b3a0bb7d7d9>)Â dstContext, [CUdeviceptr](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g183f7b0d8ad008ea2a5fd552537ace4e>)Â srcDevice, [CUcontext](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gf9f5bd81658f866613785b3a0bb7d7d9>)Â srcContext, size_tÂ ByteCount, [CUstream](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gb946c7f02e09efd788a204718015d88a>)Â hStream )
     Copies device memory between two contexts asynchronously.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuMemsetD16](<#group__CUDA__MEM_1g7d805e610054392a4d11e8a8bf5eb35c>) ( [CUdeviceptr](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g183f7b0d8ad008ea2a5fd552537ace4e>)Â dstDevice, unsigned shortÂ us, size_tÂ N )
     Initializes device memory.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuMemsetD16Async](<#group__CUDA__MEM_1gf731438877dd8ec875e4c43d848c878c>) ( [CUdeviceptr](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g183f7b0d8ad008ea2a5fd552537ace4e>)Â dstDevice, unsigned shortÂ us, size_tÂ N, [CUstream](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gb946c7f02e09efd788a204718015d88a>)Â hStream )
     Sets device memory.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuMemsetD2D16](<#group__CUDA__MEM_1g7f561a15a66144fa9f6ab5350edc8a30>) ( [CUdeviceptr](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g183f7b0d8ad008ea2a5fd552537ace4e>)Â dstDevice, size_tÂ dstPitch, unsigned shortÂ us, size_tÂ Width, size_tÂ Height )
     Initializes device memory.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuMemsetD2D16Async](<#group__CUDA__MEM_1g64ee197befac3d74d9fefedcf6ef6b10>) ( [CUdeviceptr](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g183f7b0d8ad008ea2a5fd552537ace4e>)Â dstDevice, size_tÂ dstPitch, unsigned shortÂ us, size_tÂ Width, size_tÂ Height, [CUstream](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gb946c7f02e09efd788a204718015d88a>)Â hStream )
     Sets device memory.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuMemsetD2D32](<#group__CUDA__MEM_1g74b359b2d026bfeb7c795b5038d07523>) ( [CUdeviceptr](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g183f7b0d8ad008ea2a5fd552537ace4e>)Â dstDevice, size_tÂ dstPitch, unsigned int Â ui, size_tÂ Width, size_tÂ Height )
     Initializes device memory.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuMemsetD2D32Async](<#group__CUDA__MEM_1g8a78d3147ac93fac955052c815d9ea3c>) ( [CUdeviceptr](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g183f7b0d8ad008ea2a5fd552537ace4e>)Â dstDevice, size_tÂ dstPitch, unsigned int Â ui, size_tÂ Width, size_tÂ Height, [CUstream](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gb946c7f02e09efd788a204718015d88a>)Â hStream )
     Sets device memory.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuMemsetD2D8](<#group__CUDA__MEM_1ge88b13e646e2be6ba0e0475ef5205974>) ( [CUdeviceptr](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g183f7b0d8ad008ea2a5fd552537ace4e>)Â dstDevice, size_tÂ dstPitch, unsigned char Â uc, size_tÂ Width, size_tÂ Height )
     Initializes device memory.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuMemsetD2D8Async](<#group__CUDA__MEM_1g3f7b6924a3e49c3265b328f534102e97>) ( [CUdeviceptr](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g183f7b0d8ad008ea2a5fd552537ace4e>)Â dstDevice, size_tÂ dstPitch, unsigned char Â uc, size_tÂ Width, size_tÂ Height, [CUstream](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gb946c7f02e09efd788a204718015d88a>)Â hStream )
     Sets device memory.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuMemsetD32](<#group__CUDA__MEM_1g983e8d8759acd1b64326317481fbf132>) ( [CUdeviceptr](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g183f7b0d8ad008ea2a5fd552537ace4e>)Â dstDevice, unsigned int Â ui, size_tÂ N )
     Initializes device memory.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuMemsetD32Async](<#group__CUDA__MEM_1g58229da5d30f1c0cdf667b320ec2c0f5>) ( [CUdeviceptr](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g183f7b0d8ad008ea2a5fd552537ace4e>)Â dstDevice, unsigned int Â ui, size_tÂ N, [CUstream](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gb946c7f02e09efd788a204718015d88a>)Â hStream )
     Sets device memory.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuMemsetD8](<#group__CUDA__MEM_1g6e582bf866e9e2fb014297bfaf354d7b>) ( [CUdeviceptr](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g183f7b0d8ad008ea2a5fd552537ace4e>)Â dstDevice, unsigned char Â uc, size_tÂ N )
     Initializes device memory.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuMemsetD8Async](<#group__CUDA__MEM_1gaef08a7ccd61112f94e82f2b30d43627>) ( [CUdeviceptr](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g183f7b0d8ad008ea2a5fd552537ace4e>)Â dstDevice, unsigned char Â uc, size_tÂ N, [CUstream](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gb946c7f02e09efd788a204718015d88a>)Â hStream )
     Sets device memory.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuMipmappedArrayCreate](<#group__CUDA__MEM_1ga5d2e311c7f9b0bc6d130af824a40bd3>) ( [CUmipmappedArray](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g96db856ab3d2940fb694ce4501d9b583>)*Â pHandle, const [CUDA_ARRAY3D_DESCRIPTOR](<structCUDA__ARRAY3D__DESCRIPTOR__v2.html#structCUDA__ARRAY3D__DESCRIPTOR__v2>)*Â pMipmappedArrayDesc, unsigned int Â numMipmapLevels )
     Creates a CUDA mipmapped array.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuMipmappedArrayDestroy](<#group__CUDA__MEM_1ge0d7c768b6a6963c4d4bde5bbc74f0ad>) ( [CUmipmappedArray](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g96db856ab3d2940fb694ce4501d9b583>)Â hMipmappedArray )
     Destroys a CUDA mipmapped array.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuMipmappedArrayGetLevel](<#group__CUDA__MEM_1g82f276659f05be14820e99346b0f86b7>) ( [CUarray](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gd550651524a56766b60f10f0e7628042>)*Â pLevelArray, [CUmipmappedArray](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g96db856ab3d2940fb694ce4501d9b583>)Â hMipmappedArray, unsigned int Â level )
     Gets a mipmap level of a CUDA mipmapped array.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuMipmappedArrayGetMemoryRequirements](<#group__CUDA__MEM_1g71b95168dd78c64cbca5b32b9cbf37e1>) ( [CUDA_ARRAY_MEMORY_REQUIREMENTS](<structCUDA__ARRAY__MEMORY__REQUIREMENTS__v1.html#structCUDA__ARRAY__MEMORY__REQUIREMENTS__v1>)*Â memoryRequirements, [CUmipmappedArray](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g96db856ab3d2940fb694ce4501d9b583>)Â mipmap, [CUdevice](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g41ca2a24a242b36ef2ca77330b5fb72a>)Â device )
     Returns the memory requirements of a CUDA mipmapped array.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuMipmappedArrayGetSparseProperties](<#group__CUDA__MEM_1g55a16bd1780acb3cc94e8b88d5fe5e19>) ( [CUDA_ARRAY_SPARSE_PROPERTIES](<structCUDA__ARRAY__SPARSE__PROPERTIES__v1.html#structCUDA__ARRAY__SPARSE__PROPERTIES__v1>)*Â sparseProperties, [CUmipmappedArray](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g96db856ab3d2940fb694ce4501d9b583>)Â mipmap )
     Returns the layout properties of a sparse CUDA mipmapped array.

### Enumerations

enum CUmemDecompressAlgorithm


######  Values

CU_MEM_DECOMPRESS_UNSUPPORTED = 0
    Decompression is unsupported.
CU_MEM_DECOMPRESS_ALGORITHM_DEFLATE = 1<<0
    Deflate is supported.
CU_MEM_DECOMPRESS_ALGORITHM_SNAPPY = 1<<1
    Snappy is supported.
CU_MEM_DECOMPRESS_ALGORITHM_LZ4 = 1<<2
    LZ4 is supported.

### Functions

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuArray3DCreate ( [CUarray](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gd550651524a56766b60f10f0e7628042>)*Â pHandle, const [CUDA_ARRAY3D_DESCRIPTOR](<structCUDA__ARRAY3D__DESCRIPTOR__v2.html#structCUDA__ARRAY3D__DESCRIPTOR__v2>)*Â pAllocateArray )


Creates a 3D CUDA array.

######  Parameters

`pHandle`
    \- Returned array
`pAllocateArray`
    \- 3D array descriptor

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_DEINITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9acf52f132faf29b473cdda6061f0f44a>), [CUDA_ERROR_NOT_INITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e98feb999f0af99b4a25ab26b3866f4df8>), [CUDA_ERROR_INVALID_CONTEXT](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a484e9af32c1e9893ff21f0e0191a12d>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>), [CUDA_ERROR_OUT_OF_MEMORY](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9264c50688ed110e8476b591befe60c02>), [CUDA_ERROR_UNKNOWN](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9c5a6ab0245179d297f1fa56ed0097183>)

###### Description

Creates a CUDA array according to the CUDA_ARRAY3D_DESCRIPTOR structure `pAllocateArray` and returns a handle to the new CUDA array in `*pHandle`. The CUDA_ARRAY3D_DESCRIPTOR is defined as:


    â    typedef struct {
                  unsigned int Width;
                  unsigned int Height;
                  unsigned int Depth;
                  [CUarray_format](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g9b009d9a6aa4c5765c8a00289b6068f9>) Format;
                  unsigned int NumChannels;
                  unsigned int Flags;
              } [CUDA_ARRAY3D_DESCRIPTOR](<structCUDA__ARRAY3D__DESCRIPTOR__v2.html#structCUDA__ARRAY3D__DESCRIPTOR__v2>);

where:

  * `Width`, `Height`, and `Depth` are the width, height, and depth of the CUDA array (in elements); the following types of CUDA arrays can be allocated:
    * A 1D array is allocated if `Height` and `Depth` extents are both zero.

    * A 2D array is allocated if only `Depth` extent is zero.

    * A 3D array is allocated if all three extents are non-zero.

    * A 1D layered CUDA array is allocated if only `Height` is zero and the [CUDA_ARRAY3D_LAYERED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ge4adf555c51852623a3dea962ab8ee85>) flag is set. Each layer is a 1D array. The number of layers is determined by the depth extent.

    * A 2D layered CUDA array is allocated if all three extents are non-zero and the [CUDA_ARRAY3D_LAYERED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ge4adf555c51852623a3dea962ab8ee85>) flag is set. Each layer is a 2D array. The number of layers is determined by the depth extent.

    * A cubemap CUDA array is allocated if all three extents are non-zero and the [CUDA_ARRAY3D_CUBEMAP](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gfce9ad9aa3df839571b84b47febfb7ae>) flag is set. `Width` must be equal to `Height`, and `Depth` must be six. A cubemap is a special type of 2D layered CUDA array, where the six layers represent the six faces of a cube. The order of the six layers in memory is the same as that listed in [CUarray_cubemap_face](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g012fda14b50e7db8798a340627c4c330>).

    * A cubemap layered CUDA array is allocated if all three extents are non-zero, and both, [CUDA_ARRAY3D_CUBEMAP](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gfce9ad9aa3df839571b84b47febfb7ae>) and [CUDA_ARRAY3D_LAYERED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ge4adf555c51852623a3dea962ab8ee85>) flags are set. `Width` must be equal to `Height`, and `Depth` must be a multiple of six. A cubemap layered CUDA array is a special type of 2D layered CUDA array that consists of a collection of cubemaps. The first six layers represent the first cubemap, the next six layers form the second cubemap, and so on.


  * Format specifies the format of the elements; [CUarray_format](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g9b009d9a6aa4c5765c8a00289b6068f9>) is defined as:

        â    typedef enum CUarray_format_enum {
                      [CU_AD_FORMAT_UNSIGNED_INT8](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg9b009d9a6aa4c5765c8a00289b6068f9e0af5f5a0ffa8e16a5c720364ccd5dac>) = 0x01,
                      [CU_AD_FORMAT_UNSIGNED_INT16](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg9b009d9a6aa4c5765c8a00289b6068f9d0f11e851e891af6f204cf05503ba525>) = 0x02,
                      [CU_AD_FORMAT_UNSIGNED_INT32](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg9b009d9a6aa4c5765c8a00289b6068f952b891ad5d4080db0fb2e23fe71614a0>) = 0x03,
                      [CU_AD_FORMAT_SIGNED_INT8](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg9b009d9a6aa4c5765c8a00289b6068f9376b799ee12ce9e1de0c34cfa7839284>) = 0x08,
                      [CU_AD_FORMAT_SIGNED_INT16](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg9b009d9a6aa4c5765c8a00289b6068f980864598b1579bd90fab79369072478f>) = 0x09,
                      [CU_AD_FORMAT_SIGNED_INT32](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg9b009d9a6aa4c5765c8a00289b6068f96db055c31d053bd1d5ebbaa98de2bad3>) = 0x0a,
                      [CU_AD_FORMAT_HALF](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg9b009d9a6aa4c5765c8a00289b6068f995c97289b540ff36334722ec745f53a3>) = 0x10,
                      [CU_AD_FORMAT_FLOAT](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg9b009d9a6aa4c5765c8a00289b6068f98140f3b0de3d87bdbf26964c24840f3c>) = 0x20,
                      [CU_AD_FORMAT_NV12](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg9b009d9a6aa4c5765c8a00289b6068f964889c93ccc518395eb985203735d40c>) = 0xb0,
                      [CU_AD_FORMAT_UNORM_INT8X1](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg9b009d9a6aa4c5765c8a00289b6068f90dcb720ef3238f279ebd5a7eb7284137>) = 0xc0,
                      [CU_AD_FORMAT_UNORM_INT8X2](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg9b009d9a6aa4c5765c8a00289b6068f9e23c25eb679dd70676bd35b26041d21f>) = 0xc1,
                      [CU_AD_FORMAT_UNORM_INT8X4](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg9b009d9a6aa4c5765c8a00289b6068f939e6604652c4f7dfda35ef89bcf6a1c4>) = 0xc2,
                      [CU_AD_FORMAT_UNORM_INT16X1](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg9b009d9a6aa4c5765c8a00289b6068f9a593cb744213ab457d4ebaa261879816>) = 0xc3,
                      [CU_AD_FORMAT_UNORM_INT16X2](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg9b009d9a6aa4c5765c8a00289b6068f9fe334f0b162fd9ad3caad37a8c879d95>) = 0xc4,
                      [CU_AD_FORMAT_UNORM_INT16X4](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg9b009d9a6aa4c5765c8a00289b6068f965401cdeebbc53f7b02400ba14f940a4>) = 0xc5,
                      [CU_AD_FORMAT_SNORM_INT8X1](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg9b009d9a6aa4c5765c8a00289b6068f9f92943f83ded303df264a79ee11d1db0>) = 0xc6,
                      [CU_AD_FORMAT_SNORM_INT8X2](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg9b009d9a6aa4c5765c8a00289b6068f9b8194990a6e17d78be0de66deffdf02f>) = 0xc7,
                      [CU_AD_FORMAT_SNORM_INT8X4](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg9b009d9a6aa4c5765c8a00289b6068f9117a2e043203748187605ff8a71c2d1d>) = 0xc8,
                      [CU_AD_FORMAT_SNORM_INT16X1](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg9b009d9a6aa4c5765c8a00289b6068f95026e5e8783752bf8d3601dd4dbceb4c>) = 0xc9,
                      [CU_AD_FORMAT_SNORM_INT16X2](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg9b009d9a6aa4c5765c8a00289b6068f939f633274a07dbce442325c5d90bf294>) = 0xca,
                      [CU_AD_FORMAT_SNORM_INT16X4](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg9b009d9a6aa4c5765c8a00289b6068f99acc19038dc1e68170e485f739912d49>) = 0xcb,
                      [CU_AD_FORMAT_BC1_UNORM](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg9b009d9a6aa4c5765c8a00289b6068f9299d155257aa3c0b75634d9f9b1bfa72>) = 0x91,
                      [CU_AD_FORMAT_BC1_UNORM_SRGB](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg9b009d9a6aa4c5765c8a00289b6068f9afa18b300eb91ff879532a55d5aa191b>) = 0x92,
                      [CU_AD_FORMAT_BC2_UNORM](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg9b009d9a6aa4c5765c8a00289b6068f92b9cf00f8c6012ec679654c9f012a267>) = 0x93,
                      [CU_AD_FORMAT_BC2_UNORM_SRGB](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg9b009d9a6aa4c5765c8a00289b6068f9c38b5af7926b020202562d67ba7529c2>) = 0x94,
                      [CU_AD_FORMAT_BC3_UNORM](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg9b009d9a6aa4c5765c8a00289b6068f9b8473614347359cc74574899e2e65012>) = 0x95,
                      [CU_AD_FORMAT_BC3_UNORM_SRGB](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg9b009d9a6aa4c5765c8a00289b6068f94d158239dd6c825b4bd383ed66625257>) = 0x96,
                      [CU_AD_FORMAT_BC4_UNORM](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg9b009d9a6aa4c5765c8a00289b6068f9fe7527dfa2576595eea7463a1140058c>) = 0x97,
                      [CU_AD_FORMAT_BC4_SNORM](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg9b009d9a6aa4c5765c8a00289b6068f90627520c6fc707d63e9d3c66d307eec6>) = 0x98,
                      [CU_AD_FORMAT_BC5_UNORM](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg9b009d9a6aa4c5765c8a00289b6068f94b524073942ab7460b68a98da955e59e>) = 0x99,
                      [CU_AD_FORMAT_BC5_SNORM](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg9b009d9a6aa4c5765c8a00289b6068f907466b7b5b3d897a58fac1e9d2db163e>) = 0x9a,
                      [CU_AD_FORMAT_BC6H_UF16](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg9b009d9a6aa4c5765c8a00289b6068f94085af463b118d564873b8d275ac7912>) = 0x9b,
                      [CU_AD_FORMAT_BC6H_SF16](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg9b009d9a6aa4c5765c8a00289b6068f938c1d137a2663d5ddca5ae6aa49f612e>) = 0x9c,
                      [CU_AD_FORMAT_BC7_UNORM](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg9b009d9a6aa4c5765c8a00289b6068f9f03f9cbeee0911d3c77c08e6f5c7ff62>) = 0x9d,
                      [CU_AD_FORMAT_BC7_UNORM_SRGB](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg9b009d9a6aa4c5765c8a00289b6068f9ad5b0e1cd964cbd46270223f35651677>) = 0x9e,
                      [CU_AD_FORMAT_P010](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg9b009d9a6aa4c5765c8a00289b6068f9f0efd5417115904eb086f1df0046582e>) = 0x9f,
                      [CU_AD_FORMAT_P016](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg9b009d9a6aa4c5765c8a00289b6068f9b8511f36d0a010b8846c84309d8920d5>) = 0xa1,
                      [CU_AD_FORMAT_NV16](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg9b009d9a6aa4c5765c8a00289b6068f9e41b4351cb805f35130636b0aafca609>) = 0xa2,
                      [CU_AD_FORMAT_P210](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg9b009d9a6aa4c5765c8a00289b6068f9dc77f21be8b4ff4f23dcd450c3656409>) = 0xa3,
                      [CU_AD_FORMAT_P216](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg9b009d9a6aa4c5765c8a00289b6068f9a42b3a04e2f30a93e50d7d68026f1ba9>) = 0xa4,
                      [CU_AD_FORMAT_YUY2](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg9b009d9a6aa4c5765c8a00289b6068f961f757ee5f5c125b7be70e5b562826dc>) = 0xa5,
                      [CU_AD_FORMAT_Y210](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg9b009d9a6aa4c5765c8a00289b6068f9796d73bbcb63216f7dd4cc4d8016b74c>) = 0xa6,
                      [CU_AD_FORMAT_Y216](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg9b009d9a6aa4c5765c8a00289b6068f9c2081981924fa204383f1ee05de74d8e>) = 0xa7,
                      [CU_AD_FORMAT_AYUV](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg9b009d9a6aa4c5765c8a00289b6068f99dd6d4cac84e541d2b1ad34b263bc1bc>) = 0xa8,
                      [CU_AD_FORMAT_Y410](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg9b009d9a6aa4c5765c8a00289b6068f91917374a5915ee6a5e1ed23c57f43b75>) = 0xa9,
                      [CU_AD_FORMAT_Y416](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg9b009d9a6aa4c5765c8a00289b6068f941bdcafb69e249176af2e1cc5d6178be>) = 0xb1,
                      [CU_AD_FORMAT_Y444_PLANAR8](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg9b009d9a6aa4c5765c8a00289b6068f93af0d614c7c240194c402b6ca9b4909f>) = 0xb2,
                      [CU_AD_FORMAT_Y444_PLANAR10](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg9b009d9a6aa4c5765c8a00289b6068f916b3c04a1fba1562d548d4504f06a7aa>) = 0xb3,
                      [CU_AD_FORMAT_YUV444_8bit_SemiPlanar](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg9b009d9a6aa4c5765c8a00289b6068f945b7c15d0c8a42d569b20509e7e54e1d>) = 0xb4,
                      [CU_AD_FORMAT_YUV444_16bit_SemiPlanar](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg9b009d9a6aa4c5765c8a00289b6068f9cb653da3339b76b267a6fa8085513017>) = 0xb5,
                      [CU_AD_FORMAT_UNORM_INT_101010_2](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg9b009d9a6aa4c5765c8a00289b6068f93b3828154e807c69a6e0c7e0d54d31ea>) = 0x50,
                  } [CUarray_format](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g9b009d9a6aa4c5765c8a00289b6068f9>);


  * `NumChannels` specifies the number of packed components per CUDA array element; it may be 1, 2, or 4;


  * Flags may be set to
    * [CUDA_ARRAY3D_LAYERED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ge4adf555c51852623a3dea962ab8ee85>) to enable creation of layered CUDA arrays. If this flag is set, `Depth` specifies the number of layers, not the depth of a 3D array.

    * [CUDA_ARRAY3D_SURFACE_LDST](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g7287c43cacf1ed05865d6bcad1a23cd9>) to enable surface references to be bound to the CUDA array. If this flag is not set, [cuSurfRefSetArray](<group__CUDA__SURFREF__DEPRECATED.html#group__CUDA__SURFREF__DEPRECATED_1g68abcde159fa897b1dfb23387926dd66> "Sets the CUDA array for a surface reference.") will fail when attempting to bind the CUDA array to a surface reference.

    * [CUDA_ARRAY3D_CUBEMAP](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gfce9ad9aa3df839571b84b47febfb7ae>) to enable creation of cubemaps. If this flag is set, `Width` must be equal to `Height`, and `Depth` must be six. If the [CUDA_ARRAY3D_LAYERED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ge4adf555c51852623a3dea962ab8ee85>) flag is also set, then `Depth` must be a multiple of six.

    * [CUDA_ARRAY3D_TEXTURE_GATHER](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g0c929c92a91f4d9f9f49bae0131a6ccf>) to indicate that the CUDA array will be used for texture gather. Texture gather can only be performed on 2D CUDA arrays.


`Width`, `Height` and `Depth` must meet certain size requirements as listed in the following table. All values are specified in elements. Note that for brevity's sake, the full name of the device attribute is not specified. For ex., TEXTURE1D_WIDTH refers to the device attribute [CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE1D_WIDTH](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gge12b8a782bebe21b1ac0091bf9f4e2a31f7318312b520cd5bc19eb97659e8215>).

Note that 2D CUDA arrays have different size requirements if the [CUDA_ARRAY3D_TEXTURE_GATHER](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g0c929c92a91f4d9f9f49bae0131a6ccf>) flag is set. `Width` and `Height` must not be greater than [CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_GATHER_WIDTH](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gge12b8a782bebe21b1ac0091bf9f4e2a3a3d02a5e777b952280c1f8b4fac477ef>) and [CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_GATHER_HEIGHT](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gge12b8a782bebe21b1ac0091bf9f4e2a39ceeac801dbf34671de63cc7ca383935>) respectively, in that case.

**CUDA array type** |  **Valid extents that must always be met {(width range in elements), (height range), (depth range)}** |  **Valid extents with CUDA_ARRAY3D_SURFACE_LDST set {(width range in elements), (height range), (depth range)}**
---|---|---
1D  |  { (1,TEXTURE1D_WIDTH), 0, 0 }  |  { (1,SURFACE1D_WIDTH), 0, 0 }
2D  |  { (1,TEXTURE2D_WIDTH), (1,TEXTURE2D_HEIGHT), 0 }  |  { (1,SURFACE2D_WIDTH), (1,SURFACE2D_HEIGHT), 0 }
3D  |  { (1,TEXTURE3D_WIDTH), (1,TEXTURE3D_HEIGHT), (1,TEXTURE3D_DEPTH) } OR { (1,TEXTURE3D_WIDTH_ALTERNATE), (1,TEXTURE3D_HEIGHT_ALTERNATE), (1,TEXTURE3D_DEPTH_ALTERNATE) }  |  { (1,SURFACE3D_WIDTH), (1,SURFACE3D_HEIGHT), (1,SURFACE3D_DEPTH) }
1D Layered  |  { (1,TEXTURE1D_LAYERED_WIDTH), 0, (1,TEXTURE1D_LAYERED_LAYERS) }  |  { (1,SURFACE1D_LAYERED_WIDTH), 0, (1,SURFACE1D_LAYERED_LAYERS) }
2D Layered  |  { (1,TEXTURE2D_LAYERED_WIDTH), (1,TEXTURE2D_LAYERED_HEIGHT), (1,TEXTURE2D_LAYERED_LAYERS) }  |  { (1,SURFACE2D_LAYERED_WIDTH), (1,SURFACE2D_LAYERED_HEIGHT), (1,SURFACE2D_LAYERED_LAYERS) }
Cubemap  |  { (1,TEXTURECUBEMAP_WIDTH), (1,TEXTURECUBEMAP_WIDTH), 6 }  |  { (1,SURFACECUBEMAP_WIDTH), (1,SURFACECUBEMAP_WIDTH), 6 }
Cubemap Layered  |  { (1,TEXTURECUBEMAP_LAYERED_WIDTH), (1,TEXTURECUBEMAP_LAYERED_WIDTH), (1,TEXTURECUBEMAP_LAYERED_LAYERS) }  |  { (1,SURFACECUBEMAP_LAYERED_WIDTH), (1,SURFACECUBEMAP_LAYERED_WIDTH), (1,SURFACECUBEMAP_LAYERED_LAYERS) }

Here are examples of CUDA array descriptions:

Description for a CUDA array of 2048 floats:


    â    [CUDA_ARRAY3D_DESCRIPTOR](<structCUDA__ARRAY3D__DESCRIPTOR__v2.html#structCUDA__ARRAY3D__DESCRIPTOR__v2>) desc;
              desc.[Format](<structCUDA__ARRAY3D__DESCRIPTOR__v2.html#structCUDA__ARRAY3D__DESCRIPTOR__v2_196078e824c96e0fe2d6d8291700b60c7>) = [CU_AD_FORMAT_FLOAT](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg9b009d9a6aa4c5765c8a00289b6068f98140f3b0de3d87bdbf26964c24840f3c>);
              desc.[NumChannels](<structCUDA__ARRAY3D__DESCRIPTOR__v2.html#structCUDA__ARRAY3D__DESCRIPTOR__v2_19a3c02a716777e5e74d19b35456cc49c>) = 1;
              desc.[Width](<structCUDA__ARRAY3D__DESCRIPTOR__v2.html#structCUDA__ARRAY3D__DESCRIPTOR__v2_13de201be4776cf763f87f87d671f27ba>) = 2048;
              desc.[Height](<structCUDA__ARRAY3D__DESCRIPTOR__v2.html#structCUDA__ARRAY3D__DESCRIPTOR__v2_104a3de12856f0f8dffb39c79a172d824>) = 0;
              desc.[Depth](<structCUDA__ARRAY3D__DESCRIPTOR__v2.html#structCUDA__ARRAY3D__DESCRIPTOR__v2_1404d0c4db6b39d54af70c4e312ad9ea9>) = 0;

Description for a 64 x 64 CUDA array of floats:


    â    [CUDA_ARRAY3D_DESCRIPTOR](<structCUDA__ARRAY3D__DESCRIPTOR__v2.html#structCUDA__ARRAY3D__DESCRIPTOR__v2>) desc;
              desc.[Format](<structCUDA__ARRAY3D__DESCRIPTOR__v2.html#structCUDA__ARRAY3D__DESCRIPTOR__v2_196078e824c96e0fe2d6d8291700b60c7>) = [CU_AD_FORMAT_FLOAT](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg9b009d9a6aa4c5765c8a00289b6068f98140f3b0de3d87bdbf26964c24840f3c>);
              desc.[NumChannels](<structCUDA__ARRAY3D__DESCRIPTOR__v2.html#structCUDA__ARRAY3D__DESCRIPTOR__v2_19a3c02a716777e5e74d19b35456cc49c>) = 1;
              desc.[Width](<structCUDA__ARRAY3D__DESCRIPTOR__v2.html#structCUDA__ARRAY3D__DESCRIPTOR__v2_13de201be4776cf763f87f87d671f27ba>) = 64;
              desc.[Height](<structCUDA__ARRAY3D__DESCRIPTOR__v2.html#structCUDA__ARRAY3D__DESCRIPTOR__v2_104a3de12856f0f8dffb39c79a172d824>) = 64;
              desc.[Depth](<structCUDA__ARRAY3D__DESCRIPTOR__v2.html#structCUDA__ARRAY3D__DESCRIPTOR__v2_1404d0c4db6b39d54af70c4e312ad9ea9>) = 0;

Description for a `width` x `height` x `depth` CUDA array of 64-bit, 4x16-bit float16's:


    â    [CUDA_ARRAY3D_DESCRIPTOR](<structCUDA__ARRAY3D__DESCRIPTOR__v2.html#structCUDA__ARRAY3D__DESCRIPTOR__v2>) desc;
              desc.[Format](<structCUDA__ARRAY3D__DESCRIPTOR__v2.html#structCUDA__ARRAY3D__DESCRIPTOR__v2_196078e824c96e0fe2d6d8291700b60c7>) = [CU_AD_FORMAT_HALF](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg9b009d9a6aa4c5765c8a00289b6068f995c97289b540ff36334722ec745f53a3>);
              desc.[NumChannels](<structCUDA__ARRAY3D__DESCRIPTOR__v2.html#structCUDA__ARRAY3D__DESCRIPTOR__v2_19a3c02a716777e5e74d19b35456cc49c>) = 4;
              desc.[Width](<structCUDA__ARRAY3D__DESCRIPTOR__v2.html#structCUDA__ARRAY3D__DESCRIPTOR__v2_13de201be4776cf763f87f87d671f27ba>) = width;
              desc.[Height](<structCUDA__ARRAY3D__DESCRIPTOR__v2.html#structCUDA__ARRAY3D__DESCRIPTOR__v2_104a3de12856f0f8dffb39c79a172d824>) = height;
              desc.[Depth](<structCUDA__ARRAY3D__DESCRIPTOR__v2.html#structCUDA__ARRAY3D__DESCRIPTOR__v2_1404d0c4db6b39d54af70c4e312ad9ea9>) = depth;

Note:

Note that this function may also return error codes from previous, asynchronous launches.

**See also:**

[cuArray3DGetDescriptor](<group__CUDA__MEM.html#group__CUDA__MEM_1gb58549f2f3f390b9e0e7c8f3acd53857> "Get a 3D CUDA array descriptor."), [cuArrayCreate](<group__CUDA__MEM.html#group__CUDA__MEM_1g4192ff387a81c3bd5ed8c391ed62ca24> "Creates a 1D or 2D CUDA array."), [cuArrayDestroy](<group__CUDA__MEM.html#group__CUDA__MEM_1g982878affbbc023de84874faac838b0b> "Destroys a CUDA array."), [cuArrayGetDescriptor](<group__CUDA__MEM.html#group__CUDA__MEM_1g661fe823dbd37bf11f82a71bd4762acf> "Get a 1D or 2D CUDA array descriptor."), [cuMemAlloc](<group__CUDA__MEM.html#group__CUDA__MEM_1gb82d2a09844a58dd9e744dc31e8aa467> "Allocates device memory."), [cuMemAllocHost](<group__CUDA__MEM.html#group__CUDA__MEM_1gdd8311286d2c2691605362c689bc64e0> "Allocates page-locked host memory."), [cuMemAllocPitch](<group__CUDA__MEM.html#group__CUDA__MEM_1gcbe9b033f6c4de80f63cc6e58ed9a45a> "Allocates pitched device memory."), [cuMemcpy2D](<group__CUDA__MEM.html#group__CUDA__MEM_1g27f885b30c34cc20a663a671dbf6fc27> "Copies memory for 2D arrays."), [cuMemcpy2DAsync](<group__CUDA__MEM.html#group__CUDA__MEM_1g4acf155faeb969d9d21f5433d3d0f274> "Copies memory for 2D arrays."), [cuMemcpy2DUnaligned](<group__CUDA__MEM.html#group__CUDA__MEM_1g2fa285d47fd7020e596bfeab3deb651b> "Copies memory for 2D arrays."), [cuMemcpy3D](<group__CUDA__MEM.html#group__CUDA__MEM_1g4b5238975579f002c0199a3800ca44df> "Copies memory for 3D arrays."), [cuMemcpy3DAsync](<group__CUDA__MEM.html#group__CUDA__MEM_1g79f4f3fde6ae0f529568d881d9e11987> "Copies memory for 3D arrays."), [cuMemcpyAtoA](<group__CUDA__MEM.html#group__CUDA__MEM_1gf81b218c984a31436ec9e23a85fb604a> "Copies memory from Array to Array."), [cuMemcpyAtoD](<group__CUDA__MEM.html#group__CUDA__MEM_1g825b3f037f7f51382cae991bae8173fd> "Copies memory from Array to Device."), [cuMemcpyAtoH](<group__CUDA__MEM.html#group__CUDA__MEM_1gf7ad1edb2539cccc352c6b8b76f657f4> "Copies memory from Array to Host."), [cuMemcpyAtoHAsync](<group__CUDA__MEM.html#group__CUDA__MEM_1g64cbd2e60436699aebdd0bdbf14d0f01> "Copies memory from Array to Host."), [cuMemcpyDtoA](<group__CUDA__MEM.html#group__CUDA__MEM_1gad6827247af91600b56ce6e2ddb802e1> "Copies memory from Device to Array."), [cuMemcpyDtoD](<group__CUDA__MEM.html#group__CUDA__MEM_1g1725774abf8b51b91945f3336b778c8b> "Copies memory from Device to Device."), [cuMemcpyDtoDAsync](<group__CUDA__MEM.html#group__CUDA__MEM_1g39ea09ba682b8eccc9c3e0c04319b5c8> "Copies memory from Device to Device."), [cuMemcpyDtoH](<group__CUDA__MEM.html#group__CUDA__MEM_1g3480368ee0208a98f75019c9a8450893> "Copies memory from Device to Host."), [cuMemcpyDtoHAsync](<group__CUDA__MEM.html#group__CUDA__MEM_1g56f30236c7c5247f8e061b59d3268362> "Copies memory from Device to Host."), [cuMemcpyHtoA](<group__CUDA__MEM.html#group__CUDA__MEM_1g57d3d780d165ecc0e3b3ce08e141cd89> "Copies memory from Host to Array."), [cuMemcpyHtoAAsync](<group__CUDA__MEM.html#group__CUDA__MEM_1gb5c4863f64f132b4bc2661818b3fd188> "Copies memory from Host to Array."), [cuMemcpyHtoD](<group__CUDA__MEM.html#group__CUDA__MEM_1g4d32266788c440b0220b1a9ba5795169> "Copies memory from Host to Device."), [cuMemcpyHtoDAsync](<group__CUDA__MEM.html#group__CUDA__MEM_1g1572263fe2597d7ba4f6964597a354a3> "Copies memory from Host to Device."), [cuMemFree](<group__CUDA__MEM.html#group__CUDA__MEM_1g89b3f154e17cc89b6eea277dbdf5c93a> "Frees device memory."), [cuMemFreeHost](<group__CUDA__MEM.html#group__CUDA__MEM_1g62e0fdbe181dab6b1c90fa1a51c7b92c> "Frees page-locked host memory."), [cuMemGetAddressRange](<group__CUDA__MEM.html#group__CUDA__MEM_1g64fee5711274a2a0573a789c94d8299b> "Get information on memory allocations."), [cuMemGetInfo](<group__CUDA__MEM.html#group__CUDA__MEM_1g808f555540d0143a331cc42aa98835c0> "Gets free and total memory."), [cuMemHostAlloc](<group__CUDA__MEM.html#group__CUDA__MEM_1g572ca4011bfcb25034888a14d4e035b9> "Allocates page-locked host memory."), [cuMemHostGetDevicePointer](<group__CUDA__MEM.html#group__CUDA__MEM_1g57a39e5cba26af4d06be67fc77cc62f0> "Passes back device pointer of mapped pinned memory."), [cuMemsetD2D8](<group__CUDA__MEM.html#group__CUDA__MEM_1ge88b13e646e2be6ba0e0475ef5205974> "Initializes device memory."), [cuMemsetD2D16](<group__CUDA__MEM.html#group__CUDA__MEM_1g7f561a15a66144fa9f6ab5350edc8a30> "Initializes device memory."), [cuMemsetD2D32](<group__CUDA__MEM.html#group__CUDA__MEM_1g74b359b2d026bfeb7c795b5038d07523> "Initializes device memory."), [cuMemsetD8](<group__CUDA__MEM.html#group__CUDA__MEM_1g6e582bf866e9e2fb014297bfaf354d7b> "Initializes device memory."), [cuMemsetD16](<group__CUDA__MEM.html#group__CUDA__MEM_1g7d805e610054392a4d11e8a8bf5eb35c> "Initializes device memory."), [cuMemsetD32](<group__CUDA__MEM.html#group__CUDA__MEM_1g983e8d8759acd1b64326317481fbf132> "Initializes device memory."), [cudaMalloc3DArray](<../cuda-runtime-api/group__CUDART__MEMORY.html#group__CUDART__MEMORY_1g948143cf2423a072ac6a31fb635efd88>)

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuArray3DGetDescriptor ( [CUDA_ARRAY3D_DESCRIPTOR](<structCUDA__ARRAY3D__DESCRIPTOR__v2.html#structCUDA__ARRAY3D__DESCRIPTOR__v2>)*Â pArrayDescriptor, [CUarray](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gd550651524a56766b60f10f0e7628042>)Â hArray )


Get a 3D CUDA array descriptor.

######  Parameters

`pArrayDescriptor`
    \- Returned 3D array descriptor
`hArray`
    \- 3D array to get descriptor of

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_DEINITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9acf52f132faf29b473cdda6061f0f44a>), [CUDA_ERROR_NOT_INITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e98feb999f0af99b4a25ab26b3866f4df8>), [CUDA_ERROR_INVALID_CONTEXT](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a484e9af32c1e9893ff21f0e0191a12d>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>), [CUDA_ERROR_INVALID_HANDLE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e90fd2e63260c6317ba943af0f7e4b8d21>), [CUDA_ERROR_CONTEXT_IS_DESTROYED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9b27ac43f7ce8446f5c9636dd73fb2139>)

###### Description

Returns in `*pArrayDescriptor` a descriptor containing information on the format and dimensions of the CUDA array `hArray`. It is useful for subroutines that have been passed a CUDA array, but need to know the CUDA array parameters for validation or other purposes.

This function may be called on 1D and 2D arrays, in which case the `Height` and/or `Depth` members of the descriptor struct will be set to 0.

Note:

Note that this function may also return error codes from previous, asynchronous launches.

**See also:**

[cuArray3DCreate](<group__CUDA__MEM.html#group__CUDA__MEM_1gc2322c70b38c2984536c90ed118bb1d7> "Creates a 3D CUDA array."), [cuArrayCreate](<group__CUDA__MEM.html#group__CUDA__MEM_1g4192ff387a81c3bd5ed8c391ed62ca24> "Creates a 1D or 2D CUDA array."), [cuArrayDestroy](<group__CUDA__MEM.html#group__CUDA__MEM_1g982878affbbc023de84874faac838b0b> "Destroys a CUDA array."), [cuArrayGetDescriptor](<group__CUDA__MEM.html#group__CUDA__MEM_1g661fe823dbd37bf11f82a71bd4762acf> "Get a 1D or 2D CUDA array descriptor."), [cuMemAlloc](<group__CUDA__MEM.html#group__CUDA__MEM_1gb82d2a09844a58dd9e744dc31e8aa467> "Allocates device memory."), [cuMemAllocHost](<group__CUDA__MEM.html#group__CUDA__MEM_1gdd8311286d2c2691605362c689bc64e0> "Allocates page-locked host memory."), [cuMemAllocPitch](<group__CUDA__MEM.html#group__CUDA__MEM_1gcbe9b033f6c4de80f63cc6e58ed9a45a> "Allocates pitched device memory."), [cuMemcpy2D](<group__CUDA__MEM.html#group__CUDA__MEM_1g27f885b30c34cc20a663a671dbf6fc27> "Copies memory for 2D arrays."), [cuMemcpy2DAsync](<group__CUDA__MEM.html#group__CUDA__MEM_1g4acf155faeb969d9d21f5433d3d0f274> "Copies memory for 2D arrays."), [cuMemcpy2DUnaligned](<group__CUDA__MEM.html#group__CUDA__MEM_1g2fa285d47fd7020e596bfeab3deb651b> "Copies memory for 2D arrays."), [cuMemcpy3D](<group__CUDA__MEM.html#group__CUDA__MEM_1g4b5238975579f002c0199a3800ca44df> "Copies memory for 3D arrays."), [cuMemcpy3DAsync](<group__CUDA__MEM.html#group__CUDA__MEM_1g79f4f3fde6ae0f529568d881d9e11987> "Copies memory for 3D arrays."), [cuMemcpyAtoA](<group__CUDA__MEM.html#group__CUDA__MEM_1gf81b218c984a31436ec9e23a85fb604a> "Copies memory from Array to Array."), [cuMemcpyAtoD](<group__CUDA__MEM.html#group__CUDA__MEM_1g825b3f037f7f51382cae991bae8173fd> "Copies memory from Array to Device."), [cuMemcpyAtoH](<group__CUDA__MEM.html#group__CUDA__MEM_1gf7ad1edb2539cccc352c6b8b76f657f4> "Copies memory from Array to Host."), [cuMemcpyAtoHAsync](<group__CUDA__MEM.html#group__CUDA__MEM_1g64cbd2e60436699aebdd0bdbf14d0f01> "Copies memory from Array to Host."), [cuMemcpyDtoA](<group__CUDA__MEM.html#group__CUDA__MEM_1gad6827247af91600b56ce6e2ddb802e1> "Copies memory from Device to Array."), [cuMemcpyDtoD](<group__CUDA__MEM.html#group__CUDA__MEM_1g1725774abf8b51b91945f3336b778c8b> "Copies memory from Device to Device."), [cuMemcpyDtoDAsync](<group__CUDA__MEM.html#group__CUDA__MEM_1g39ea09ba682b8eccc9c3e0c04319b5c8> "Copies memory from Device to Device."), [cuMemcpyDtoH](<group__CUDA__MEM.html#group__CUDA__MEM_1g3480368ee0208a98f75019c9a8450893> "Copies memory from Device to Host."), [cuMemcpyDtoHAsync](<group__CUDA__MEM.html#group__CUDA__MEM_1g56f30236c7c5247f8e061b59d3268362> "Copies memory from Device to Host."), [cuMemcpyHtoA](<group__CUDA__MEM.html#group__CUDA__MEM_1g57d3d780d165ecc0e3b3ce08e141cd89> "Copies memory from Host to Array."), [cuMemcpyHtoAAsync](<group__CUDA__MEM.html#group__CUDA__MEM_1gb5c4863f64f132b4bc2661818b3fd188> "Copies memory from Host to Array."), [cuMemcpyHtoD](<group__CUDA__MEM.html#group__CUDA__MEM_1g4d32266788c440b0220b1a9ba5795169> "Copies memory from Host to Device."), [cuMemcpyHtoDAsync](<group__CUDA__MEM.html#group__CUDA__MEM_1g1572263fe2597d7ba4f6964597a354a3> "Copies memory from Host to Device."), [cuMemFree](<group__CUDA__MEM.html#group__CUDA__MEM_1g89b3f154e17cc89b6eea277dbdf5c93a> "Frees device memory."), [cuMemFreeHost](<group__CUDA__MEM.html#group__CUDA__MEM_1g62e0fdbe181dab6b1c90fa1a51c7b92c> "Frees page-locked host memory."), [cuMemGetAddressRange](<group__CUDA__MEM.html#group__CUDA__MEM_1g64fee5711274a2a0573a789c94d8299b> "Get information on memory allocations."), [cuMemGetInfo](<group__CUDA__MEM.html#group__CUDA__MEM_1g808f555540d0143a331cc42aa98835c0> "Gets free and total memory."), [cuMemHostAlloc](<group__CUDA__MEM.html#group__CUDA__MEM_1g572ca4011bfcb25034888a14d4e035b9> "Allocates page-locked host memory."), [cuMemHostGetDevicePointer](<group__CUDA__MEM.html#group__CUDA__MEM_1g57a39e5cba26af4d06be67fc77cc62f0> "Passes back device pointer of mapped pinned memory."), [cuMemsetD2D8](<group__CUDA__MEM.html#group__CUDA__MEM_1ge88b13e646e2be6ba0e0475ef5205974> "Initializes device memory."), [cuMemsetD2D16](<group__CUDA__MEM.html#group__CUDA__MEM_1g7f561a15a66144fa9f6ab5350edc8a30> "Initializes device memory."), [cuMemsetD2D32](<group__CUDA__MEM.html#group__CUDA__MEM_1g74b359b2d026bfeb7c795b5038d07523> "Initializes device memory."), [cuMemsetD8](<group__CUDA__MEM.html#group__CUDA__MEM_1g6e582bf866e9e2fb014297bfaf354d7b> "Initializes device memory."), [cuMemsetD16](<group__CUDA__MEM.html#group__CUDA__MEM_1g7d805e610054392a4d11e8a8bf5eb35c> "Initializes device memory."), [cuMemsetD32](<group__CUDA__MEM.html#group__CUDA__MEM_1g983e8d8759acd1b64326317481fbf132> "Initializes device memory."), [cudaArrayGetInfo](<../cuda-runtime-api/group__CUDART__MEMORY.html#group__CUDART__MEMORY_1g373dacf191566b0bf5e5b807517b6bf9>)

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuArrayCreate ( [CUarray](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gd550651524a56766b60f10f0e7628042>)*Â pHandle, const [CUDA_ARRAY_DESCRIPTOR](<structCUDA__ARRAY__DESCRIPTOR__v2.html#structCUDA__ARRAY__DESCRIPTOR__v2>)*Â pAllocateArray )


Creates a 1D or 2D CUDA array.

######  Parameters

`pHandle`
    \- Returned array
`pAllocateArray`
    \- Array descriptor

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_DEINITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9acf52f132faf29b473cdda6061f0f44a>), [CUDA_ERROR_NOT_INITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e98feb999f0af99b4a25ab26b3866f4df8>), [CUDA_ERROR_INVALID_CONTEXT](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a484e9af32c1e9893ff21f0e0191a12d>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>), [CUDA_ERROR_OUT_OF_MEMORY](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9264c50688ed110e8476b591befe60c02>), [CUDA_ERROR_UNKNOWN](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9c5a6ab0245179d297f1fa56ed0097183>)

###### Description

Creates a CUDA array according to the CUDA_ARRAY_DESCRIPTOR structure `pAllocateArray` and returns a handle to the new CUDA array in `*pHandle`. The CUDA_ARRAY_DESCRIPTOR is defined as:


    â    typedef struct {
                  unsigned int Width;
                  unsigned int Height;
                  [CUarray_format](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g9b009d9a6aa4c5765c8a00289b6068f9>) Format;
                  unsigned int NumChannels;
              } [CUDA_ARRAY_DESCRIPTOR](<structCUDA__ARRAY__DESCRIPTOR__v2.html#structCUDA__ARRAY__DESCRIPTOR__v2>);

where:

  * `Width`, and `Height` are the width, and height of the CUDA array (in elements); the CUDA array is one-dimensional if height is 0, two-dimensional otherwise;

  * Format specifies the format of the elements; [CUarray_format](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g9b009d9a6aa4c5765c8a00289b6068f9>) is defined as:

        â    typedef enum CUarray_format_enum {
                      [CU_AD_FORMAT_UNSIGNED_INT8](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg9b009d9a6aa4c5765c8a00289b6068f9e0af5f5a0ffa8e16a5c720364ccd5dac>) = 0x01,
                      [CU_AD_FORMAT_UNSIGNED_INT16](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg9b009d9a6aa4c5765c8a00289b6068f9d0f11e851e891af6f204cf05503ba525>) = 0x02,
                      [CU_AD_FORMAT_UNSIGNED_INT32](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg9b009d9a6aa4c5765c8a00289b6068f952b891ad5d4080db0fb2e23fe71614a0>) = 0x03,
                      [CU_AD_FORMAT_SIGNED_INT8](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg9b009d9a6aa4c5765c8a00289b6068f9376b799ee12ce9e1de0c34cfa7839284>) = 0x08,
                      [CU_AD_FORMAT_SIGNED_INT16](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg9b009d9a6aa4c5765c8a00289b6068f980864598b1579bd90fab79369072478f>) = 0x09,
                      [CU_AD_FORMAT_SIGNED_INT32](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg9b009d9a6aa4c5765c8a00289b6068f96db055c31d053bd1d5ebbaa98de2bad3>) = 0x0a,
                      [CU_AD_FORMAT_HALF](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg9b009d9a6aa4c5765c8a00289b6068f995c97289b540ff36334722ec745f53a3>) = 0x10,
                      [CU_AD_FORMAT_FLOAT](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg9b009d9a6aa4c5765c8a00289b6068f98140f3b0de3d87bdbf26964c24840f3c>) = 0x20,
                      [CU_AD_FORMAT_NV12](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg9b009d9a6aa4c5765c8a00289b6068f964889c93ccc518395eb985203735d40c>) = 0xb0,
                      [CU_AD_FORMAT_UNORM_INT8X1](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg9b009d9a6aa4c5765c8a00289b6068f90dcb720ef3238f279ebd5a7eb7284137>) = 0xc0,
                      [CU_AD_FORMAT_UNORM_INT8X2](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg9b009d9a6aa4c5765c8a00289b6068f9e23c25eb679dd70676bd35b26041d21f>) = 0xc1,
                      [CU_AD_FORMAT_UNORM_INT8X4](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg9b009d9a6aa4c5765c8a00289b6068f939e6604652c4f7dfda35ef89bcf6a1c4>) = 0xc2,
                      [CU_AD_FORMAT_UNORM_INT16X1](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg9b009d9a6aa4c5765c8a00289b6068f9a593cb744213ab457d4ebaa261879816>) = 0xc3,
                      [CU_AD_FORMAT_UNORM_INT16X2](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg9b009d9a6aa4c5765c8a00289b6068f9fe334f0b162fd9ad3caad37a8c879d95>) = 0xc4,
                      [CU_AD_FORMAT_UNORM_INT16X4](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg9b009d9a6aa4c5765c8a00289b6068f965401cdeebbc53f7b02400ba14f940a4>) = 0xc5,
                      [CU_AD_FORMAT_SNORM_INT8X1](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg9b009d9a6aa4c5765c8a00289b6068f9f92943f83ded303df264a79ee11d1db0>) = 0xc6,
                      [CU_AD_FORMAT_SNORM_INT8X2](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg9b009d9a6aa4c5765c8a00289b6068f9b8194990a6e17d78be0de66deffdf02f>) = 0xc7,
                      [CU_AD_FORMAT_SNORM_INT8X4](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg9b009d9a6aa4c5765c8a00289b6068f9117a2e043203748187605ff8a71c2d1d>) = 0xc8,
                      [CU_AD_FORMAT_SNORM_INT16X1](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg9b009d9a6aa4c5765c8a00289b6068f95026e5e8783752bf8d3601dd4dbceb4c>) = 0xc9,
                      [CU_AD_FORMAT_SNORM_INT16X2](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg9b009d9a6aa4c5765c8a00289b6068f939f633274a07dbce442325c5d90bf294>) = 0xca,
                      [CU_AD_FORMAT_SNORM_INT16X4](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg9b009d9a6aa4c5765c8a00289b6068f99acc19038dc1e68170e485f739912d49>) = 0xcb,
                      [CU_AD_FORMAT_BC1_UNORM](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg9b009d9a6aa4c5765c8a00289b6068f9299d155257aa3c0b75634d9f9b1bfa72>) = 0x91,
                      [CU_AD_FORMAT_BC1_UNORM_SRGB](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg9b009d9a6aa4c5765c8a00289b6068f9afa18b300eb91ff879532a55d5aa191b>) = 0x92,
                      [CU_AD_FORMAT_BC2_UNORM](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg9b009d9a6aa4c5765c8a00289b6068f92b9cf00f8c6012ec679654c9f012a267>) = 0x93,
                      [CU_AD_FORMAT_BC2_UNORM_SRGB](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg9b009d9a6aa4c5765c8a00289b6068f9c38b5af7926b020202562d67ba7529c2>) = 0x94,
                      [CU_AD_FORMAT_BC3_UNORM](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg9b009d9a6aa4c5765c8a00289b6068f9b8473614347359cc74574899e2e65012>) = 0x95,
                      [CU_AD_FORMAT_BC3_UNORM_SRGB](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg9b009d9a6aa4c5765c8a00289b6068f94d158239dd6c825b4bd383ed66625257>) = 0x96,
                      [CU_AD_FORMAT_BC4_UNORM](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg9b009d9a6aa4c5765c8a00289b6068f9fe7527dfa2576595eea7463a1140058c>) = 0x97,
                      [CU_AD_FORMAT_BC4_SNORM](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg9b009d9a6aa4c5765c8a00289b6068f90627520c6fc707d63e9d3c66d307eec6>) = 0x98,
                      [CU_AD_FORMAT_BC5_UNORM](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg9b009d9a6aa4c5765c8a00289b6068f94b524073942ab7460b68a98da955e59e>) = 0x99,
                      [CU_AD_FORMAT_BC5_SNORM](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg9b009d9a6aa4c5765c8a00289b6068f907466b7b5b3d897a58fac1e9d2db163e>) = 0x9a,
                      [CU_AD_FORMAT_BC6H_UF16](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg9b009d9a6aa4c5765c8a00289b6068f94085af463b118d564873b8d275ac7912>) = 0x9b,
                      [CU_AD_FORMAT_BC6H_SF16](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg9b009d9a6aa4c5765c8a00289b6068f938c1d137a2663d5ddca5ae6aa49f612e>) = 0x9c,
                      [CU_AD_FORMAT_BC7_UNORM](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg9b009d9a6aa4c5765c8a00289b6068f9f03f9cbeee0911d3c77c08e6f5c7ff62>) = 0x9d,
                      [CU_AD_FORMAT_BC7_UNORM_SRGB](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg9b009d9a6aa4c5765c8a00289b6068f9ad5b0e1cd964cbd46270223f35651677>) = 0x9e,
                      [CU_AD_FORMAT_P010](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg9b009d9a6aa4c5765c8a00289b6068f9f0efd5417115904eb086f1df0046582e>) = 0x9f,
                      [CU_AD_FORMAT_P016](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg9b009d9a6aa4c5765c8a00289b6068f9b8511f36d0a010b8846c84309d8920d5>) = 0xa1,
                      [CU_AD_FORMAT_NV16](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg9b009d9a6aa4c5765c8a00289b6068f9e41b4351cb805f35130636b0aafca609>) = 0xa2,
                      [CU_AD_FORMAT_P210](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg9b009d9a6aa4c5765c8a00289b6068f9dc77f21be8b4ff4f23dcd450c3656409>) = 0xa3,
                      [CU_AD_FORMAT_P216](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg9b009d9a6aa4c5765c8a00289b6068f9a42b3a04e2f30a93e50d7d68026f1ba9>) = 0xa4,
                      [CU_AD_FORMAT_YUY2](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg9b009d9a6aa4c5765c8a00289b6068f961f757ee5f5c125b7be70e5b562826dc>) = 0xa5,
                      [CU_AD_FORMAT_Y210](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg9b009d9a6aa4c5765c8a00289b6068f9796d73bbcb63216f7dd4cc4d8016b74c>) = 0xa6,
                      [CU_AD_FORMAT_Y216](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg9b009d9a6aa4c5765c8a00289b6068f9c2081981924fa204383f1ee05de74d8e>) = 0xa7,
                      [CU_AD_FORMAT_AYUV](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg9b009d9a6aa4c5765c8a00289b6068f99dd6d4cac84e541d2b1ad34b263bc1bc>) = 0xa8,
                      [CU_AD_FORMAT_Y410](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg9b009d9a6aa4c5765c8a00289b6068f91917374a5915ee6a5e1ed23c57f43b75>) = 0xa9,
                      [CU_AD_FORMAT_Y416](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg9b009d9a6aa4c5765c8a00289b6068f941bdcafb69e249176af2e1cc5d6178be>) = 0xb1,
                      [CU_AD_FORMAT_Y444_PLANAR8](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg9b009d9a6aa4c5765c8a00289b6068f93af0d614c7c240194c402b6ca9b4909f>) = 0xb2,
                      [CU_AD_FORMAT_Y444_PLANAR10](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg9b009d9a6aa4c5765c8a00289b6068f916b3c04a1fba1562d548d4504f06a7aa>) = 0xb3,
                      [CU_AD_FORMAT_YUV444_8bit_SemiPlanar](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg9b009d9a6aa4c5765c8a00289b6068f945b7c15d0c8a42d569b20509e7e54e1d>) = 0xb4,
                      [CU_AD_FORMAT_YUV444_16bit_SemiPlanar](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg9b009d9a6aa4c5765c8a00289b6068f9cb653da3339b76b267a6fa8085513017>) = 0xb5,
                      [CU_AD_FORMAT_UNORM_INT_101010_2](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg9b009d9a6aa4c5765c8a00289b6068f93b3828154e807c69a6e0c7e0d54d31ea>) = 0x50,
                      [CU_AD_FORMAT_UINT8_PACKED_422](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg9b009d9a6aa4c5765c8a00289b6068f9c3e98982827e44204ed4a4d41031c135>) = 0x51,
                      [CU_AD_FORMAT_UINT8_PACKED_444](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg9b009d9a6aa4c5765c8a00289b6068f90cb5a5812940939b5f0eb0242a2146e7>) = 0x52,
                      [CU_AD_FORMAT_UINT8_SEMIPLANAR_420](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg9b009d9a6aa4c5765c8a00289b6068f9f212e89e226ee1d69ca4a47fba3c39c3>) = 0x53,
                      [CU_AD_FORMAT_UINT16_SEMIPLANAR_420](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg9b009d9a6aa4c5765c8a00289b6068f9e076ab1291241ef4c6c149b23321e1b5>) = 0x54,
                      [CU_AD_FORMAT_UINT8_SEMIPLANAR_422](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg9b009d9a6aa4c5765c8a00289b6068f959c089e74d94f90973118ef287d4f352>) = 0x55,
                      [CU_AD_FORMAT_UINT16_SEMIPLANAR_422](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg9b009d9a6aa4c5765c8a00289b6068f97f759c17c105bfa6fb486502fad3705e>) = 0x56,
                      [CU_AD_FORMAT_UINT8_SEMIPLANAR_444](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg9b009d9a6aa4c5765c8a00289b6068f90548d7ee27a7f9401064a4d3b3dfc528>) = 0x57,
                      [CU_AD_FORMAT_UINT16_SEMIPLANAR_444](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg9b009d9a6aa4c5765c8a00289b6068f90a4038e90a78ae9bf495d043c39a9e29>) = 0x58,
                      [CU_AD_FORMAT_UINT8_PLANAR_420](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg9b009d9a6aa4c5765c8a00289b6068f9d0f3182f705a6615ac5299de395cace8>) = 0x59,
                      [CU_AD_FORMAT_UINT16_PLANAR_420](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg9b009d9a6aa4c5765c8a00289b6068f97a9888731c72732a6880a18ef2f082cb>) = 0x5a,
                      [CU_AD_FORMAT_UINT8_PLANAR_422](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg9b009d9a6aa4c5765c8a00289b6068f932bb01870f63cd2d9949ccb2ea235ef1>) = 0x5b,
                      [CU_AD_FORMAT_UINT16_PLANAR_422](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg9b009d9a6aa4c5765c8a00289b6068f97a9a4abfb8ce20c04ddb47925cdf3752>) = 0x5c,
                      [CU_AD_FORMAT_UINT8_PLANAR_444](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg9b009d9a6aa4c5765c8a00289b6068f9922d032a80ac1229a05dae35c18c4b2e>) = 0x5d,
                      [CU_AD_FORMAT_UINT16_PLANAR_444](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg9b009d9a6aa4c5765c8a00289b6068f98ff25a5b7ff451a608b2ecca340b1f71>) = 0x5e,
                 } [CUarray_format](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g9b009d9a6aa4c5765c8a00289b6068f9>);

  * `NumChannels` specifies the number of packed components per CUDA array element; it may be 1, 2, or 4;


Here are examples of CUDA array descriptions:

Description for a CUDA array of 2048 floats:


    â    [CUDA_ARRAY_DESCRIPTOR](<structCUDA__ARRAY__DESCRIPTOR__v2.html#structCUDA__ARRAY__DESCRIPTOR__v2>) desc;
              desc.[Format](<structCUDA__ARRAY__DESCRIPTOR__v2.html#structCUDA__ARRAY__DESCRIPTOR__v2_19ea7ac9a60d1e85a2b45a3b7287fb5e9>) = [CU_AD_FORMAT_FLOAT](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg9b009d9a6aa4c5765c8a00289b6068f98140f3b0de3d87bdbf26964c24840f3c>);
              desc.[NumChannels](<structCUDA__ARRAY__DESCRIPTOR__v2.html#structCUDA__ARRAY__DESCRIPTOR__v2_11c4f64c9b3497ab7d315b4fb85bc468d>) = 1;
              desc.[Width](<structCUDA__ARRAY__DESCRIPTOR__v2.html#structCUDA__ARRAY__DESCRIPTOR__v2_140015fb3fed92224b92650450c3ea2f0>) = 2048;
              desc.[Height](<structCUDA__ARRAY__DESCRIPTOR__v2.html#structCUDA__ARRAY__DESCRIPTOR__v2_1796dde1623e8bff79f764020d4b8f798>) = 1;

Description for a 64 x 64 CUDA array of floats:


    â    [CUDA_ARRAY_DESCRIPTOR](<structCUDA__ARRAY__DESCRIPTOR__v2.html#structCUDA__ARRAY__DESCRIPTOR__v2>) desc;
              desc.[Format](<structCUDA__ARRAY__DESCRIPTOR__v2.html#structCUDA__ARRAY__DESCRIPTOR__v2_19ea7ac9a60d1e85a2b45a3b7287fb5e9>) = [CU_AD_FORMAT_FLOAT](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg9b009d9a6aa4c5765c8a00289b6068f98140f3b0de3d87bdbf26964c24840f3c>);
              desc.[NumChannels](<structCUDA__ARRAY__DESCRIPTOR__v2.html#structCUDA__ARRAY__DESCRIPTOR__v2_11c4f64c9b3497ab7d315b4fb85bc468d>) = 1;
              desc.[Width](<structCUDA__ARRAY__DESCRIPTOR__v2.html#structCUDA__ARRAY__DESCRIPTOR__v2_140015fb3fed92224b92650450c3ea2f0>) = 64;
              desc.[Height](<structCUDA__ARRAY__DESCRIPTOR__v2.html#structCUDA__ARRAY__DESCRIPTOR__v2_1796dde1623e8bff79f764020d4b8f798>) = 64;

Description for a `width` x `height` CUDA array of 64-bit, 4x16-bit float16's:


    â    [CUDA_ARRAY_DESCRIPTOR](<structCUDA__ARRAY__DESCRIPTOR__v2.html#structCUDA__ARRAY__DESCRIPTOR__v2>) desc;
              desc.[Format](<structCUDA__ARRAY__DESCRIPTOR__v2.html#structCUDA__ARRAY__DESCRIPTOR__v2_19ea7ac9a60d1e85a2b45a3b7287fb5e9>) = [CU_AD_FORMAT_HALF](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg9b009d9a6aa4c5765c8a00289b6068f995c97289b540ff36334722ec745f53a3>);
              desc.[NumChannels](<structCUDA__ARRAY__DESCRIPTOR__v2.html#structCUDA__ARRAY__DESCRIPTOR__v2_11c4f64c9b3497ab7d315b4fb85bc468d>) = 4;
              desc.[Width](<structCUDA__ARRAY__DESCRIPTOR__v2.html#structCUDA__ARRAY__DESCRIPTOR__v2_140015fb3fed92224b92650450c3ea2f0>) = width;
              desc.[Height](<structCUDA__ARRAY__DESCRIPTOR__v2.html#structCUDA__ARRAY__DESCRIPTOR__v2_1796dde1623e8bff79f764020d4b8f798>) = height;

Description for a `width` x `height` CUDA array of 16-bit elements, each of which is two 8-bit unsigned chars:


    â    [CUDA_ARRAY_DESCRIPTOR](<structCUDA__ARRAY__DESCRIPTOR__v2.html#structCUDA__ARRAY__DESCRIPTOR__v2>) arrayDesc;
              desc.[Format](<structCUDA__ARRAY__DESCRIPTOR__v2.html#structCUDA__ARRAY__DESCRIPTOR__v2_19ea7ac9a60d1e85a2b45a3b7287fb5e9>) = [CU_AD_FORMAT_UNSIGNED_INT8](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg9b009d9a6aa4c5765c8a00289b6068f9e0af5f5a0ffa8e16a5c720364ccd5dac>);
              desc.[NumChannels](<structCUDA__ARRAY__DESCRIPTOR__v2.html#structCUDA__ARRAY__DESCRIPTOR__v2_11c4f64c9b3497ab7d315b4fb85bc468d>) = 2;
              desc.[Width](<structCUDA__ARRAY__DESCRIPTOR__v2.html#structCUDA__ARRAY__DESCRIPTOR__v2_140015fb3fed92224b92650450c3ea2f0>) = width;
              desc.[Height](<structCUDA__ARRAY__DESCRIPTOR__v2.html#structCUDA__ARRAY__DESCRIPTOR__v2_1796dde1623e8bff79f764020d4b8f798>) = height;

Note:

Note that this function may also return error codes from previous, asynchronous launches.

**See also:**

[cuArray3DCreate](<group__CUDA__MEM.html#group__CUDA__MEM_1gc2322c70b38c2984536c90ed118bb1d7> "Creates a 3D CUDA array."), [cuArray3DGetDescriptor](<group__CUDA__MEM.html#group__CUDA__MEM_1gb58549f2f3f390b9e0e7c8f3acd53857> "Get a 3D CUDA array descriptor."), [cuArrayDestroy](<group__CUDA__MEM.html#group__CUDA__MEM_1g982878affbbc023de84874faac838b0b> "Destroys a CUDA array."), [cuArrayGetDescriptor](<group__CUDA__MEM.html#group__CUDA__MEM_1g661fe823dbd37bf11f82a71bd4762acf> "Get a 1D or 2D CUDA array descriptor."), [cuMemAlloc](<group__CUDA__MEM.html#group__CUDA__MEM_1gb82d2a09844a58dd9e744dc31e8aa467> "Allocates device memory."), [cuMemAllocHost](<group__CUDA__MEM.html#group__CUDA__MEM_1gdd8311286d2c2691605362c689bc64e0> "Allocates page-locked host memory."), [cuMemAllocPitch](<group__CUDA__MEM.html#group__CUDA__MEM_1gcbe9b033f6c4de80f63cc6e58ed9a45a> "Allocates pitched device memory."), [cuMemcpy2D](<group__CUDA__MEM.html#group__CUDA__MEM_1g27f885b30c34cc20a663a671dbf6fc27> "Copies memory for 2D arrays."), [cuMemcpy2DAsync](<group__CUDA__MEM.html#group__CUDA__MEM_1g4acf155faeb969d9d21f5433d3d0f274> "Copies memory for 2D arrays."), [cuMemcpy2DUnaligned](<group__CUDA__MEM.html#group__CUDA__MEM_1g2fa285d47fd7020e596bfeab3deb651b> "Copies memory for 2D arrays."), [cuMemcpy3D](<group__CUDA__MEM.html#group__CUDA__MEM_1g4b5238975579f002c0199a3800ca44df> "Copies memory for 3D arrays."), [cuMemcpy3DAsync](<group__CUDA__MEM.html#group__CUDA__MEM_1g79f4f3fde6ae0f529568d881d9e11987> "Copies memory for 3D arrays."), [cuMemcpyAtoA](<group__CUDA__MEM.html#group__CUDA__MEM_1gf81b218c984a31436ec9e23a85fb604a> "Copies memory from Array to Array."), [cuMemcpyAtoD](<group__CUDA__MEM.html#group__CUDA__MEM_1g825b3f037f7f51382cae991bae8173fd> "Copies memory from Array to Device."), [cuMemcpyAtoH](<group__CUDA__MEM.html#group__CUDA__MEM_1gf7ad1edb2539cccc352c6b8b76f657f4> "Copies memory from Array to Host."), [cuMemcpyAtoHAsync](<group__CUDA__MEM.html#group__CUDA__MEM_1g64cbd2e60436699aebdd0bdbf14d0f01> "Copies memory from Array to Host."), [cuMemcpyDtoA](<group__CUDA__MEM.html#group__CUDA__MEM_1gad6827247af91600b56ce6e2ddb802e1> "Copies memory from Device to Array."), [cuMemcpyDtoD](<group__CUDA__MEM.html#group__CUDA__MEM_1g1725774abf8b51b91945f3336b778c8b> "Copies memory from Device to Device."), [cuMemcpyDtoDAsync](<group__CUDA__MEM.html#group__CUDA__MEM_1g39ea09ba682b8eccc9c3e0c04319b5c8> "Copies memory from Device to Device."), [cuMemcpyDtoH](<group__CUDA__MEM.html#group__CUDA__MEM_1g3480368ee0208a98f75019c9a8450893> "Copies memory from Device to Host."), [cuMemcpyDtoHAsync](<group__CUDA__MEM.html#group__CUDA__MEM_1g56f30236c7c5247f8e061b59d3268362> "Copies memory from Device to Host."), [cuMemcpyHtoA](<group__CUDA__MEM.html#group__CUDA__MEM_1g57d3d780d165ecc0e3b3ce08e141cd89> "Copies memory from Host to Array."), [cuMemcpyHtoAAsync](<group__CUDA__MEM.html#group__CUDA__MEM_1gb5c4863f64f132b4bc2661818b3fd188> "Copies memory from Host to Array."), [cuMemcpyHtoD](<group__CUDA__MEM.html#group__CUDA__MEM_1g4d32266788c440b0220b1a9ba5795169> "Copies memory from Host to Device."), [cuMemcpyHtoDAsync](<group__CUDA__MEM.html#group__CUDA__MEM_1g1572263fe2597d7ba4f6964597a354a3> "Copies memory from Host to Device."), [cuMemFree](<group__CUDA__MEM.html#group__CUDA__MEM_1g89b3f154e17cc89b6eea277dbdf5c93a> "Frees device memory."), [cuMemFreeHost](<group__CUDA__MEM.html#group__CUDA__MEM_1g62e0fdbe181dab6b1c90fa1a51c7b92c> "Frees page-locked host memory."), [cuMemGetAddressRange](<group__CUDA__MEM.html#group__CUDA__MEM_1g64fee5711274a2a0573a789c94d8299b> "Get information on memory allocations."), [cuMemGetInfo](<group__CUDA__MEM.html#group__CUDA__MEM_1g808f555540d0143a331cc42aa98835c0> "Gets free and total memory."), [cuMemHostAlloc](<group__CUDA__MEM.html#group__CUDA__MEM_1g572ca4011bfcb25034888a14d4e035b9> "Allocates page-locked host memory."), [cuMemHostGetDevicePointer](<group__CUDA__MEM.html#group__CUDA__MEM_1g57a39e5cba26af4d06be67fc77cc62f0> "Passes back device pointer of mapped pinned memory."), [cuMemsetD2D8](<group__CUDA__MEM.html#group__CUDA__MEM_1ge88b13e646e2be6ba0e0475ef5205974> "Initializes device memory."), [cuMemsetD2D16](<group__CUDA__MEM.html#group__CUDA__MEM_1g7f561a15a66144fa9f6ab5350edc8a30> "Initializes device memory."), [cuMemsetD2D32](<group__CUDA__MEM.html#group__CUDA__MEM_1g74b359b2d026bfeb7c795b5038d07523> "Initializes device memory."), [cuMemsetD8](<group__CUDA__MEM.html#group__CUDA__MEM_1g6e582bf866e9e2fb014297bfaf354d7b> "Initializes device memory."), [cuMemsetD16](<group__CUDA__MEM.html#group__CUDA__MEM_1g7d805e610054392a4d11e8a8bf5eb35c> "Initializes device memory."), [cuMemsetD32](<group__CUDA__MEM.html#group__CUDA__MEM_1g983e8d8759acd1b64326317481fbf132> "Initializes device memory."), [cudaMallocArray](<../cuda-runtime-api/group__CUDART__MEMORY.html#group__CUDART__MEMORY_1g6728eb7dc25f332f50bdb16a19620d3d>)

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuArrayDestroy ( [CUarray](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gd550651524a56766b60f10f0e7628042>)Â hArray )


Destroys a CUDA array.

######  Parameters

`hArray`
    \- Array to destroy

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_DEINITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9acf52f132faf29b473cdda6061f0f44a>), [CUDA_ERROR_NOT_INITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e98feb999f0af99b4a25ab26b3866f4df8>), [CUDA_ERROR_INVALID_CONTEXT](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a484e9af32c1e9893ff21f0e0191a12d>), [CUDA_ERROR_INVALID_HANDLE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e90fd2e63260c6317ba943af0f7e4b8d21>), [CUDA_ERROR_ARRAY_IS_MAPPED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9b668b10d56232c51b67db40516cc6b5b>), [CUDA_ERROR_CONTEXT_IS_DESTROYED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9b27ac43f7ce8446f5c9636dd73fb2139>)

###### Description

Destroys the CUDA array `hArray`.

Note:

Note that this function may also return error codes from previous, asynchronous launches.

**See also:**

[cuArray3DCreate](<group__CUDA__MEM.html#group__CUDA__MEM_1gc2322c70b38c2984536c90ed118bb1d7> "Creates a 3D CUDA array."), [cuArray3DGetDescriptor](<group__CUDA__MEM.html#group__CUDA__MEM_1gb58549f2f3f390b9e0e7c8f3acd53857> "Get a 3D CUDA array descriptor."), [cuArrayCreate](<group__CUDA__MEM.html#group__CUDA__MEM_1g4192ff387a81c3bd5ed8c391ed62ca24> "Creates a 1D or 2D CUDA array."), [cuArrayGetDescriptor](<group__CUDA__MEM.html#group__CUDA__MEM_1g661fe823dbd37bf11f82a71bd4762acf> "Get a 1D or 2D CUDA array descriptor."), [cuMemAlloc](<group__CUDA__MEM.html#group__CUDA__MEM_1gb82d2a09844a58dd9e744dc31e8aa467> "Allocates device memory."), [cuMemAllocHost](<group__CUDA__MEM.html#group__CUDA__MEM_1gdd8311286d2c2691605362c689bc64e0> "Allocates page-locked host memory."), [cuMemAllocPitch](<group__CUDA__MEM.html#group__CUDA__MEM_1gcbe9b033f6c4de80f63cc6e58ed9a45a> "Allocates pitched device memory."), [cuMemcpy2D](<group__CUDA__MEM.html#group__CUDA__MEM_1g27f885b30c34cc20a663a671dbf6fc27> "Copies memory for 2D arrays."), [cuMemcpy2DAsync](<group__CUDA__MEM.html#group__CUDA__MEM_1g4acf155faeb969d9d21f5433d3d0f274> "Copies memory for 2D arrays."), [cuMemcpy2DUnaligned](<group__CUDA__MEM.html#group__CUDA__MEM_1g2fa285d47fd7020e596bfeab3deb651b> "Copies memory for 2D arrays."), [cuMemcpy3D](<group__CUDA__MEM.html#group__CUDA__MEM_1g4b5238975579f002c0199a3800ca44df> "Copies memory for 3D arrays."), [cuMemcpy3DAsync](<group__CUDA__MEM.html#group__CUDA__MEM_1g79f4f3fde6ae0f529568d881d9e11987> "Copies memory for 3D arrays."), [cuMemcpyAtoA](<group__CUDA__MEM.html#group__CUDA__MEM_1gf81b218c984a31436ec9e23a85fb604a> "Copies memory from Array to Array."), [cuMemcpyAtoD](<group__CUDA__MEM.html#group__CUDA__MEM_1g825b3f037f7f51382cae991bae8173fd> "Copies memory from Array to Device."), [cuMemcpyAtoH](<group__CUDA__MEM.html#group__CUDA__MEM_1gf7ad1edb2539cccc352c6b8b76f657f4> "Copies memory from Array to Host."), [cuMemcpyAtoHAsync](<group__CUDA__MEM.html#group__CUDA__MEM_1g64cbd2e60436699aebdd0bdbf14d0f01> "Copies memory from Array to Host."), [cuMemcpyDtoA](<group__CUDA__MEM.html#group__CUDA__MEM_1gad6827247af91600b56ce6e2ddb802e1> "Copies memory from Device to Array."), [cuMemcpyDtoD](<group__CUDA__MEM.html#group__CUDA__MEM_1g1725774abf8b51b91945f3336b778c8b> "Copies memory from Device to Device."), [cuMemcpyDtoDAsync](<group__CUDA__MEM.html#group__CUDA__MEM_1g39ea09ba682b8eccc9c3e0c04319b5c8> "Copies memory from Device to Device."), [cuMemcpyDtoH](<group__CUDA__MEM.html#group__CUDA__MEM_1g3480368ee0208a98f75019c9a8450893> "Copies memory from Device to Host."), [cuMemcpyDtoHAsync](<group__CUDA__MEM.html#group__CUDA__MEM_1g56f30236c7c5247f8e061b59d3268362> "Copies memory from Device to Host."), [cuMemcpyHtoA](<group__CUDA__MEM.html#group__CUDA__MEM_1g57d3d780d165ecc0e3b3ce08e141cd89> "Copies memory from Host to Array."), [cuMemcpyHtoAAsync](<group__CUDA__MEM.html#group__CUDA__MEM_1gb5c4863f64f132b4bc2661818b3fd188> "Copies memory from Host to Array."), [cuMemcpyHtoD](<group__CUDA__MEM.html#group__CUDA__MEM_1g4d32266788c440b0220b1a9ba5795169> "Copies memory from Host to Device."), [cuMemcpyHtoDAsync](<group__CUDA__MEM.html#group__CUDA__MEM_1g1572263fe2597d7ba4f6964597a354a3> "Copies memory from Host to Device."), [cuMemFree](<group__CUDA__MEM.html#group__CUDA__MEM_1g89b3f154e17cc89b6eea277dbdf5c93a> "Frees device memory."), [cuMemFreeHost](<group__CUDA__MEM.html#group__CUDA__MEM_1g62e0fdbe181dab6b1c90fa1a51c7b92c> "Frees page-locked host memory."), [cuMemGetAddressRange](<group__CUDA__MEM.html#group__CUDA__MEM_1g64fee5711274a2a0573a789c94d8299b> "Get information on memory allocations."), [cuMemGetInfo](<group__CUDA__MEM.html#group__CUDA__MEM_1g808f555540d0143a331cc42aa98835c0> "Gets free and total memory."), [cuMemHostAlloc](<group__CUDA__MEM.html#group__CUDA__MEM_1g572ca4011bfcb25034888a14d4e035b9> "Allocates page-locked host memory."), [cuMemHostGetDevicePointer](<group__CUDA__MEM.html#group__CUDA__MEM_1g57a39e5cba26af4d06be67fc77cc62f0> "Passes back device pointer of mapped pinned memory."), [cuMemsetD2D8](<group__CUDA__MEM.html#group__CUDA__MEM_1ge88b13e646e2be6ba0e0475ef5205974> "Initializes device memory."), [cuMemsetD2D16](<group__CUDA__MEM.html#group__CUDA__MEM_1g7f561a15a66144fa9f6ab5350edc8a30> "Initializes device memory."), [cuMemsetD2D32](<group__CUDA__MEM.html#group__CUDA__MEM_1g74b359b2d026bfeb7c795b5038d07523> "Initializes device memory."), [cuMemsetD8](<group__CUDA__MEM.html#group__CUDA__MEM_1g6e582bf866e9e2fb014297bfaf354d7b> "Initializes device memory."), [cuMemsetD16](<group__CUDA__MEM.html#group__CUDA__MEM_1g7d805e610054392a4d11e8a8bf5eb35c> "Initializes device memory."), [cuMemsetD32](<group__CUDA__MEM.html#group__CUDA__MEM_1g983e8d8759acd1b64326317481fbf132> "Initializes device memory."), [cudaFreeArray](<../cuda-runtime-api/group__CUDART__MEMORY.html#group__CUDART__MEMORY_1g1b553f5f4806d67525230ac305d50900>)

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuArrayGetDescriptor ( [CUDA_ARRAY_DESCRIPTOR](<structCUDA__ARRAY__DESCRIPTOR__v2.html#structCUDA__ARRAY__DESCRIPTOR__v2>)*Â pArrayDescriptor, [CUarray](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gd550651524a56766b60f10f0e7628042>)Â hArray )


Get a 1D or 2D CUDA array descriptor.

######  Parameters

`pArrayDescriptor`
    \- Returned array descriptor
`hArray`
    \- Array to get descriptor of

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_DEINITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9acf52f132faf29b473cdda6061f0f44a>), [CUDA_ERROR_NOT_INITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e98feb999f0af99b4a25ab26b3866f4df8>), [CUDA_ERROR_INVALID_CONTEXT](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a484e9af32c1e9893ff21f0e0191a12d>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>), [CUDA_ERROR_INVALID_HANDLE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e90fd2e63260c6317ba943af0f7e4b8d21>)

###### Description

Returns in `*pArrayDescriptor` a descriptor containing information on the format and dimensions of the CUDA array `hArray`. It is useful for subroutines that have been passed a CUDA array, but need to know the CUDA array parameters for validation or other purposes.

Note:

Note that this function may also return error codes from previous, asynchronous launches.

**See also:**

[cuArray3DCreate](<group__CUDA__MEM.html#group__CUDA__MEM_1gc2322c70b38c2984536c90ed118bb1d7> "Creates a 3D CUDA array."), [cuArray3DGetDescriptor](<group__CUDA__MEM.html#group__CUDA__MEM_1gb58549f2f3f390b9e0e7c8f3acd53857> "Get a 3D CUDA array descriptor."), [cuArrayCreate](<group__CUDA__MEM.html#group__CUDA__MEM_1g4192ff387a81c3bd5ed8c391ed62ca24> "Creates a 1D or 2D CUDA array."), [cuArrayDestroy](<group__CUDA__MEM.html#group__CUDA__MEM_1g982878affbbc023de84874faac838b0b> "Destroys a CUDA array."), [cuMemAlloc](<group__CUDA__MEM.html#group__CUDA__MEM_1gb82d2a09844a58dd9e744dc31e8aa467> "Allocates device memory."), [cuMemAllocHost](<group__CUDA__MEM.html#group__CUDA__MEM_1gdd8311286d2c2691605362c689bc64e0> "Allocates page-locked host memory."), [cuMemAllocPitch](<group__CUDA__MEM.html#group__CUDA__MEM_1gcbe9b033f6c4de80f63cc6e58ed9a45a> "Allocates pitched device memory."), [cuMemcpy2D](<group__CUDA__MEM.html#group__CUDA__MEM_1g27f885b30c34cc20a663a671dbf6fc27> "Copies memory for 2D arrays."), [cuMemcpy2DAsync](<group__CUDA__MEM.html#group__CUDA__MEM_1g4acf155faeb969d9d21f5433d3d0f274> "Copies memory for 2D arrays."), [cuMemcpy2DUnaligned](<group__CUDA__MEM.html#group__CUDA__MEM_1g2fa285d47fd7020e596bfeab3deb651b> "Copies memory for 2D arrays."), [cuMemcpy3D](<group__CUDA__MEM.html#group__CUDA__MEM_1g4b5238975579f002c0199a3800ca44df> "Copies memory for 3D arrays."), [cuMemcpy3DAsync](<group__CUDA__MEM.html#group__CUDA__MEM_1g79f4f3fde6ae0f529568d881d9e11987> "Copies memory for 3D arrays."), [cuMemcpyAtoA](<group__CUDA__MEM.html#group__CUDA__MEM_1gf81b218c984a31436ec9e23a85fb604a> "Copies memory from Array to Array."), [cuMemcpyAtoD](<group__CUDA__MEM.html#group__CUDA__MEM_1g825b3f037f7f51382cae991bae8173fd> "Copies memory from Array to Device."), [cuMemcpyAtoH](<group__CUDA__MEM.html#group__CUDA__MEM_1gf7ad1edb2539cccc352c6b8b76f657f4> "Copies memory from Array to Host."), [cuMemcpyAtoHAsync](<group__CUDA__MEM.html#group__CUDA__MEM_1g64cbd2e60436699aebdd0bdbf14d0f01> "Copies memory from Array to Host."), [cuMemcpyDtoA](<group__CUDA__MEM.html#group__CUDA__MEM_1gad6827247af91600b56ce6e2ddb802e1> "Copies memory from Device to Array."), [cuMemcpyDtoD](<group__CUDA__MEM.html#group__CUDA__MEM_1g1725774abf8b51b91945f3336b778c8b> "Copies memory from Device to Device."), [cuMemcpyDtoDAsync](<group__CUDA__MEM.html#group__CUDA__MEM_1g39ea09ba682b8eccc9c3e0c04319b5c8> "Copies memory from Device to Device."), [cuMemcpyDtoH](<group__CUDA__MEM.html#group__CUDA__MEM_1g3480368ee0208a98f75019c9a8450893> "Copies memory from Device to Host."), [cuMemcpyDtoHAsync](<group__CUDA__MEM.html#group__CUDA__MEM_1g56f30236c7c5247f8e061b59d3268362> "Copies memory from Device to Host."), [cuMemcpyHtoA](<group__CUDA__MEM.html#group__CUDA__MEM_1g57d3d780d165ecc0e3b3ce08e141cd89> "Copies memory from Host to Array."), [cuMemcpyHtoAAsync](<group__CUDA__MEM.html#group__CUDA__MEM_1gb5c4863f64f132b4bc2661818b3fd188> "Copies memory from Host to Array."), [cuMemcpyHtoD](<group__CUDA__MEM.html#group__CUDA__MEM_1g4d32266788c440b0220b1a9ba5795169> "Copies memory from Host to Device."), [cuMemcpyHtoDAsync](<group__CUDA__MEM.html#group__CUDA__MEM_1g1572263fe2597d7ba4f6964597a354a3> "Copies memory from Host to Device."), [cuMemFree](<group__CUDA__MEM.html#group__CUDA__MEM_1g89b3f154e17cc89b6eea277dbdf5c93a> "Frees device memory."), [cuMemFreeHost](<group__CUDA__MEM.html#group__CUDA__MEM_1g62e0fdbe181dab6b1c90fa1a51c7b92c> "Frees page-locked host memory."), [cuMemGetAddressRange](<group__CUDA__MEM.html#group__CUDA__MEM_1g64fee5711274a2a0573a789c94d8299b> "Get information on memory allocations."), [cuMemGetInfo](<group__CUDA__MEM.html#group__CUDA__MEM_1g808f555540d0143a331cc42aa98835c0> "Gets free and total memory."), [cuMemHostAlloc](<group__CUDA__MEM.html#group__CUDA__MEM_1g572ca4011bfcb25034888a14d4e035b9> "Allocates page-locked host memory."), [cuMemHostGetDevicePointer](<group__CUDA__MEM.html#group__CUDA__MEM_1g57a39e5cba26af4d06be67fc77cc62f0> "Passes back device pointer of mapped pinned memory."), [cuMemsetD2D8](<group__CUDA__MEM.html#group__CUDA__MEM_1ge88b13e646e2be6ba0e0475ef5205974> "Initializes device memory."), [cuMemsetD2D16](<group__CUDA__MEM.html#group__CUDA__MEM_1g7f561a15a66144fa9f6ab5350edc8a30> "Initializes device memory."), [cuMemsetD2D32](<group__CUDA__MEM.html#group__CUDA__MEM_1g74b359b2d026bfeb7c795b5038d07523> "Initializes device memory."), [cuMemsetD8](<group__CUDA__MEM.html#group__CUDA__MEM_1g6e582bf866e9e2fb014297bfaf354d7b> "Initializes device memory."), [cuMemsetD16](<group__CUDA__MEM.html#group__CUDA__MEM_1g7d805e610054392a4d11e8a8bf5eb35c> "Initializes device memory."), [cuMemsetD32](<group__CUDA__MEM.html#group__CUDA__MEM_1g983e8d8759acd1b64326317481fbf132> "Initializes device memory."), [cudaArrayGetInfo](<../cuda-runtime-api/group__CUDART__MEMORY.html#group__CUDART__MEMORY_1g373dacf191566b0bf5e5b807517b6bf9>)

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuArrayGetMemoryRequirements ( [CUDA_ARRAY_MEMORY_REQUIREMENTS](<structCUDA__ARRAY__MEMORY__REQUIREMENTS__v1.html#structCUDA__ARRAY__MEMORY__REQUIREMENTS__v1>)*Â memoryRequirements, [CUarray](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gd550651524a56766b60f10f0e7628042>)Â array, [CUdevice](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g41ca2a24a242b36ef2ca77330b5fb72a>)Â device )


Returns the memory requirements of a CUDA array.

######  Parameters

`memoryRequirements`
    \- Pointer to CUDA_ARRAY_MEMORY_REQUIREMENTS
`array`
    \- CUDA array to get the memory requirements of
`device`
    \- Device to get the memory requirements for

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>)[CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>)

###### Description

Returns the memory requirements of a CUDA array in `memoryRequirements` If the CUDA array is not allocated with flag [CUDA_ARRAY3D_DEFERRED_MAPPING](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g854c29dbc47d04a4e42863cb87487d55>)[CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>) will be returned.

The returned value in [CUDA_ARRAY_MEMORY_REQUIREMENTS::size](<structCUDA__ARRAY__MEMORY__REQUIREMENTS__v1.html#structCUDA__ARRAY__MEMORY__REQUIREMENTS__v1_17a2851735a1d2c11af797f01b1d4969e>) represents the total size of the CUDA array. The returned value in [CUDA_ARRAY_MEMORY_REQUIREMENTS::alignment](<structCUDA__ARRAY__MEMORY__REQUIREMENTS__v1.html#structCUDA__ARRAY__MEMORY__REQUIREMENTS__v1_135c6c8106451b6313d1dffe9a28af755>) represents the alignment necessary for mapping the CUDA array.

**See also:**

[cuMipmappedArrayGetMemoryRequirements](<group__CUDA__MEM.html#group__CUDA__MEM_1g71b95168dd78c64cbca5b32b9cbf37e1> "Returns the memory requirements of a CUDA mipmapped array."), [cuMemMapArrayAsync](<group__CUDA__VA.html#group__CUDA__VA_1g5dc41a62a9feb68f2e943b438c83e5ab> "Maps or unmaps subregions of sparse CUDA arrays and sparse CUDA mipmapped arrays.")

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuArrayGetPlane ( [CUarray](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gd550651524a56766b60f10f0e7628042>)*Â pPlaneArray, [CUarray](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gd550651524a56766b60f10f0e7628042>)Â hArray, unsigned int Â planeIdx )


Gets a CUDA array plane from a CUDA array.

######  Parameters

`pPlaneArray`
    \- Returned CUDA array referenced by the `planeIdx`
`hArray`
    \- Multiplanar CUDA array
`planeIdx`
    \- Plane index

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_DEINITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9acf52f132faf29b473cdda6061f0f44a>), [CUDA_ERROR_NOT_INITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e98feb999f0af99b4a25ab26b3866f4df8>), [CUDA_ERROR_INVALID_CONTEXT](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a484e9af32c1e9893ff21f0e0191a12d>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>), [CUDA_ERROR_INVALID_HANDLE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e90fd2e63260c6317ba943af0f7e4b8d21>)

###### Description

Returns in `pPlaneArray` a CUDA array that represents a single format plane of the CUDA array `hArray`.

If `planeIdx` is greater than the maximum number of planes in this array or if the array does not have a multi-planar format e.g: [CU_AD_FORMAT_NV12](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg9b009d9a6aa4c5765c8a00289b6068f964889c93ccc518395eb985203735d40c>), then [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>) is returned.

Note that if the `hArray` has format [CU_AD_FORMAT_NV12](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg9b009d9a6aa4c5765c8a00289b6068f964889c93ccc518395eb985203735d40c>), then passing in 0 for `planeIdx` returns a CUDA array of the same size as `hArray` but with one channel and [CU_AD_FORMAT_UNSIGNED_INT8](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg9b009d9a6aa4c5765c8a00289b6068f9e0af5f5a0ffa8e16a5c720364ccd5dac>) as its format. If 1 is passed for `planeIdx`, then the returned CUDA array has half the height and width of `hArray` with two channels and [CU_AD_FORMAT_UNSIGNED_INT8](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg9b009d9a6aa4c5765c8a00289b6068f9e0af5f5a0ffa8e16a5c720364ccd5dac>) as its format.

Note:

Note that this function may also return error codes from previous, asynchronous launches.

**See also:**

[cuArrayCreate](<group__CUDA__MEM.html#group__CUDA__MEM_1g4192ff387a81c3bd5ed8c391ed62ca24> "Creates a 1D or 2D CUDA array."), [cudaArrayGetPlane](<../cuda-runtime-api/group__CUDART__MEMORY.html#group__CUDART__MEMORY_1g9a851663a2b9f222b549c727adc0e079>)

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuArrayGetSparseProperties ( [CUDA_ARRAY_SPARSE_PROPERTIES](<structCUDA__ARRAY__SPARSE__PROPERTIES__v1.html#structCUDA__ARRAY__SPARSE__PROPERTIES__v1>)*Â sparseProperties, [CUarray](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gd550651524a56766b60f10f0e7628042>)Â array )


Returns the layout properties of a sparse CUDA array.

######  Parameters

`sparseProperties`
    \- Pointer to CUDA_ARRAY_SPARSE_PROPERTIES
`array`
    \- CUDA array to get the sparse properties of

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>)[CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>)

###### Description

Returns the layout properties of a sparse CUDA array in `sparseProperties` If the CUDA array is not allocated with flag [CUDA_ARRAY3D_SPARSE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g8e13c9d3ef98d1f3dce95901a115abc2>)[CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>) will be returned.

If the returned value in [CUDA_ARRAY_SPARSE_PROPERTIES::flags](<structCUDA__ARRAY__SPARSE__PROPERTIES__v1.html#structCUDA__ARRAY__SPARSE__PROPERTIES__v1_10e842bb64091fa47809112c700cb5f0a>) contains [CU_ARRAY_SPARSE_PROPERTIES_SINGLE_MIPTAIL](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g0dcf4ba7e64caa5c1aa4e88caa7f659a>), then [CUDA_ARRAY_SPARSE_PROPERTIES::miptailSize](<structCUDA__ARRAY__SPARSE__PROPERTIES__v1.html#structCUDA__ARRAY__SPARSE__PROPERTIES__v1_1895ecb42681678271b0edba05bf1dcd9>) represents the total size of the array. Otherwise, it will be zero. Also, the returned value in [CUDA_ARRAY_SPARSE_PROPERTIES::miptailFirstLevel](<structCUDA__ARRAY__SPARSE__PROPERTIES__v1.html#structCUDA__ARRAY__SPARSE__PROPERTIES__v1_1edd0cca8fad1fcbb1789d537edd7e6b6>) is always zero. Note that the `array` must have been allocated using [cuArrayCreate](<group__CUDA__MEM.html#group__CUDA__MEM_1g4192ff387a81c3bd5ed8c391ed62ca24> "Creates a 1D or 2D CUDA array.") or [cuArray3DCreate](<group__CUDA__MEM.html#group__CUDA__MEM_1gc2322c70b38c2984536c90ed118bb1d7> "Creates a 3D CUDA array."). For CUDA arrays obtained using [cuMipmappedArrayGetLevel](<group__CUDA__MEM.html#group__CUDA__MEM_1g82f276659f05be14820e99346b0f86b7> "Gets a mipmap level of a CUDA mipmapped array."), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>) will be returned. Instead, [cuMipmappedArrayGetSparseProperties](<group__CUDA__MEM.html#group__CUDA__MEM_1g55a16bd1780acb3cc94e8b88d5fe5e19> "Returns the layout properties of a sparse CUDA mipmapped array.") must be used to obtain the sparse properties of the entire CUDA mipmapped array to which `array` belongs to.

**See also:**

[cuMipmappedArrayGetSparseProperties](<group__CUDA__MEM.html#group__CUDA__MEM_1g55a16bd1780acb3cc94e8b88d5fe5e19> "Returns the layout properties of a sparse CUDA mipmapped array."), [cuMemMapArrayAsync](<group__CUDA__VA.html#group__CUDA__VA_1g5dc41a62a9feb68f2e943b438c83e5ab> "Maps or unmaps subregions of sparse CUDA arrays and sparse CUDA mipmapped arrays.")

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuDeviceGetByPCIBusId ( [CUdevice](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g41ca2a24a242b36ef2ca77330b5fb72a>)*Â dev, const char*Â pciBusId )


Returns a handle to a compute device.

######  Parameters

`dev`
    \- Returned device handle
`pciBusId`
    \- String in one of the following forms: [domain]:[bus]:[device].[function] [domain]:[bus]:[device] [bus]:[device].[function] where `domain`, `bus`, `device`, and `function` are all hexadecimal values

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_DEINITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9acf52f132faf29b473cdda6061f0f44a>), [CUDA_ERROR_NOT_INITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e98feb999f0af99b4a25ab26b3866f4df8>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>), [CUDA_ERROR_INVALID_DEVICE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e96f047e7215788ca96c81af92a04bfb6c>)

###### Description

Returns in `*device` a device handle given a PCI bus ID string.

Note:

Note that this function may also return error codes from previous, asynchronous launches.

**See also:**

[cuDeviceGet](<group__CUDA__DEVICE.html#group__CUDA__DEVICE_1g8bdd1cc7201304b01357b8034f6587cb> "Returns a handle to a compute device."), [cuDeviceGetAttribute](<group__CUDA__DEVICE.html#group__CUDA__DEVICE_1g9c3e1414f0ad901d3278a4d6645fc266> "Returns information about the device."), [cuDeviceGetPCIBusId](<group__CUDA__MEM.html#group__CUDA__MEM_1g85295e7d9745ab8f0aa80dd1e172acfc> "Returns a PCI Bus Id string for the device."), [cudaDeviceGetByPCIBusId](<../cuda-runtime-api/group__CUDART__DEVICE.html#group__CUDART__DEVICE_1g65f57fb8d0981ca03f6f9b20031c3e5d>)

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuDeviceGetPCIBusId ( char*Â pciBusId, int Â len, [CUdevice](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g41ca2a24a242b36ef2ca77330b5fb72a>)Â dev )


Returns a PCI Bus Id string for the device.

######  Parameters

`pciBusId`
    \- Returned identifier string for the device in the following format [domain]:[bus]:[device].[function] where `domain`, `bus`, `device`, and `function` are all hexadecimal values. pciBusId should be large enough to store 13 characters including the NULL-terminator.
`len`
    \- Maximum length of string to store in `name`
`dev`
    \- Device to get identifier string for

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_DEINITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9acf52f132faf29b473cdda6061f0f44a>), [CUDA_ERROR_NOT_INITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e98feb999f0af99b4a25ab26b3866f4df8>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>), [CUDA_ERROR_INVALID_DEVICE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e96f047e7215788ca96c81af92a04bfb6c>)

###### Description

Returns an ASCII string identifying the device `dev` in the NULL-terminated string pointed to by `pciBusId`. `len` specifies the maximum length of the string that may be returned.

Note:

Note that this function may also return error codes from previous, asynchronous launches.

**See also:**

[cuDeviceGet](<group__CUDA__DEVICE.html#group__CUDA__DEVICE_1g8bdd1cc7201304b01357b8034f6587cb> "Returns a handle to a compute device."), [cuDeviceGetAttribute](<group__CUDA__DEVICE.html#group__CUDA__DEVICE_1g9c3e1414f0ad901d3278a4d6645fc266> "Returns information about the device."), [cuDeviceGetByPCIBusId](<group__CUDA__MEM.html#group__CUDA__MEM_1ga89cd3fa06334ba7853ed1232c5ebe2a> "Returns a handle to a compute device."), [cudaDeviceGetPCIBusId](<../cuda-runtime-api/group__CUDART__DEVICE.html#group__CUDART__DEVICE_1gea264dad3d8c4898e0b82213c0253def>)

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuDeviceRegisterAsyncNotification ( [CUdevice](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g41ca2a24a242b36ef2ca77330b5fb72a>)Â device, [CUasyncCallback](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g466d4731f270b66441a355ddb2c84777>)Â callbackFunc, void*Â userData, [CUasyncCallbackHandle](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g0ff5c3d4645d51b02b6d11b8b0c228c5>)*Â callback )


Registers a callback function to receive async notifications.

######  Parameters

`device`
    \- The device on which to register the callback
`callbackFunc`
    \- The function to register as a callback
`userData`
    \- A generic pointer to user data. This is passed into the callback function.
`callback`
    \- A handle representing the registered callback instance

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_NOT_SUPPORTED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e954756ae7ade0dfd09faeccb513dd831b>), [CUDA_ERROR_INVALID_DEVICE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e96f047e7215788ca96c81af92a04bfb6c>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>), [CUDA_ERROR_NOT_PERMITTED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9e23d0197c490ec332a43e55b167968a3>), [CUDA_ERROR_UNKNOWN](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9c5a6ab0245179d297f1fa56ed0097183>)

###### Description

Registers `callbackFunc` to receive async notifications.

The `userData` parameter is passed to the callback function at async notification time. Likewise, `callback` is also passed to the callback function to distinguish between multiple registered callbacks.

The callback function being registered should be designed to return quickly (~10ms). Any long running tasks should be queued for execution on an application thread.

Callbacks may not call cuDeviceRegisterAsyncNotification or cuDeviceUnregisterAsyncNotification. Doing so will result in [CUDA_ERROR_NOT_PERMITTED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9e23d0197c490ec332a43e55b167968a3>). Async notification callbacks execute in an undefined order and may be serialized.

Returns in `*callback` a handle representing the registered callback instance.

Note:

Note that this function may also return error codes from previous, asynchronous launches.

**See also:**

[cuDeviceUnregisterAsyncNotification](<group__CUDA__MEM.html#group__CUDA__MEM_1gc0ae698fd18cbc2c395c9140e28e83ca> "Unregisters an async notification callback.")

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuDeviceUnregisterAsyncNotification ( [CUdevice](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g41ca2a24a242b36ef2ca77330b5fb72a>)Â device, [CUasyncCallbackHandle](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g0ff5c3d4645d51b02b6d11b8b0c228c5>)Â callback )


Unregisters an async notification callback.

######  Parameters

`device`
    \- The device from which to remove `callback`.
`callback`
    \- The callback instance to unregister from receiving async notifications.

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_NOT_SUPPORTED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e954756ae7ade0dfd09faeccb513dd831b>), [CUDA_ERROR_INVALID_DEVICE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e96f047e7215788ca96c81af92a04bfb6c>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>), [CUDA_ERROR_NOT_PERMITTED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9e23d0197c490ec332a43e55b167968a3>), [CUDA_ERROR_UNKNOWN](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9c5a6ab0245179d297f1fa56ed0097183>)

###### Description

Unregisters `callback` so that the corresponding callback function will stop receiving async notifications.

Note:

Note that this function may also return error codes from previous, asynchronous launches.

**See also:**

[cuDeviceRegisterAsyncNotification](<group__CUDA__MEM.html#group__CUDA__MEM_1g4325f3e53f7817c93b37f12da91ed199> "Registers a callback function to receive async notifications.")

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuIpcCloseMemHandle ( [CUdeviceptr](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g183f7b0d8ad008ea2a5fd552537ace4e>)Â dptr )


Attempts to close memory mapped with cuIpcOpenMemHandle.

######  Parameters

`dptr`
    \- Device pointer returned by [cuIpcOpenMemHandle](<group__CUDA__MEM.html#group__CUDA__MEM_1ga8bd126fcff919a0c996b7640f197b79> "Opens an interprocess memory handle exported from another process and returns a device pointer usable in the local process.")

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_INVALID_CONTEXT](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a484e9af32c1e9893ff21f0e0191a12d>), [CUDA_ERROR_MAP_FAILED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9b9a95891afee8e479ca2e89595b51a2f>), [CUDA_ERROR_INVALID_HANDLE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e90fd2e63260c6317ba943af0f7e4b8d21>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>)

###### Description

Decrements the reference count of the memory returned by [cuIpcOpenMemHandle](<group__CUDA__MEM.html#group__CUDA__MEM_1ga8bd126fcff919a0c996b7640f197b79> "Opens an interprocess memory handle exported from another process and returns a device pointer usable in the local process.") by 1. When the reference count reaches 0, this API unmaps the memory. The original allocation in the exporting process as well as imported mappings in other processes will be unaffected.

Any resources used to enable peer access will be freed if this is the last mapping using them.

IPC functionality is restricted to devices with support for unified addressing on Linux and Windows operating systems. IPC functionality on Windows is supported for compatibility purposes but not recommended as it comes with performance cost. Users can test their device for IPC functionality by calling cuapiDeviceGetAttribute with [CU_DEVICE_ATTRIBUTE_IPC_EVENT_SUPPORTED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gge12b8a782bebe21b1ac0091bf9f4e2a3348f3c29378467df5114e2e738c4b380>)

**See also:**

[cuMemAlloc](<group__CUDA__MEM.html#group__CUDA__MEM_1gb82d2a09844a58dd9e744dc31e8aa467> "Allocates device memory."), [cuMemFree](<group__CUDA__MEM.html#group__CUDA__MEM_1g89b3f154e17cc89b6eea277dbdf5c93a> "Frees device memory."), [cuIpcGetEventHandle](<group__CUDA__MEM.html#group__CUDA__MEM_1gea02eadd12483de5305878b13288a86c> "Gets an interprocess handle for a previously allocated event."), [cuIpcOpenEventHandle](<group__CUDA__MEM.html#group__CUDA__MEM_1gf1d525918b6c643b99ca8c8e42e36c2e> "Opens an interprocess event handle for use in the current process."), [cuIpcGetMemHandle](<group__CUDA__MEM.html#group__CUDA__MEM_1g6f1b5be767b275f016523b2ac49ebec1> "Gets an interprocess memory handle for an existing device memory allocation."), [cuIpcOpenMemHandle](<group__CUDA__MEM.html#group__CUDA__MEM_1ga8bd126fcff919a0c996b7640f197b79> "Opens an interprocess memory handle exported from another process and returns a device pointer usable in the local process."), [cudaIpcCloseMemHandle](<../cuda-runtime-api/group__CUDART__DEVICE.html#group__CUDART__DEVICE_1g02bb3632b5d223db6acae5f8744e2c91>)

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuIpcGetEventHandle ( [CUipcEventHandle](<structCUipcEventHandle__v1.html#structCUipcEventHandle__v1>)*Â pHandle, [CUevent](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g6d740185cf0953636d4ae37f68d7559b>)Â event )


Gets an interprocess handle for a previously allocated event.

######  Parameters

`pHandle`
    \- Pointer to a user allocated CUipcEventHandle in which to return the opaque event handle
`event`
    \- Event allocated with [CU_EVENT_INTERPROCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg5ae04079c671c8e659a3a27c7b23f629adab662356d24cf59f3d7de07c3cd52e>) and [CU_EVENT_DISABLE_TIMING](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg5ae04079c671c8e659a3a27c7b23f629daa5463f64794c10b78c603d23c0bff2>) flags.

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_INVALID_HANDLE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e90fd2e63260c6317ba943af0f7e4b8d21>), [CUDA_ERROR_OUT_OF_MEMORY](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9264c50688ed110e8476b591befe60c02>), [CUDA_ERROR_MAP_FAILED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9b9a95891afee8e479ca2e89595b51a2f>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>)

###### Description

Takes as input a previously allocated event. This event must have been created with the [CU_EVENT_INTERPROCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg5ae04079c671c8e659a3a27c7b23f629adab662356d24cf59f3d7de07c3cd52e>) and [CU_EVENT_DISABLE_TIMING](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg5ae04079c671c8e659a3a27c7b23f629daa5463f64794c10b78c603d23c0bff2>) flags set. This opaque handle may be copied into other processes and opened with [cuIpcOpenEventHandle](<group__CUDA__MEM.html#group__CUDA__MEM_1gf1d525918b6c643b99ca8c8e42e36c2e> "Opens an interprocess event handle for use in the current process.") to allow efficient hardware synchronization between GPU work in different processes.

After the event has been opened in the importing process, [cuEventRecord](<group__CUDA__EVENT.html#group__CUDA__EVENT_1g95424d3be52c4eb95d83861b70fb89d1> "Records an event."), [cuEventSynchronize](<group__CUDA__EVENT.html#group__CUDA__EVENT_1g9e520d34e51af7f5375610bca4add99c> "Waits for an event to complete."), [cuStreamWaitEvent](<group__CUDA__STREAM.html#group__CUDA__STREAM_1g6a898b652dfc6aa1d5c8d97062618b2f> "Make a compute stream wait on an event.") and [cuEventQuery](<group__CUDA__EVENT.html#group__CUDA__EVENT_1g6f0704d755066b0ee705749ae911deef> "Queries an event's status.") may be used in either process. Performing operations on the imported event after the exported event has been freed with [cuEventDestroy](<group__CUDA__EVENT.html#group__CUDA__EVENT_1g593ec73a8ec5a5fc031311d3e4dca1ef> "Destroys an event.") will result in undefined behavior.

IPC functionality is restricted to devices with support for unified addressing on Linux and Windows operating systems. IPC functionality on Windows is supported for compatibility purposes but not recommended as it comes with performance cost. Users can test their device for IPC functionality by calling [cuDeviceGetAttribute](<group__CUDA__DEVICE.html#group__CUDA__DEVICE_1g9c3e1414f0ad901d3278a4d6645fc266> "Returns information about the device.") with [CU_DEVICE_ATTRIBUTE_IPC_EVENT_SUPPORTED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gge12b8a782bebe21b1ac0091bf9f4e2a3348f3c29378467df5114e2e738c4b380>)

**See also:**

[cuEventCreate](<group__CUDA__EVENT.html#group__CUDA__EVENT_1g450687e75f3ff992fe01662a43d9d3db> "Creates an event."), [cuEventDestroy](<group__CUDA__EVENT.html#group__CUDA__EVENT_1g593ec73a8ec5a5fc031311d3e4dca1ef> "Destroys an event."), [cuEventSynchronize](<group__CUDA__EVENT.html#group__CUDA__EVENT_1g9e520d34e51af7f5375610bca4add99c> "Waits for an event to complete."), [cuEventQuery](<group__CUDA__EVENT.html#group__CUDA__EVENT_1g6f0704d755066b0ee705749ae911deef> "Queries an event's status."), [cuStreamWaitEvent](<group__CUDA__STREAM.html#group__CUDA__STREAM_1g6a898b652dfc6aa1d5c8d97062618b2f> "Make a compute stream wait on an event."), [cuIpcOpenEventHandle](<group__CUDA__MEM.html#group__CUDA__MEM_1gf1d525918b6c643b99ca8c8e42e36c2e> "Opens an interprocess event handle for use in the current process."), [cuIpcGetMemHandle](<group__CUDA__MEM.html#group__CUDA__MEM_1g6f1b5be767b275f016523b2ac49ebec1> "Gets an interprocess memory handle for an existing device memory allocation."), [cuIpcOpenMemHandle](<group__CUDA__MEM.html#group__CUDA__MEM_1ga8bd126fcff919a0c996b7640f197b79> "Opens an interprocess memory handle exported from another process and returns a device pointer usable in the local process."), [cuIpcCloseMemHandle](<group__CUDA__MEM.html#group__CUDA__MEM_1gd6f5d5bcf6376c6853b64635b0157b9e> "Attempts to close memory mapped with cuIpcOpenMemHandle."), [cudaIpcGetEventHandle](<../cuda-runtime-api/group__CUDART__DEVICE.html#group__CUDART__DEVICE_1g89a3abe1e9a11d08c665176669109784>)

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuIpcGetMemHandle ( [CUipcMemHandle](<structCUipcMemHandle__v1.html#structCUipcMemHandle__v1>)*Â pHandle, [CUdeviceptr](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g183f7b0d8ad008ea2a5fd552537ace4e>)Â dptr )


Gets an interprocess memory handle for an existing device memory allocation.

######  Parameters

`pHandle`
    \- Pointer to user allocated CUipcMemHandle to return the handle in.
`dptr`
    \- Base pointer to previously allocated device memory

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_INVALID_HANDLE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e90fd2e63260c6317ba943af0f7e4b8d21>), [CUDA_ERROR_INVALID_CONTEXT](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a484e9af32c1e9893ff21f0e0191a12d>), [CUDA_ERROR_OUT_OF_MEMORY](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9264c50688ed110e8476b591befe60c02>), [CUDA_ERROR_MAP_FAILED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9b9a95891afee8e479ca2e89595b51a2f>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>)

###### Description

Takes a pointer to the base of an existing device memory allocation created with [cuMemAlloc](<group__CUDA__MEM.html#group__CUDA__MEM_1gb82d2a09844a58dd9e744dc31e8aa467> "Allocates device memory.") and exports it for use in another process. This is a lightweight operation and may be called multiple times on an allocation without adverse effects.

If a region of memory is freed with [cuMemFree](<group__CUDA__MEM.html#group__CUDA__MEM_1g89b3f154e17cc89b6eea277dbdf5c93a> "Frees device memory.") and a subsequent call to [cuMemAlloc](<group__CUDA__MEM.html#group__CUDA__MEM_1gb82d2a09844a58dd9e744dc31e8aa467> "Allocates device memory.") returns memory with the same device address, [cuIpcGetMemHandle](<group__CUDA__MEM.html#group__CUDA__MEM_1g6f1b5be767b275f016523b2ac49ebec1> "Gets an interprocess memory handle for an existing device memory allocation.") will return a unique handle for the new memory.

IPC functionality is restricted to devices with support for unified addressing on Linux and Windows operating systems. IPC functionality on Windows is supported for compatibility purposes but not recommended as it comes with performance cost. Users can test their device for IPC functionality by calling cuapiDeviceGetAttribute with [CU_DEVICE_ATTRIBUTE_IPC_EVENT_SUPPORTED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gge12b8a782bebe21b1ac0091bf9f4e2a3348f3c29378467df5114e2e738c4b380>)

**See also:**

[cuMemAlloc](<group__CUDA__MEM.html#group__CUDA__MEM_1gb82d2a09844a58dd9e744dc31e8aa467> "Allocates device memory."), [cuMemFree](<group__CUDA__MEM.html#group__CUDA__MEM_1g89b3f154e17cc89b6eea277dbdf5c93a> "Frees device memory."), [cuIpcGetEventHandle](<group__CUDA__MEM.html#group__CUDA__MEM_1gea02eadd12483de5305878b13288a86c> "Gets an interprocess handle for a previously allocated event."), [cuIpcOpenEventHandle](<group__CUDA__MEM.html#group__CUDA__MEM_1gf1d525918b6c643b99ca8c8e42e36c2e> "Opens an interprocess event handle for use in the current process."), [cuIpcOpenMemHandle](<group__CUDA__MEM.html#group__CUDA__MEM_1ga8bd126fcff919a0c996b7640f197b79> "Opens an interprocess memory handle exported from another process and returns a device pointer usable in the local process."), [cuIpcCloseMemHandle](<group__CUDA__MEM.html#group__CUDA__MEM_1gd6f5d5bcf6376c6853b64635b0157b9e> "Attempts to close memory mapped with cuIpcOpenMemHandle."), [cudaIpcGetMemHandle](<../cuda-runtime-api/group__CUDART__DEVICE.html#group__CUDART__DEVICE_1g8a37f7dfafaca652391d0758b3667539>)

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuIpcOpenEventHandle ( [CUevent](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g6d740185cf0953636d4ae37f68d7559b>)*Â phEvent, [CUipcEventHandle](<structCUipcEventHandle__v1.html#structCUipcEventHandle__v1>)Â handle )


Opens an interprocess event handle for use in the current process.

######  Parameters

`phEvent`
    \- Returns the imported event
`handle`
    \- Interprocess handle to open

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_INVALID_CONTEXT](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a484e9af32c1e9893ff21f0e0191a12d>), [CUDA_ERROR_MAP_FAILED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9b9a95891afee8e479ca2e89595b51a2f>), [CUDA_ERROR_PEER_ACCESS_UNSUPPORTED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9d60abcaa3f2710f961db8c383bb95cae>), [CUDA_ERROR_INVALID_HANDLE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e90fd2e63260c6317ba943af0f7e4b8d21>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>)

###### Description

Opens an interprocess event handle exported from another process with [cuIpcGetEventHandle](<group__CUDA__MEM.html#group__CUDA__MEM_1gea02eadd12483de5305878b13288a86c> "Gets an interprocess handle for a previously allocated event."). This function returns a [CUevent](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g6d740185cf0953636d4ae37f68d7559b>) that behaves like a locally created event with the [CU_EVENT_DISABLE_TIMING](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg5ae04079c671c8e659a3a27c7b23f629daa5463f64794c10b78c603d23c0bff2>) flag specified. This event must be freed with [cuEventDestroy](<group__CUDA__EVENT.html#group__CUDA__EVENT_1g593ec73a8ec5a5fc031311d3e4dca1ef> "Destroys an event.").

Performing operations on the imported event after the exported event has been freed with [cuEventDestroy](<group__CUDA__EVENT.html#group__CUDA__EVENT_1g593ec73a8ec5a5fc031311d3e4dca1ef> "Destroys an event.") will result in undefined behavior.

IPC functionality is restricted to devices with support for unified addressing on Linux and Windows operating systems. IPC functionality on Windows is supported for compatibility purposes but not recommended as it comes with performance cost. Users can test their device for IPC functionality by calling cuapiDeviceGetAttribute with [CU_DEVICE_ATTRIBUTE_IPC_EVENT_SUPPORTED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gge12b8a782bebe21b1ac0091bf9f4e2a3348f3c29378467df5114e2e738c4b380>)

**See also:**

[cuEventCreate](<group__CUDA__EVENT.html#group__CUDA__EVENT_1g450687e75f3ff992fe01662a43d9d3db> "Creates an event."), [cuEventDestroy](<group__CUDA__EVENT.html#group__CUDA__EVENT_1g593ec73a8ec5a5fc031311d3e4dca1ef> "Destroys an event."), [cuEventSynchronize](<group__CUDA__EVENT.html#group__CUDA__EVENT_1g9e520d34e51af7f5375610bca4add99c> "Waits for an event to complete."), [cuEventQuery](<group__CUDA__EVENT.html#group__CUDA__EVENT_1g6f0704d755066b0ee705749ae911deef> "Queries an event's status."), [cuStreamWaitEvent](<group__CUDA__STREAM.html#group__CUDA__STREAM_1g6a898b652dfc6aa1d5c8d97062618b2f> "Make a compute stream wait on an event."), [cuIpcGetEventHandle](<group__CUDA__MEM.html#group__CUDA__MEM_1gea02eadd12483de5305878b13288a86c> "Gets an interprocess handle for a previously allocated event."), [cuIpcGetMemHandle](<group__CUDA__MEM.html#group__CUDA__MEM_1g6f1b5be767b275f016523b2ac49ebec1> "Gets an interprocess memory handle for an existing device memory allocation."), [cuIpcOpenMemHandle](<group__CUDA__MEM.html#group__CUDA__MEM_1ga8bd126fcff919a0c996b7640f197b79> "Opens an interprocess memory handle exported from another process and returns a device pointer usable in the local process."), [cuIpcCloseMemHandle](<group__CUDA__MEM.html#group__CUDA__MEM_1gd6f5d5bcf6376c6853b64635b0157b9e> "Attempts to close memory mapped with cuIpcOpenMemHandle."), [cudaIpcOpenEventHandle](<../cuda-runtime-api/group__CUDART__DEVICE.html#group__CUDART__DEVICE_1g9691446ab0aec1d6e528357387ed87b2>)

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuIpcOpenMemHandle ( [CUdeviceptr](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g183f7b0d8ad008ea2a5fd552537ace4e>)*Â pdptr, [CUipcMemHandle](<structCUipcMemHandle__v1.html#structCUipcMemHandle__v1>)Â handle, unsigned int Â Flags )


Opens an interprocess memory handle exported from another process and returns a device pointer usable in the local process.

######  Parameters

`pdptr`
    \- Returned device pointer
`handle`
    \- CUipcMemHandle to open
`Flags`
    \- Flags for this operation. Must be specified as [CU_IPC_MEM_LAZY_ENABLE_PEER_ACCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg871d09eefd2aacd3b10fe4f5f23b1a32567565e36fc87a2180109170a0501947>)

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_INVALID_CONTEXT](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a484e9af32c1e9893ff21f0e0191a12d>), [CUDA_ERROR_MAP_FAILED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9b9a95891afee8e479ca2e89595b51a2f>), [CUDA_ERROR_INVALID_HANDLE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e90fd2e63260c6317ba943af0f7e4b8d21>), [CUDA_ERROR_TOO_MANY_PEERS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9168ef870793a31ef4cdd7cb6e279b34a>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>)

###### Description

Maps memory exported from another process with [cuIpcGetMemHandle](<group__CUDA__MEM.html#group__CUDA__MEM_1g6f1b5be767b275f016523b2ac49ebec1> "Gets an interprocess memory handle for an existing device memory allocation.") into the current device address space. For contexts on different devices [cuIpcOpenMemHandle](<group__CUDA__MEM.html#group__CUDA__MEM_1ga8bd126fcff919a0c996b7640f197b79> "Opens an interprocess memory handle exported from another process and returns a device pointer usable in the local process.") can attempt to enable peer access between the devices as if the user called [cuCtxEnablePeerAccess](<group__CUDA__PEER__ACCESS.html#group__CUDA__PEER__ACCESS_1g0889ec6728e61c05ed359551d67b3f5a> "Enables direct access to memory allocations in a peer context."). This behavior is controlled by the [CU_IPC_MEM_LAZY_ENABLE_PEER_ACCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg871d09eefd2aacd3b10fe4f5f23b1a32567565e36fc87a2180109170a0501947>) flag. [cuDeviceCanAccessPeer](<group__CUDA__PEER__ACCESS.html#group__CUDA__PEER__ACCESS_1g496bdaae1f632ebfb695b99d2c40f19e> "Queries if a device may directly access a peer device's memory.") can determine if a mapping is possible.

Contexts that may open CUipcMemHandles are restricted in the following way. CUipcMemHandles from each [CUdevice](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g41ca2a24a242b36ef2ca77330b5fb72a>) in a given process may only be opened by one [CUcontext](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gf9f5bd81658f866613785b3a0bb7d7d9>) per [CUdevice](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g41ca2a24a242b36ef2ca77330b5fb72a>) per other process.

If the memory handle has already been opened by the current context, the reference count on the handle is incremented by 1 and the existing device pointer is returned.

Memory returned from [cuIpcOpenMemHandle](<group__CUDA__MEM.html#group__CUDA__MEM_1ga8bd126fcff919a0c996b7640f197b79> "Opens an interprocess memory handle exported from another process and returns a device pointer usable in the local process.") must be freed with [cuIpcCloseMemHandle](<group__CUDA__MEM.html#group__CUDA__MEM_1gd6f5d5bcf6376c6853b64635b0157b9e> "Attempts to close memory mapped with cuIpcOpenMemHandle.").

Calling [cuMemFree](<group__CUDA__MEM.html#group__CUDA__MEM_1g89b3f154e17cc89b6eea277dbdf5c93a> "Frees device memory.") on an exported memory region before calling [cuIpcCloseMemHandle](<group__CUDA__MEM.html#group__CUDA__MEM_1gd6f5d5bcf6376c6853b64635b0157b9e> "Attempts to close memory mapped with cuIpcOpenMemHandle.") in the importing context will result in undefined behavior.

IPC functionality is restricted to devices with support for unified addressing on Linux and Windows operating systems. IPC functionality on Windows is supported for compatibility purposes but not recommended as it comes with performance cost. Users can test their device for IPC functionality by calling cuapiDeviceGetAttribute with [CU_DEVICE_ATTRIBUTE_IPC_EVENT_SUPPORTED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gge12b8a782bebe21b1ac0091bf9f4e2a3348f3c29378467df5114e2e738c4b380>)

Note:

No guarantees are made about the address returned in `*pdptr`. In particular, multiple processes may not receive the same address for the same `handle`.

**See also:**

[cuMemAlloc](<group__CUDA__MEM.html#group__CUDA__MEM_1gb82d2a09844a58dd9e744dc31e8aa467> "Allocates device memory."), [cuMemFree](<group__CUDA__MEM.html#group__CUDA__MEM_1g89b3f154e17cc89b6eea277dbdf5c93a> "Frees device memory."), [cuIpcGetEventHandle](<group__CUDA__MEM.html#group__CUDA__MEM_1gea02eadd12483de5305878b13288a86c> "Gets an interprocess handle for a previously allocated event."), [cuIpcOpenEventHandle](<group__CUDA__MEM.html#group__CUDA__MEM_1gf1d525918b6c643b99ca8c8e42e36c2e> "Opens an interprocess event handle for use in the current process."), [cuIpcGetMemHandle](<group__CUDA__MEM.html#group__CUDA__MEM_1g6f1b5be767b275f016523b2ac49ebec1> "Gets an interprocess memory handle for an existing device memory allocation."), [cuIpcCloseMemHandle](<group__CUDA__MEM.html#group__CUDA__MEM_1gd6f5d5bcf6376c6853b64635b0157b9e> "Attempts to close memory mapped with cuIpcOpenMemHandle."), [cuCtxEnablePeerAccess](<group__CUDA__PEER__ACCESS.html#group__CUDA__PEER__ACCESS_1g0889ec6728e61c05ed359551d67b3f5a> "Enables direct access to memory allocations in a peer context."), [cuDeviceCanAccessPeer](<group__CUDA__PEER__ACCESS.html#group__CUDA__PEER__ACCESS_1g496bdaae1f632ebfb695b99d2c40f19e> "Queries if a device may directly access a peer device's memory."), [cudaIpcOpenMemHandle](<../cuda-runtime-api/group__CUDART__DEVICE.html#group__CUDART__DEVICE_1g01050a29fefde385b1042081ada4cde9>)

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuMemAlloc ( [CUdeviceptr](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g183f7b0d8ad008ea2a5fd552537ace4e>)*Â dptr, size_tÂ bytesize )


Allocates device memory.

######  Parameters

`dptr`
    \- Returned device pointer
`bytesize`
    \- Requested allocation size in bytes

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_DEINITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9acf52f132faf29b473cdda6061f0f44a>), [CUDA_ERROR_NOT_INITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e98feb999f0af99b4a25ab26b3866f4df8>), [CUDA_ERROR_INVALID_CONTEXT](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a484e9af32c1e9893ff21f0e0191a12d>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>), [CUDA_ERROR_OUT_OF_MEMORY](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9264c50688ed110e8476b591befe60c02>)

###### Description

Allocates `bytesize` bytes of linear memory on the device and returns in `*dptr` a pointer to the allocated memory. The allocated memory is suitably aligned for any kind of variable. The memory is not cleared. If `bytesize` is 0, [cuMemAlloc()](<group__CUDA__MEM.html#group__CUDA__MEM_1gb82d2a09844a58dd9e744dc31e8aa467> "Allocates device memory.") returns [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>).

Note:

Note that this function may also return error codes from previous, asynchronous launches.

**See also:**

[cuArray3DCreate](<group__CUDA__MEM.html#group__CUDA__MEM_1gc2322c70b38c2984536c90ed118bb1d7> "Creates a 3D CUDA array."), [cuArray3DGetDescriptor](<group__CUDA__MEM.html#group__CUDA__MEM_1gb58549f2f3f390b9e0e7c8f3acd53857> "Get a 3D CUDA array descriptor."), [cuArrayCreate](<group__CUDA__MEM.html#group__CUDA__MEM_1g4192ff387a81c3bd5ed8c391ed62ca24> "Creates a 1D or 2D CUDA array."), [cuArrayDestroy](<group__CUDA__MEM.html#group__CUDA__MEM_1g982878affbbc023de84874faac838b0b> "Destroys a CUDA array."), [cuArrayGetDescriptor](<group__CUDA__MEM.html#group__CUDA__MEM_1g661fe823dbd37bf11f82a71bd4762acf> "Get a 1D or 2D CUDA array descriptor."), [cuMemAllocHost](<group__CUDA__MEM.html#group__CUDA__MEM_1gdd8311286d2c2691605362c689bc64e0> "Allocates page-locked host memory."), [cuMemAllocPitch](<group__CUDA__MEM.html#group__CUDA__MEM_1gcbe9b033f6c4de80f63cc6e58ed9a45a> "Allocates pitched device memory."), [cuMemcpy2D](<group__CUDA__MEM.html#group__CUDA__MEM_1g27f885b30c34cc20a663a671dbf6fc27> "Copies memory for 2D arrays."), [cuMemcpy2DAsync](<group__CUDA__MEM.html#group__CUDA__MEM_1g4acf155faeb969d9d21f5433d3d0f274> "Copies memory for 2D arrays."), [cuMemcpy2DUnaligned](<group__CUDA__MEM.html#group__CUDA__MEM_1g2fa285d47fd7020e596bfeab3deb651b> "Copies memory for 2D arrays."), [cuMemcpy3D](<group__CUDA__MEM.html#group__CUDA__MEM_1g4b5238975579f002c0199a3800ca44df> "Copies memory for 3D arrays."), [cuMemcpy3DAsync](<group__CUDA__MEM.html#group__CUDA__MEM_1g79f4f3fde6ae0f529568d881d9e11987> "Copies memory for 3D arrays."), [cuMemcpyAtoA](<group__CUDA__MEM.html#group__CUDA__MEM_1gf81b218c984a31436ec9e23a85fb604a> "Copies memory from Array to Array."), [cuMemcpyAtoD](<group__CUDA__MEM.html#group__CUDA__MEM_1g825b3f037f7f51382cae991bae8173fd> "Copies memory from Array to Device."), [cuMemcpyAtoH](<group__CUDA__MEM.html#group__CUDA__MEM_1gf7ad1edb2539cccc352c6b8b76f657f4> "Copies memory from Array to Host."), [cuMemcpyAtoHAsync](<group__CUDA__MEM.html#group__CUDA__MEM_1g64cbd2e60436699aebdd0bdbf14d0f01> "Copies memory from Array to Host."), [cuMemcpyDtoA](<group__CUDA__MEM.html#group__CUDA__MEM_1gad6827247af91600b56ce6e2ddb802e1> "Copies memory from Device to Array."), [cuMemcpyDtoD](<group__CUDA__MEM.html#group__CUDA__MEM_1g1725774abf8b51b91945f3336b778c8b> "Copies memory from Device to Device."), [cuMemcpyDtoDAsync](<group__CUDA__MEM.html#group__CUDA__MEM_1g39ea09ba682b8eccc9c3e0c04319b5c8> "Copies memory from Device to Device."), [cuMemcpyDtoH](<group__CUDA__MEM.html#group__CUDA__MEM_1g3480368ee0208a98f75019c9a8450893> "Copies memory from Device to Host."), [cuMemcpyDtoHAsync](<group__CUDA__MEM.html#group__CUDA__MEM_1g56f30236c7c5247f8e061b59d3268362> "Copies memory from Device to Host."), [cuMemcpyHtoA](<group__CUDA__MEM.html#group__CUDA__MEM_1g57d3d780d165ecc0e3b3ce08e141cd89> "Copies memory from Host to Array."), [cuMemcpyHtoAAsync](<group__CUDA__MEM.html#group__CUDA__MEM_1gb5c4863f64f132b4bc2661818b3fd188> "Copies memory from Host to Array."), [cuMemcpyHtoD](<group__CUDA__MEM.html#group__CUDA__MEM_1g4d32266788c440b0220b1a9ba5795169> "Copies memory from Host to Device."), [cuMemcpyHtoDAsync](<group__CUDA__MEM.html#group__CUDA__MEM_1g1572263fe2597d7ba4f6964597a354a3> "Copies memory from Host to Device."), [cuMemFree](<group__CUDA__MEM.html#group__CUDA__MEM_1g89b3f154e17cc89b6eea277dbdf5c93a> "Frees device memory."), [cuMemFreeHost](<group__CUDA__MEM.html#group__CUDA__MEM_1g62e0fdbe181dab6b1c90fa1a51c7b92c> "Frees page-locked host memory."), [cuMemGetAddressRange](<group__CUDA__MEM.html#group__CUDA__MEM_1g64fee5711274a2a0573a789c94d8299b> "Get information on memory allocations."), [cuMemGetInfo](<group__CUDA__MEM.html#group__CUDA__MEM_1g808f555540d0143a331cc42aa98835c0> "Gets free and total memory."), [cuMemHostAlloc](<group__CUDA__MEM.html#group__CUDA__MEM_1g572ca4011bfcb25034888a14d4e035b9> "Allocates page-locked host memory."), [cuMemHostGetDevicePointer](<group__CUDA__MEM.html#group__CUDA__MEM_1g57a39e5cba26af4d06be67fc77cc62f0> "Passes back device pointer of mapped pinned memory."), [cuMemsetD2D8](<group__CUDA__MEM.html#group__CUDA__MEM_1ge88b13e646e2be6ba0e0475ef5205974> "Initializes device memory."), [cuMemsetD2D16](<group__CUDA__MEM.html#group__CUDA__MEM_1g7f561a15a66144fa9f6ab5350edc8a30> "Initializes device memory."), [cuMemsetD2D32](<group__CUDA__MEM.html#group__CUDA__MEM_1g74b359b2d026bfeb7c795b5038d07523> "Initializes device memory."), [cuMemsetD8](<group__CUDA__MEM.html#group__CUDA__MEM_1g6e582bf866e9e2fb014297bfaf354d7b> "Initializes device memory."), [cuMemsetD16](<group__CUDA__MEM.html#group__CUDA__MEM_1g7d805e610054392a4d11e8a8bf5eb35c> "Initializes device memory."), [cuMemsetD32](<group__CUDA__MEM.html#group__CUDA__MEM_1g983e8d8759acd1b64326317481fbf132> "Initializes device memory."), [cudaMalloc](<../cuda-runtime-api/group__CUDART__MEMORY.html#group__CUDART__MEMORY_1g37d37965bfb4803b6d4e59ff26856356>)

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuMemAllocHost ( void**Â pp, size_tÂ bytesize )


Allocates page-locked host memory.

######  Parameters

`pp`
    \- Returned pointer to host memory
`bytesize`
    \- Requested allocation size in bytes

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_DEINITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9acf52f132faf29b473cdda6061f0f44a>), [CUDA_ERROR_NOT_INITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e98feb999f0af99b4a25ab26b3866f4df8>), [CUDA_ERROR_INVALID_CONTEXT](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a484e9af32c1e9893ff21f0e0191a12d>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>), [CUDA_ERROR_OUT_OF_MEMORY](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9264c50688ed110e8476b591befe60c02>)

###### Description

Allocates `bytesize` bytes of host memory that is page-locked and accessible to the device. The driver tracks the virtual memory ranges allocated with this function and automatically accelerates calls to functions such as [cuMemcpy()](<group__CUDA__MEM.html#group__CUDA__MEM_1g8d0ff510f26d4b87bd3a51e731e7f698> "Copies memory."). Since the memory can be accessed directly by the device, it can be read or written with much higher bandwidth than pageable memory obtained with functions such as malloc().

On systems where [CU_DEVICE_ATTRIBUTE_PAGEABLE_MEMORY_ACCESS_USES_HOST_PAGE_TABLES](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gge12b8a782bebe21b1ac0091bf9f4e2a352c58d6fd1d3a72673cce199ab30cd40>) is true, [cuMemAllocHost](<group__CUDA__MEM.html#group__CUDA__MEM_1gdd8311286d2c2691605362c689bc64e0> "Allocates page-locked host memory.") may not page-lock the allocated memory.

Page-locking excessive amounts of memory with [cuMemAllocHost()](<group__CUDA__MEM.html#group__CUDA__MEM_1gdd8311286d2c2691605362c689bc64e0> "Allocates page-locked host memory.") may degrade system performance, since it reduces the amount of memory available to the system for paging. As a result, this function is best used sparingly to allocate staging areas for data exchange between host and device.

Note all host memory allocated using [cuMemAllocHost()](<group__CUDA__MEM.html#group__CUDA__MEM_1gdd8311286d2c2691605362c689bc64e0> "Allocates page-locked host memory.") will automatically be immediately accessible to all contexts on all devices which support unified addressing (as may be queried using [CU_DEVICE_ATTRIBUTE_UNIFIED_ADDRESSING](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gge12b8a782bebe21b1ac0091bf9f4e2a3dc11dd6d9f149a7bae32499f2b802c0d>)). The device pointer that may be used to access this host memory from those contexts is always equal to the returned host pointer `*pp`. See [Unified Addressing](<group__CUDA__UNIFIED.html#group__CUDA__UNIFIED>) for additional details.

Note:

Note that this function may also return error codes from previous, asynchronous launches.

**See also:**

[cuArray3DCreate](<group__CUDA__MEM.html#group__CUDA__MEM_1gc2322c70b38c2984536c90ed118bb1d7> "Creates a 3D CUDA array."), [cuArray3DGetDescriptor](<group__CUDA__MEM.html#group__CUDA__MEM_1gb58549f2f3f390b9e0e7c8f3acd53857> "Get a 3D CUDA array descriptor."), [cuArrayCreate](<group__CUDA__MEM.html#group__CUDA__MEM_1g4192ff387a81c3bd5ed8c391ed62ca24> "Creates a 1D or 2D CUDA array."), [cuArrayDestroy](<group__CUDA__MEM.html#group__CUDA__MEM_1g982878affbbc023de84874faac838b0b> "Destroys a CUDA array."), [cuArrayGetDescriptor](<group__CUDA__MEM.html#group__CUDA__MEM_1g661fe823dbd37bf11f82a71bd4762acf> "Get a 1D or 2D CUDA array descriptor."), [cuMemAlloc](<group__CUDA__MEM.html#group__CUDA__MEM_1gb82d2a09844a58dd9e744dc31e8aa467> "Allocates device memory."), [cuMemAllocPitch](<group__CUDA__MEM.html#group__CUDA__MEM_1gcbe9b033f6c4de80f63cc6e58ed9a45a> "Allocates pitched device memory."), [cuMemcpy2D](<group__CUDA__MEM.html#group__CUDA__MEM_1g27f885b30c34cc20a663a671dbf6fc27> "Copies memory for 2D arrays."), [cuMemcpy2DAsync](<group__CUDA__MEM.html#group__CUDA__MEM_1g4acf155faeb969d9d21f5433d3d0f274> "Copies memory for 2D arrays."), [cuMemcpy2DUnaligned](<group__CUDA__MEM.html#group__CUDA__MEM_1g2fa285d47fd7020e596bfeab3deb651b> "Copies memory for 2D arrays."), [cuMemcpy3D](<group__CUDA__MEM.html#group__CUDA__MEM_1g4b5238975579f002c0199a3800ca44df> "Copies memory for 3D arrays."), [cuMemcpy3DAsync](<group__CUDA__MEM.html#group__CUDA__MEM_1g79f4f3fde6ae0f529568d881d9e11987> "Copies memory for 3D arrays."), [cuMemcpyAtoA](<group__CUDA__MEM.html#group__CUDA__MEM_1gf81b218c984a31436ec9e23a85fb604a> "Copies memory from Array to Array."), [cuMemcpyAtoD](<group__CUDA__MEM.html#group__CUDA__MEM_1g825b3f037f7f51382cae991bae8173fd> "Copies memory from Array to Device."), [cuMemcpyAtoH](<group__CUDA__MEM.html#group__CUDA__MEM_1gf7ad1edb2539cccc352c6b8b76f657f4> "Copies memory from Array to Host."), [cuMemcpyAtoHAsync](<group__CUDA__MEM.html#group__CUDA__MEM_1g64cbd2e60436699aebdd0bdbf14d0f01> "Copies memory from Array to Host."), [cuMemcpyDtoA](<group__CUDA__MEM.html#group__CUDA__MEM_1gad6827247af91600b56ce6e2ddb802e1> "Copies memory from Device to Array."), [cuMemcpyDtoD](<group__CUDA__MEM.html#group__CUDA__MEM_1g1725774abf8b51b91945f3336b778c8b> "Copies memory from Device to Device."), [cuMemcpyDtoDAsync](<group__CUDA__MEM.html#group__CUDA__MEM_1g39ea09ba682b8eccc9c3e0c04319b5c8> "Copies memory from Device to Device."), [cuMemcpyDtoH](<group__CUDA__MEM.html#group__CUDA__MEM_1g3480368ee0208a98f75019c9a8450893> "Copies memory from Device to Host."), [cuMemcpyDtoHAsync](<group__CUDA__MEM.html#group__CUDA__MEM_1g56f30236c7c5247f8e061b59d3268362> "Copies memory from Device to Host."), [cuMemcpyHtoA](<group__CUDA__MEM.html#group__CUDA__MEM_1g57d3d780d165ecc0e3b3ce08e141cd89> "Copies memory from Host to Array."), [cuMemcpyHtoAAsync](<group__CUDA__MEM.html#group__CUDA__MEM_1gb5c4863f64f132b4bc2661818b3fd188> "Copies memory from Host to Array."), [cuMemcpyHtoD](<group__CUDA__MEM.html#group__CUDA__MEM_1g4d32266788c440b0220b1a9ba5795169> "Copies memory from Host to Device."), [cuMemcpyHtoDAsync](<group__CUDA__MEM.html#group__CUDA__MEM_1g1572263fe2597d7ba4f6964597a354a3> "Copies memory from Host to Device."), [cuMemFree](<group__CUDA__MEM.html#group__CUDA__MEM_1g89b3f154e17cc89b6eea277dbdf5c93a> "Frees device memory."), [cuMemFreeHost](<group__CUDA__MEM.html#group__CUDA__MEM_1g62e0fdbe181dab6b1c90fa1a51c7b92c> "Frees page-locked host memory."), [cuMemGetAddressRange](<group__CUDA__MEM.html#group__CUDA__MEM_1g64fee5711274a2a0573a789c94d8299b> "Get information on memory allocations."), [cuMemGetInfo](<group__CUDA__MEM.html#group__CUDA__MEM_1g808f555540d0143a331cc42aa98835c0> "Gets free and total memory."), [cuMemHostAlloc](<group__CUDA__MEM.html#group__CUDA__MEM_1g572ca4011bfcb25034888a14d4e035b9> "Allocates page-locked host memory."), [cuMemHostGetDevicePointer](<group__CUDA__MEM.html#group__CUDA__MEM_1g57a39e5cba26af4d06be67fc77cc62f0> "Passes back device pointer of mapped pinned memory."), [cuMemsetD2D8](<group__CUDA__MEM.html#group__CUDA__MEM_1ge88b13e646e2be6ba0e0475ef5205974> "Initializes device memory."), [cuMemsetD2D16](<group__CUDA__MEM.html#group__CUDA__MEM_1g7f561a15a66144fa9f6ab5350edc8a30> "Initializes device memory."), [cuMemsetD2D32](<group__CUDA__MEM.html#group__CUDA__MEM_1g74b359b2d026bfeb7c795b5038d07523> "Initializes device memory."), [cuMemsetD8](<group__CUDA__MEM.html#group__CUDA__MEM_1g6e582bf866e9e2fb014297bfaf354d7b> "Initializes device memory."), [cuMemsetD16](<group__CUDA__MEM.html#group__CUDA__MEM_1g7d805e610054392a4d11e8a8bf5eb35c> "Initializes device memory."), [cuMemsetD32](<group__CUDA__MEM.html#group__CUDA__MEM_1g983e8d8759acd1b64326317481fbf132> "Initializes device memory."), [cudaMallocHost](<../cuda-runtime-api/group__CUDART__HIGHLEVEL.html#group__CUDART__HIGHLEVEL_1gd5c991beb38e2b8419f50285707ae87e>)

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuMemAllocManaged ( [CUdeviceptr](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g183f7b0d8ad008ea2a5fd552537ace4e>)*Â dptr, size_tÂ bytesize, unsigned int Â flags )


Allocates memory that will be automatically managed by the Unified Memory system.

######  Parameters

`dptr`
    \- Returned device pointer
`bytesize`
    \- Requested allocation size in bytes
`flags`
    \- Must be one of [CU_MEM_ATTACH_GLOBAL](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg17c5d5f9b585aa2d6f121847d1a78f4c0b42aae6a29b41b734d4c0dea6c33313>) or [CU_MEM_ATTACH_HOST](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg17c5d5f9b585aa2d6f121847d1a78f4c8b59c62cab9c7a762338e5fae92e2e9c>)

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_DEINITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9acf52f132faf29b473cdda6061f0f44a>), [CUDA_ERROR_NOT_INITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e98feb999f0af99b4a25ab26b3866f4df8>), [CUDA_ERROR_INVALID_CONTEXT](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a484e9af32c1e9893ff21f0e0191a12d>), [CUDA_ERROR_NOT_SUPPORTED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e954756ae7ade0dfd09faeccb513dd831b>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>), [CUDA_ERROR_OUT_OF_MEMORY](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9264c50688ed110e8476b591befe60c02>)

###### Description

Allocates `bytesize` bytes of managed memory on the device and returns in `*dptr` a pointer to the allocated memory. If the device doesn't support allocating managed memory, [CUDA_ERROR_NOT_SUPPORTED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e954756ae7ade0dfd09faeccb513dd831b>) is returned. Support for managed memory can be queried using the device attribute [CU_DEVICE_ATTRIBUTE_MANAGED_MEMORY](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gge12b8a782bebe21b1ac0091bf9f4e2a32e652d7656b5e1a381b8c430e41a055e>). The allocated memory is suitably aligned for any kind of variable. The memory is not cleared. If `bytesize` is 0, [cuMemAllocManaged](<group__CUDA__MEM.html#group__CUDA__MEM_1gb347ded34dc326af404aa02af5388a32> "Allocates memory that will be automatically managed by the Unified Memory system.") returns [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>). The pointer is valid on the CPU and on all GPUs in the system that support managed memory. All accesses to this pointer must obey the Unified Memory programming model.

`flags` specifies the default stream association for this allocation. `flags` must be one of [CU_MEM_ATTACH_GLOBAL](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg17c5d5f9b585aa2d6f121847d1a78f4c0b42aae6a29b41b734d4c0dea6c33313>) or [CU_MEM_ATTACH_HOST](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg17c5d5f9b585aa2d6f121847d1a78f4c8b59c62cab9c7a762338e5fae92e2e9c>). If [CU_MEM_ATTACH_GLOBAL](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg17c5d5f9b585aa2d6f121847d1a78f4c0b42aae6a29b41b734d4c0dea6c33313>) is specified, then this memory is accessible from any stream on any device. If [CU_MEM_ATTACH_HOST](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg17c5d5f9b585aa2d6f121847d1a78f4c8b59c62cab9c7a762338e5fae92e2e9c>) is specified, then the allocation should not be accessed from devices that have a zero value for the device attribute [CU_DEVICE_ATTRIBUTE_CONCURRENT_MANAGED_ACCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gge12b8a782bebe21b1ac0091bf9f4e2a333110e44c9cb6ead02f03ff6f6fd495e>); an explicit call to [cuStreamAttachMemAsync](<group__CUDA__STREAM.html#group__CUDA__STREAM_1g6e468d680e263e7eba02a56643c50533> "Attach memory to a stream asynchronously.") will be required to enable access on such devices.

If the association is later changed via [cuStreamAttachMemAsync](<group__CUDA__STREAM.html#group__CUDA__STREAM_1g6e468d680e263e7eba02a56643c50533> "Attach memory to a stream asynchronously.") to a single stream, the default association as specified during [cuMemAllocManaged](<group__CUDA__MEM.html#group__CUDA__MEM_1gb347ded34dc326af404aa02af5388a32> "Allocates memory that will be automatically managed by the Unified Memory system.") is restored when that stream is destroyed. For __managed__ variables, the default association is always [CU_MEM_ATTACH_GLOBAL](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg17c5d5f9b585aa2d6f121847d1a78f4c0b42aae6a29b41b734d4c0dea6c33313>). Note that destroying a stream is an asynchronous operation, and as a result, the change to default association won't happen until all work in the stream has completed.

Memory allocated with [cuMemAllocManaged](<group__CUDA__MEM.html#group__CUDA__MEM_1gb347ded34dc326af404aa02af5388a32> "Allocates memory that will be automatically managed by the Unified Memory system.") should be released with [cuMemFree](<group__CUDA__MEM.html#group__CUDA__MEM_1g89b3f154e17cc89b6eea277dbdf5c93a> "Frees device memory.").

Device memory oversubscription is possible for GPUs that have a non-zero value for the device attribute [CU_DEVICE_ATTRIBUTE_CONCURRENT_MANAGED_ACCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gge12b8a782bebe21b1ac0091bf9f4e2a333110e44c9cb6ead02f03ff6f6fd495e>). Managed memory on such GPUs may be evicted from device memory to host memory at any time by the Unified Memory driver in order to make room for other allocations.

In a system where all GPUs have a non-zero value for the device attribute [CU_DEVICE_ATTRIBUTE_CONCURRENT_MANAGED_ACCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gge12b8a782bebe21b1ac0091bf9f4e2a333110e44c9cb6ead02f03ff6f6fd495e>), managed memory may not be populated when this API returns and instead may be populated on access. In such systems, managed memory can migrate to any processor's memory at any time. The Unified Memory driver will employ heuristics to maintain data locality and prevent excessive page faults to the extent possible. The application can also guide the driver about memory usage patterns via [cuMemAdvise](<group__CUDA__UNIFIED.html#group__CUDA__UNIFIED_1gaac8924b2f5a2a93f8775fb81c1a643f> "Advise about the usage of a given memory range."). The application can also explicitly migrate memory to a desired processor's memory via [cuMemPrefetchAsync](<group__CUDA__UNIFIED.html#group__CUDA__UNIFIED_1g45c0e085febc3be8fabf5c526355b6a3> "Prefetches memory to the specified destination location.").

In a multi-GPU system where all of the GPUs have a zero value for the device attribute [CU_DEVICE_ATTRIBUTE_CONCURRENT_MANAGED_ACCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gge12b8a782bebe21b1ac0091bf9f4e2a333110e44c9cb6ead02f03ff6f6fd495e>) and all the GPUs have peer-to-peer support with each other, the physical storage for managed memory is created on the GPU which is active at the time [cuMemAllocManaged](<group__CUDA__MEM.html#group__CUDA__MEM_1gb347ded34dc326af404aa02af5388a32> "Allocates memory that will be automatically managed by the Unified Memory system.") is called. All other GPUs will reference the data at reduced bandwidth via peer mappings over the PCIe bus. The Unified Memory driver does not migrate memory among such GPUs.

In a multi-GPU system where not all GPUs have peer-to-peer support with each other and where the value of the device attribute [CU_DEVICE_ATTRIBUTE_CONCURRENT_MANAGED_ACCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gge12b8a782bebe21b1ac0091bf9f4e2a333110e44c9cb6ead02f03ff6f6fd495e>) is zero for at least one of those GPUs, the location chosen for physical storage of managed memory is system-dependent.

  * On Linux, the location chosen will be device memory as long as the current set of active contexts are on devices that either have peer-to-peer support with each other or have a non-zero value for the device attribute [CU_DEVICE_ATTRIBUTE_CONCURRENT_MANAGED_ACCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gge12b8a782bebe21b1ac0091bf9f4e2a333110e44c9cb6ead02f03ff6f6fd495e>). If there is an active context on a GPU that does not have a non-zero value for that device attribute and it does not have peer-to-peer support with the other devices that have active contexts on them, then the location for physical storage will be 'zero-copy' or host memory. Note that this means that managed memory that is located in device memory is migrated to host memory if a new context is created on a GPU that doesn't have a non-zero value for the device attribute and does not support peer-to-peer with at least one of the other devices that has an active context. This in turn implies that context creation may fail if there is insufficient host memory to migrate all managed allocations.

  * On Windows, the physical storage is always created in 'zero-copy' or host memory. All GPUs will reference the data at reduced bandwidth over the PCIe bus. In these circumstances, use of the environment variable CUDA_VISIBLE_DEVICES is recommended to restrict CUDA to only use those GPUs that have peer-to-peer support. Alternatively, users can also set CUDA_MANAGED_FORCE_DEVICE_ALLOC to a non-zero value to force the driver to always use device memory for physical storage. When this environment variable is set to a non-zero value, all contexts created in that process on devices that support managed memory have to be peer-to-peer compatible with each other. Context creation will fail if a context is created on a device that supports managed memory and is not peer-to-peer compatible with any of the other managed memory supporting devices on which contexts were previously created, even if those contexts have been destroyed. These environment variables are described in the CUDA programming guide under the "CUDA environment variables" section.

  * On ARM, managed memory is not available on discrete gpu with Drive PX-2.


Note:

Note that this function may also return error codes from previous, asynchronous launches.

**See also:**

[cuArray3DCreate](<group__CUDA__MEM.html#group__CUDA__MEM_1gc2322c70b38c2984536c90ed118bb1d7> "Creates a 3D CUDA array."), [cuArray3DGetDescriptor](<group__CUDA__MEM.html#group__CUDA__MEM_1gb58549f2f3f390b9e0e7c8f3acd53857> "Get a 3D CUDA array descriptor."), [cuArrayCreate](<group__CUDA__MEM.html#group__CUDA__MEM_1g4192ff387a81c3bd5ed8c391ed62ca24> "Creates a 1D or 2D CUDA array."), [cuArrayDestroy](<group__CUDA__MEM.html#group__CUDA__MEM_1g982878affbbc023de84874faac838b0b> "Destroys a CUDA array."), [cuArrayGetDescriptor](<group__CUDA__MEM.html#group__CUDA__MEM_1g661fe823dbd37bf11f82a71bd4762acf> "Get a 1D or 2D CUDA array descriptor."), [cuMemAllocHost](<group__CUDA__MEM.html#group__CUDA__MEM_1gdd8311286d2c2691605362c689bc64e0> "Allocates page-locked host memory."), [cuMemAllocPitch](<group__CUDA__MEM.html#group__CUDA__MEM_1gcbe9b033f6c4de80f63cc6e58ed9a45a> "Allocates pitched device memory."), [cuMemcpy2D](<group__CUDA__MEM.html#group__CUDA__MEM_1g27f885b30c34cc20a663a671dbf6fc27> "Copies memory for 2D arrays."), [cuMemcpy2DAsync](<group__CUDA__MEM.html#group__CUDA__MEM_1g4acf155faeb969d9d21f5433d3d0f274> "Copies memory for 2D arrays."), [cuMemcpy2DUnaligned](<group__CUDA__MEM.html#group__CUDA__MEM_1g2fa285d47fd7020e596bfeab3deb651b> "Copies memory for 2D arrays."), [cuMemcpy3D](<group__CUDA__MEM.html#group__CUDA__MEM_1g4b5238975579f002c0199a3800ca44df> "Copies memory for 3D arrays."), [cuMemcpy3DAsync](<group__CUDA__MEM.html#group__CUDA__MEM_1g79f4f3fde6ae0f529568d881d9e11987> "Copies memory for 3D arrays."), [cuMemcpyAtoA](<group__CUDA__MEM.html#group__CUDA__MEM_1gf81b218c984a31436ec9e23a85fb604a> "Copies memory from Array to Array."), [cuMemcpyAtoD](<group__CUDA__MEM.html#group__CUDA__MEM_1g825b3f037f7f51382cae991bae8173fd> "Copies memory from Array to Device."), [cuMemcpyAtoH](<group__CUDA__MEM.html#group__CUDA__MEM_1gf7ad1edb2539cccc352c6b8b76f657f4> "Copies memory from Array to Host."), [cuMemcpyAtoHAsync](<group__CUDA__MEM.html#group__CUDA__MEM_1g64cbd2e60436699aebdd0bdbf14d0f01> "Copies memory from Array to Host."), [cuMemcpyDtoA](<group__CUDA__MEM.html#group__CUDA__MEM_1gad6827247af91600b56ce6e2ddb802e1> "Copies memory from Device to Array."), [cuMemcpyDtoD](<group__CUDA__MEM.html#group__CUDA__MEM_1g1725774abf8b51b91945f3336b778c8b> "Copies memory from Device to Device."), [cuMemcpyDtoDAsync](<group__CUDA__MEM.html#group__CUDA__MEM_1g39ea09ba682b8eccc9c3e0c04319b5c8> "Copies memory from Device to Device."), [cuMemcpyDtoH](<group__CUDA__MEM.html#group__CUDA__MEM_1g3480368ee0208a98f75019c9a8450893> "Copies memory from Device to Host."), [cuMemcpyDtoHAsync](<group__CUDA__MEM.html#group__CUDA__MEM_1g56f30236c7c5247f8e061b59d3268362> "Copies memory from Device to Host."), [cuMemcpyHtoA](<group__CUDA__MEM.html#group__CUDA__MEM_1g57d3d780d165ecc0e3b3ce08e141cd89> "Copies memory from Host to Array."), [cuMemcpyHtoAAsync](<group__CUDA__MEM.html#group__CUDA__MEM_1gb5c4863f64f132b4bc2661818b3fd188> "Copies memory from Host to Array."), [cuMemcpyHtoD](<group__CUDA__MEM.html#group__CUDA__MEM_1g4d32266788c440b0220b1a9ba5795169> "Copies memory from Host to Device."), [cuMemcpyHtoDAsync](<group__CUDA__MEM.html#group__CUDA__MEM_1g1572263fe2597d7ba4f6964597a354a3> "Copies memory from Host to Device."), [cuMemFree](<group__CUDA__MEM.html#group__CUDA__MEM_1g89b3f154e17cc89b6eea277dbdf5c93a> "Frees device memory."), [cuMemFreeHost](<group__CUDA__MEM.html#group__CUDA__MEM_1g62e0fdbe181dab6b1c90fa1a51c7b92c> "Frees page-locked host memory."), [cuMemGetAddressRange](<group__CUDA__MEM.html#group__CUDA__MEM_1g64fee5711274a2a0573a789c94d8299b> "Get information on memory allocations."), [cuMemGetInfo](<group__CUDA__MEM.html#group__CUDA__MEM_1g808f555540d0143a331cc42aa98835c0> "Gets free and total memory."), [cuMemHostAlloc](<group__CUDA__MEM.html#group__CUDA__MEM_1g572ca4011bfcb25034888a14d4e035b9> "Allocates page-locked host memory."), [cuMemHostGetDevicePointer](<group__CUDA__MEM.html#group__CUDA__MEM_1g57a39e5cba26af4d06be67fc77cc62f0> "Passes back device pointer of mapped pinned memory."), [cuMemsetD2D8](<group__CUDA__MEM.html#group__CUDA__MEM_1ge88b13e646e2be6ba0e0475ef5205974> "Initializes device memory."), [cuMemsetD2D16](<group__CUDA__MEM.html#group__CUDA__MEM_1g7f561a15a66144fa9f6ab5350edc8a30> "Initializes device memory."), [cuMemsetD2D32](<group__CUDA__MEM.html#group__CUDA__MEM_1g74b359b2d026bfeb7c795b5038d07523> "Initializes device memory."), [cuMemsetD8](<group__CUDA__MEM.html#group__CUDA__MEM_1g6e582bf866e9e2fb014297bfaf354d7b> "Initializes device memory."), [cuMemsetD16](<group__CUDA__MEM.html#group__CUDA__MEM_1g7d805e610054392a4d11e8a8bf5eb35c> "Initializes device memory."), [cuMemsetD32](<group__CUDA__MEM.html#group__CUDA__MEM_1g983e8d8759acd1b64326317481fbf132> "Initializes device memory."), [cuDeviceGetAttribute](<group__CUDA__DEVICE.html#group__CUDA__DEVICE_1g9c3e1414f0ad901d3278a4d6645fc266> "Returns information about the device."), [cuStreamAttachMemAsync](<group__CUDA__STREAM.html#group__CUDA__STREAM_1g6e468d680e263e7eba02a56643c50533> "Attach memory to a stream asynchronously."), [cudaMallocManaged](<../cuda-runtime-api/group__CUDART__HIGHLEVEL.html#group__CUDART__HIGHLEVEL_1gcf6b9b1019e73c5bc2b39b39fe90816e>)

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuMemAllocPitch ( [CUdeviceptr](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g183f7b0d8ad008ea2a5fd552537ace4e>)*Â dptr, size_t*Â pPitch, size_tÂ WidthInBytes, size_tÂ Height, unsigned int Â ElementSizeBytes )


Allocates pitched device memory.

######  Parameters

`dptr`
    \- Returned device pointer
`pPitch`
    \- Returned pitch of allocation in bytes
`WidthInBytes`
    \- Requested allocation width in bytes
`Height`
    \- Requested allocation height in rows
`ElementSizeBytes`
    \- Size of largest reads/writes for range

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_DEINITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9acf52f132faf29b473cdda6061f0f44a>), [CUDA_ERROR_NOT_INITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e98feb999f0af99b4a25ab26b3866f4df8>), [CUDA_ERROR_INVALID_CONTEXT](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a484e9af32c1e9893ff21f0e0191a12d>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>), [CUDA_ERROR_OUT_OF_MEMORY](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9264c50688ed110e8476b591befe60c02>)

###### Description

Allocates at least `WidthInBytes` * `Height` bytes of linear memory on the device and returns in `*dptr` a pointer to the allocated memory. The function may pad the allocation to ensure that corresponding pointers in any given row will continue to meet the alignment requirements for coalescing as the address is updated from row to row. `ElementSizeBytes` specifies the size of the largest reads and writes that will be performed on the memory range. `ElementSizeBytes` may be 4, 8 or 16 (since coalesced memory transactions are not possible on other data sizes). If `ElementSizeBytes` is smaller than the actual read/write size of a kernel, the kernel will run correctly, but possibly at reduced speed. The pitch returned in `*pPitch` by [cuMemAllocPitch()](<group__CUDA__MEM.html#group__CUDA__MEM_1gcbe9b033f6c4de80f63cc6e58ed9a45a> "Allocates pitched device memory.") is the width in bytes of the allocation. The intended usage of pitch is as a separate parameter of the allocation, used to compute addresses within the 2D array. Given the row and column of an array element of type **T** , the address is computed as:


    â   T* pElement = (T*)((char*)BaseAddress + Row * Pitch) + Column;

The pitch returned by [cuMemAllocPitch()](<group__CUDA__MEM.html#group__CUDA__MEM_1gcbe9b033f6c4de80f63cc6e58ed9a45a> "Allocates pitched device memory.") is guaranteed to work with [cuMemcpy2D()](<group__CUDA__MEM.html#group__CUDA__MEM_1g27f885b30c34cc20a663a671dbf6fc27> "Copies memory for 2D arrays.") under all circumstances. For allocations of 2D arrays, it is recommended that programmers consider performing pitch allocations using [cuMemAllocPitch()](<group__CUDA__MEM.html#group__CUDA__MEM_1gcbe9b033f6c4de80f63cc6e58ed9a45a> "Allocates pitched device memory."). Due to alignment restrictions in the hardware, this is especially true if the application will be performing 2D memory copies between different regions of device memory (whether linear memory or CUDA arrays).

The byte alignment of the pitch returned by [cuMemAllocPitch()](<group__CUDA__MEM.html#group__CUDA__MEM_1gcbe9b033f6c4de80f63cc6e58ed9a45a> "Allocates pitched device memory.") is guaranteed to match or exceed the alignment requirement for texture binding with [cuTexRefSetAddress2D()](<group__CUDA__TEXREF__DEPRECATED.html#group__CUDA__TEXREF__DEPRECATED_1gbdec8983628f68bcde5db4b4c3f90851> "Binds an address as a 2D texture reference.").

Note:

Note that this function may also return error codes from previous, asynchronous launches.

**See also:**

[cuArray3DCreate](<group__CUDA__MEM.html#group__CUDA__MEM_1gc2322c70b38c2984536c90ed118bb1d7> "Creates a 3D CUDA array."), [cuArray3DGetDescriptor](<group__CUDA__MEM.html#group__CUDA__MEM_1gb58549f2f3f390b9e0e7c8f3acd53857> "Get a 3D CUDA array descriptor."), [cuArrayCreate](<group__CUDA__MEM.html#group__CUDA__MEM_1g4192ff387a81c3bd5ed8c391ed62ca24> "Creates a 1D or 2D CUDA array."), [cuArrayDestroy](<group__CUDA__MEM.html#group__CUDA__MEM_1g982878affbbc023de84874faac838b0b> "Destroys a CUDA array."), [cuArrayGetDescriptor](<group__CUDA__MEM.html#group__CUDA__MEM_1g661fe823dbd37bf11f82a71bd4762acf> "Get a 1D or 2D CUDA array descriptor."), [cuMemAlloc](<group__CUDA__MEM.html#group__CUDA__MEM_1gb82d2a09844a58dd9e744dc31e8aa467> "Allocates device memory."), [cuMemAllocHost](<group__CUDA__MEM.html#group__CUDA__MEM_1gdd8311286d2c2691605362c689bc64e0> "Allocates page-locked host memory."), [cuMemcpy2D](<group__CUDA__MEM.html#group__CUDA__MEM_1g27f885b30c34cc20a663a671dbf6fc27> "Copies memory for 2D arrays."), [cuMemcpy2DAsync](<group__CUDA__MEM.html#group__CUDA__MEM_1g4acf155faeb969d9d21f5433d3d0f274> "Copies memory for 2D arrays."), [cuMemcpy2DUnaligned](<group__CUDA__MEM.html#group__CUDA__MEM_1g2fa285d47fd7020e596bfeab3deb651b> "Copies memory for 2D arrays."), [cuMemcpy3D](<group__CUDA__MEM.html#group__CUDA__MEM_1g4b5238975579f002c0199a3800ca44df> "Copies memory for 3D arrays."), [cuMemcpy3DAsync](<group__CUDA__MEM.html#group__CUDA__MEM_1g79f4f3fde6ae0f529568d881d9e11987> "Copies memory for 3D arrays."), [cuMemcpyAtoA](<group__CUDA__MEM.html#group__CUDA__MEM_1gf81b218c984a31436ec9e23a85fb604a> "Copies memory from Array to Array."), [cuMemcpyAtoD](<group__CUDA__MEM.html#group__CUDA__MEM_1g825b3f037f7f51382cae991bae8173fd> "Copies memory from Array to Device."), [cuMemcpyAtoH](<group__CUDA__MEM.html#group__CUDA__MEM_1gf7ad1edb2539cccc352c6b8b76f657f4> "Copies memory from Array to Host."), [cuMemcpyAtoHAsync](<group__CUDA__MEM.html#group__CUDA__MEM_1g64cbd2e60436699aebdd0bdbf14d0f01> "Copies memory from Array to Host."), [cuMemcpyDtoA](<group__CUDA__MEM.html#group__CUDA__MEM_1gad6827247af91600b56ce6e2ddb802e1> "Copies memory from Device to Array."), [cuMemcpyDtoD](<group__CUDA__MEM.html#group__CUDA__MEM_1g1725774abf8b51b91945f3336b778c8b> "Copies memory from Device to Device."), [cuMemcpyDtoDAsync](<group__CUDA__MEM.html#group__CUDA__MEM_1g39ea09ba682b8eccc9c3e0c04319b5c8> "Copies memory from Device to Device."), [cuMemcpyDtoH](<group__CUDA__MEM.html#group__CUDA__MEM_1g3480368ee0208a98f75019c9a8450893> "Copies memory from Device to Host."), [cuMemcpyDtoHAsync](<group__CUDA__MEM.html#group__CUDA__MEM_1g56f30236c7c5247f8e061b59d3268362> "Copies memory from Device to Host."), [cuMemcpyHtoA](<group__CUDA__MEM.html#group__CUDA__MEM_1g57d3d780d165ecc0e3b3ce08e141cd89> "Copies memory from Host to Array."), [cuMemcpyHtoAAsync](<group__CUDA__MEM.html#group__CUDA__MEM_1gb5c4863f64f132b4bc2661818b3fd188> "Copies memory from Host to Array."), [cuMemcpyHtoD](<group__CUDA__MEM.html#group__CUDA__MEM_1g4d32266788c440b0220b1a9ba5795169> "Copies memory from Host to Device."), [cuMemcpyHtoDAsync](<group__CUDA__MEM.html#group__CUDA__MEM_1g1572263fe2597d7ba4f6964597a354a3> "Copies memory from Host to Device."), [cuMemFree](<group__CUDA__MEM.html#group__CUDA__MEM_1g89b3f154e17cc89b6eea277dbdf5c93a> "Frees device memory."), [cuMemFreeHost](<group__CUDA__MEM.html#group__CUDA__MEM_1g62e0fdbe181dab6b1c90fa1a51c7b92c> "Frees page-locked host memory."), [cuMemGetAddressRange](<group__CUDA__MEM.html#group__CUDA__MEM_1g64fee5711274a2a0573a789c94d8299b> "Get information on memory allocations."), [cuMemGetInfo](<group__CUDA__MEM.html#group__CUDA__MEM_1g808f555540d0143a331cc42aa98835c0> "Gets free and total memory."), [cuMemHostAlloc](<group__CUDA__MEM.html#group__CUDA__MEM_1g572ca4011bfcb25034888a14d4e035b9> "Allocates page-locked host memory."), [cuMemHostGetDevicePointer](<group__CUDA__MEM.html#group__CUDA__MEM_1g57a39e5cba26af4d06be67fc77cc62f0> "Passes back device pointer of mapped pinned memory."), [cuMemsetD2D8](<group__CUDA__MEM.html#group__CUDA__MEM_1ge88b13e646e2be6ba0e0475ef5205974> "Initializes device memory."), [cuMemsetD2D16](<group__CUDA__MEM.html#group__CUDA__MEM_1g7f561a15a66144fa9f6ab5350edc8a30> "Initializes device memory."), [cuMemsetD2D32](<group__CUDA__MEM.html#group__CUDA__MEM_1g74b359b2d026bfeb7c795b5038d07523> "Initializes device memory."), [cuMemsetD8](<group__CUDA__MEM.html#group__CUDA__MEM_1g6e582bf866e9e2fb014297bfaf354d7b> "Initializes device memory."), [cuMemsetD16](<group__CUDA__MEM.html#group__CUDA__MEM_1g7d805e610054392a4d11e8a8bf5eb35c> "Initializes device memory."), [cuMemsetD32](<group__CUDA__MEM.html#group__CUDA__MEM_1g983e8d8759acd1b64326317481fbf132> "Initializes device memory."), [cudaMallocPitch](<../cuda-runtime-api/group__CUDART__MEMORY.html#group__CUDART__MEMORY_1g32bd7a39135594788a542ae72217775c>)

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuMemBatchDecompressAsync ( [CUmemDecompressParams](<structCUmemDecompressParams.html#structCUmemDecompressParams> "Structure describing the parameters that compose a single decompression operation. ")*Â paramsArray, size_tÂ count, unsigned int Â flags, size_t*Â errorIndex, [CUstream](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gb946c7f02e09efd788a204718015d88a>)Â stream )


Submit a batch of `count` independent decompression operations.

######  Parameters

`paramsArray`
    The array of structures describing the independent decompression operations.
`count`
    The number of entries in `paramsArray` array.
`flags`
    Must be 0.
`errorIndex`
    The index into `paramsArray` of the decompression operation for which the error returned by this function pertains to. If `index` is SIZE_MAX and the value returned is not [CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), then the error returned by this function should be considered a general error that does not pertain to a particular decompression operation. May be `NULL`, in which case, no index will be recorded in the event of error.
`stream`
    The stream where the work will be enqueued.

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_DEINITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9acf52f132faf29b473cdda6061f0f44a>), [CUDA_ERROR_NOT_INITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e98feb999f0af99b4a25ab26b3866f4df8>), [CUDA_ERROR_INVALID_CONTEXT](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a484e9af32c1e9893ff21f0e0191a12d>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>), [CUDA_ERROR_INVALID_HANDLE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e90fd2e63260c6317ba943af0f7e4b8d21>)

###### Description

Each of the `count` decompression operations is described by a single entry in the `paramsArray` array. Once the batch has been submitted, the function will return, and decompression will happen asynchronously w.r.t. the CPU. To the work completion tracking mechanisms in the CUDA driver, the batch will be considered a single unit of work and processed according to stream semantics, i.e., it is not possible to query the completion of individual decompression operations within a batch.

The memory pointed to by each of [CUmemDecompressParams.src](<structCUmemDecompressParams.html#structCUmemDecompressParams_14d390c15ec5ed068f0912e42077ae0e0>), [CUmemDecompressParams.dst](<structCUmemDecompressParams.html#structCUmemDecompressParams_139077e823122cfcfab6aeca53093c88c>), and [CUmemDecompressParams.dstActBytes](<structCUmemDecompressParams.html#structCUmemDecompressParams_1df7e9b52dd81aa6c0ed689eeab86d1a7>), must be capable of usage with the hardware decompress feature. That is, for each of said pointers, the pointer attribute [CU_POINTER_ATTRIBUTE_IS_HW_DECOMPRESS_CAPABLE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc2cce590e35080745e72633dfc6e0b60820cbe95f809088e8045fcb1c9857bf5>) should give a non-zero value. To ensure this, the memory backing the pointers should have been allocated using one of the following CUDA memory allocators: * [cuMemAlloc()](<group__CUDA__MEM.html#group__CUDA__MEM_1gb82d2a09844a58dd9e744dc31e8aa467> "Allocates device memory.") * [cuMemCreate()](<group__CUDA__VA.html#group__CUDA__VA_1g899d69a862bba36449789c64b430dc7c> "Create a CUDA memory handle representing a memory allocation of a given size described by the given properties.") with the usage flag [CU_MEM_CREATE_USAGE_HW_DECOMPRESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g8b3b5d15c34f384cd3ada57fe8bb4a57>) * [cuMemAllocFromPoolAsync()](<group__CUDA__MALLOC__ASYNC.html#group__CUDA__MALLOC__ASYNC_1gf1dd6e1e2e8f767a5e0ea63f38ff260b> "Allocates memory from a specified pool with stream ordered semantics.") from a pool that was created with the usage flag [CU_MEM_POOL_CREATE_USAGE_HW_DECOMPRESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gaba1d50e8fd2014843f97c2758ce9cc9>) Additionally, [CUmemDecompressParams.src](<structCUmemDecompressParams.html#structCUmemDecompressParams_14d390c15ec5ed068f0912e42077ae0e0>), [CUmemDecompressParams.dst](<structCUmemDecompressParams.html#structCUmemDecompressParams_139077e823122cfcfab6aeca53093c88c>), and [CUmemDecompressParams.dstActBytes](<structCUmemDecompressParams.html#structCUmemDecompressParams_1df7e9b52dd81aa6c0ed689eeab86d1a7>), must all be accessible from the device associated with the context where `stream` was created. For information on how to ensure this, see the documentation for the allocator of interest.

Note:

  * Note that this function may also return error codes from previous, asynchronous launches.

  * This function exhibits [asynchronous](<api-sync-behavior.html#api-sync-behavior__memcpy-async>) behavior for most use cases.

  * This function uses standard [default stream](<stream-sync-behavior.html#stream-sync-behavior__default-stream>) semantics.


**See also:**

[cuMemAlloc](<group__CUDA__MEM.html#group__CUDA__MEM_1gb82d2a09844a58dd9e744dc31e8aa467> "Allocates device memory."), [cuMemPoolCreate](<group__CUDA__MALLOC__ASYNC.html#group__CUDA__MALLOC__ASYNC_1g8aa4c143dbc20293659cd883232b95f2> "Creates a memory pool."), [cuMemAllocFromPoolAsync](<group__CUDA__MALLOC__ASYNC.html#group__CUDA__MALLOC__ASYNC_1gf1dd6e1e2e8f767a5e0ea63f38ff260b> "Allocates memory from a specified pool with stream ordered semantics.")

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuMemFree ( [CUdeviceptr](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g183f7b0d8ad008ea2a5fd552537ace4e>)Â dptr )


Frees device memory.

######  Parameters

`dptr`
    \- Pointer to memory to free

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_DEINITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9acf52f132faf29b473cdda6061f0f44a>), [CUDA_ERROR_NOT_INITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e98feb999f0af99b4a25ab26b3866f4df8>), [CUDA_ERROR_INVALID_CONTEXT](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a484e9af32c1e9893ff21f0e0191a12d>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>)

###### Description

Frees the memory space pointed to by `dptr`, which must have been returned by a previous call to one of the following memory allocation APIs - [cuMemAlloc()](<group__CUDA__MEM.html#group__CUDA__MEM_1gb82d2a09844a58dd9e744dc31e8aa467> "Allocates device memory."), [cuMemAllocPitch()](<group__CUDA__MEM.html#group__CUDA__MEM_1gcbe9b033f6c4de80f63cc6e58ed9a45a> "Allocates pitched device memory."), [cuMemAllocManaged()](<group__CUDA__MEM.html#group__CUDA__MEM_1gb347ded34dc326af404aa02af5388a32> "Allocates memory that will be automatically managed by the Unified Memory system."), [cuMemAllocAsync()](<group__CUDA__MALLOC__ASYNC.html#group__CUDA__MALLOC__ASYNC_1g13413273e84a641bce1929eae9e6501f> "Allocates memory with stream ordered semantics."), [cuMemAllocFromPoolAsync()](<group__CUDA__MALLOC__ASYNC.html#group__CUDA__MALLOC__ASYNC_1gf1dd6e1e2e8f767a5e0ea63f38ff260b> "Allocates memory from a specified pool with stream ordered semantics.")

Note - This API will not perform any implict synchronization when the pointer was allocated with [cuMemAllocAsync](<group__CUDA__MALLOC__ASYNC.html#group__CUDA__MALLOC__ASYNC_1g13413273e84a641bce1929eae9e6501f> "Allocates memory with stream ordered semantics.") or [cuMemAllocFromPoolAsync](<group__CUDA__MALLOC__ASYNC.html#group__CUDA__MALLOC__ASYNC_1gf1dd6e1e2e8f767a5e0ea63f38ff260b> "Allocates memory from a specified pool with stream ordered semantics."). Callers must ensure that all accesses to these pointer have completed before invoking [cuMemFree](<group__CUDA__MEM.html#group__CUDA__MEM_1g89b3f154e17cc89b6eea277dbdf5c93a> "Frees device memory."). For best performance and memory reuse, users should use [cuMemFreeAsync](<group__CUDA__MALLOC__ASYNC.html#group__CUDA__MALLOC__ASYNC_1g41acf4131f672a2a75cd93d3241f10cf> "Frees memory with stream ordered semantics.") to free memory allocated via the stream ordered memory allocator. For all other pointers, this API may perform implicit synchronization.

Note:

Note that this function may also return error codes from previous, asynchronous launches.

**See also:**

[cuArray3DCreate](<group__CUDA__MEM.html#group__CUDA__MEM_1gc2322c70b38c2984536c90ed118bb1d7> "Creates a 3D CUDA array."), [cuArray3DGetDescriptor](<group__CUDA__MEM.html#group__CUDA__MEM_1gb58549f2f3f390b9e0e7c8f3acd53857> "Get a 3D CUDA array descriptor."), [cuArrayCreate](<group__CUDA__MEM.html#group__CUDA__MEM_1g4192ff387a81c3bd5ed8c391ed62ca24> "Creates a 1D or 2D CUDA array."), [cuArrayDestroy](<group__CUDA__MEM.html#group__CUDA__MEM_1g982878affbbc023de84874faac838b0b> "Destroys a CUDA array."), [cuArrayGetDescriptor](<group__CUDA__MEM.html#group__CUDA__MEM_1g661fe823dbd37bf11f82a71bd4762acf> "Get a 1D or 2D CUDA array descriptor."), [cuMemAlloc](<group__CUDA__MEM.html#group__CUDA__MEM_1gb82d2a09844a58dd9e744dc31e8aa467> "Allocates device memory."), [cuMemAllocHost](<group__CUDA__MEM.html#group__CUDA__MEM_1gdd8311286d2c2691605362c689bc64e0> "Allocates page-locked host memory."), [cuMemAllocPitch](<group__CUDA__MEM.html#group__CUDA__MEM_1gcbe9b033f6c4de80f63cc6e58ed9a45a> "Allocates pitched device memory."), [cuMemAllocManaged](<group__CUDA__MEM.html#group__CUDA__MEM_1gb347ded34dc326af404aa02af5388a32> "Allocates memory that will be automatically managed by the Unified Memory system."), [cuMemAllocAsync](<group__CUDA__MALLOC__ASYNC.html#group__CUDA__MALLOC__ASYNC_1g13413273e84a641bce1929eae9e6501f> "Allocates memory with stream ordered semantics."), [cuMemAllocFromPoolAsync](<group__CUDA__MALLOC__ASYNC.html#group__CUDA__MALLOC__ASYNC_1gf1dd6e1e2e8f767a5e0ea63f38ff260b> "Allocates memory from a specified pool with stream ordered semantics."), [cuMemcpy2D](<group__CUDA__MEM.html#group__CUDA__MEM_1g27f885b30c34cc20a663a671dbf6fc27> "Copies memory for 2D arrays."), [cuMemcpy2DAsync](<group__CUDA__MEM.html#group__CUDA__MEM_1g4acf155faeb969d9d21f5433d3d0f274> "Copies memory for 2D arrays."), [cuMemcpy2DUnaligned](<group__CUDA__MEM.html#group__CUDA__MEM_1g2fa285d47fd7020e596bfeab3deb651b> "Copies memory for 2D arrays."), [cuMemcpy3D](<group__CUDA__MEM.html#group__CUDA__MEM_1g4b5238975579f002c0199a3800ca44df> "Copies memory for 3D arrays."), [cuMemcpy3DAsync](<group__CUDA__MEM.html#group__CUDA__MEM_1g79f4f3fde6ae0f529568d881d9e11987> "Copies memory for 3D arrays."), [cuMemcpyAtoA](<group__CUDA__MEM.html#group__CUDA__MEM_1gf81b218c984a31436ec9e23a85fb604a> "Copies memory from Array to Array."), [cuMemcpyAtoD](<group__CUDA__MEM.html#group__CUDA__MEM_1g825b3f037f7f51382cae991bae8173fd> "Copies memory from Array to Device."), [cuMemcpyAtoH](<group__CUDA__MEM.html#group__CUDA__MEM_1gf7ad1edb2539cccc352c6b8b76f657f4> "Copies memory from Array to Host."), [cuMemcpyAtoHAsync](<group__CUDA__MEM.html#group__CUDA__MEM_1g64cbd2e60436699aebdd0bdbf14d0f01> "Copies memory from Array to Host."), [cuMemcpyDtoA](<group__CUDA__MEM.html#group__CUDA__MEM_1gad6827247af91600b56ce6e2ddb802e1> "Copies memory from Device to Array."), [cuMemcpyDtoD](<group__CUDA__MEM.html#group__CUDA__MEM_1g1725774abf8b51b91945f3336b778c8b> "Copies memory from Device to Device."), [cuMemcpyDtoDAsync](<group__CUDA__MEM.html#group__CUDA__MEM_1g39ea09ba682b8eccc9c3e0c04319b5c8> "Copies memory from Device to Device."), [cuMemcpyDtoH](<group__CUDA__MEM.html#group__CUDA__MEM_1g3480368ee0208a98f75019c9a8450893> "Copies memory from Device to Host."), [cuMemcpyDtoHAsync](<group__CUDA__MEM.html#group__CUDA__MEM_1g56f30236c7c5247f8e061b59d3268362> "Copies memory from Device to Host."), [cuMemcpyHtoA](<group__CUDA__MEM.html#group__CUDA__MEM_1g57d3d780d165ecc0e3b3ce08e141cd89> "Copies memory from Host to Array."), [cuMemcpyHtoAAsync](<group__CUDA__MEM.html#group__CUDA__MEM_1gb5c4863f64f132b4bc2661818b3fd188> "Copies memory from Host to Array."), [cuMemcpyHtoD](<group__CUDA__MEM.html#group__CUDA__MEM_1g4d32266788c440b0220b1a9ba5795169> "Copies memory from Host to Device."), [cuMemcpyHtoDAsync](<group__CUDA__MEM.html#group__CUDA__MEM_1g1572263fe2597d7ba4f6964597a354a3> "Copies memory from Host to Device."), [cuMemFreeHost](<group__CUDA__MEM.html#group__CUDA__MEM_1g62e0fdbe181dab6b1c90fa1a51c7b92c> "Frees page-locked host memory."), [cuMemGetAddressRange](<group__CUDA__MEM.html#group__CUDA__MEM_1g64fee5711274a2a0573a789c94d8299b> "Get information on memory allocations."), [cuMemGetInfo](<group__CUDA__MEM.html#group__CUDA__MEM_1g808f555540d0143a331cc42aa98835c0> "Gets free and total memory."), [cuMemHostAlloc](<group__CUDA__MEM.html#group__CUDA__MEM_1g572ca4011bfcb25034888a14d4e035b9> "Allocates page-locked host memory."), [cuMemFreeAsync](<group__CUDA__MALLOC__ASYNC.html#group__CUDA__MALLOC__ASYNC_1g41acf4131f672a2a75cd93d3241f10cf> "Frees memory with stream ordered semantics."), [cuMemHostGetDevicePointer](<group__CUDA__MEM.html#group__CUDA__MEM_1g57a39e5cba26af4d06be67fc77cc62f0> "Passes back device pointer of mapped pinned memory."), [cuMemsetD2D8](<group__CUDA__MEM.html#group__CUDA__MEM_1ge88b13e646e2be6ba0e0475ef5205974> "Initializes device memory."), [cuMemsetD2D16](<group__CUDA__MEM.html#group__CUDA__MEM_1g7f561a15a66144fa9f6ab5350edc8a30> "Initializes device memory."), [cuMemsetD2D32](<group__CUDA__MEM.html#group__CUDA__MEM_1g74b359b2d026bfeb7c795b5038d07523> "Initializes device memory."), [cuMemsetD8](<group__CUDA__MEM.html#group__CUDA__MEM_1g6e582bf866e9e2fb014297bfaf354d7b> "Initializes device memory."), [cuMemsetD16](<group__CUDA__MEM.html#group__CUDA__MEM_1g7d805e610054392a4d11e8a8bf5eb35c> "Initializes device memory."), [cuMemsetD32](<group__CUDA__MEM.html#group__CUDA__MEM_1g983e8d8759acd1b64326317481fbf132> "Initializes device memory."), [cudaFree](<../cuda-runtime-api/group__CUDART__MEMORY.html#group__CUDART__MEMORY_1ga042655cbbf3408f01061652a075e094>)

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuMemFreeHost ( void*Â p )


Frees page-locked host memory.

######  Parameters

`p`
    \- Pointer to memory to free

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_DEINITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9acf52f132faf29b473cdda6061f0f44a>), [CUDA_ERROR_NOT_INITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e98feb999f0af99b4a25ab26b3866f4df8>), [CUDA_ERROR_INVALID_CONTEXT](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a484e9af32c1e9893ff21f0e0191a12d>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>)

###### Description

Frees the memory space pointed to by `p`, which must have been returned by a previous call to [cuMemAllocHost()](<group__CUDA__MEM.html#group__CUDA__MEM_1gdd8311286d2c2691605362c689bc64e0> "Allocates page-locked host memory.").

Note:

Note that this function may also return error codes from previous, asynchronous launches.

**See also:**

[cuArray3DCreate](<group__CUDA__MEM.html#group__CUDA__MEM_1gc2322c70b38c2984536c90ed118bb1d7> "Creates a 3D CUDA array."), [cuArray3DGetDescriptor](<group__CUDA__MEM.html#group__CUDA__MEM_1gb58549f2f3f390b9e0e7c8f3acd53857> "Get a 3D CUDA array descriptor."), [cuArrayCreate](<group__CUDA__MEM.html#group__CUDA__MEM_1g4192ff387a81c3bd5ed8c391ed62ca24> "Creates a 1D or 2D CUDA array."), [cuArrayDestroy](<group__CUDA__MEM.html#group__CUDA__MEM_1g982878affbbc023de84874faac838b0b> "Destroys a CUDA array."), [cuArrayGetDescriptor](<group__CUDA__MEM.html#group__CUDA__MEM_1g661fe823dbd37bf11f82a71bd4762acf> "Get a 1D or 2D CUDA array descriptor."), [cuMemAlloc](<group__CUDA__MEM.html#group__CUDA__MEM_1gb82d2a09844a58dd9e744dc31e8aa467> "Allocates device memory."), [cuMemAllocHost](<group__CUDA__MEM.html#group__CUDA__MEM_1gdd8311286d2c2691605362c689bc64e0> "Allocates page-locked host memory."), [cuMemAllocPitch](<group__CUDA__MEM.html#group__CUDA__MEM_1gcbe9b033f6c4de80f63cc6e58ed9a45a> "Allocates pitched device memory."), [cuMemcpy2D](<group__CUDA__MEM.html#group__CUDA__MEM_1g27f885b30c34cc20a663a671dbf6fc27> "Copies memory for 2D arrays."), [cuMemcpy2DAsync](<group__CUDA__MEM.html#group__CUDA__MEM_1g4acf155faeb969d9d21f5433d3d0f274> "Copies memory for 2D arrays."), [cuMemcpy2DUnaligned](<group__CUDA__MEM.html#group__CUDA__MEM_1g2fa285d47fd7020e596bfeab3deb651b> "Copies memory for 2D arrays."), [cuMemcpy3D](<group__CUDA__MEM.html#group__CUDA__MEM_1g4b5238975579f002c0199a3800ca44df> "Copies memory for 3D arrays."), [cuMemcpy3DAsync](<group__CUDA__MEM.html#group__CUDA__MEM_1g79f4f3fde6ae0f529568d881d9e11987> "Copies memory for 3D arrays."), [cuMemcpyAtoA](<group__CUDA__MEM.html#group__CUDA__MEM_1gf81b218c984a31436ec9e23a85fb604a> "Copies memory from Array to Array."), [cuMemcpyAtoD](<group__CUDA__MEM.html#group__CUDA__MEM_1g825b3f037f7f51382cae991bae8173fd> "Copies memory from Array to Device."), [cuMemcpyAtoH](<group__CUDA__MEM.html#group__CUDA__MEM_1gf7ad1edb2539cccc352c6b8b76f657f4> "Copies memory from Array to Host."), [cuMemcpyAtoHAsync](<group__CUDA__MEM.html#group__CUDA__MEM_1g64cbd2e60436699aebdd0bdbf14d0f01> "Copies memory from Array to Host."), [cuMemcpyDtoA](<group__CUDA__MEM.html#group__CUDA__MEM_1gad6827247af91600b56ce6e2ddb802e1> "Copies memory from Device to Array."), [cuMemcpyDtoD](<group__CUDA__MEM.html#group__CUDA__MEM_1g1725774abf8b51b91945f3336b778c8b> "Copies memory from Device to Device."), [cuMemcpyDtoDAsync](<group__CUDA__MEM.html#group__CUDA__MEM_1g39ea09ba682b8eccc9c3e0c04319b5c8> "Copies memory from Device to Device."), [cuMemcpyDtoH](<group__CUDA__MEM.html#group__CUDA__MEM_1g3480368ee0208a98f75019c9a8450893> "Copies memory from Device to Host."), [cuMemcpyDtoHAsync](<group__CUDA__MEM.html#group__CUDA__MEM_1g56f30236c7c5247f8e061b59d3268362> "Copies memory from Device to Host."), [cuMemcpyHtoA](<group__CUDA__MEM.html#group__CUDA__MEM_1g57d3d780d165ecc0e3b3ce08e141cd89> "Copies memory from Host to Array."), [cuMemcpyHtoAAsync](<group__CUDA__MEM.html#group__CUDA__MEM_1gb5c4863f64f132b4bc2661818b3fd188> "Copies memory from Host to Array."), [cuMemcpyHtoD](<group__CUDA__MEM.html#group__CUDA__MEM_1g4d32266788c440b0220b1a9ba5795169> "Copies memory from Host to Device."), [cuMemcpyHtoDAsync](<group__CUDA__MEM.html#group__CUDA__MEM_1g1572263fe2597d7ba4f6964597a354a3> "Copies memory from Host to Device."), [cuMemFree](<group__CUDA__MEM.html#group__CUDA__MEM_1g89b3f154e17cc89b6eea277dbdf5c93a> "Frees device memory."), [cuMemGetAddressRange](<group__CUDA__MEM.html#group__CUDA__MEM_1g64fee5711274a2a0573a789c94d8299b> "Get information on memory allocations."), [cuMemGetInfo](<group__CUDA__MEM.html#group__CUDA__MEM_1g808f555540d0143a331cc42aa98835c0> "Gets free and total memory."), [cuMemHostAlloc](<group__CUDA__MEM.html#group__CUDA__MEM_1g572ca4011bfcb25034888a14d4e035b9> "Allocates page-locked host memory."), [cuMemHostGetDevicePointer](<group__CUDA__MEM.html#group__CUDA__MEM_1g57a39e5cba26af4d06be67fc77cc62f0> "Passes back device pointer of mapped pinned memory."), [cuMemsetD2D8](<group__CUDA__MEM.html#group__CUDA__MEM_1ge88b13e646e2be6ba0e0475ef5205974> "Initializes device memory."), [cuMemsetD2D16](<group__CUDA__MEM.html#group__CUDA__MEM_1g7f561a15a66144fa9f6ab5350edc8a30> "Initializes device memory."), [cuMemsetD2D32](<group__CUDA__MEM.html#group__CUDA__MEM_1g74b359b2d026bfeb7c795b5038d07523> "Initializes device memory."), [cuMemsetD8](<group__CUDA__MEM.html#group__CUDA__MEM_1g6e582bf866e9e2fb014297bfaf354d7b> "Initializes device memory."), [cuMemsetD16](<group__CUDA__MEM.html#group__CUDA__MEM_1g7d805e610054392a4d11e8a8bf5eb35c> "Initializes device memory."), [cuMemsetD32](<group__CUDA__MEM.html#group__CUDA__MEM_1g983e8d8759acd1b64326317481fbf132> "Initializes device memory."), [cudaFreeHost](<../cuda-runtime-api/group__CUDART__MEMORY.html#group__CUDART__MEMORY_1g71c078689c17627566b2a91989184969>)

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuMemGetAddressRange ( [CUdeviceptr](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g183f7b0d8ad008ea2a5fd552537ace4e>)*Â pbase, size_t*Â psize, [CUdeviceptr](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g183f7b0d8ad008ea2a5fd552537ace4e>)Â dptr )


Get information on memory allocations.

######  Parameters

`pbase`
    \- Returned base address
`psize`
    \- Returned size of device memory allocation
`dptr`
    \- Device pointer to query

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_DEINITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9acf52f132faf29b473cdda6061f0f44a>), [CUDA_ERROR_NOT_INITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e98feb999f0af99b4a25ab26b3866f4df8>), [CUDA_ERROR_INVALID_CONTEXT](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a484e9af32c1e9893ff21f0e0191a12d>), [CUDA_ERROR_NOT_FOUND](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9af1cadbeb21d3a78115ca211ba44c053>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>)

###### Description

Returns the base address in `*pbase` and size in `*psize` of the allocation that contains the input pointer `dptr`. Both parameters `pbase` and `psize` are optional. If one of them is NULL, it is ignored.

Note:

Note that this function may also return error codes from previous, asynchronous launches.

**See also:**

[cuArray3DCreate](<group__CUDA__MEM.html#group__CUDA__MEM_1gc2322c70b38c2984536c90ed118bb1d7> "Creates a 3D CUDA array."), [cuArray3DGetDescriptor](<group__CUDA__MEM.html#group__CUDA__MEM_1gb58549f2f3f390b9e0e7c8f3acd53857> "Get a 3D CUDA array descriptor."), [cuArrayCreate](<group__CUDA__MEM.html#group__CUDA__MEM_1g4192ff387a81c3bd5ed8c391ed62ca24> "Creates a 1D or 2D CUDA array."), [cuArrayDestroy](<group__CUDA__MEM.html#group__CUDA__MEM_1g982878affbbc023de84874faac838b0b> "Destroys a CUDA array."), [cuArrayGetDescriptor](<group__CUDA__MEM.html#group__CUDA__MEM_1g661fe823dbd37bf11f82a71bd4762acf> "Get a 1D or 2D CUDA array descriptor."), [cuMemAlloc](<group__CUDA__MEM.html#group__CUDA__MEM_1gb82d2a09844a58dd9e744dc31e8aa467> "Allocates device memory."), [cuMemAllocHost](<group__CUDA__MEM.html#group__CUDA__MEM_1gdd8311286d2c2691605362c689bc64e0> "Allocates page-locked host memory."), [cuMemAllocPitch](<group__CUDA__MEM.html#group__CUDA__MEM_1gcbe9b033f6c4de80f63cc6e58ed9a45a> "Allocates pitched device memory."), [cuMemcpy2D](<group__CUDA__MEM.html#group__CUDA__MEM_1g27f885b30c34cc20a663a671dbf6fc27> "Copies memory for 2D arrays."), [cuMemcpy2DAsync](<group__CUDA__MEM.html#group__CUDA__MEM_1g4acf155faeb969d9d21f5433d3d0f274> "Copies memory for 2D arrays."), [cuMemcpy2DUnaligned](<group__CUDA__MEM.html#group__CUDA__MEM_1g2fa285d47fd7020e596bfeab3deb651b> "Copies memory for 2D arrays."), [cuMemcpy3D](<group__CUDA__MEM.html#group__CUDA__MEM_1g4b5238975579f002c0199a3800ca44df> "Copies memory for 3D arrays."), [cuMemcpy3DAsync](<group__CUDA__MEM.html#group__CUDA__MEM_1g79f4f3fde6ae0f529568d881d9e11987> "Copies memory for 3D arrays."), [cuMemcpyAtoA](<group__CUDA__MEM.html#group__CUDA__MEM_1gf81b218c984a31436ec9e23a85fb604a> "Copies memory from Array to Array."), [cuMemcpyAtoD](<group__CUDA__MEM.html#group__CUDA__MEM_1g825b3f037f7f51382cae991bae8173fd> "Copies memory from Array to Device."), [cuMemcpyAtoH](<group__CUDA__MEM.html#group__CUDA__MEM_1gf7ad1edb2539cccc352c6b8b76f657f4> "Copies memory from Array to Host."), [cuMemcpyAtoHAsync](<group__CUDA__MEM.html#group__CUDA__MEM_1g64cbd2e60436699aebdd0bdbf14d0f01> "Copies memory from Array to Host."), [cuMemcpyDtoA](<group__CUDA__MEM.html#group__CUDA__MEM_1gad6827247af91600b56ce6e2ddb802e1> "Copies memory from Device to Array."), [cuMemcpyDtoD](<group__CUDA__MEM.html#group__CUDA__MEM_1g1725774abf8b51b91945f3336b778c8b> "Copies memory from Device to Device."), [cuMemcpyDtoDAsync](<group__CUDA__MEM.html#group__CUDA__MEM_1g39ea09ba682b8eccc9c3e0c04319b5c8> "Copies memory from Device to Device."), [cuMemcpyDtoH](<group__CUDA__MEM.html#group__CUDA__MEM_1g3480368ee0208a98f75019c9a8450893> "Copies memory from Device to Host."), [cuMemcpyDtoHAsync](<group__CUDA__MEM.html#group__CUDA__MEM_1g56f30236c7c5247f8e061b59d3268362> "Copies memory from Device to Host."), [cuMemcpyHtoA](<group__CUDA__MEM.html#group__CUDA__MEM_1g57d3d780d165ecc0e3b3ce08e141cd89> "Copies memory from Host to Array."), [cuMemcpyHtoAAsync](<group__CUDA__MEM.html#group__CUDA__MEM_1gb5c4863f64f132b4bc2661818b3fd188> "Copies memory from Host to Array."), [cuMemcpyHtoD](<group__CUDA__MEM.html#group__CUDA__MEM_1g4d32266788c440b0220b1a9ba5795169> "Copies memory from Host to Device."), [cuMemcpyHtoDAsync](<group__CUDA__MEM.html#group__CUDA__MEM_1g1572263fe2597d7ba4f6964597a354a3> "Copies memory from Host to Device."), [cuMemFree](<group__CUDA__MEM.html#group__CUDA__MEM_1g89b3f154e17cc89b6eea277dbdf5c93a> "Frees device memory."), [cuMemFreeHost](<group__CUDA__MEM.html#group__CUDA__MEM_1g62e0fdbe181dab6b1c90fa1a51c7b92c> "Frees page-locked host memory."), [cuMemGetInfo](<group__CUDA__MEM.html#group__CUDA__MEM_1g808f555540d0143a331cc42aa98835c0> "Gets free and total memory."), [cuMemHostAlloc](<group__CUDA__MEM.html#group__CUDA__MEM_1g572ca4011bfcb25034888a14d4e035b9> "Allocates page-locked host memory."), [cuMemHostGetDevicePointer](<group__CUDA__MEM.html#group__CUDA__MEM_1g57a39e5cba26af4d06be67fc77cc62f0> "Passes back device pointer of mapped pinned memory."), [cuMemsetD2D8](<group__CUDA__MEM.html#group__CUDA__MEM_1ge88b13e646e2be6ba0e0475ef5205974> "Initializes device memory."), [cuMemsetD2D16](<group__CUDA__MEM.html#group__CUDA__MEM_1g7f561a15a66144fa9f6ab5350edc8a30> "Initializes device memory."), [cuMemsetD2D32](<group__CUDA__MEM.html#group__CUDA__MEM_1g74b359b2d026bfeb7c795b5038d07523> "Initializes device memory."), [cuMemsetD8](<group__CUDA__MEM.html#group__CUDA__MEM_1g6e582bf866e9e2fb014297bfaf354d7b> "Initializes device memory."), [cuMemsetD16](<group__CUDA__MEM.html#group__CUDA__MEM_1g7d805e610054392a4d11e8a8bf5eb35c> "Initializes device memory."), [cuMemsetD32](<group__CUDA__MEM.html#group__CUDA__MEM_1g983e8d8759acd1b64326317481fbf132> "Initializes device memory.")

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuMemGetHandleForAddressRange ( void*Â handle, [CUdeviceptr](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g183f7b0d8ad008ea2a5fd552537ace4e>)Â dptr, size_tÂ size, [CUmemRangeHandleType](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g579b315f05d1e65a4f3de7da45013210>)Â handleType, unsigned long longÂ flags )


Retrieve handle for an address range.

######  Parameters

`handle`
    \- Pointer to the location where the returned handle will be stored.
`dptr`
    \- Pointer to a valid CUDA device allocation. Must be aligned to host page size.
`size`
    \- Length of the address range. Must be aligned to host page size.
`handleType`
    \- Type of handle requested (defines type and size of the `handle` output parameter)
`flags`
    \- When requesting CUmemRangeHandleType::CU_MEM_RANGE_HANDLE_TYPE_DMA_BUF_FD the value could be [CU_MEM_RANGE_FLAG_DMA_BUF_MAPPING_TYPE_PCIE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg75c53565b19e5c434edc5a65a6a7ab20ff810d1182d50bd1385eb543478b99f5>), otherwise 0.

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>), [CUDA_ERROR_NOT_SUPPORTED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e954756ae7ade0dfd09faeccb513dd831b>)

###### Description

Get a handle of the specified type to an address range. When requesting CUmemRangeHandleType::CU_MEM_RANGE_HANDLE_TYPE_DMA_BUF_FD, address range obtained by a prior call to either [cuMemAlloc](<group__CUDA__MEM.html#group__CUDA__MEM_1gb82d2a09844a58dd9e744dc31e8aa467> "Allocates device memory.") or [cuMemAddressReserve](<group__CUDA__VA.html#group__CUDA__VA_1ge489256c107df2a07ddf96d80c86cd9b> "Allocate an address range reservation.") is supported if the [CU_DEVICE_ATTRIBUTE_DMA_BUF_SUPPORTED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gge12b8a782bebe21b1ac0091bf9f4e2a339de64a7d3e21d22411d8dc6a2cde25b>) device attribute returns true. If the address range was obtained via [cuMemAddressReserve](<group__CUDA__VA.html#group__CUDA__VA_1ge489256c107df2a07ddf96d80c86cd9b> "Allocate an address range reservation."), it must also be fully mapped via [cuMemMap](<group__CUDA__VA.html#group__CUDA__VA_1gff1d395423af5c5c75375516959dae56> "Maps an allocation handle to a reserved virtual address range."). Address range obtained by a prior call to either [cuMemAllocHost](<group__CUDA__MEM.html#group__CUDA__MEM_1gdd8311286d2c2691605362c689bc64e0> "Allocates page-locked host memory.") or [cuMemHostAlloc](<group__CUDA__MEM.html#group__CUDA__MEM_1g572ca4011bfcb25034888a14d4e035b9> "Allocates page-locked host memory.") is supported if the [CU_DEVICE_ATTRIBUTE_HOST_ALLOC_DMA_BUF_SUPPORTED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gge12b8a782bebe21b1ac0091bf9f4e2a3a7208113fdb76066caa5468ab3be4ce5>) device attribute returns true.

As of CUDA 13.0, querying support for address range obtained by calling [cuMemAllocHost](<group__CUDA__MEM.html#group__CUDA__MEM_1gdd8311286d2c2691605362c689bc64e0> "Allocates page-locked host memory.") or [cuMemHostAlloc](<group__CUDA__MEM.html#group__CUDA__MEM_1g572ca4011bfcb25034888a14d4e035b9> "Allocates page-locked host memory.") using the [CU_DEVICE_ATTRIBUTE_DMA_BUF_SUPPORTED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gge12b8a782bebe21b1ac0091bf9f4e2a339de64a7d3e21d22411d8dc6a2cde25b>) device attribute is deprecated.

Users must ensure the `dptr` and `size` are aligned to the host page size.

The `handle` will be interpreted as a pointer to an integer to store the dma_buf file descriptor. Users must ensure the entire address range is backed and mapped when the address range is allocated by [cuMemAddressReserve](<group__CUDA__VA.html#group__CUDA__VA_1ge489256c107df2a07ddf96d80c86cd9b> "Allocate an address range reservation."). All the physical allocations backing the address range must be resident on the same device and have identical allocation properties. Users are also expected to retrieve a new handle every time the underlying physical allocation(s) corresponding to a previously queried VA range are changed.

For CUmemRangeHandleType::CU_MEM_RANGE_HANDLE_TYPE_DMA_BUF_FD, users may set flags to [CU_MEM_RANGE_FLAG_DMA_BUF_MAPPING_TYPE_PCIE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg75c53565b19e5c434edc5a65a6a7ab20ff810d1182d50bd1385eb543478b99f5>). Which when set on a supported platform, will give a DMA_BUF handle mapped via PCIE BAR1 or will return an error otherwise.

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuMemGetInfo ( size_t*Â free, size_t*Â total )


Gets free and total memory.

######  Parameters

`free`
    \- Returned free memory in bytes
`total`
    \- Returned total memory in bytes

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_DEINITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9acf52f132faf29b473cdda6061f0f44a>), [CUDA_ERROR_NOT_INITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e98feb999f0af99b4a25ab26b3866f4df8>), [CUDA_ERROR_INVALID_CONTEXT](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a484e9af32c1e9893ff21f0e0191a12d>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>)

###### Description

Returns in `*total` the total amount of memory available to the the current context. Returns in `*free` the amount of memory on the device that is free according to the OS. CUDA is not guaranteed to be able to allocate all of the memory that the OS reports as free. In a multi-tenet situation, free estimate returned is prone to race condition where a new allocation/free done by a different process or a different thread in the same process between the time when free memory was estimated and reported, will result in deviation in free value reported and actual free memory.

The integrated GPU on Tegra shares memory with CPU and other component of the SoC. The free and total values returned by the API excludes the SWAP memory space maintained by the OS on some platforms. The OS may move some of the memory pages into swap area as the GPU or CPU allocate or access memory. See Tegra app note on how to calculate total and free memory on Tegra.

Note:

Note that this function may also return error codes from previous, asynchronous launches.

**See also:**

[cuArray3DCreate](<group__CUDA__MEM.html#group__CUDA__MEM_1gc2322c70b38c2984536c90ed118bb1d7> "Creates a 3D CUDA array."), [cuArray3DGetDescriptor](<group__CUDA__MEM.html#group__CUDA__MEM_1gb58549f2f3f390b9e0e7c8f3acd53857> "Get a 3D CUDA array descriptor."), [cuArrayCreate](<group__CUDA__MEM.html#group__CUDA__MEM_1g4192ff387a81c3bd5ed8c391ed62ca24> "Creates a 1D or 2D CUDA array."), [cuArrayDestroy](<group__CUDA__MEM.html#group__CUDA__MEM_1g982878affbbc023de84874faac838b0b> "Destroys a CUDA array."), [cuArrayGetDescriptor](<group__CUDA__MEM.html#group__CUDA__MEM_1g661fe823dbd37bf11f82a71bd4762acf> "Get a 1D or 2D CUDA array descriptor."), [cuMemAlloc](<group__CUDA__MEM.html#group__CUDA__MEM_1gb82d2a09844a58dd9e744dc31e8aa467> "Allocates device memory."), [cuMemAllocHost](<group__CUDA__MEM.html#group__CUDA__MEM_1gdd8311286d2c2691605362c689bc64e0> "Allocates page-locked host memory."), [cuMemAllocPitch](<group__CUDA__MEM.html#group__CUDA__MEM_1gcbe9b033f6c4de80f63cc6e58ed9a45a> "Allocates pitched device memory."), [cuMemcpy2D](<group__CUDA__MEM.html#group__CUDA__MEM_1g27f885b30c34cc20a663a671dbf6fc27> "Copies memory for 2D arrays."), [cuMemcpy2DAsync](<group__CUDA__MEM.html#group__CUDA__MEM_1g4acf155faeb969d9d21f5433d3d0f274> "Copies memory for 2D arrays."), [cuMemcpy2DUnaligned](<group__CUDA__MEM.html#group__CUDA__MEM_1g2fa285d47fd7020e596bfeab3deb651b> "Copies memory for 2D arrays."), [cuMemcpy3D](<group__CUDA__MEM.html#group__CUDA__MEM_1g4b5238975579f002c0199a3800ca44df> "Copies memory for 3D arrays."), [cuMemcpy3DAsync](<group__CUDA__MEM.html#group__CUDA__MEM_1g79f4f3fde6ae0f529568d881d9e11987> "Copies memory for 3D arrays."), [cuMemcpyAtoA](<group__CUDA__MEM.html#group__CUDA__MEM_1gf81b218c984a31436ec9e23a85fb604a> "Copies memory from Array to Array."), [cuMemcpyAtoD](<group__CUDA__MEM.html#group__CUDA__MEM_1g825b3f037f7f51382cae991bae8173fd> "Copies memory from Array to Device."), [cuMemcpyAtoH](<group__CUDA__MEM.html#group__CUDA__MEM_1gf7ad1edb2539cccc352c6b8b76f657f4> "Copies memory from Array to Host."), [cuMemcpyAtoHAsync](<group__CUDA__MEM.html#group__CUDA__MEM_1g64cbd2e60436699aebdd0bdbf14d0f01> "Copies memory from Array to Host."), [cuMemcpyDtoA](<group__CUDA__MEM.html#group__CUDA__MEM_1gad6827247af91600b56ce6e2ddb802e1> "Copies memory from Device to Array."), [cuMemcpyDtoD](<group__CUDA__MEM.html#group__CUDA__MEM_1g1725774abf8b51b91945f3336b778c8b> "Copies memory from Device to Device."), [cuMemcpyDtoDAsync](<group__CUDA__MEM.html#group__CUDA__MEM_1g39ea09ba682b8eccc9c3e0c04319b5c8> "Copies memory from Device to Device."), [cuMemcpyDtoH](<group__CUDA__MEM.html#group__CUDA__MEM_1g3480368ee0208a98f75019c9a8450893> "Copies memory from Device to Host."), [cuMemcpyDtoHAsync](<group__CUDA__MEM.html#group__CUDA__MEM_1g56f30236c7c5247f8e061b59d3268362> "Copies memory from Device to Host."), [cuMemcpyHtoA](<group__CUDA__MEM.html#group__CUDA__MEM_1g57d3d780d165ecc0e3b3ce08e141cd89> "Copies memory from Host to Array."), [cuMemcpyHtoAAsync](<group__CUDA__MEM.html#group__CUDA__MEM_1gb5c4863f64f132b4bc2661818b3fd188> "Copies memory from Host to Array."), [cuMemcpyHtoD](<group__CUDA__MEM.html#group__CUDA__MEM_1g4d32266788c440b0220b1a9ba5795169> "Copies memory from Host to Device."), [cuMemcpyHtoDAsync](<group__CUDA__MEM.html#group__CUDA__MEM_1g1572263fe2597d7ba4f6964597a354a3> "Copies memory from Host to Device."), [cuMemFree](<group__CUDA__MEM.html#group__CUDA__MEM_1g89b3f154e17cc89b6eea277dbdf5c93a> "Frees device memory."), [cuMemFreeHost](<group__CUDA__MEM.html#group__CUDA__MEM_1g62e0fdbe181dab6b1c90fa1a51c7b92c> "Frees page-locked host memory."), [cuMemGetAddressRange](<group__CUDA__MEM.html#group__CUDA__MEM_1g64fee5711274a2a0573a789c94d8299b> "Get information on memory allocations."), [cuMemHostAlloc](<group__CUDA__MEM.html#group__CUDA__MEM_1g572ca4011bfcb25034888a14d4e035b9> "Allocates page-locked host memory."), [cuMemHostGetDevicePointer](<group__CUDA__MEM.html#group__CUDA__MEM_1g57a39e5cba26af4d06be67fc77cc62f0> "Passes back device pointer of mapped pinned memory."), [cuMemsetD2D8](<group__CUDA__MEM.html#group__CUDA__MEM_1ge88b13e646e2be6ba0e0475ef5205974> "Initializes device memory."), [cuMemsetD2D16](<group__CUDA__MEM.html#group__CUDA__MEM_1g7f561a15a66144fa9f6ab5350edc8a30> "Initializes device memory."), [cuMemsetD2D32](<group__CUDA__MEM.html#group__CUDA__MEM_1g74b359b2d026bfeb7c795b5038d07523> "Initializes device memory."), [cuMemsetD8](<group__CUDA__MEM.html#group__CUDA__MEM_1g6e582bf866e9e2fb014297bfaf354d7b> "Initializes device memory."), [cuMemsetD16](<group__CUDA__MEM.html#group__CUDA__MEM_1g7d805e610054392a4d11e8a8bf5eb35c> "Initializes device memory."), [cuMemsetD32](<group__CUDA__MEM.html#group__CUDA__MEM_1g983e8d8759acd1b64326317481fbf132> "Initializes device memory."), [cudaMemGetInfo](<../cuda-runtime-api/group__CUDART__MEMORY.html#group__CUDART__MEMORY_1g376b97f5ab20321ca46f7cfa9511b978>)

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuMemHostAlloc ( void**Â pp, size_tÂ bytesize, unsigned int Â Flags )


Allocates page-locked host memory.

######  Parameters

`pp`
    \- Returned pointer to host memory
`bytesize`
    \- Requested allocation size in bytes
`Flags`
    \- Flags for allocation request

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_DEINITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9acf52f132faf29b473cdda6061f0f44a>), [CUDA_ERROR_NOT_INITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e98feb999f0af99b4a25ab26b3866f4df8>), [CUDA_ERROR_INVALID_CONTEXT](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a484e9af32c1e9893ff21f0e0191a12d>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>), [CUDA_ERROR_OUT_OF_MEMORY](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9264c50688ed110e8476b591befe60c02>)

###### Description

Allocates `bytesize` bytes of host memory that is page-locked and accessible to the device. The driver tracks the virtual memory ranges allocated with this function and automatically accelerates calls to functions such as [cuMemcpyHtoD()](<group__CUDA__MEM.html#group__CUDA__MEM_1g4d32266788c440b0220b1a9ba5795169> "Copies memory from Host to Device."). Since the memory can be accessed directly by the device, it can be read or written with much higher bandwidth than pageable memory obtained with functions such as malloc().

On systems where [CU_DEVICE_ATTRIBUTE_PAGEABLE_MEMORY_ACCESS_USES_HOST_PAGE_TABLES](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gge12b8a782bebe21b1ac0091bf9f4e2a352c58d6fd1d3a72673cce199ab30cd40>) is true, [cuMemHostAlloc](<group__CUDA__MEM.html#group__CUDA__MEM_1g572ca4011bfcb25034888a14d4e035b9> "Allocates page-locked host memory.") may not page-lock the allocated memory.

Page-locking excessive amounts of memory may degrade system performance, since it reduces the amount of memory available to the system for paging. As a result, this function is best used sparingly to allocate staging areas for data exchange between host and device.

The `Flags` parameter enables different options to be specified that affect the allocation, as follows.

  * [CU_MEMHOSTALLOC_PORTABLE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g50f4528d46bda58b592551654a7ee0ff>): The memory returned by this call will be considered as pinned memory by all CUDA contexts, not just the one that performed the allocation.


  * [CU_MEMHOSTALLOC_DEVICEMAP](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g054589ee2a0f188e664d93965d81113d>): Maps the allocation into the CUDA address space. The device pointer to the memory may be obtained by calling [cuMemHostGetDevicePointer()](<group__CUDA__MEM.html#group__CUDA__MEM_1g57a39e5cba26af4d06be67fc77cc62f0> "Passes back device pointer of mapped pinned memory.").


  * [CU_MEMHOSTALLOC_WRITECOMBINED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g7361580951deecace15352c97a210038>): Allocates the memory as write-combined (WC). WC memory can be transferred across the PCI Express bus more quickly on some system configurations, but cannot be read efficiently by most CPUs. WC memory is a good option for buffers that will be written by the CPU and read by the GPU via mapped pinned memory or host->device transfers.


All of these flags are orthogonal to one another: a developer may allocate memory that is portable, mapped and/or write-combined with no restrictions.

The [CU_MEMHOSTALLOC_DEVICEMAP](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g054589ee2a0f188e664d93965d81113d>) flag may be specified on CUDA contexts for devices that do not support mapped pinned memory. The failure is deferred to [cuMemHostGetDevicePointer()](<group__CUDA__MEM.html#group__CUDA__MEM_1g57a39e5cba26af4d06be67fc77cc62f0> "Passes back device pointer of mapped pinned memory.") because the memory may be mapped into other CUDA contexts via the [CU_MEMHOSTALLOC_PORTABLE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g50f4528d46bda58b592551654a7ee0ff>) flag.

The memory allocated by this function must be freed with [cuMemFreeHost()](<group__CUDA__MEM.html#group__CUDA__MEM_1g62e0fdbe181dab6b1c90fa1a51c7b92c> "Frees page-locked host memory.").

Note all host memory allocated using [cuMemHostAlloc()](<group__CUDA__MEM.html#group__CUDA__MEM_1g572ca4011bfcb25034888a14d4e035b9> "Allocates page-locked host memory.") will automatically be immediately accessible to all contexts on all devices which support unified addressing (as may be queried using [CU_DEVICE_ATTRIBUTE_UNIFIED_ADDRESSING](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gge12b8a782bebe21b1ac0091bf9f4e2a3dc11dd6d9f149a7bae32499f2b802c0d>)). Unless the flag [CU_MEMHOSTALLOC_WRITECOMBINED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g7361580951deecace15352c97a210038>) is specified, the device pointer that may be used to access this host memory from those contexts is always equal to the returned host pointer `*pp`. If the flag [CU_MEMHOSTALLOC_WRITECOMBINED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g7361580951deecace15352c97a210038>) is specified, then the function [cuMemHostGetDevicePointer()](<group__CUDA__MEM.html#group__CUDA__MEM_1g57a39e5cba26af4d06be67fc77cc62f0> "Passes back device pointer of mapped pinned memory.") must be used to query the device pointer, even if the context supports unified addressing. See [Unified Addressing](<group__CUDA__UNIFIED.html#group__CUDA__UNIFIED>) for additional details.

Note:

Note that this function may also return error codes from previous, asynchronous launches.

**See also:**

[cuArray3DCreate](<group__CUDA__MEM.html#group__CUDA__MEM_1gc2322c70b38c2984536c90ed118bb1d7> "Creates a 3D CUDA array."), [cuArray3DGetDescriptor](<group__CUDA__MEM.html#group__CUDA__MEM_1gb58549f2f3f390b9e0e7c8f3acd53857> "Get a 3D CUDA array descriptor."), [cuArrayCreate](<group__CUDA__MEM.html#group__CUDA__MEM_1g4192ff387a81c3bd5ed8c391ed62ca24> "Creates a 1D or 2D CUDA array."), [cuArrayDestroy](<group__CUDA__MEM.html#group__CUDA__MEM_1g982878affbbc023de84874faac838b0b> "Destroys a CUDA array."), [cuArrayGetDescriptor](<group__CUDA__MEM.html#group__CUDA__MEM_1g661fe823dbd37bf11f82a71bd4762acf> "Get a 1D or 2D CUDA array descriptor."), [cuMemAlloc](<group__CUDA__MEM.html#group__CUDA__MEM_1gb82d2a09844a58dd9e744dc31e8aa467> "Allocates device memory."), [cuMemAllocHost](<group__CUDA__MEM.html#group__CUDA__MEM_1gdd8311286d2c2691605362c689bc64e0> "Allocates page-locked host memory."), [cuMemAllocPitch](<group__CUDA__MEM.html#group__CUDA__MEM_1gcbe9b033f6c4de80f63cc6e58ed9a45a> "Allocates pitched device memory."), [cuMemcpy2D](<group__CUDA__MEM.html#group__CUDA__MEM_1g27f885b30c34cc20a663a671dbf6fc27> "Copies memory for 2D arrays."), [cuMemcpy2DAsync](<group__CUDA__MEM.html#group__CUDA__MEM_1g4acf155faeb969d9d21f5433d3d0f274> "Copies memory for 2D arrays."), [cuMemcpy2DUnaligned](<group__CUDA__MEM.html#group__CUDA__MEM_1g2fa285d47fd7020e596bfeab3deb651b> "Copies memory for 2D arrays."), [cuMemcpy3D](<group__CUDA__MEM.html#group__CUDA__MEM_1g4b5238975579f002c0199a3800ca44df> "Copies memory for 3D arrays."), [cuMemcpy3DAsync](<group__CUDA__MEM.html#group__CUDA__MEM_1g79f4f3fde6ae0f529568d881d9e11987> "Copies memory for 3D arrays."), [cuMemcpyAtoA](<group__CUDA__MEM.html#group__CUDA__MEM_1gf81b218c984a31436ec9e23a85fb604a> "Copies memory from Array to Array."), [cuMemcpyAtoD](<group__CUDA__MEM.html#group__CUDA__MEM_1g825b3f037f7f51382cae991bae8173fd> "Copies memory from Array to Device."), [cuMemcpyAtoH](<group__CUDA__MEM.html#group__CUDA__MEM_1gf7ad1edb2539cccc352c6b8b76f657f4> "Copies memory from Array to Host."), [cuMemcpyAtoHAsync](<group__CUDA__MEM.html#group__CUDA__MEM_1g64cbd2e60436699aebdd0bdbf14d0f01> "Copies memory from Array to Host."), [cuMemcpyDtoA](<group__CUDA__MEM.html#group__CUDA__MEM_1gad6827247af91600b56ce6e2ddb802e1> "Copies memory from Device to Array."), [cuMemcpyDtoD](<group__CUDA__MEM.html#group__CUDA__MEM_1g1725774abf8b51b91945f3336b778c8b> "Copies memory from Device to Device."), [cuMemcpyDtoDAsync](<group__CUDA__MEM.html#group__CUDA__MEM_1g39ea09ba682b8eccc9c3e0c04319b5c8> "Copies memory from Device to Device."), [cuMemcpyDtoH](<group__CUDA__MEM.html#group__CUDA__MEM_1g3480368ee0208a98f75019c9a8450893> "Copies memory from Device to Host."), [cuMemcpyDtoHAsync](<group__CUDA__MEM.html#group__CUDA__MEM_1g56f30236c7c5247f8e061b59d3268362> "Copies memory from Device to Host."), [cuMemcpyHtoA](<group__CUDA__MEM.html#group__CUDA__MEM_1g57d3d780d165ecc0e3b3ce08e141cd89> "Copies memory from Host to Array."), [cuMemcpyHtoAAsync](<group__CUDA__MEM.html#group__CUDA__MEM_1gb5c4863f64f132b4bc2661818b3fd188> "Copies memory from Host to Array."), [cuMemcpyHtoD](<group__CUDA__MEM.html#group__CUDA__MEM_1g4d32266788c440b0220b1a9ba5795169> "Copies memory from Host to Device."), [cuMemcpyHtoDAsync](<group__CUDA__MEM.html#group__CUDA__MEM_1g1572263fe2597d7ba4f6964597a354a3> "Copies memory from Host to Device."), [cuMemFree](<group__CUDA__MEM.html#group__CUDA__MEM_1g89b3f154e17cc89b6eea277dbdf5c93a> "Frees device memory."), [cuMemFreeHost](<group__CUDA__MEM.html#group__CUDA__MEM_1g62e0fdbe181dab6b1c90fa1a51c7b92c> "Frees page-locked host memory."), [cuMemGetAddressRange](<group__CUDA__MEM.html#group__CUDA__MEM_1g64fee5711274a2a0573a789c94d8299b> "Get information on memory allocations."), [cuMemGetInfo](<group__CUDA__MEM.html#group__CUDA__MEM_1g808f555540d0143a331cc42aa98835c0> "Gets free and total memory."), [cuMemHostGetDevicePointer](<group__CUDA__MEM.html#group__CUDA__MEM_1g57a39e5cba26af4d06be67fc77cc62f0> "Passes back device pointer of mapped pinned memory."), [cuMemsetD2D8](<group__CUDA__MEM.html#group__CUDA__MEM_1ge88b13e646e2be6ba0e0475ef5205974> "Initializes device memory."), [cuMemsetD2D16](<group__CUDA__MEM.html#group__CUDA__MEM_1g7f561a15a66144fa9f6ab5350edc8a30> "Initializes device memory."), [cuMemsetD2D32](<group__CUDA__MEM.html#group__CUDA__MEM_1g74b359b2d026bfeb7c795b5038d07523> "Initializes device memory."), [cuMemsetD8](<group__CUDA__MEM.html#group__CUDA__MEM_1g6e582bf866e9e2fb014297bfaf354d7b> "Initializes device memory."), [cuMemsetD16](<group__CUDA__MEM.html#group__CUDA__MEM_1g7d805e610054392a4d11e8a8bf5eb35c> "Initializes device memory."), [cuMemsetD32](<group__CUDA__MEM.html#group__CUDA__MEM_1g983e8d8759acd1b64326317481fbf132> "Initializes device memory."), [cudaHostAlloc](<../cuda-runtime-api/group__CUDART__MEMORY.html#group__CUDART__MEMORY_1gb65da58f444e7230d3322b6126bb4902>)

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuMemHostGetDevicePointer ( [CUdeviceptr](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g183f7b0d8ad008ea2a5fd552537ace4e>)*Â pdptr, void*Â p, unsigned int Â Flags )


Passes back device pointer of mapped pinned memory.

######  Parameters

`pdptr`
    \- Returned device pointer
`p`
    \- Host pointer
`Flags`
    \- Options (must be 0)

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_DEINITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9acf52f132faf29b473cdda6061f0f44a>), [CUDA_ERROR_NOT_INITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e98feb999f0af99b4a25ab26b3866f4df8>), [CUDA_ERROR_INVALID_CONTEXT](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a484e9af32c1e9893ff21f0e0191a12d>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>)

###### Description

Passes back the device pointer `pdptr` corresponding to the mapped, pinned host buffer `p` allocated by [cuMemHostAlloc](<group__CUDA__MEM.html#group__CUDA__MEM_1g572ca4011bfcb25034888a14d4e035b9> "Allocates page-locked host memory.").

[cuMemHostGetDevicePointer()](<group__CUDA__MEM.html#group__CUDA__MEM_1g57a39e5cba26af4d06be67fc77cc62f0> "Passes back device pointer of mapped pinned memory.") will fail if the [CU_MEMHOSTALLOC_DEVICEMAP](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g054589ee2a0f188e664d93965d81113d>) flag was not specified at the time the memory was allocated, or if the function is called on a GPU that does not support mapped pinned memory.

For devices that have a non-zero value for the device attribute [CU_DEVICE_ATTRIBUTE_CAN_USE_HOST_POINTER_FOR_REGISTERED_MEM](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gge12b8a782bebe21b1ac0091bf9f4e2a3904c097da7a1891f9904b3e6a49e4cdd>), the memory can also be accessed from the device using the host pointer `p`. The device pointer returned by [cuMemHostGetDevicePointer()](<group__CUDA__MEM.html#group__CUDA__MEM_1g57a39e5cba26af4d06be67fc77cc62f0> "Passes back device pointer of mapped pinned memory.") may or may not match the original host pointer `p` and depends on the devices visible to the application. If all devices visible to the application have a non-zero value for the device attribute, the device pointer returned by [cuMemHostGetDevicePointer()](<group__CUDA__MEM.html#group__CUDA__MEM_1g57a39e5cba26af4d06be67fc77cc62f0> "Passes back device pointer of mapped pinned memory.") will match the original pointer `p`. If any device visible to the application has a zero value for the device attribute, the device pointer returned by [cuMemHostGetDevicePointer()](<group__CUDA__MEM.html#group__CUDA__MEM_1g57a39e5cba26af4d06be67fc77cc62f0> "Passes back device pointer of mapped pinned memory.") will not match the original host pointer `p`, but it will be suitable for use on all devices provided Unified Virtual Addressing is enabled. In such systems, it is valid to access the memory using either pointer on devices that have a non-zero value for the device attribute. Note however that such devices should access the memory using only one of the two pointers and not both.

`Flags` provides for future releases. For now, it must be set to 0.

Note:

Note that this function may also return error codes from previous, asynchronous launches.

**See also:**

[cuArray3DCreate](<group__CUDA__MEM.html#group__CUDA__MEM_1gc2322c70b38c2984536c90ed118bb1d7> "Creates a 3D CUDA array."), [cuArray3DGetDescriptor](<group__CUDA__MEM.html#group__CUDA__MEM_1gb58549f2f3f390b9e0e7c8f3acd53857> "Get a 3D CUDA array descriptor."), [cuArrayCreate](<group__CUDA__MEM.html#group__CUDA__MEM_1g4192ff387a81c3bd5ed8c391ed62ca24> "Creates a 1D or 2D CUDA array."), [cuArrayDestroy](<group__CUDA__MEM.html#group__CUDA__MEM_1g982878affbbc023de84874faac838b0b> "Destroys a CUDA array."), [cuArrayGetDescriptor](<group__CUDA__MEM.html#group__CUDA__MEM_1g661fe823dbd37bf11f82a71bd4762acf> "Get a 1D or 2D CUDA array descriptor."), [cuMemAlloc](<group__CUDA__MEM.html#group__CUDA__MEM_1gb82d2a09844a58dd9e744dc31e8aa467> "Allocates device memory."), [cuMemAllocHost](<group__CUDA__MEM.html#group__CUDA__MEM_1gdd8311286d2c2691605362c689bc64e0> "Allocates page-locked host memory."), [cuMemAllocPitch](<group__CUDA__MEM.html#group__CUDA__MEM_1gcbe9b033f6c4de80f63cc6e58ed9a45a> "Allocates pitched device memory."), [cuMemcpy2D](<group__CUDA__MEM.html#group__CUDA__MEM_1g27f885b30c34cc20a663a671dbf6fc27> "Copies memory for 2D arrays."), [cuMemcpy2DAsync](<group__CUDA__MEM.html#group__CUDA__MEM_1g4acf155faeb969d9d21f5433d3d0f274> "Copies memory for 2D arrays."), [cuMemcpy2DUnaligned](<group__CUDA__MEM.html#group__CUDA__MEM_1g2fa285d47fd7020e596bfeab3deb651b> "Copies memory for 2D arrays."), [cuMemcpy3D](<group__CUDA__MEM.html#group__CUDA__MEM_1g4b5238975579f002c0199a3800ca44df> "Copies memory for 3D arrays."), [cuMemcpy3DAsync](<group__CUDA__MEM.html#group__CUDA__MEM_1g79f4f3fde6ae0f529568d881d9e11987> "Copies memory for 3D arrays."), [cuMemcpyAtoA](<group__CUDA__MEM.html#group__CUDA__MEM_1gf81b218c984a31436ec9e23a85fb604a> "Copies memory from Array to Array."), [cuMemcpyAtoD](<group__CUDA__MEM.html#group__CUDA__MEM_1g825b3f037f7f51382cae991bae8173fd> "Copies memory from Array to Device."), [cuMemcpyAtoH](<group__CUDA__MEM.html#group__CUDA__MEM_1gf7ad1edb2539cccc352c6b8b76f657f4> "Copies memory from Array to Host."), [cuMemcpyAtoHAsync](<group__CUDA__MEM.html#group__CUDA__MEM_1g64cbd2e60436699aebdd0bdbf14d0f01> "Copies memory from Array to Host."), [cuMemcpyDtoA](<group__CUDA__MEM.html#group__CUDA__MEM_1gad6827247af91600b56ce6e2ddb802e1> "Copies memory from Device to Array."), [cuMemcpyDtoD](<group__CUDA__MEM.html#group__CUDA__MEM_1g1725774abf8b51b91945f3336b778c8b> "Copies memory from Device to Device."), [cuMemcpyDtoDAsync](<group__CUDA__MEM.html#group__CUDA__MEM_1g39ea09ba682b8eccc9c3e0c04319b5c8> "Copies memory from Device to Device."), [cuMemcpyDtoH](<group__CUDA__MEM.html#group__CUDA__MEM_1g3480368ee0208a98f75019c9a8450893> "Copies memory from Device to Host."), [cuMemcpyDtoHAsync](<group__CUDA__MEM.html#group__CUDA__MEM_1g56f30236c7c5247f8e061b59d3268362> "Copies memory from Device to Host."), [cuMemcpyHtoA](<group__CUDA__MEM.html#group__CUDA__MEM_1g57d3d780d165ecc0e3b3ce08e141cd89> "Copies memory from Host to Array."), [cuMemcpyHtoAAsync](<group__CUDA__MEM.html#group__CUDA__MEM_1gb5c4863f64f132b4bc2661818b3fd188> "Copies memory from Host to Array."), [cuMemcpyHtoD](<group__CUDA__MEM.html#group__CUDA__MEM_1g4d32266788c440b0220b1a9ba5795169> "Copies memory from Host to Device."), [cuMemcpyHtoDAsync](<group__CUDA__MEM.html#group__CUDA__MEM_1g1572263fe2597d7ba4f6964597a354a3> "Copies memory from Host to Device."), [cuMemFree](<group__CUDA__MEM.html#group__CUDA__MEM_1g89b3f154e17cc89b6eea277dbdf5c93a> "Frees device memory."), [cuMemFreeHost](<group__CUDA__MEM.html#group__CUDA__MEM_1g62e0fdbe181dab6b1c90fa1a51c7b92c> "Frees page-locked host memory."), [cuMemGetAddressRange](<group__CUDA__MEM.html#group__CUDA__MEM_1g64fee5711274a2a0573a789c94d8299b> "Get information on memory allocations."), [cuMemGetInfo](<group__CUDA__MEM.html#group__CUDA__MEM_1g808f555540d0143a331cc42aa98835c0> "Gets free and total memory."), [cuMemHostAlloc](<group__CUDA__MEM.html#group__CUDA__MEM_1g572ca4011bfcb25034888a14d4e035b9> "Allocates page-locked host memory."), [cuMemsetD2D8](<group__CUDA__MEM.html#group__CUDA__MEM_1ge88b13e646e2be6ba0e0475ef5205974> "Initializes device memory."), [cuMemsetD2D16](<group__CUDA__MEM.html#group__CUDA__MEM_1g7f561a15a66144fa9f6ab5350edc8a30> "Initializes device memory."), [cuMemsetD2D32](<group__CUDA__MEM.html#group__CUDA__MEM_1g74b359b2d026bfeb7c795b5038d07523> "Initializes device memory."), [cuMemsetD8](<group__CUDA__MEM.html#group__CUDA__MEM_1g6e582bf866e9e2fb014297bfaf354d7b> "Initializes device memory."), [cuMemsetD16](<group__CUDA__MEM.html#group__CUDA__MEM_1g7d805e610054392a4d11e8a8bf5eb35c> "Initializes device memory."), [cuMemsetD32](<group__CUDA__MEM.html#group__CUDA__MEM_1g983e8d8759acd1b64326317481fbf132> "Initializes device memory."), [cudaHostGetDevicePointer](<../cuda-runtime-api/group__CUDART__MEMORY.html#group__CUDART__MEMORY_1gc00502b44e5f1bdc0b424487ebb08db0>)

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuMemHostGetFlags ( unsigned int*Â pFlags, void*Â p )


Passes back flags that were used for a pinned allocation.

######  Parameters

`pFlags`
    \- Returned flags word
`p`
    \- Host pointer

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_DEINITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9acf52f132faf29b473cdda6061f0f44a>), [CUDA_ERROR_NOT_INITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e98feb999f0af99b4a25ab26b3866f4df8>), [CUDA_ERROR_INVALID_CONTEXT](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a484e9af32c1e9893ff21f0e0191a12d>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>)

###### Description

Passes back the flags `pFlags` that were specified when allocating the pinned host buffer `p` allocated by [cuMemHostAlloc](<group__CUDA__MEM.html#group__CUDA__MEM_1g572ca4011bfcb25034888a14d4e035b9> "Allocates page-locked host memory.").

[cuMemHostGetFlags()](<group__CUDA__MEM.html#group__CUDA__MEM_1g42066246915fcb0400df2a17a851b35f> "Passes back flags that were used for a pinned allocation.") will fail if the pointer does not reside in an allocation performed by [cuMemAllocHost()](<group__CUDA__MEM.html#group__CUDA__MEM_1gdd8311286d2c2691605362c689bc64e0> "Allocates page-locked host memory.") or [cuMemHostAlloc()](<group__CUDA__MEM.html#group__CUDA__MEM_1g572ca4011bfcb25034888a14d4e035b9> "Allocates page-locked host memory.").

Note:

Note that this function may also return error codes from previous, asynchronous launches.

**See also:**

[cuMemAllocHost](<group__CUDA__MEM.html#group__CUDA__MEM_1gdd8311286d2c2691605362c689bc64e0> "Allocates page-locked host memory."), [cuMemHostAlloc](<group__CUDA__MEM.html#group__CUDA__MEM_1g572ca4011bfcb25034888a14d4e035b9> "Allocates page-locked host memory."), [cudaHostGetFlags](<../cuda-runtime-api/group__CUDART__MEMORY.html#group__CUDART__MEMORY_1gc470e9220559109f5088d9a01c0aeeda>)

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuMemHostRegister ( void*Â p, size_tÂ bytesize, unsigned int Â Flags )


Registers an existing host memory range for use by CUDA.

######  Parameters

`p`
    \- Host pointer to memory to page-lock
`bytesize`
    \- Size in bytes of the address range to page-lock
`Flags`
    \- Flags for allocation request

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_DEINITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9acf52f132faf29b473cdda6061f0f44a>), [CUDA_ERROR_NOT_INITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e98feb999f0af99b4a25ab26b3866f4df8>), [CUDA_ERROR_INVALID_CONTEXT](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a484e9af32c1e9893ff21f0e0191a12d>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>), [CUDA_ERROR_OUT_OF_MEMORY](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9264c50688ed110e8476b591befe60c02>), [CUDA_ERROR_HOST_MEMORY_ALREADY_REGISTERED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9959a4a8475dc87812c3c64213b18dcba>), [CUDA_ERROR_NOT_PERMITTED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9e23d0197c490ec332a43e55b167968a3>), [CUDA_ERROR_NOT_SUPPORTED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e954756ae7ade0dfd09faeccb513dd831b>)

###### Description

Page-locks the memory range specified by `p` and `bytesize` and maps it for the device(s) as specified by `Flags`. This memory range also is added to the same tracking mechanism as [cuMemHostAlloc](<group__CUDA__MEM.html#group__CUDA__MEM_1g572ca4011bfcb25034888a14d4e035b9> "Allocates page-locked host memory.") to automatically accelerate calls to functions such as [cuMemcpyHtoD()](<group__CUDA__MEM.html#group__CUDA__MEM_1g4d32266788c440b0220b1a9ba5795169> "Copies memory from Host to Device."). Since the memory can be accessed directly by the device, it can be read or written with much higher bandwidth than pageable memory that has not been registered. Page-locking excessive amounts of memory may degrade system performance, since it reduces the amount of memory available to the system for paging. As a result, this function is best used sparingly to register staging areas for data exchange between host and device.

On systems where [CU_DEVICE_ATTRIBUTE_PAGEABLE_MEMORY_ACCESS_USES_HOST_PAGE_TABLES](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gge12b8a782bebe21b1ac0091bf9f4e2a352c58d6fd1d3a72673cce199ab30cd40>) is true, [cuMemHostRegister](<group__CUDA__MEM.html#group__CUDA__MEM_1gf0a9fe11544326dabd743b7aa6b54223> "Registers an existing host memory range for use by CUDA.") will not page-lock the memory range specified by `ptr` but only populate unpopulated pages.

The `Flags` parameter enables different options to be specified that affect the allocation, as follows.

  * [CU_MEMHOSTREGISTER_PORTABLE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g4f20a39f0a7bddc8ce7d644327a2e7da>): The memory returned by this call will be considered as pinned memory by all CUDA contexts, not just the one that performed the allocation.


  * [CU_MEMHOSTREGISTER_DEVICEMAP](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gf1fc8645f0ab5481e7be96c80f6bfa50>): Maps the allocation into the CUDA address space. The device pointer to the memory may be obtained by calling [cuMemHostGetDevicePointer()](<group__CUDA__MEM.html#group__CUDA__MEM_1g57a39e5cba26af4d06be67fc77cc62f0> "Passes back device pointer of mapped pinned memory.").


  * [CU_MEMHOSTREGISTER_IOMEMORY](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g6a86cf1a826f8da5b01f1b5cd8da2bde>): The pointer is treated as pointing to some I/O memory space, e.g. the PCI Express resource of a 3rd party device.


  * [CU_MEMHOSTREGISTER_READ_ONLY](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gd870d49634958b801f5c02a6ba459a1a>): The pointer is treated as pointing to memory that is considered read-only by the device. On platforms without [CU_DEVICE_ATTRIBUTE_PAGEABLE_MEMORY_ACCESS_USES_HOST_PAGE_TABLES](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gge12b8a782bebe21b1ac0091bf9f4e2a352c58d6fd1d3a72673cce199ab30cd40>), this flag is required in order to register memory mapped to the CPU as read-only. Support for the use of this flag can be queried from the device attribute [CU_DEVICE_ATTRIBUTE_READ_ONLY_HOST_REGISTER_SUPPORTED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gge12b8a782bebe21b1ac0091bf9f4e2a33a3a9091a7991536d507dd5eff146d2b>). Using this flag with a current context associated with a device that does not have this attribute set will cause [cuMemHostRegister](<group__CUDA__MEM.html#group__CUDA__MEM_1gf0a9fe11544326dabd743b7aa6b54223> "Registers an existing host memory range for use by CUDA.") to error with CUDA_ERROR_NOT_SUPPORTED.


All of these flags are orthogonal to one another: a developer may page-lock memory that is portable or mapped with no restrictions.

The [CU_MEMHOSTREGISTER_DEVICEMAP](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gf1fc8645f0ab5481e7be96c80f6bfa50>) flag may be specified on CUDA contexts for devices that do not support mapped pinned memory. The failure is deferred to [cuMemHostGetDevicePointer()](<group__CUDA__MEM.html#group__CUDA__MEM_1g57a39e5cba26af4d06be67fc77cc62f0> "Passes back device pointer of mapped pinned memory.") because the memory may be mapped into other CUDA contexts via the [CU_MEMHOSTREGISTER_PORTABLE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g4f20a39f0a7bddc8ce7d644327a2e7da>) flag.

For devices that have a non-zero value for the device attribute [CU_DEVICE_ATTRIBUTE_CAN_USE_HOST_POINTER_FOR_REGISTERED_MEM](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gge12b8a782bebe21b1ac0091bf9f4e2a3904c097da7a1891f9904b3e6a49e4cdd>), the memory can also be accessed from the device using the host pointer `p`. The device pointer returned by [cuMemHostGetDevicePointer()](<group__CUDA__MEM.html#group__CUDA__MEM_1g57a39e5cba26af4d06be67fc77cc62f0> "Passes back device pointer of mapped pinned memory.") may or may not match the original host pointer `ptr` and depends on the devices visible to the application. If all devices visible to the application have a non-zero value for the device attribute, the device pointer returned by [cuMemHostGetDevicePointer()](<group__CUDA__MEM.html#group__CUDA__MEM_1g57a39e5cba26af4d06be67fc77cc62f0> "Passes back device pointer of mapped pinned memory.") will match the original pointer `ptr`. If any device visible to the application has a zero value for the device attribute, the device pointer returned by [cuMemHostGetDevicePointer()](<group__CUDA__MEM.html#group__CUDA__MEM_1g57a39e5cba26af4d06be67fc77cc62f0> "Passes back device pointer of mapped pinned memory.") will not match the original host pointer `ptr`, but it will be suitable for use on all devices provided Unified Virtual Addressing is enabled. In such systems, it is valid to access the memory using either pointer on devices that have a non-zero value for the device attribute. Note however that such devices should access the memory using only of the two pointers and not both.

The memory page-locked by this function must be unregistered with [cuMemHostUnregister()](<group__CUDA__MEM.html#group__CUDA__MEM_1g63f450c8125359be87b7623b1c0b2a14> "Unregisters a memory range that was registered with cuMemHostRegister.").

Note:

Note that this function may also return error codes from previous, asynchronous launches.

**See also:**

[cuMemHostUnregister](<group__CUDA__MEM.html#group__CUDA__MEM_1g63f450c8125359be87b7623b1c0b2a14> "Unregisters a memory range that was registered with cuMemHostRegister."), [cuMemHostGetFlags](<group__CUDA__MEM.html#group__CUDA__MEM_1g42066246915fcb0400df2a17a851b35f> "Passes back flags that were used for a pinned allocation."), [cuMemHostGetDevicePointer](<group__CUDA__MEM.html#group__CUDA__MEM_1g57a39e5cba26af4d06be67fc77cc62f0> "Passes back device pointer of mapped pinned memory."), [cudaHostRegister](<../cuda-runtime-api/group__CUDART__MEMORY.html#group__CUDART__MEMORY_1ge8d5c17670f16ac4fc8fcb4181cb490c>)

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuMemHostUnregister ( void*Â p )


Unregisters a memory range that was registered with cuMemHostRegister.

######  Parameters

`p`
    \- Host pointer to memory to unregister

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_DEINITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9acf52f132faf29b473cdda6061f0f44a>), [CUDA_ERROR_NOT_INITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e98feb999f0af99b4a25ab26b3866f4df8>), [CUDA_ERROR_INVALID_CONTEXT](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a484e9af32c1e9893ff21f0e0191a12d>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>), [CUDA_ERROR_OUT_OF_MEMORY](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9264c50688ed110e8476b591befe60c02>), [CUDA_ERROR_HOST_MEMORY_NOT_REGISTERED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9e6e64a1f120336c5a90794e4d634c703>),

###### Description

Unmaps the memory range whose base address is specified by `p`, and makes it pageable again.

The base address must be the same one specified to [cuMemHostRegister()](<group__CUDA__MEM.html#group__CUDA__MEM_1gf0a9fe11544326dabd743b7aa6b54223> "Registers an existing host memory range for use by CUDA.").

Note:

Note that this function may also return error codes from previous, asynchronous launches.

**See also:**

[cuMemHostRegister](<group__CUDA__MEM.html#group__CUDA__MEM_1gf0a9fe11544326dabd743b7aa6b54223> "Registers an existing host memory range for use by CUDA."), [cudaHostUnregister](<../cuda-runtime-api/group__CUDART__MEMORY.html#group__CUDART__MEMORY_1g81fd4101862bbefdb42a62d60e515eea>)

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuMemcpy ( [CUdeviceptr](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g183f7b0d8ad008ea2a5fd552537ace4e>)Â dst, [CUdeviceptr](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g183f7b0d8ad008ea2a5fd552537ace4e>)Â src, size_tÂ ByteCount )


Copies memory.

######  Parameters

`dst`
    \- Destination unified virtual address space pointer
`src`
    \- Source unified virtual address space pointer
`ByteCount`
    \- Size of memory copy in bytes

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_DEINITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9acf52f132faf29b473cdda6061f0f44a>), [CUDA_ERROR_NOT_INITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e98feb999f0af99b4a25ab26b3866f4df8>), [CUDA_ERROR_INVALID_CONTEXT](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a484e9af32c1e9893ff21f0e0191a12d>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>)

###### Description

Copies data between two pointers. `dst` and `src` are base pointers of the destination and source, respectively. `ByteCount` specifies the number of bytes to copy. Note that this function infers the type of the transfer (host to host, host to device, device to device, or device to host) from the pointer values. This function is only allowed in contexts which support unified addressing.

Note:

  * Note that this function may also return error codes from previous, asynchronous launches.

  * This function exhibits [synchronous](<api-sync-behavior.html#api-sync-behavior__memcpy-sync>) behavior for most use cases.

  * Memory regions requested must be either entirely registered with CUDA, or in the case of host pageable transfers, not registered at all. Memory regions spanning over allocations that are both registered and not registered with CUDA are not supported and will return CUDA_ERROR_INVALID_VALUE.


**See also:**

[cuArray3DCreate](<group__CUDA__MEM.html#group__CUDA__MEM_1gc2322c70b38c2984536c90ed118bb1d7> "Creates a 3D CUDA array."), [cuArray3DGetDescriptor](<group__CUDA__MEM.html#group__CUDA__MEM_1gb58549f2f3f390b9e0e7c8f3acd53857> "Get a 3D CUDA array descriptor."), [cuArrayCreate](<group__CUDA__MEM.html#group__CUDA__MEM_1g4192ff387a81c3bd5ed8c391ed62ca24> "Creates a 1D or 2D CUDA array."), [cuArrayDestroy](<group__CUDA__MEM.html#group__CUDA__MEM_1g982878affbbc023de84874faac838b0b> "Destroys a CUDA array."), [cuArrayGetDescriptor](<group__CUDA__MEM.html#group__CUDA__MEM_1g661fe823dbd37bf11f82a71bd4762acf> "Get a 1D or 2D CUDA array descriptor."), [cuMemAlloc](<group__CUDA__MEM.html#group__CUDA__MEM_1gb82d2a09844a58dd9e744dc31e8aa467> "Allocates device memory."), [cuMemAllocHost](<group__CUDA__MEM.html#group__CUDA__MEM_1gdd8311286d2c2691605362c689bc64e0> "Allocates page-locked host memory."), [cuMemAllocPitch](<group__CUDA__MEM.html#group__CUDA__MEM_1gcbe9b033f6c4de80f63cc6e58ed9a45a> "Allocates pitched device memory."), [cuMemcpy2D](<group__CUDA__MEM.html#group__CUDA__MEM_1g27f885b30c34cc20a663a671dbf6fc27> "Copies memory for 2D arrays."), [cuMemcpy2DAsync](<group__CUDA__MEM.html#group__CUDA__MEM_1g4acf155faeb969d9d21f5433d3d0f274> "Copies memory for 2D arrays."), [cuMemcpy2DUnaligned](<group__CUDA__MEM.html#group__CUDA__MEM_1g2fa285d47fd7020e596bfeab3deb651b> "Copies memory for 2D arrays."), [cuMemcpy3D](<group__CUDA__MEM.html#group__CUDA__MEM_1g4b5238975579f002c0199a3800ca44df> "Copies memory for 3D arrays."), [cuMemcpy3DAsync](<group__CUDA__MEM.html#group__CUDA__MEM_1g79f4f3fde6ae0f529568d881d9e11987> "Copies memory for 3D arrays."), [cuMemcpyAtoA](<group__CUDA__MEM.html#group__CUDA__MEM_1gf81b218c984a31436ec9e23a85fb604a> "Copies memory from Array to Array."), [cuMemcpyAtoD](<group__CUDA__MEM.html#group__CUDA__MEM_1g825b3f037f7f51382cae991bae8173fd> "Copies memory from Array to Device."), [cuMemcpyAtoH](<group__CUDA__MEM.html#group__CUDA__MEM_1gf7ad1edb2539cccc352c6b8b76f657f4> "Copies memory from Array to Host."), [cuMemcpyAtoHAsync](<group__CUDA__MEM.html#group__CUDA__MEM_1g64cbd2e60436699aebdd0bdbf14d0f01> "Copies memory from Array to Host."), [cuMemcpyDtoA](<group__CUDA__MEM.html#group__CUDA__MEM_1gad6827247af91600b56ce6e2ddb802e1> "Copies memory from Device to Array."), [cuMemcpyDtoH](<group__CUDA__MEM.html#group__CUDA__MEM_1g3480368ee0208a98f75019c9a8450893> "Copies memory from Device to Host."), [cuMemcpyDtoHAsync](<group__CUDA__MEM.html#group__CUDA__MEM_1g56f30236c7c5247f8e061b59d3268362> "Copies memory from Device to Host."), [cuMemcpyHtoA](<group__CUDA__MEM.html#group__CUDA__MEM_1g57d3d780d165ecc0e3b3ce08e141cd89> "Copies memory from Host to Array."), [cuMemcpyHtoAAsync](<group__CUDA__MEM.html#group__CUDA__MEM_1gb5c4863f64f132b4bc2661818b3fd188> "Copies memory from Host to Array."), [cuMemcpyHtoD](<group__CUDA__MEM.html#group__CUDA__MEM_1g4d32266788c440b0220b1a9ba5795169> "Copies memory from Host to Device."), [cuMemcpyHtoDAsync](<group__CUDA__MEM.html#group__CUDA__MEM_1g1572263fe2597d7ba4f6964597a354a3> "Copies memory from Host to Device."), [cuMemFree](<group__CUDA__MEM.html#group__CUDA__MEM_1g89b3f154e17cc89b6eea277dbdf5c93a> "Frees device memory."), [cuMemFreeHost](<group__CUDA__MEM.html#group__CUDA__MEM_1g62e0fdbe181dab6b1c90fa1a51c7b92c> "Frees page-locked host memory."), [cuMemGetAddressRange](<group__CUDA__MEM.html#group__CUDA__MEM_1g64fee5711274a2a0573a789c94d8299b> "Get information on memory allocations."), [cuMemGetInfo](<group__CUDA__MEM.html#group__CUDA__MEM_1g808f555540d0143a331cc42aa98835c0> "Gets free and total memory."), [cuMemHostAlloc](<group__CUDA__MEM.html#group__CUDA__MEM_1g572ca4011bfcb25034888a14d4e035b9> "Allocates page-locked host memory."), [cuMemHostGetDevicePointer](<group__CUDA__MEM.html#group__CUDA__MEM_1g57a39e5cba26af4d06be67fc77cc62f0> "Passes back device pointer of mapped pinned memory."), [cuMemsetD2D8](<group__CUDA__MEM.html#group__CUDA__MEM_1ge88b13e646e2be6ba0e0475ef5205974> "Initializes device memory."), [cuMemsetD2D16](<group__CUDA__MEM.html#group__CUDA__MEM_1g7f561a15a66144fa9f6ab5350edc8a30> "Initializes device memory."), [cuMemsetD2D32](<group__CUDA__MEM.html#group__CUDA__MEM_1g74b359b2d026bfeb7c795b5038d07523> "Initializes device memory."), [cuMemsetD8](<group__CUDA__MEM.html#group__CUDA__MEM_1g6e582bf866e9e2fb014297bfaf354d7b> "Initializes device memory."), [cuMemsetD16](<group__CUDA__MEM.html#group__CUDA__MEM_1g7d805e610054392a4d11e8a8bf5eb35c> "Initializes device memory."), [cuMemsetD32](<group__CUDA__MEM.html#group__CUDA__MEM_1g983e8d8759acd1b64326317481fbf132> "Initializes device memory."), [cudaMemcpy](<../cuda-runtime-api/group__CUDART__MEMORY.html#group__CUDART__MEMORY_1gc263dbe6574220cc776b45438fc351e8>), [cudaMemcpyToSymbol](<../cuda-runtime-api/group__CUDART__HIGHLEVEL.html#group__CUDART__HIGHLEVEL_1g4561bf9c99d91c92684a91a0bd356bfe>), [cudaMemcpyFromSymbol](<../cuda-runtime-api/group__CUDART__HIGHLEVEL.html#group__CUDART__HIGHLEVEL_1g99db510d18d37fbb0f5c075a8caf3b5f>)

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuMemcpy2D ( const [CUDA_MEMCPY2D](<structCUDA__MEMCPY2D__v2.html#structCUDA__MEMCPY2D__v2>)*Â pCopy )


Copies memory for 2D arrays.

######  Parameters

`pCopy`
    \- Parameters for the memory copy

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_DEINITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9acf52f132faf29b473cdda6061f0f44a>), [CUDA_ERROR_NOT_INITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e98feb999f0af99b4a25ab26b3866f4df8>), [CUDA_ERROR_INVALID_CONTEXT](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a484e9af32c1e9893ff21f0e0191a12d>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>)

###### Description

Perform a 2D memory copy according to the parameters specified in `pCopy`. The CUDA_MEMCPY2D structure is defined as:


    â   typedef struct CUDA_MEMCPY2D_st {
                unsigned int srcXInBytes, srcY;
                [CUmemorytype](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g8a114cc994ad2e865c44ef3838eaec72>) srcMemoryType;
                    const void *srcHost;
                    [CUdeviceptr](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g183f7b0d8ad008ea2a5fd552537ace4e>) srcDevice;
                    [CUarray](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gd550651524a56766b60f10f0e7628042>) srcArray;
                    unsigned int srcPitch;

                unsigned int dstXInBytes, dstY;
                [CUmemorytype](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g8a114cc994ad2e865c44ef3838eaec72>) dstMemoryType;
                    void *dstHost;
                    [CUdeviceptr](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g183f7b0d8ad008ea2a5fd552537ace4e>) dstDevice;
                    [CUarray](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gd550651524a56766b60f10f0e7628042>) dstArray;
                    unsigned int dstPitch;

                unsigned int WidthInBytes;
                unsigned int Height;
             } [CUDA_MEMCPY2D](<structCUDA__MEMCPY2D__v2.html#structCUDA__MEMCPY2D__v2>);

where:

  * srcMemoryType and dstMemoryType specify the type of memory of the source and destination, respectively; CUmemorytype_enum is defined as:




    â   typedef enum CUmemorytype_enum {
                [CU_MEMORYTYPE_HOST](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg8a114cc994ad2e865c44ef3838eaec727f98a88f26eec8490bfc180c5a73e101>) = 0x01,
                [CU_MEMORYTYPE_DEVICE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg8a114cc994ad2e865c44ef3838eaec72ec7e15ba4b111a26adb3487023707299>) = 0x02,
                [CU_MEMORYTYPE_ARRAY](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg8a114cc994ad2e865c44ef3838eaec72d7f97cd13a156651767607456fe25b66>) = 0x03,
                [CU_MEMORYTYPE_UNIFIED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg8a114cc994ad2e865c44ef3838eaec727a47ca2de6db5cf82084ad80ce66aa71>) = 0x04
             } [CUmemorytype](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g8a114cc994ad2e865c44ef3838eaec72>);

If srcMemoryType is [CU_MEMORYTYPE_UNIFIED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg8a114cc994ad2e865c44ef3838eaec727a47ca2de6db5cf82084ad80ce66aa71>), srcDevice and srcPitch specify the (unified virtual address space) base address of the source data and the bytes per row to apply. srcArray is ignored. This value may be used only if unified addressing is supported in the calling context.

If srcMemoryType is [CU_MEMORYTYPE_HOST](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg8a114cc994ad2e865c44ef3838eaec727f98a88f26eec8490bfc180c5a73e101>), srcHost and srcPitch specify the (host) base address of the source data and the bytes per row to apply. srcArray is ignored.

If srcMemoryType is [CU_MEMORYTYPE_DEVICE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg8a114cc994ad2e865c44ef3838eaec72ec7e15ba4b111a26adb3487023707299>), srcDevice and srcPitch specify the (device) base address of the source data and the bytes per row to apply. srcArray is ignored.

If srcMemoryType is [CU_MEMORYTYPE_ARRAY](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg8a114cc994ad2e865c44ef3838eaec72d7f97cd13a156651767607456fe25b66>), srcArray specifies the handle of the source data. srcHost, srcDevice and srcPitch are ignored.

If dstMemoryType is [CU_MEMORYTYPE_HOST](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg8a114cc994ad2e865c44ef3838eaec727f98a88f26eec8490bfc180c5a73e101>), dstHost and dstPitch specify the (host) base address of the destination data and the bytes per row to apply. dstArray is ignored.

If dstMemoryType is [CU_MEMORYTYPE_UNIFIED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg8a114cc994ad2e865c44ef3838eaec727a47ca2de6db5cf82084ad80ce66aa71>), dstDevice and dstPitch specify the (unified virtual address space) base address of the source data and the bytes per row to apply. dstArray is ignored. This value may be used only if unified addressing is supported in the calling context.

If dstMemoryType is [CU_MEMORYTYPE_DEVICE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg8a114cc994ad2e865c44ef3838eaec72ec7e15ba4b111a26adb3487023707299>), dstDevice and dstPitch specify the (device) base address of the destination data and the bytes per row to apply. dstArray is ignored.

If dstMemoryType is [CU_MEMORYTYPE_ARRAY](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg8a114cc994ad2e865c44ef3838eaec72d7f97cd13a156651767607456fe25b66>), dstArray specifies the handle of the destination data. dstHost, dstDevice and dstPitch are ignored.

  * srcXInBytes and srcY specify the base address of the source data for the copy.


For host pointers, the starting address is


    â  void* Start = (void*)((char*)srcHost+srcY*srcPitch + srcXInBytes);

For device pointers, the starting address is


    â  [CUdeviceptr](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g183f7b0d8ad008ea2a5fd552537ace4e>) Start = srcDevice+srcY*srcPitch+srcXInBytes;

For CUDA arrays, srcXInBytes must be evenly divisible by the array element size.

  * dstXInBytes and dstY specify the base address of the destination data for the copy.


For host pointers, the base address is


    â  void* dstStart = (void*)((char*)dstHost+dstY*dstPitch + dstXInBytes);

For device pointers, the starting address is


    â  [CUdeviceptr](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g183f7b0d8ad008ea2a5fd552537ace4e>) dstStart = dstDevice+dstY*dstPitch+dstXInBytes;

For CUDA arrays, dstXInBytes must be evenly divisible by the array element size.

  * WidthInBytes and Height specify the width (in bytes) and height of the 2D copy being performed.

  * If specified, srcPitch must be greater than or equal to WidthInBytes + srcXInBytes, and dstPitch must be greater than or equal to WidthInBytes + dstXInBytes.


[cuMemcpy2D()](<group__CUDA__MEM.html#group__CUDA__MEM_1g27f885b30c34cc20a663a671dbf6fc27> "Copies memory for 2D arrays.") returns an error if any pitch is greater than the maximum allowed ([CU_DEVICE_ATTRIBUTE_MAX_PITCH](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gge12b8a782bebe21b1ac0091bf9f4e2a3c1625acc7a2db635bc1efae34030598d>)). [cuMemAllocPitch()](<group__CUDA__MEM.html#group__CUDA__MEM_1gcbe9b033f6c4de80f63cc6e58ed9a45a> "Allocates pitched device memory.") passes back pitches that always work with [cuMemcpy2D()](<group__CUDA__MEM.html#group__CUDA__MEM_1g27f885b30c34cc20a663a671dbf6fc27> "Copies memory for 2D arrays."). On intra-device memory copies (device to device, CUDA array to device, CUDA array to CUDA array), [cuMemcpy2D()](<group__CUDA__MEM.html#group__CUDA__MEM_1g27f885b30c34cc20a663a671dbf6fc27> "Copies memory for 2D arrays.") may fail for pitches not computed by [cuMemAllocPitch()](<group__CUDA__MEM.html#group__CUDA__MEM_1gcbe9b033f6c4de80f63cc6e58ed9a45a> "Allocates pitched device memory."). [cuMemcpy2DUnaligned()](<group__CUDA__MEM.html#group__CUDA__MEM_1g2fa285d47fd7020e596bfeab3deb651b> "Copies memory for 2D arrays.") does not have this restriction, but may run significantly slower in the cases where [cuMemcpy2D()](<group__CUDA__MEM.html#group__CUDA__MEM_1g27f885b30c34cc20a663a671dbf6fc27> "Copies memory for 2D arrays.") would have returned an error code.

Note:

  * Note that this function may also return error codes from previous, asynchronous launches.

  * This function exhibits [synchronous](<api-sync-behavior.html#api-sync-behavior__memcpy-sync>) behavior for most use cases.


**See also:**

[cuArray3DCreate](<group__CUDA__MEM.html#group__CUDA__MEM_1gc2322c70b38c2984536c90ed118bb1d7> "Creates a 3D CUDA array."), [cuArray3DGetDescriptor](<group__CUDA__MEM.html#group__CUDA__MEM_1gb58549f2f3f390b9e0e7c8f3acd53857> "Get a 3D CUDA array descriptor."), [cuArrayCreate](<group__CUDA__MEM.html#group__CUDA__MEM_1g4192ff387a81c3bd5ed8c391ed62ca24> "Creates a 1D or 2D CUDA array."), [cuArrayDestroy](<group__CUDA__MEM.html#group__CUDA__MEM_1g982878affbbc023de84874faac838b0b> "Destroys a CUDA array."), [cuArrayGetDescriptor](<group__CUDA__MEM.html#group__CUDA__MEM_1g661fe823dbd37bf11f82a71bd4762acf> "Get a 1D or 2D CUDA array descriptor."), [cuMemAlloc](<group__CUDA__MEM.html#group__CUDA__MEM_1gb82d2a09844a58dd9e744dc31e8aa467> "Allocates device memory."), [cuMemAllocHost](<group__CUDA__MEM.html#group__CUDA__MEM_1gdd8311286d2c2691605362c689bc64e0> "Allocates page-locked host memory."), [cuMemAllocPitch](<group__CUDA__MEM.html#group__CUDA__MEM_1gcbe9b033f6c4de80f63cc6e58ed9a45a> "Allocates pitched device memory."), [cuMemcpy2DAsync](<group__CUDA__MEM.html#group__CUDA__MEM_1g4acf155faeb969d9d21f5433d3d0f274> "Copies memory for 2D arrays."), [cuMemcpy2DUnaligned](<group__CUDA__MEM.html#group__CUDA__MEM_1g2fa285d47fd7020e596bfeab3deb651b> "Copies memory for 2D arrays."), [cuMemcpy3D](<group__CUDA__MEM.html#group__CUDA__MEM_1g4b5238975579f002c0199a3800ca44df> "Copies memory for 3D arrays."), [cuMemcpy3DAsync](<group__CUDA__MEM.html#group__CUDA__MEM_1g79f4f3fde6ae0f529568d881d9e11987> "Copies memory for 3D arrays."), [cuMemcpyAtoA](<group__CUDA__MEM.html#group__CUDA__MEM_1gf81b218c984a31436ec9e23a85fb604a> "Copies memory from Array to Array."), [cuMemcpyAtoD](<group__CUDA__MEM.html#group__CUDA__MEM_1g825b3f037f7f51382cae991bae8173fd> "Copies memory from Array to Device."), [cuMemcpyAtoH](<group__CUDA__MEM.html#group__CUDA__MEM_1gf7ad1edb2539cccc352c6b8b76f657f4> "Copies memory from Array to Host."), [cuMemcpyAtoHAsync](<group__CUDA__MEM.html#group__CUDA__MEM_1g64cbd2e60436699aebdd0bdbf14d0f01> "Copies memory from Array to Host."), [cuMemcpyDtoA](<group__CUDA__MEM.html#group__CUDA__MEM_1gad6827247af91600b56ce6e2ddb802e1> "Copies memory from Device to Array."), [cuMemcpyDtoD](<group__CUDA__MEM.html#group__CUDA__MEM_1g1725774abf8b51b91945f3336b778c8b> "Copies memory from Device to Device."), [cuMemcpyDtoDAsync](<group__CUDA__MEM.html#group__CUDA__MEM_1g39ea09ba682b8eccc9c3e0c04319b5c8> "Copies memory from Device to Device."), [cuMemcpyDtoH](<group__CUDA__MEM.html#group__CUDA__MEM_1g3480368ee0208a98f75019c9a8450893> "Copies memory from Device to Host."), [cuMemcpyDtoHAsync](<group__CUDA__MEM.html#group__CUDA__MEM_1g56f30236c7c5247f8e061b59d3268362> "Copies memory from Device to Host."), [cuMemcpyHtoA](<group__CUDA__MEM.html#group__CUDA__MEM_1g57d3d780d165ecc0e3b3ce08e141cd89> "Copies memory from Host to Array."), [cuMemcpyHtoAAsync](<group__CUDA__MEM.html#group__CUDA__MEM_1gb5c4863f64f132b4bc2661818b3fd188> "Copies memory from Host to Array."), [cuMemcpyHtoD](<group__CUDA__MEM.html#group__CUDA__MEM_1g4d32266788c440b0220b1a9ba5795169> "Copies memory from Host to Device."), [cuMemcpyHtoDAsync](<group__CUDA__MEM.html#group__CUDA__MEM_1g1572263fe2597d7ba4f6964597a354a3> "Copies memory from Host to Device."), [cuMemFree](<group__CUDA__MEM.html#group__CUDA__MEM_1g89b3f154e17cc89b6eea277dbdf5c93a> "Frees device memory."), [cuMemFreeHost](<group__CUDA__MEM.html#group__CUDA__MEM_1g62e0fdbe181dab6b1c90fa1a51c7b92c> "Frees page-locked host memory."), [cuMemGetAddressRange](<group__CUDA__MEM.html#group__CUDA__MEM_1g64fee5711274a2a0573a789c94d8299b> "Get information on memory allocations."), [cuMemGetInfo](<group__CUDA__MEM.html#group__CUDA__MEM_1g808f555540d0143a331cc42aa98835c0> "Gets free and total memory."), [cuMemHostAlloc](<group__CUDA__MEM.html#group__CUDA__MEM_1g572ca4011bfcb25034888a14d4e035b9> "Allocates page-locked host memory."), [cuMemHostGetDevicePointer](<group__CUDA__MEM.html#group__CUDA__MEM_1g57a39e5cba26af4d06be67fc77cc62f0> "Passes back device pointer of mapped pinned memory."), [cuMemsetD2D8](<group__CUDA__MEM.html#group__CUDA__MEM_1ge88b13e646e2be6ba0e0475ef5205974> "Initializes device memory."), [cuMemsetD2D16](<group__CUDA__MEM.html#group__CUDA__MEM_1g7f561a15a66144fa9f6ab5350edc8a30> "Initializes device memory."), [cuMemsetD2D32](<group__CUDA__MEM.html#group__CUDA__MEM_1g74b359b2d026bfeb7c795b5038d07523> "Initializes device memory."), [cuMemsetD8](<group__CUDA__MEM.html#group__CUDA__MEM_1g6e582bf866e9e2fb014297bfaf354d7b> "Initializes device memory."), [cuMemsetD16](<group__CUDA__MEM.html#group__CUDA__MEM_1g7d805e610054392a4d11e8a8bf5eb35c> "Initializes device memory."), [cuMemsetD32](<group__CUDA__MEM.html#group__CUDA__MEM_1g983e8d8759acd1b64326317481fbf132> "Initializes device memory."), [cudaMemcpy2D](<../cuda-runtime-api/group__CUDART__MEMORY.html#group__CUDART__MEMORY_1g3a58270f6775efe56c65ac47843e7cee>), [cudaMemcpy2DToArray](<../cuda-runtime-api/group__CUDART__MEMORY.html#group__CUDART__MEMORY_1g9509226164aaa58baf0c5b8ed165df58>), [cudaMemcpy2DFromArray](<../cuda-runtime-api/group__CUDART__MEMORY.html#group__CUDART__MEMORY_1g0f944b3fd3c81edad0a352cf22de24f0>)

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuMemcpy2DAsync ( const [CUDA_MEMCPY2D](<structCUDA__MEMCPY2D__v2.html#structCUDA__MEMCPY2D__v2>)*Â pCopy, [CUstream](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gb946c7f02e09efd788a204718015d88a>)Â hStream )


Copies memory for 2D arrays.

######  Parameters

`pCopy`
    \- Parameters for the memory copy
`hStream`
    \- Stream identifier

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_DEINITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9acf52f132faf29b473cdda6061f0f44a>), [CUDA_ERROR_NOT_INITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e98feb999f0af99b4a25ab26b3866f4df8>), [CUDA_ERROR_INVALID_CONTEXT](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a484e9af32c1e9893ff21f0e0191a12d>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>), [CUDA_ERROR_INVALID_HANDLE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e90fd2e63260c6317ba943af0f7e4b8d21>)

###### Description

Perform a 2D memory copy according to the parameters specified in `pCopy`. The CUDA_MEMCPY2D structure is defined as:


    â   typedef struct CUDA_MEMCPY2D_st {
                unsigned int srcXInBytes, srcY;
                [CUmemorytype](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g8a114cc994ad2e865c44ef3838eaec72>) srcMemoryType;
                const void *srcHost;
                [CUdeviceptr](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g183f7b0d8ad008ea2a5fd552537ace4e>) srcDevice;
                [CUarray](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gd550651524a56766b60f10f0e7628042>) srcArray;
                unsigned int srcPitch;
                unsigned int dstXInBytes, dstY;
                [CUmemorytype](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g8a114cc994ad2e865c44ef3838eaec72>) dstMemoryType;
                void *dstHost;
                [CUdeviceptr](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g183f7b0d8ad008ea2a5fd552537ace4e>) dstDevice;
                [CUarray](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gd550651524a56766b60f10f0e7628042>) dstArray;
                unsigned int dstPitch;
                unsigned int WidthInBytes;
                unsigned int Height;
             } [CUDA_MEMCPY2D](<structCUDA__MEMCPY2D__v2.html#structCUDA__MEMCPY2D__v2>);

where:

  * srcMemoryType and dstMemoryType specify the type of memory of the source and destination, respectively; CUmemorytype_enum is defined as:




    â   typedef enum CUmemorytype_enum {
                [CU_MEMORYTYPE_HOST](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg8a114cc994ad2e865c44ef3838eaec727f98a88f26eec8490bfc180c5a73e101>) = 0x01,
                [CU_MEMORYTYPE_DEVICE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg8a114cc994ad2e865c44ef3838eaec72ec7e15ba4b111a26adb3487023707299>) = 0x02,
                [CU_MEMORYTYPE_ARRAY](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg8a114cc994ad2e865c44ef3838eaec72d7f97cd13a156651767607456fe25b66>) = 0x03,
                [CU_MEMORYTYPE_UNIFIED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg8a114cc994ad2e865c44ef3838eaec727a47ca2de6db5cf82084ad80ce66aa71>) = 0x04
             } [CUmemorytype](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g8a114cc994ad2e865c44ef3838eaec72>);

If srcMemoryType is [CU_MEMORYTYPE_HOST](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg8a114cc994ad2e865c44ef3838eaec727f98a88f26eec8490bfc180c5a73e101>), srcHost and srcPitch specify the (host) base address of the source data and the bytes per row to apply. srcArray is ignored.

If srcMemoryType is [CU_MEMORYTYPE_UNIFIED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg8a114cc994ad2e865c44ef3838eaec727a47ca2de6db5cf82084ad80ce66aa71>), srcDevice and srcPitch specify the (unified virtual address space) base address of the source data and the bytes per row to apply. srcArray is ignored. This value may be used only if unified addressing is supported in the calling context.

If srcMemoryType is [CU_MEMORYTYPE_DEVICE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg8a114cc994ad2e865c44ef3838eaec72ec7e15ba4b111a26adb3487023707299>), srcDevice and srcPitch specify the (device) base address of the source data and the bytes per row to apply. srcArray is ignored.

If srcMemoryType is [CU_MEMORYTYPE_ARRAY](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg8a114cc994ad2e865c44ef3838eaec72d7f97cd13a156651767607456fe25b66>), srcArray specifies the handle of the source data. srcHost, srcDevice and srcPitch are ignored.

If dstMemoryType is [CU_MEMORYTYPE_UNIFIED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg8a114cc994ad2e865c44ef3838eaec727a47ca2de6db5cf82084ad80ce66aa71>), dstDevice and dstPitch specify the (unified virtual address space) base address of the source data and the bytes per row to apply. dstArray is ignored. This value may be used only if unified addressing is supported in the calling context.

If dstMemoryType is [CU_MEMORYTYPE_HOST](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg8a114cc994ad2e865c44ef3838eaec727f98a88f26eec8490bfc180c5a73e101>), dstHost and dstPitch specify the (host) base address of the destination data and the bytes per row to apply. dstArray is ignored.

If dstMemoryType is [CU_MEMORYTYPE_DEVICE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg8a114cc994ad2e865c44ef3838eaec72ec7e15ba4b111a26adb3487023707299>), dstDevice and dstPitch specify the (device) base address of the destination data and the bytes per row to apply. dstArray is ignored.

If dstMemoryType is [CU_MEMORYTYPE_ARRAY](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg8a114cc994ad2e865c44ef3838eaec72d7f97cd13a156651767607456fe25b66>), dstArray specifies the handle of the destination data. dstHost, dstDevice and dstPitch are ignored.

  * srcXInBytes and srcY specify the base address of the source data for the copy.


For host pointers, the starting address is


    â  void* Start = (void*)((char*)srcHost+srcY*srcPitch + srcXInBytes);

For device pointers, the starting address is


    â  [CUdeviceptr](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g183f7b0d8ad008ea2a5fd552537ace4e>) Start = srcDevice+srcY*srcPitch+srcXInBytes;

For CUDA arrays, srcXInBytes must be evenly divisible by the array element size.

  * dstXInBytes and dstY specify the base address of the destination data for the copy.


For host pointers, the base address is


    â  void* dstStart = (void*)((char*)dstHost+dstY*dstPitch + dstXInBytes);

For device pointers, the starting address is


    â  [CUdeviceptr](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g183f7b0d8ad008ea2a5fd552537ace4e>) dstStart = dstDevice+dstY*dstPitch+dstXInBytes;

For CUDA arrays, dstXInBytes must be evenly divisible by the array element size.

  * WidthInBytes and Height specify the width (in bytes) and height of the 2D copy being performed.

  * If specified, srcPitch must be greater than or equal to WidthInBytes + srcXInBytes, and dstPitch must be greater than or equal to WidthInBytes + dstXInBytes.

  * If specified, srcPitch must be greater than or equal to WidthInBytes + srcXInBytes, and dstPitch must be greater than or equal to WidthInBytes + dstXInBytes.

  * If specified, srcHeight must be greater than or equal to Height + srcY, and dstHeight must be greater than or equal to Height \+ dstY.


[cuMemcpy2DAsync()](<group__CUDA__MEM.html#group__CUDA__MEM_1g4acf155faeb969d9d21f5433d3d0f274> "Copies memory for 2D arrays.") returns an error if any pitch is greater than the maximum allowed ([CU_DEVICE_ATTRIBUTE_MAX_PITCH](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gge12b8a782bebe21b1ac0091bf9f4e2a3c1625acc7a2db635bc1efae34030598d>)). [cuMemAllocPitch()](<group__CUDA__MEM.html#group__CUDA__MEM_1gcbe9b033f6c4de80f63cc6e58ed9a45a> "Allocates pitched device memory.") passes back pitches that always work with [cuMemcpy2D()](<group__CUDA__MEM.html#group__CUDA__MEM_1g27f885b30c34cc20a663a671dbf6fc27> "Copies memory for 2D arrays."). On intra-device memory copies (device to device, CUDA array to device, CUDA array to CUDA array), [cuMemcpy2DAsync()](<group__CUDA__MEM.html#group__CUDA__MEM_1g4acf155faeb969d9d21f5433d3d0f274> "Copies memory for 2D arrays.") may fail for pitches not computed by [cuMemAllocPitch()](<group__CUDA__MEM.html#group__CUDA__MEM_1gcbe9b033f6c4de80f63cc6e58ed9a45a> "Allocates pitched device memory.").

Note:

  * Note that this function may also return error codes from previous, asynchronous launches.

  * This function exhibits [asynchronous](<api-sync-behavior.html#api-sync-behavior__memcpy-async>) behavior for most use cases.

  * This function uses standard [default stream](<stream-sync-behavior.html#stream-sync-behavior__default-stream>) semantics.


**See also:**

[cuArray3DCreate](<group__CUDA__MEM.html#group__CUDA__MEM_1gc2322c70b38c2984536c90ed118bb1d7> "Creates a 3D CUDA array."), [cuArray3DGetDescriptor](<group__CUDA__MEM.html#group__CUDA__MEM_1gb58549f2f3f390b9e0e7c8f3acd53857> "Get a 3D CUDA array descriptor."), [cuArrayCreate](<group__CUDA__MEM.html#group__CUDA__MEM_1g4192ff387a81c3bd5ed8c391ed62ca24> "Creates a 1D or 2D CUDA array."), [cuArrayDestroy](<group__CUDA__MEM.html#group__CUDA__MEM_1g982878affbbc023de84874faac838b0b> "Destroys a CUDA array."), [cuArrayGetDescriptor](<group__CUDA__MEM.html#group__CUDA__MEM_1g661fe823dbd37bf11f82a71bd4762acf> "Get a 1D or 2D CUDA array descriptor."), [cuMemAlloc](<group__CUDA__MEM.html#group__CUDA__MEM_1gb82d2a09844a58dd9e744dc31e8aa467> "Allocates device memory."), [cuMemAllocHost](<group__CUDA__MEM.html#group__CUDA__MEM_1gdd8311286d2c2691605362c689bc64e0> "Allocates page-locked host memory."), [cuMemAllocPitch](<group__CUDA__MEM.html#group__CUDA__MEM_1gcbe9b033f6c4de80f63cc6e58ed9a45a> "Allocates pitched device memory."), [cuMemcpy2D](<group__CUDA__MEM.html#group__CUDA__MEM_1g27f885b30c34cc20a663a671dbf6fc27> "Copies memory for 2D arrays."), [cuMemcpy2DUnaligned](<group__CUDA__MEM.html#group__CUDA__MEM_1g2fa285d47fd7020e596bfeab3deb651b> "Copies memory for 2D arrays."), [cuMemcpy3D](<group__CUDA__MEM.html#group__CUDA__MEM_1g4b5238975579f002c0199a3800ca44df> "Copies memory for 3D arrays."), [cuMemcpy3DAsync](<group__CUDA__MEM.html#group__CUDA__MEM_1g79f4f3fde6ae0f529568d881d9e11987> "Copies memory for 3D arrays."), [cuMemcpyAtoA](<group__CUDA__MEM.html#group__CUDA__MEM_1gf81b218c984a31436ec9e23a85fb604a> "Copies memory from Array to Array."), [cuMemcpyAtoD](<group__CUDA__MEM.html#group__CUDA__MEM_1g825b3f037f7f51382cae991bae8173fd> "Copies memory from Array to Device."), [cuMemcpyAtoH](<group__CUDA__MEM.html#group__CUDA__MEM_1gf7ad1edb2539cccc352c6b8b76f657f4> "Copies memory from Array to Host."), [cuMemcpyAtoHAsync](<group__CUDA__MEM.html#group__CUDA__MEM_1g64cbd2e60436699aebdd0bdbf14d0f01> "Copies memory from Array to Host."), [cuMemcpyDtoA](<group__CUDA__MEM.html#group__CUDA__MEM_1gad6827247af91600b56ce6e2ddb802e1> "Copies memory from Device to Array."), [cuMemcpyDtoD](<group__CUDA__MEM.html#group__CUDA__MEM_1g1725774abf8b51b91945f3336b778c8b> "Copies memory from Device to Device."), [cuMemcpyDtoDAsync](<group__CUDA__MEM.html#group__CUDA__MEM_1g39ea09ba682b8eccc9c3e0c04319b5c8> "Copies memory from Device to Device."), [cuMemcpyDtoH](<group__CUDA__MEM.html#group__CUDA__MEM_1g3480368ee0208a98f75019c9a8450893> "Copies memory from Device to Host."), [cuMemcpyDtoHAsync](<group__CUDA__MEM.html#group__CUDA__MEM_1g56f30236c7c5247f8e061b59d3268362> "Copies memory from Device to Host."), [cuMemcpyHtoA](<group__CUDA__MEM.html#group__CUDA__MEM_1g57d3d780d165ecc0e3b3ce08e141cd89> "Copies memory from Host to Array."), [cuMemcpyHtoAAsync](<group__CUDA__MEM.html#group__CUDA__MEM_1gb5c4863f64f132b4bc2661818b3fd188> "Copies memory from Host to Array."), [cuMemcpyHtoD](<group__CUDA__MEM.html#group__CUDA__MEM_1g4d32266788c440b0220b1a9ba5795169> "Copies memory from Host to Device."), [cuMemcpyHtoDAsync](<group__CUDA__MEM.html#group__CUDA__MEM_1g1572263fe2597d7ba4f6964597a354a3> "Copies memory from Host to Device."), [cuMemFree](<group__CUDA__MEM.html#group__CUDA__MEM_1g89b3f154e17cc89b6eea277dbdf5c93a> "Frees device memory."), [cuMemFreeHost](<group__CUDA__MEM.html#group__CUDA__MEM_1g62e0fdbe181dab6b1c90fa1a51c7b92c> "Frees page-locked host memory."), [cuMemGetAddressRange](<group__CUDA__MEM.html#group__CUDA__MEM_1g64fee5711274a2a0573a789c94d8299b> "Get information on memory allocations."), [cuMemGetInfo](<group__CUDA__MEM.html#group__CUDA__MEM_1g808f555540d0143a331cc42aa98835c0> "Gets free and total memory."), [cuMemHostAlloc](<group__CUDA__MEM.html#group__CUDA__MEM_1g572ca4011bfcb25034888a14d4e035b9> "Allocates page-locked host memory."), [cuMemHostGetDevicePointer](<group__CUDA__MEM.html#group__CUDA__MEM_1g57a39e5cba26af4d06be67fc77cc62f0> "Passes back device pointer of mapped pinned memory."), [cuMemsetD2D8](<group__CUDA__MEM.html#group__CUDA__MEM_1ge88b13e646e2be6ba0e0475ef5205974> "Initializes device memory."), [cuMemsetD2D8Async](<group__CUDA__MEM.html#group__CUDA__MEM_1g3f7b6924a3e49c3265b328f534102e97> "Sets device memory."), [cuMemsetD2D16](<group__CUDA__MEM.html#group__CUDA__MEM_1g7f561a15a66144fa9f6ab5350edc8a30> "Initializes device memory."), [cuMemsetD2D16Async](<group__CUDA__MEM.html#group__CUDA__MEM_1g64ee197befac3d74d9fefedcf6ef6b10> "Sets device memory."), [cuMemsetD2D32](<group__CUDA__MEM.html#group__CUDA__MEM_1g74b359b2d026bfeb7c795b5038d07523> "Initializes device memory."), [cuMemsetD2D32Async](<group__CUDA__MEM.html#group__CUDA__MEM_1g8a78d3147ac93fac955052c815d9ea3c> "Sets device memory."), [cuMemsetD8](<group__CUDA__MEM.html#group__CUDA__MEM_1g6e582bf866e9e2fb014297bfaf354d7b> "Initializes device memory."), [cuMemsetD8Async](<group__CUDA__MEM.html#group__CUDA__MEM_1gaef08a7ccd61112f94e82f2b30d43627> "Sets device memory."), [cuMemsetD16](<group__CUDA__MEM.html#group__CUDA__MEM_1g7d805e610054392a4d11e8a8bf5eb35c> "Initializes device memory."), [cuMemsetD16Async](<group__CUDA__MEM.html#group__CUDA__MEM_1gf731438877dd8ec875e4c43d848c878c> "Sets device memory."), [cuMemsetD32](<group__CUDA__MEM.html#group__CUDA__MEM_1g983e8d8759acd1b64326317481fbf132> "Initializes device memory."), [cuMemsetD32Async](<group__CUDA__MEM.html#group__CUDA__MEM_1g58229da5d30f1c0cdf667b320ec2c0f5> "Sets device memory."), [cudaMemcpy2DAsync](<../cuda-runtime-api/group__CUDART__MEMORY.html#group__CUDART__MEMORY_1ge529b926e8fb574c2666a9a1d58b0dc1>), [cudaMemcpy2DToArrayAsync](<../cuda-runtime-api/group__CUDART__MEMORY.html#group__CUDART__MEMORY_1g217af4b9e2de79d9252418fc661e6a6a>), [cudaMemcpy2DFromArrayAsync](<../cuda-runtime-api/group__CUDART__MEMORY.html#group__CUDART__MEMORY_1g1c81de45e9ed5e72008a8f28e706b599>)

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuMemcpy2DUnaligned ( const [CUDA_MEMCPY2D](<structCUDA__MEMCPY2D__v2.html#structCUDA__MEMCPY2D__v2>)*Â pCopy )


Copies memory for 2D arrays.

######  Parameters

`pCopy`
    \- Parameters for the memory copy

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_DEINITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9acf52f132faf29b473cdda6061f0f44a>), [CUDA_ERROR_NOT_INITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e98feb999f0af99b4a25ab26b3866f4df8>), [CUDA_ERROR_INVALID_CONTEXT](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a484e9af32c1e9893ff21f0e0191a12d>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>)

###### Description

Perform a 2D memory copy according to the parameters specified in `pCopy`. The CUDA_MEMCPY2D structure is defined as:


    â   typedef struct CUDA_MEMCPY2D_st {
                unsigned int srcXInBytes, srcY;
                [CUmemorytype](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g8a114cc994ad2e865c44ef3838eaec72>) srcMemoryType;
                const void *srcHost;
                [CUdeviceptr](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g183f7b0d8ad008ea2a5fd552537ace4e>) srcDevice;
                [CUarray](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gd550651524a56766b60f10f0e7628042>) srcArray;
                unsigned int srcPitch;
                unsigned int dstXInBytes, dstY;
                [CUmemorytype](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g8a114cc994ad2e865c44ef3838eaec72>) dstMemoryType;
                void *dstHost;
                [CUdeviceptr](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g183f7b0d8ad008ea2a5fd552537ace4e>) dstDevice;
                [CUarray](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gd550651524a56766b60f10f0e7628042>) dstArray;
                unsigned int dstPitch;
                unsigned int WidthInBytes;
                unsigned int Height;
             } [CUDA_MEMCPY2D](<structCUDA__MEMCPY2D__v2.html#structCUDA__MEMCPY2D__v2>);

where:

  * srcMemoryType and dstMemoryType specify the type of memory of the source and destination, respectively; CUmemorytype_enum is defined as:




    â   typedef enum CUmemorytype_enum {
                [CU_MEMORYTYPE_HOST](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg8a114cc994ad2e865c44ef3838eaec727f98a88f26eec8490bfc180c5a73e101>) = 0x01,
                [CU_MEMORYTYPE_DEVICE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg8a114cc994ad2e865c44ef3838eaec72ec7e15ba4b111a26adb3487023707299>) = 0x02,
                [CU_MEMORYTYPE_ARRAY](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg8a114cc994ad2e865c44ef3838eaec72d7f97cd13a156651767607456fe25b66>) = 0x03,
                [CU_MEMORYTYPE_UNIFIED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg8a114cc994ad2e865c44ef3838eaec727a47ca2de6db5cf82084ad80ce66aa71>) = 0x04
             } [CUmemorytype](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g8a114cc994ad2e865c44ef3838eaec72>);

If srcMemoryType is [CU_MEMORYTYPE_UNIFIED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg8a114cc994ad2e865c44ef3838eaec727a47ca2de6db5cf82084ad80ce66aa71>), srcDevice and srcPitch specify the (unified virtual address space) base address of the source data and the bytes per row to apply. srcArray is ignored. This value may be used only if unified addressing is supported in the calling context.

If srcMemoryType is [CU_MEMORYTYPE_HOST](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg8a114cc994ad2e865c44ef3838eaec727f98a88f26eec8490bfc180c5a73e101>), srcHost and srcPitch specify the (host) base address of the source data and the bytes per row to apply. srcArray is ignored.

If srcMemoryType is [CU_MEMORYTYPE_DEVICE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg8a114cc994ad2e865c44ef3838eaec72ec7e15ba4b111a26adb3487023707299>), srcDevice and srcPitch specify the (device) base address of the source data and the bytes per row to apply. srcArray is ignored.

If srcMemoryType is [CU_MEMORYTYPE_ARRAY](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg8a114cc994ad2e865c44ef3838eaec72d7f97cd13a156651767607456fe25b66>), srcArray specifies the handle of the source data. srcHost, srcDevice and srcPitch are ignored.

If dstMemoryType is [CU_MEMORYTYPE_UNIFIED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg8a114cc994ad2e865c44ef3838eaec727a47ca2de6db5cf82084ad80ce66aa71>), dstDevice and dstPitch specify the (unified virtual address space) base address of the source data and the bytes per row to apply. dstArray is ignored. This value may be used only if unified addressing is supported in the calling context.

If dstMemoryType is [CU_MEMORYTYPE_HOST](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg8a114cc994ad2e865c44ef3838eaec727f98a88f26eec8490bfc180c5a73e101>), dstHost and dstPitch specify the (host) base address of the destination data and the bytes per row to apply. dstArray is ignored.

If dstMemoryType is [CU_MEMORYTYPE_DEVICE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg8a114cc994ad2e865c44ef3838eaec72ec7e15ba4b111a26adb3487023707299>), dstDevice and dstPitch specify the (device) base address of the destination data and the bytes per row to apply. dstArray is ignored.

If dstMemoryType is [CU_MEMORYTYPE_ARRAY](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg8a114cc994ad2e865c44ef3838eaec72d7f97cd13a156651767607456fe25b66>), dstArray specifies the handle of the destination data. dstHost, dstDevice and dstPitch are ignored.

  * srcXInBytes and srcY specify the base address of the source data for the copy.


For host pointers, the starting address is


    â  void* Start = (void*)((char*)srcHost+srcY*srcPitch + srcXInBytes);

For device pointers, the starting address is


    â  [CUdeviceptr](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g183f7b0d8ad008ea2a5fd552537ace4e>) Start = srcDevice+srcY*srcPitch+srcXInBytes;

For CUDA arrays, srcXInBytes must be evenly divisible by the array element size.

  * dstXInBytes and dstY specify the base address of the destination data for the copy.


For host pointers, the base address is


    â  void* dstStart = (void*)((char*)dstHost+dstY*dstPitch + dstXInBytes);

For device pointers, the starting address is


    â  [CUdeviceptr](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g183f7b0d8ad008ea2a5fd552537ace4e>) dstStart = dstDevice+dstY*dstPitch+dstXInBytes;

For CUDA arrays, dstXInBytes must be evenly divisible by the array element size.

  * WidthInBytes and Height specify the width (in bytes) and height of the 2D copy being performed.

  * If specified, srcPitch must be greater than or equal to WidthInBytes + srcXInBytes, and dstPitch must be greater than or equal to WidthInBytes + dstXInBytes.


[cuMemcpy2D()](<group__CUDA__MEM.html#group__CUDA__MEM_1g27f885b30c34cc20a663a671dbf6fc27> "Copies memory for 2D arrays.") returns an error if any pitch is greater than the maximum allowed ([CU_DEVICE_ATTRIBUTE_MAX_PITCH](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gge12b8a782bebe21b1ac0091bf9f4e2a3c1625acc7a2db635bc1efae34030598d>)). [cuMemAllocPitch()](<group__CUDA__MEM.html#group__CUDA__MEM_1gcbe9b033f6c4de80f63cc6e58ed9a45a> "Allocates pitched device memory.") passes back pitches that always work with [cuMemcpy2D()](<group__CUDA__MEM.html#group__CUDA__MEM_1g27f885b30c34cc20a663a671dbf6fc27> "Copies memory for 2D arrays."). On intra-device memory copies (device to device, CUDA array to device, CUDA array to CUDA array), [cuMemcpy2D()](<group__CUDA__MEM.html#group__CUDA__MEM_1g27f885b30c34cc20a663a671dbf6fc27> "Copies memory for 2D arrays.") may fail for pitches not computed by [cuMemAllocPitch()](<group__CUDA__MEM.html#group__CUDA__MEM_1gcbe9b033f6c4de80f63cc6e58ed9a45a> "Allocates pitched device memory."). [cuMemcpy2DUnaligned()](<group__CUDA__MEM.html#group__CUDA__MEM_1g2fa285d47fd7020e596bfeab3deb651b> "Copies memory for 2D arrays.") does not have this restriction, but may run significantly slower in the cases where [cuMemcpy2D()](<group__CUDA__MEM.html#group__CUDA__MEM_1g27f885b30c34cc20a663a671dbf6fc27> "Copies memory for 2D arrays.") would have returned an error code.

Note:

  * Note that this function may also return error codes from previous, asynchronous launches.

  * This function exhibits [synchronous](<api-sync-behavior.html#api-sync-behavior__memcpy-sync>) behavior for most use cases.


**See also:**

[cuArray3DCreate](<group__CUDA__MEM.html#group__CUDA__MEM_1gc2322c70b38c2984536c90ed118bb1d7> "Creates a 3D CUDA array."), [cuArray3DGetDescriptor](<group__CUDA__MEM.html#group__CUDA__MEM_1gb58549f2f3f390b9e0e7c8f3acd53857> "Get a 3D CUDA array descriptor."), [cuArrayCreate](<group__CUDA__MEM.html#group__CUDA__MEM_1g4192ff387a81c3bd5ed8c391ed62ca24> "Creates a 1D or 2D CUDA array."), [cuArrayDestroy](<group__CUDA__MEM.html#group__CUDA__MEM_1g982878affbbc023de84874faac838b0b> "Destroys a CUDA array."), [cuArrayGetDescriptor](<group__CUDA__MEM.html#group__CUDA__MEM_1g661fe823dbd37bf11f82a71bd4762acf> "Get a 1D or 2D CUDA array descriptor."), [cuMemAlloc](<group__CUDA__MEM.html#group__CUDA__MEM_1gb82d2a09844a58dd9e744dc31e8aa467> "Allocates device memory."), [cuMemAllocHost](<group__CUDA__MEM.html#group__CUDA__MEM_1gdd8311286d2c2691605362c689bc64e0> "Allocates page-locked host memory."), [cuMemAllocPitch](<group__CUDA__MEM.html#group__CUDA__MEM_1gcbe9b033f6c4de80f63cc6e58ed9a45a> "Allocates pitched device memory."), [cuMemcpy2D](<group__CUDA__MEM.html#group__CUDA__MEM_1g27f885b30c34cc20a663a671dbf6fc27> "Copies memory for 2D arrays."), [cuMemcpy2DAsync](<group__CUDA__MEM.html#group__CUDA__MEM_1g4acf155faeb969d9d21f5433d3d0f274> "Copies memory for 2D arrays."), [cuMemcpy3D](<group__CUDA__MEM.html#group__CUDA__MEM_1g4b5238975579f002c0199a3800ca44df> "Copies memory for 3D arrays."), [cuMemcpy3DAsync](<group__CUDA__MEM.html#group__CUDA__MEM_1g79f4f3fde6ae0f529568d881d9e11987> "Copies memory for 3D arrays."), [cuMemcpyAtoA](<group__CUDA__MEM.html#group__CUDA__MEM_1gf81b218c984a31436ec9e23a85fb604a> "Copies memory from Array to Array."), [cuMemcpyAtoD](<group__CUDA__MEM.html#group__CUDA__MEM_1g825b3f037f7f51382cae991bae8173fd> "Copies memory from Array to Device."), [cuMemcpyAtoH](<group__CUDA__MEM.html#group__CUDA__MEM_1gf7ad1edb2539cccc352c6b8b76f657f4> "Copies memory from Array to Host."), [cuMemcpyAtoHAsync](<group__CUDA__MEM.html#group__CUDA__MEM_1g64cbd2e60436699aebdd0bdbf14d0f01> "Copies memory from Array to Host."), [cuMemcpyDtoA](<group__CUDA__MEM.html#group__CUDA__MEM_1gad6827247af91600b56ce6e2ddb802e1> "Copies memory from Device to Array."), [cuMemcpyDtoD](<group__CUDA__MEM.html#group__CUDA__MEM_1g1725774abf8b51b91945f3336b778c8b> "Copies memory from Device to Device."), [cuMemcpyDtoDAsync](<group__CUDA__MEM.html#group__CUDA__MEM_1g39ea09ba682b8eccc9c3e0c04319b5c8> "Copies memory from Device to Device."), [cuMemcpyDtoH](<group__CUDA__MEM.html#group__CUDA__MEM_1g3480368ee0208a98f75019c9a8450893> "Copies memory from Device to Host."), [cuMemcpyDtoHAsync](<group__CUDA__MEM.html#group__CUDA__MEM_1g56f30236c7c5247f8e061b59d3268362> "Copies memory from Device to Host."), [cuMemcpyHtoA](<group__CUDA__MEM.html#group__CUDA__MEM_1g57d3d780d165ecc0e3b3ce08e141cd89> "Copies memory from Host to Array."), [cuMemcpyHtoAAsync](<group__CUDA__MEM.html#group__CUDA__MEM_1gb5c4863f64f132b4bc2661818b3fd188> "Copies memory from Host to Array."), [cuMemcpyHtoD](<group__CUDA__MEM.html#group__CUDA__MEM_1g4d32266788c440b0220b1a9ba5795169> "Copies memory from Host to Device."), [cuMemcpyHtoDAsync](<group__CUDA__MEM.html#group__CUDA__MEM_1g1572263fe2597d7ba4f6964597a354a3> "Copies memory from Host to Device."), [cuMemFree](<group__CUDA__MEM.html#group__CUDA__MEM_1g89b3f154e17cc89b6eea277dbdf5c93a> "Frees device memory."), [cuMemFreeHost](<group__CUDA__MEM.html#group__CUDA__MEM_1g62e0fdbe181dab6b1c90fa1a51c7b92c> "Frees page-locked host memory."), [cuMemGetAddressRange](<group__CUDA__MEM.html#group__CUDA__MEM_1g64fee5711274a2a0573a789c94d8299b> "Get information on memory allocations."), [cuMemGetInfo](<group__CUDA__MEM.html#group__CUDA__MEM_1g808f555540d0143a331cc42aa98835c0> "Gets free and total memory."), [cuMemHostAlloc](<group__CUDA__MEM.html#group__CUDA__MEM_1g572ca4011bfcb25034888a14d4e035b9> "Allocates page-locked host memory."), [cuMemHostGetDevicePointer](<group__CUDA__MEM.html#group__CUDA__MEM_1g57a39e5cba26af4d06be67fc77cc62f0> "Passes back device pointer of mapped pinned memory."), [cuMemsetD2D8](<group__CUDA__MEM.html#group__CUDA__MEM_1ge88b13e646e2be6ba0e0475ef5205974> "Initializes device memory."), [cuMemsetD2D16](<group__CUDA__MEM.html#group__CUDA__MEM_1g7f561a15a66144fa9f6ab5350edc8a30> "Initializes device memory."), [cuMemsetD2D32](<group__CUDA__MEM.html#group__CUDA__MEM_1g74b359b2d026bfeb7c795b5038d07523> "Initializes device memory."), [cuMemsetD8](<group__CUDA__MEM.html#group__CUDA__MEM_1g6e582bf866e9e2fb014297bfaf354d7b> "Initializes device memory."), [cuMemsetD16](<group__CUDA__MEM.html#group__CUDA__MEM_1g7d805e610054392a4d11e8a8bf5eb35c> "Initializes device memory."), [cuMemsetD32](<group__CUDA__MEM.html#group__CUDA__MEM_1g983e8d8759acd1b64326317481fbf132> "Initializes device memory."), [cudaMemcpy2D](<../cuda-runtime-api/group__CUDART__MEMORY.html#group__CUDART__MEMORY_1g3a58270f6775efe56c65ac47843e7cee>), [cudaMemcpy2DToArray](<../cuda-runtime-api/group__CUDART__MEMORY.html#group__CUDART__MEMORY_1g9509226164aaa58baf0c5b8ed165df58>), [cudaMemcpy2DFromArray](<../cuda-runtime-api/group__CUDART__MEMORY.html#group__CUDART__MEMORY_1g0f944b3fd3c81edad0a352cf22de24f0>)

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuMemcpy3D ( const [CUDA_MEMCPY3D](<structCUDA__MEMCPY3D__v2.html#structCUDA__MEMCPY3D__v2>)*Â pCopy )


Copies memory for 3D arrays.

######  Parameters

`pCopy`
    \- Parameters for the memory copy

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_DEINITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9acf52f132faf29b473cdda6061f0f44a>), [CUDA_ERROR_NOT_INITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e98feb999f0af99b4a25ab26b3866f4df8>), [CUDA_ERROR_INVALID_CONTEXT](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a484e9af32c1e9893ff21f0e0191a12d>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>)

###### Description

Perform a 3D memory copy according to the parameters specified in `pCopy`. The CUDA_MEMCPY3D structure is defined as:


    â        typedef struct CUDA_MEMCPY3D_st {

                      unsigned int srcXInBytes, srcY, srcZ;
                      unsigned int srcLOD;
                      [CUmemorytype](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g8a114cc994ad2e865c44ef3838eaec72>) srcMemoryType;
                          const void *srcHost;
                          [CUdeviceptr](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g183f7b0d8ad008ea2a5fd552537ace4e>) srcDevice;
                          [CUarray](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gd550651524a56766b60f10f0e7628042>) srcArray;
                          unsigned int srcPitch;  // ignored when src is array
                          unsigned int srcHeight; // ignored when src is array; may be 0 if Depth==1

                      unsigned int dstXInBytes, dstY, dstZ;
                      unsigned int dstLOD;
                      [CUmemorytype](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g8a114cc994ad2e865c44ef3838eaec72>) dstMemoryType;
                          void *dstHost;
                          [CUdeviceptr](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g183f7b0d8ad008ea2a5fd552537ace4e>) dstDevice;
                          [CUarray](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gd550651524a56766b60f10f0e7628042>) dstArray;
                          unsigned int dstPitch;  // ignored when dst is array
                          unsigned int dstHeight; // ignored when dst is array; may be 0 if Depth==1

                      unsigned int WidthInBytes;
                      unsigned int Height;
                      unsigned int Depth;
                  } [CUDA_MEMCPY3D](<structCUDA__MEMCPY3D__v2.html#structCUDA__MEMCPY3D__v2>);

where:

  * srcMemoryType and dstMemoryType specify the type of memory of the source and destination, respectively; CUmemorytype_enum is defined as:




    â   typedef enum CUmemorytype_enum {
                [CU_MEMORYTYPE_HOST](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg8a114cc994ad2e865c44ef3838eaec727f98a88f26eec8490bfc180c5a73e101>) = 0x01,
                [CU_MEMORYTYPE_DEVICE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg8a114cc994ad2e865c44ef3838eaec72ec7e15ba4b111a26adb3487023707299>) = 0x02,
                [CU_MEMORYTYPE_ARRAY](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg8a114cc994ad2e865c44ef3838eaec72d7f97cd13a156651767607456fe25b66>) = 0x03,
                [CU_MEMORYTYPE_UNIFIED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg8a114cc994ad2e865c44ef3838eaec727a47ca2de6db5cf82084ad80ce66aa71>) = 0x04
             } [CUmemorytype](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g8a114cc994ad2e865c44ef3838eaec72>);

If srcMemoryType is [CU_MEMORYTYPE_UNIFIED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg8a114cc994ad2e865c44ef3838eaec727a47ca2de6db5cf82084ad80ce66aa71>), srcDevice and srcPitch specify the (unified virtual address space) base address of the source data and the bytes per row to apply. srcArray is ignored. This value may be used only if unified addressing is supported in the calling context.

If srcMemoryType is [CU_MEMORYTYPE_HOST](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg8a114cc994ad2e865c44ef3838eaec727f98a88f26eec8490bfc180c5a73e101>), srcHost, srcPitch and srcHeight specify the (host) base address of the source data, the bytes per row, and the height of each 2D slice of the 3D array. srcArray is ignored.

If srcMemoryType is [CU_MEMORYTYPE_DEVICE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg8a114cc994ad2e865c44ef3838eaec72ec7e15ba4b111a26adb3487023707299>), srcDevice, srcPitch and srcHeight specify the (device) base address of the source data, the bytes per row, and the height of each 2D slice of the 3D array. srcArray is ignored.

If srcMemoryType is [CU_MEMORYTYPE_ARRAY](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg8a114cc994ad2e865c44ef3838eaec72d7f97cd13a156651767607456fe25b66>), srcArray specifies the handle of the source data. srcHost, srcDevice, srcPitch and srcHeight are ignored.

If dstMemoryType is [CU_MEMORYTYPE_UNIFIED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg8a114cc994ad2e865c44ef3838eaec727a47ca2de6db5cf82084ad80ce66aa71>), dstDevice and dstPitch specify the (unified virtual address space) base address of the source data and the bytes per row to apply. dstArray is ignored. This value may be used only if unified addressing is supported in the calling context.

If dstMemoryType is [CU_MEMORYTYPE_HOST](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg8a114cc994ad2e865c44ef3838eaec727f98a88f26eec8490bfc180c5a73e101>), dstHost and dstPitch specify the (host) base address of the destination data, the bytes per row, and the height of each 2D slice of the 3D array. dstArray is ignored.

If dstMemoryType is [CU_MEMORYTYPE_DEVICE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg8a114cc994ad2e865c44ef3838eaec72ec7e15ba4b111a26adb3487023707299>), dstDevice and dstPitch specify the (device) base address of the destination data, the bytes per row, and the height of each 2D slice of the 3D array. dstArray is ignored.

If dstMemoryType is [CU_MEMORYTYPE_ARRAY](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg8a114cc994ad2e865c44ef3838eaec72d7f97cd13a156651767607456fe25b66>), dstArray specifies the handle of the destination data. dstHost, dstDevice, dstPitch and dstHeight are ignored.

  * srcXInBytes, srcY and srcZ specify the base address of the source data for the copy.


For host pointers, the starting address is


    â  void* Start = (void*)((char*)srcHost+(srcZ*srcHeight+srcY)*srcPitch + srcXInBytes);

For device pointers, the starting address is


    â  [CUdeviceptr](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g183f7b0d8ad008ea2a5fd552537ace4e>) Start = srcDevice+(srcZ*srcHeight+srcY)*srcPitch+srcXInBytes;

For CUDA arrays, srcXInBytes must be evenly divisible by the array element size.

  * dstXInBytes, dstY and dstZ specify the base address of the destination data for the copy.


For host pointers, the base address is


    â  void* dstStart = (void*)((char*)dstHost+(dstZ*dstHeight+dstY)*dstPitch + dstXInBytes);

For device pointers, the starting address is


    â  [CUdeviceptr](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g183f7b0d8ad008ea2a5fd552537ace4e>) dstStart = dstDevice+(dstZ*dstHeight+dstY)*dstPitch+dstXInBytes;

For CUDA arrays, dstXInBytes must be evenly divisible by the array element size.

  * WidthInBytes, Height and Depth specify the width (in bytes), height and depth of the 3D copy being performed.

  * If specified, srcPitch must be greater than or equal to WidthInBytes + srcXInBytes, and dstPitch must be greater than or equal to WidthInBytes + dstXInBytes.

  * If specified, srcHeight must be greater than or equal to Height + srcY, and dstHeight must be greater than or equal to Height \+ dstY.


[cuMemcpy3D()](<group__CUDA__MEM.html#group__CUDA__MEM_1g4b5238975579f002c0199a3800ca44df> "Copies memory for 3D arrays.") returns an error if any pitch is greater than the maximum allowed ([CU_DEVICE_ATTRIBUTE_MAX_PITCH](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gge12b8a782bebe21b1ac0091bf9f4e2a3c1625acc7a2db635bc1efae34030598d>)).

The srcLOD and dstLOD members of the CUDA_MEMCPY3D structure must be set to 0.

Note:

  * Note that this function may also return error codes from previous, asynchronous launches.

  * This function exhibits [synchronous](<api-sync-behavior.html#api-sync-behavior__memcpy-sync>) behavior for most use cases.


**See also:**

[cuArray3DCreate](<group__CUDA__MEM.html#group__CUDA__MEM_1gc2322c70b38c2984536c90ed118bb1d7> "Creates a 3D CUDA array."), [cuArray3DGetDescriptor](<group__CUDA__MEM.html#group__CUDA__MEM_1gb58549f2f3f390b9e0e7c8f3acd53857> "Get a 3D CUDA array descriptor."), [cuArrayCreate](<group__CUDA__MEM.html#group__CUDA__MEM_1g4192ff387a81c3bd5ed8c391ed62ca24> "Creates a 1D or 2D CUDA array."), [cuArrayDestroy](<group__CUDA__MEM.html#group__CUDA__MEM_1g982878affbbc023de84874faac838b0b> "Destroys a CUDA array."), [cuArrayGetDescriptor](<group__CUDA__MEM.html#group__CUDA__MEM_1g661fe823dbd37bf11f82a71bd4762acf> "Get a 1D or 2D CUDA array descriptor."), [cuMemAlloc](<group__CUDA__MEM.html#group__CUDA__MEM_1gb82d2a09844a58dd9e744dc31e8aa467> "Allocates device memory."), [cuMemAllocHost](<group__CUDA__MEM.html#group__CUDA__MEM_1gdd8311286d2c2691605362c689bc64e0> "Allocates page-locked host memory."), [cuMemAllocPitch](<group__CUDA__MEM.html#group__CUDA__MEM_1gcbe9b033f6c4de80f63cc6e58ed9a45a> "Allocates pitched device memory."), [cuMemcpy2D](<group__CUDA__MEM.html#group__CUDA__MEM_1g27f885b30c34cc20a663a671dbf6fc27> "Copies memory for 2D arrays."), [cuMemcpy2DAsync](<group__CUDA__MEM.html#group__CUDA__MEM_1g4acf155faeb969d9d21f5433d3d0f274> "Copies memory for 2D arrays."), [cuMemcpy2DUnaligned](<group__CUDA__MEM.html#group__CUDA__MEM_1g2fa285d47fd7020e596bfeab3deb651b> "Copies memory for 2D arrays."), [cuMemcpy3DAsync](<group__CUDA__MEM.html#group__CUDA__MEM_1g79f4f3fde6ae0f529568d881d9e11987> "Copies memory for 3D arrays."), [cuMemcpyAtoA](<group__CUDA__MEM.html#group__CUDA__MEM_1gf81b218c984a31436ec9e23a85fb604a> "Copies memory from Array to Array."), [cuMemcpyAtoD](<group__CUDA__MEM.html#group__CUDA__MEM_1g825b3f037f7f51382cae991bae8173fd> "Copies memory from Array to Device."), [cuMemcpyAtoH](<group__CUDA__MEM.html#group__CUDA__MEM_1gf7ad1edb2539cccc352c6b8b76f657f4> "Copies memory from Array to Host."), [cuMemcpyAtoHAsync](<group__CUDA__MEM.html#group__CUDA__MEM_1g64cbd2e60436699aebdd0bdbf14d0f01> "Copies memory from Array to Host."), [cuMemcpyDtoA](<group__CUDA__MEM.html#group__CUDA__MEM_1gad6827247af91600b56ce6e2ddb802e1> "Copies memory from Device to Array."), [cuMemcpyDtoD](<group__CUDA__MEM.html#group__CUDA__MEM_1g1725774abf8b51b91945f3336b778c8b> "Copies memory from Device to Device."), [cuMemcpyDtoDAsync](<group__CUDA__MEM.html#group__CUDA__MEM_1g39ea09ba682b8eccc9c3e0c04319b5c8> "Copies memory from Device to Device."), [cuMemcpyDtoH](<group__CUDA__MEM.html#group__CUDA__MEM_1g3480368ee0208a98f75019c9a8450893> "Copies memory from Device to Host."), [cuMemcpyDtoHAsync](<group__CUDA__MEM.html#group__CUDA__MEM_1g56f30236c7c5247f8e061b59d3268362> "Copies memory from Device to Host."), [cuMemcpyHtoA](<group__CUDA__MEM.html#group__CUDA__MEM_1g57d3d780d165ecc0e3b3ce08e141cd89> "Copies memory from Host to Array."), [cuMemcpyHtoAAsync](<group__CUDA__MEM.html#group__CUDA__MEM_1gb5c4863f64f132b4bc2661818b3fd188> "Copies memory from Host to Array."), [cuMemcpyHtoD](<group__CUDA__MEM.html#group__CUDA__MEM_1g4d32266788c440b0220b1a9ba5795169> "Copies memory from Host to Device."), [cuMemcpyHtoDAsync](<group__CUDA__MEM.html#group__CUDA__MEM_1g1572263fe2597d7ba4f6964597a354a3> "Copies memory from Host to Device."), [cuMemFree](<group__CUDA__MEM.html#group__CUDA__MEM_1g89b3f154e17cc89b6eea277dbdf5c93a> "Frees device memory."), [cuMemFreeHost](<group__CUDA__MEM.html#group__CUDA__MEM_1g62e0fdbe181dab6b1c90fa1a51c7b92c> "Frees page-locked host memory."), [cuMemGetAddressRange](<group__CUDA__MEM.html#group__CUDA__MEM_1g64fee5711274a2a0573a789c94d8299b> "Get information on memory allocations."), [cuMemGetInfo](<group__CUDA__MEM.html#group__CUDA__MEM_1g808f555540d0143a331cc42aa98835c0> "Gets free and total memory."), [cuMemHostAlloc](<group__CUDA__MEM.html#group__CUDA__MEM_1g572ca4011bfcb25034888a14d4e035b9> "Allocates page-locked host memory."), [cuMemHostGetDevicePointer](<group__CUDA__MEM.html#group__CUDA__MEM_1g57a39e5cba26af4d06be67fc77cc62f0> "Passes back device pointer of mapped pinned memory."), [cuMemsetD2D8](<group__CUDA__MEM.html#group__CUDA__MEM_1ge88b13e646e2be6ba0e0475ef5205974> "Initializes device memory."), [cuMemsetD2D16](<group__CUDA__MEM.html#group__CUDA__MEM_1g7f561a15a66144fa9f6ab5350edc8a30> "Initializes device memory."), [cuMemsetD2D32](<group__CUDA__MEM.html#group__CUDA__MEM_1g74b359b2d026bfeb7c795b5038d07523> "Initializes device memory."), [cuMemsetD8](<group__CUDA__MEM.html#group__CUDA__MEM_1g6e582bf866e9e2fb014297bfaf354d7b> "Initializes device memory."), [cuMemsetD16](<group__CUDA__MEM.html#group__CUDA__MEM_1g7d805e610054392a4d11e8a8bf5eb35c> "Initializes device memory."), [cuMemsetD32](<group__CUDA__MEM.html#group__CUDA__MEM_1g983e8d8759acd1b64326317481fbf132> "Initializes device memory."), [cudaMemcpy3D](<../cuda-runtime-api/group__CUDART__MEMORY.html#group__CUDART__MEMORY_1gfec7ee5257d48c8528a709ffad48d208>)

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuMemcpy3DAsync ( const [CUDA_MEMCPY3D](<structCUDA__MEMCPY3D__v2.html#structCUDA__MEMCPY3D__v2>)*Â pCopy, [CUstream](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gb946c7f02e09efd788a204718015d88a>)Â hStream )


Copies memory for 3D arrays.

######  Parameters

`pCopy`
    \- Parameters for the memory copy
`hStream`
    \- Stream identifier

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_DEINITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9acf52f132faf29b473cdda6061f0f44a>), [CUDA_ERROR_NOT_INITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e98feb999f0af99b4a25ab26b3866f4df8>), [CUDA_ERROR_INVALID_CONTEXT](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a484e9af32c1e9893ff21f0e0191a12d>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>), [CUDA_ERROR_INVALID_HANDLE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e90fd2e63260c6317ba943af0f7e4b8d21>)

###### Description

Perform a 3D memory copy according to the parameters specified in `pCopy`. The CUDA_MEMCPY3D structure is defined as:


    â        typedef struct CUDA_MEMCPY3D_st {

                      unsigned int srcXInBytes, srcY, srcZ;
                      unsigned int srcLOD;
                      [CUmemorytype](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g8a114cc994ad2e865c44ef3838eaec72>) srcMemoryType;
                          const void *srcHost;
                          [CUdeviceptr](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g183f7b0d8ad008ea2a5fd552537ace4e>) srcDevice;
                          [CUarray](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gd550651524a56766b60f10f0e7628042>) srcArray;
                          unsigned int srcPitch;  // ignored when src is array
                          unsigned int srcHeight; // ignored when src is array; may be 0 if Depth==1

                      unsigned int dstXInBytes, dstY, dstZ;
                      unsigned int dstLOD;
                      [CUmemorytype](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g8a114cc994ad2e865c44ef3838eaec72>) dstMemoryType;
                          void *dstHost;
                          [CUdeviceptr](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g183f7b0d8ad008ea2a5fd552537ace4e>) dstDevice;
                          [CUarray](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gd550651524a56766b60f10f0e7628042>) dstArray;
                          unsigned int dstPitch;  // ignored when dst is array
                          unsigned int dstHeight; // ignored when dst is array; may be 0 if Depth==1

                      unsigned int WidthInBytes;
                      unsigned int Height;
                      unsigned int Depth;
                  } [CUDA_MEMCPY3D](<structCUDA__MEMCPY3D__v2.html#structCUDA__MEMCPY3D__v2>);

where:

  * srcMemoryType and dstMemoryType specify the type of memory of the source and destination, respectively; CUmemorytype_enum is defined as:




    â   typedef enum CUmemorytype_enum {
                [CU_MEMORYTYPE_HOST](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg8a114cc994ad2e865c44ef3838eaec727f98a88f26eec8490bfc180c5a73e101>) = 0x01,
                [CU_MEMORYTYPE_DEVICE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg8a114cc994ad2e865c44ef3838eaec72ec7e15ba4b111a26adb3487023707299>) = 0x02,
                [CU_MEMORYTYPE_ARRAY](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg8a114cc994ad2e865c44ef3838eaec72d7f97cd13a156651767607456fe25b66>) = 0x03,
                [CU_MEMORYTYPE_UNIFIED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg8a114cc994ad2e865c44ef3838eaec727a47ca2de6db5cf82084ad80ce66aa71>) = 0x04
             } [CUmemorytype](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g8a114cc994ad2e865c44ef3838eaec72>);

If srcMemoryType is [CU_MEMORYTYPE_UNIFIED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg8a114cc994ad2e865c44ef3838eaec727a47ca2de6db5cf82084ad80ce66aa71>), srcDevice and srcPitch specify the (unified virtual address space) base address of the source data and the bytes per row to apply. srcArray is ignored. This value may be used only if unified addressing is supported in the calling context.

If srcMemoryType is [CU_MEMORYTYPE_HOST](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg8a114cc994ad2e865c44ef3838eaec727f98a88f26eec8490bfc180c5a73e101>), srcHost, srcPitch and srcHeight specify the (host) base address of the source data, the bytes per row, and the height of each 2D slice of the 3D array. srcArray is ignored.

If srcMemoryType is [CU_MEMORYTYPE_DEVICE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg8a114cc994ad2e865c44ef3838eaec72ec7e15ba4b111a26adb3487023707299>), srcDevice, srcPitch and srcHeight specify the (device) base address of the source data, the bytes per row, and the height of each 2D slice of the 3D array. srcArray is ignored.

If srcMemoryType is [CU_MEMORYTYPE_ARRAY](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg8a114cc994ad2e865c44ef3838eaec72d7f97cd13a156651767607456fe25b66>), srcArray specifies the handle of the source data. srcHost, srcDevice, srcPitch and srcHeight are ignored.

If dstMemoryType is [CU_MEMORYTYPE_UNIFIED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg8a114cc994ad2e865c44ef3838eaec727a47ca2de6db5cf82084ad80ce66aa71>), dstDevice and dstPitch specify the (unified virtual address space) base address of the source data and the bytes per row to apply. dstArray is ignored. This value may be used only if unified addressing is supported in the calling context.

If dstMemoryType is [CU_MEMORYTYPE_HOST](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg8a114cc994ad2e865c44ef3838eaec727f98a88f26eec8490bfc180c5a73e101>), dstHost and dstPitch specify the (host) base address of the destination data, the bytes per row, and the height of each 2D slice of the 3D array. dstArray is ignored.

If dstMemoryType is [CU_MEMORYTYPE_DEVICE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg8a114cc994ad2e865c44ef3838eaec72ec7e15ba4b111a26adb3487023707299>), dstDevice and dstPitch specify the (device) base address of the destination data, the bytes per row, and the height of each 2D slice of the 3D array. dstArray is ignored.

If dstMemoryType is [CU_MEMORYTYPE_ARRAY](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg8a114cc994ad2e865c44ef3838eaec72d7f97cd13a156651767607456fe25b66>), dstArray specifies the handle of the destination data. dstHost, dstDevice, dstPitch and dstHeight are ignored.

  * srcXInBytes, srcY and srcZ specify the base address of the source data for the copy.


For host pointers, the starting address is


    â  void* Start = (void*)((char*)srcHost+(srcZ*srcHeight+srcY)*srcPitch + srcXInBytes);

For device pointers, the starting address is


    â  [CUdeviceptr](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g183f7b0d8ad008ea2a5fd552537ace4e>) Start = srcDevice+(srcZ*srcHeight+srcY)*srcPitch+srcXInBytes;

For CUDA arrays, srcXInBytes must be evenly divisible by the array element size.

  * dstXInBytes, dstY and dstZ specify the base address of the destination data for the copy.


For host pointers, the base address is


    â  void* dstStart = (void*)((char*)dstHost+(dstZ*dstHeight+dstY)*dstPitch + dstXInBytes);

For device pointers, the starting address is


    â  [CUdeviceptr](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g183f7b0d8ad008ea2a5fd552537ace4e>) dstStart = dstDevice+(dstZ*dstHeight+dstY)*dstPitch+dstXInBytes;

For CUDA arrays, dstXInBytes must be evenly divisible by the array element size.

  * WidthInBytes, Height and Depth specify the width (in bytes), height and depth of the 3D copy being performed.

  * If specified, srcPitch must be greater than or equal to WidthInBytes + srcXInBytes, and dstPitch must be greater than or equal to WidthInBytes + dstXInBytes.

  * If specified, srcHeight must be greater than or equal to Height + srcY, and dstHeight must be greater than or equal to Height \+ dstY.


[cuMemcpy3DAsync()](<group__CUDA__MEM.html#group__CUDA__MEM_1g79f4f3fde6ae0f529568d881d9e11987> "Copies memory for 3D arrays.") returns an error if any pitch is greater than the maximum allowed ([CU_DEVICE_ATTRIBUTE_MAX_PITCH](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gge12b8a782bebe21b1ac0091bf9f4e2a3c1625acc7a2db635bc1efae34030598d>)).

The srcLOD and dstLOD members of the CUDA_MEMCPY3D structure must be set to 0.

Note:

  * Note that this function may also return error codes from previous, asynchronous launches.

  * This function exhibits [asynchronous](<api-sync-behavior.html#api-sync-behavior__memcpy-async>) behavior for most use cases.

  * This function uses standard [default stream](<stream-sync-behavior.html#stream-sync-behavior__default-stream>) semantics.


**See also:**

[cuArray3DCreate](<group__CUDA__MEM.html#group__CUDA__MEM_1gc2322c70b38c2984536c90ed118bb1d7> "Creates a 3D CUDA array."), [cuArray3DGetDescriptor](<group__CUDA__MEM.html#group__CUDA__MEM_1gb58549f2f3f390b9e0e7c8f3acd53857> "Get a 3D CUDA array descriptor."), [cuArrayCreate](<group__CUDA__MEM.html#group__CUDA__MEM_1g4192ff387a81c3bd5ed8c391ed62ca24> "Creates a 1D or 2D CUDA array."), [cuArrayDestroy](<group__CUDA__MEM.html#group__CUDA__MEM_1g982878affbbc023de84874faac838b0b> "Destroys a CUDA array."), [cuArrayGetDescriptor](<group__CUDA__MEM.html#group__CUDA__MEM_1g661fe823dbd37bf11f82a71bd4762acf> "Get a 1D or 2D CUDA array descriptor."), [cuMemAlloc](<group__CUDA__MEM.html#group__CUDA__MEM_1gb82d2a09844a58dd9e744dc31e8aa467> "Allocates device memory."), [cuMemAllocHost](<group__CUDA__MEM.html#group__CUDA__MEM_1gdd8311286d2c2691605362c689bc64e0> "Allocates page-locked host memory."), [cuMemAllocPitch](<group__CUDA__MEM.html#group__CUDA__MEM_1gcbe9b033f6c4de80f63cc6e58ed9a45a> "Allocates pitched device memory."), [cuMemcpy2D](<group__CUDA__MEM.html#group__CUDA__MEM_1g27f885b30c34cc20a663a671dbf6fc27> "Copies memory for 2D arrays."), [cuMemcpy2DAsync](<group__CUDA__MEM.html#group__CUDA__MEM_1g4acf155faeb969d9d21f5433d3d0f274> "Copies memory for 2D arrays."), [cuMemcpy2DUnaligned](<group__CUDA__MEM.html#group__CUDA__MEM_1g2fa285d47fd7020e596bfeab3deb651b> "Copies memory for 2D arrays."), [cuMemcpy3D](<group__CUDA__MEM.html#group__CUDA__MEM_1g4b5238975579f002c0199a3800ca44df> "Copies memory for 3D arrays."), [cuMemcpyAtoA](<group__CUDA__MEM.html#group__CUDA__MEM_1gf81b218c984a31436ec9e23a85fb604a> "Copies memory from Array to Array."), [cuMemcpyAtoD](<group__CUDA__MEM.html#group__CUDA__MEM_1g825b3f037f7f51382cae991bae8173fd> "Copies memory from Array to Device."), [cuMemcpyAtoH](<group__CUDA__MEM.html#group__CUDA__MEM_1gf7ad1edb2539cccc352c6b8b76f657f4> "Copies memory from Array to Host."), [cuMemcpyAtoHAsync](<group__CUDA__MEM.html#group__CUDA__MEM_1g64cbd2e60436699aebdd0bdbf14d0f01> "Copies memory from Array to Host."), [cuMemcpyDtoA](<group__CUDA__MEM.html#group__CUDA__MEM_1gad6827247af91600b56ce6e2ddb802e1> "Copies memory from Device to Array."), [cuMemcpyDtoD](<group__CUDA__MEM.html#group__CUDA__MEM_1g1725774abf8b51b91945f3336b778c8b> "Copies memory from Device to Device."), [cuMemcpyDtoDAsync](<group__CUDA__MEM.html#group__CUDA__MEM_1g39ea09ba682b8eccc9c3e0c04319b5c8> "Copies memory from Device to Device."), [cuMemcpyDtoH](<group__CUDA__MEM.html#group__CUDA__MEM_1g3480368ee0208a98f75019c9a8450893> "Copies memory from Device to Host."), [cuMemcpyDtoHAsync](<group__CUDA__MEM.html#group__CUDA__MEM_1g56f30236c7c5247f8e061b59d3268362> "Copies memory from Device to Host."), [cuMemcpyHtoA](<group__CUDA__MEM.html#group__CUDA__MEM_1g57d3d780d165ecc0e3b3ce08e141cd89> "Copies memory from Host to Array."), [cuMemcpyHtoAAsync](<group__CUDA__MEM.html#group__CUDA__MEM_1gb5c4863f64f132b4bc2661818b3fd188> "Copies memory from Host to Array."), [cuMemcpyHtoD](<group__CUDA__MEM.html#group__CUDA__MEM_1g4d32266788c440b0220b1a9ba5795169> "Copies memory from Host to Device."), [cuMemcpyHtoDAsync](<group__CUDA__MEM.html#group__CUDA__MEM_1g1572263fe2597d7ba4f6964597a354a3> "Copies memory from Host to Device."), [cuMemFree](<group__CUDA__MEM.html#group__CUDA__MEM_1g89b3f154e17cc89b6eea277dbdf5c93a> "Frees device memory."), [cuMemFreeHost](<group__CUDA__MEM.html#group__CUDA__MEM_1g62e0fdbe181dab6b1c90fa1a51c7b92c> "Frees page-locked host memory."), [cuMemGetAddressRange](<group__CUDA__MEM.html#group__CUDA__MEM_1g64fee5711274a2a0573a789c94d8299b> "Get information on memory allocations."), [cuMemGetInfo](<group__CUDA__MEM.html#group__CUDA__MEM_1g808f555540d0143a331cc42aa98835c0> "Gets free and total memory."), [cuMemHostAlloc](<group__CUDA__MEM.html#group__CUDA__MEM_1g572ca4011bfcb25034888a14d4e035b9> "Allocates page-locked host memory."), [cuMemHostGetDevicePointer](<group__CUDA__MEM.html#group__CUDA__MEM_1g57a39e5cba26af4d06be67fc77cc62f0> "Passes back device pointer of mapped pinned memory."), [cuMemsetD2D8](<group__CUDA__MEM.html#group__CUDA__MEM_1ge88b13e646e2be6ba0e0475ef5205974> "Initializes device memory."), [cuMemsetD2D8Async](<group__CUDA__MEM.html#group__CUDA__MEM_1g3f7b6924a3e49c3265b328f534102e97> "Sets device memory."), [cuMemsetD2D16](<group__CUDA__MEM.html#group__CUDA__MEM_1g7f561a15a66144fa9f6ab5350edc8a30> "Initializes device memory."), [cuMemsetD2D16Async](<group__CUDA__MEM.html#group__CUDA__MEM_1g64ee197befac3d74d9fefedcf6ef6b10> "Sets device memory."), [cuMemsetD2D32](<group__CUDA__MEM.html#group__CUDA__MEM_1g74b359b2d026bfeb7c795b5038d07523> "Initializes device memory."), [cuMemsetD2D32Async](<group__CUDA__MEM.html#group__CUDA__MEM_1g8a78d3147ac93fac955052c815d9ea3c> "Sets device memory."), [cuMemsetD8](<group__CUDA__MEM.html#group__CUDA__MEM_1g6e582bf866e9e2fb014297bfaf354d7b> "Initializes device memory."), [cuMemsetD8Async](<group__CUDA__MEM.html#group__CUDA__MEM_1gaef08a7ccd61112f94e82f2b30d43627> "Sets device memory."), [cuMemsetD16](<group__CUDA__MEM.html#group__CUDA__MEM_1g7d805e610054392a4d11e8a8bf5eb35c> "Initializes device memory."), [cuMemsetD16Async](<group__CUDA__MEM.html#group__CUDA__MEM_1gf731438877dd8ec875e4c43d848c878c> "Sets device memory."), [cuMemsetD32](<group__CUDA__MEM.html#group__CUDA__MEM_1g983e8d8759acd1b64326317481fbf132> "Initializes device memory."), [cuMemsetD32Async](<group__CUDA__MEM.html#group__CUDA__MEM_1g58229da5d30f1c0cdf667b320ec2c0f5> "Sets device memory."), [cudaMemcpy3DAsync](<../cuda-runtime-api/group__CUDART__MEMORY.html#group__CUDART__MEMORY_1g785bd0963e476a740533382a67674641>)

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuMemcpy3DBatchAsync ( size_tÂ numOps, CUDA_MEMCPY3D_BATCH_OP*Â opList, unsigned long longÂ flags, [CUstream](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gb946c7f02e09efd788a204718015d88a>)Â hStream )


Performs a batch of 3D memory copies asynchronously.

######  Parameters

`numOps`
    \- Total number of memcpy operations.
`opList`
    \- Array of size `numOps` containing the actual memcpy operations.
`flags`
    \- Flags for future use, must be zero now.
`hStream`
    \- The stream to enqueue the operations in. Must not be default NULL stream.

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_DEINITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9acf52f132faf29b473cdda6061f0f44a>), [CUDA_ERROR_NOT_INITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e98feb999f0af99b4a25ab26b3866f4df8>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>)

###### Description

Performs a batch of memory copies. The batch as a whole executes in stream order but copies within a batch are not guaranteed to execute in any specific order. Note that this means specifying any dependent copies within a batch will result in undefined behavior.

Performs memory copies as specified in the `opList` array. The length of this array is specified in `numOps`. Each entry in this array describes a copy operation. This includes among other things, the source and destination operands for the copy as specified in CUDA_MEMCPY3D_BATCH_OP::src and CUDA_MEMCPY3D_BATCH_OP::dst respectively. The source and destination operands of a copy can either be a pointer or a CUDA array. The width, height and depth of a copy is specified in CUDA_MEMCPY3D_BATCH_OP::extent. The width, height and depth of a copy are specified in elements and must not be zero. For pointer-to-pointer copies, the element size is considered to be 1. For pointer to CUDA array or vice versa copies, the element size is determined by the CUDA array. For CUDA array to CUDA array copies, the element size of the two CUDA arrays must match.

For a given operand, if CUmemcpy3DOperand::type is specified as [CU_MEMCPY_OPERAND_TYPE_POINTER](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg507c7c67580a9b998fd8a59ce883c7d4c8f57f3e6c8b3863359d15cf89aaa593>), then CUmemcpy3DOperand::op::ptr will be used. The CUmemcpy3DOperand::op::ptr::ptr field must contain the pointer where the copy should begin. The CUmemcpy3DOperand::op::ptr::rowLength field specifies the length of each row in elements and must either be zero or be greater than or equal to the width of the copy specified in CUDA_MEMCPY3D_BATCH_OP::extent::width. The CUmemcpy3DOperand::op::ptr::layerHeight field specifies the height of each layer and must either be zero or be greater than or equal to the height of the copy specified in CUDA_MEMCPY3D_BATCH_OP::extent::height. When either of these values is zero, that aspect of the operand is considered to be tightly packed according to the copy extent. For managed memory pointers on devices where [CU_DEVICE_ATTRIBUTE_CONCURRENT_MANAGED_ACCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gge12b8a782bebe21b1ac0091bf9f4e2a333110e44c9cb6ead02f03ff6f6fd495e>) is true or system-allocated pageable memory on devices where [CU_DEVICE_ATTRIBUTE_PAGEABLE_MEMORY_ACCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gge12b8a782bebe21b1ac0091bf9f4e2a35fdcdbe1dfc3ad5ec428c279e0efb9cd>) is true, the CUmemcpy3DOperand::op::ptr::locHint field can be used to hint the location of the operand.

If an operand's type is specified as [CU_MEMCPY_OPERAND_TYPE_ARRAY](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg507c7c67580a9b998fd8a59ce883c7d416fd927c15c167e4e734e657f9aa323b>), then CUmemcpy3DOperand::op::array will be used. The CUmemcpy3DOperand::op::array::array field specifies the CUDA array and CUmemcpy3DOperand::op::array::offset specifies the 3D offset into that array where the copy begins.

The [CUmemcpyAttributes::srcAccessOrder](<structCUmemcpyAttributes__v1.html#structCUmemcpyAttributes__v1_1d152922b22834808ca5714f688400761>) indicates the source access ordering to be observed for copies associated with the attribute. If the source access order is set to [CU_MEMCPY_SRC_ACCESS_ORDER_STREAM](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg88fcbe39c3714884fcd1ca9d3b9e425183a1e3dd6ef4b91364f645443d183c70>), then the source will be accessed in stream order. If the source access order is set to [CU_MEMCPY_SRC_ACCESS_ORDER_DURING_API_CALL](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg88fcbe39c3714884fcd1ca9d3b9e4251d05487493fc2a9ba99d4ccdc834a4266>) then it indicates that access to the source pointer can be out of stream order and all accesses must be complete before the API call returns. This flag is suited for ephemeral sources (ex., stack variables) when it's known that no prior operations in the stream can be accessing the memory and also that the lifetime of the memory is limited to the scope that the source variable was declared in. Specifying this flag allows the driver to optimize the copy and removes the need for the user to synchronize the stream after the API call. If the source access order is set to [CU_MEMCPY_SRC_ACCESS_ORDER_ANY](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg88fcbe39c3714884fcd1ca9d3b9e4251f9cb69c7dc969e7f9350e5749b310314>) then it indicates that access to the source pointer can be out of stream order and the accesses can happen even after the API call returns. This flag is suited for host pointers allocated outside CUDA (ex., via malloc) when it's known that no prior operations in the stream can be accessing the memory. Specifying this flag allows the driver to optimize the copy on certain platforms. Each memcopy operation in `opList` must have a valid srcAccessOrder setting, otherwise this API will return [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>).

The [CUmemcpyAttributes::flags](<structCUmemcpyAttributes__v1.html#structCUmemcpyAttributes__v1_10c9ad8770c38c992894a6870991127e4>) field can be used to specify certain flags for copies. Setting the [CU_MEMCPY_FLAG_PREFER_OVERLAP_WITH_COMPUTE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg0badb1f4f792793fdcf4a78593b4655a4c2b776afc2c1570cc93d48984b4d794>) flag indicates that the associated copies should preferably overlap with any compute work. Note that this flag is a hint and can be ignored depending on the platform and other parameters of the copy.

Note:

  * Note that this function may also return error codes from previous, asynchronous launches.

  * This function exhibits [asynchronous](<api-sync-behavior.html#api-sync-behavior__memcpy-async>) behavior for most use cases.

  * Memory regions requested must be either entirely registered with CUDA, or in the case of host pageable transfers, not registered at all. Memory regions spanning over allocations that are both registered and not registered with CUDA are not supported and will return CUDA_ERROR_INVALID_VALUE.


[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuMemcpy3DPeer ( const [CUDA_MEMCPY3D_PEER](<structCUDA__MEMCPY3D__PEER__v1.html#structCUDA__MEMCPY3D__PEER__v1>)*Â pCopy )


Copies memory between contexts.

######  Parameters

`pCopy`
    \- Parameters for the memory copy

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_DEINITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9acf52f132faf29b473cdda6061f0f44a>), [CUDA_ERROR_NOT_INITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e98feb999f0af99b4a25ab26b3866f4df8>), [CUDA_ERROR_INVALID_CONTEXT](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a484e9af32c1e9893ff21f0e0191a12d>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>)

###### Description

Perform a 3D memory copy according to the parameters specified in `pCopy`. See the definition of the CUDA_MEMCPY3D_PEER structure for documentation of its parameters.

Note:

  * Note that this function may also return error codes from previous, asynchronous launches.

  * This function exhibits [synchronous](<api-sync-behavior.html#api-sync-behavior__memcpy-sync>) behavior for most use cases.


**See also:**

[cuMemcpyDtoD](<group__CUDA__MEM.html#group__CUDA__MEM_1g1725774abf8b51b91945f3336b778c8b> "Copies memory from Device to Device."), [cuMemcpyPeer](<group__CUDA__MEM.html#group__CUDA__MEM_1ge1f5c7771544fee150ada8853c7cbf4a> "Copies device memory between two contexts."), [cuMemcpyDtoDAsync](<group__CUDA__MEM.html#group__CUDA__MEM_1g39ea09ba682b8eccc9c3e0c04319b5c8> "Copies memory from Device to Device."), [cuMemcpyPeerAsync](<group__CUDA__MEM.html#group__CUDA__MEM_1g82fcecb38018e64b98616a8ac30112f2> "Copies device memory between two contexts asynchronously."), [cuMemcpy3DPeerAsync](<group__CUDA__MEM.html#group__CUDA__MEM_1gc4e4bfd9f627d3aa3695979e058f1bb8> "Copies memory between contexts asynchronously."), [cudaMemcpy3DPeer](<../cuda-runtime-api/group__CUDART__MEMORY.html#group__CUDART__MEMORY_1geeab4601354962a5968eefc8b79ec2dd>)

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuMemcpy3DPeerAsync ( const [CUDA_MEMCPY3D_PEER](<structCUDA__MEMCPY3D__PEER__v1.html#structCUDA__MEMCPY3D__PEER__v1>)*Â pCopy, [CUstream](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gb946c7f02e09efd788a204718015d88a>)Â hStream )


Copies memory between contexts asynchronously.

######  Parameters

`pCopy`
    \- Parameters for the memory copy
`hStream`
    \- Stream identifier

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_DEINITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9acf52f132faf29b473cdda6061f0f44a>), [CUDA_ERROR_NOT_INITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e98feb999f0af99b4a25ab26b3866f4df8>), [CUDA_ERROR_INVALID_CONTEXT](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a484e9af32c1e9893ff21f0e0191a12d>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>)

###### Description

Perform a 3D memory copy according to the parameters specified in `pCopy`. See the definition of the CUDA_MEMCPY3D_PEER structure for documentation of its parameters.

Note:

  * Note that this function may also return error codes from previous, asynchronous launches.

  * This function exhibits [asynchronous](<api-sync-behavior.html#api-sync-behavior__memcpy-async>) behavior for most use cases.

  * This function uses standard [default stream](<stream-sync-behavior.html#stream-sync-behavior__default-stream>) semantics.


**See also:**

[cuMemcpyDtoD](<group__CUDA__MEM.html#group__CUDA__MEM_1g1725774abf8b51b91945f3336b778c8b> "Copies memory from Device to Device."), [cuMemcpyPeer](<group__CUDA__MEM.html#group__CUDA__MEM_1ge1f5c7771544fee150ada8853c7cbf4a> "Copies device memory between two contexts."), [cuMemcpyDtoDAsync](<group__CUDA__MEM.html#group__CUDA__MEM_1g39ea09ba682b8eccc9c3e0c04319b5c8> "Copies memory from Device to Device."), [cuMemcpyPeerAsync](<group__CUDA__MEM.html#group__CUDA__MEM_1g82fcecb38018e64b98616a8ac30112f2> "Copies device memory between two contexts asynchronously."), [cuMemcpy3DPeerAsync](<group__CUDA__MEM.html#group__CUDA__MEM_1gc4e4bfd9f627d3aa3695979e058f1bb8> "Copies memory between contexts asynchronously."), [cudaMemcpy3DPeerAsync](<../cuda-runtime-api/group__CUDART__MEMORY.html#group__CUDART__MEMORY_1g7386b2845149b48c87f82ea017690aa8>)

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuMemcpyAsync ( [CUdeviceptr](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g183f7b0d8ad008ea2a5fd552537ace4e>)Â dst, [CUdeviceptr](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g183f7b0d8ad008ea2a5fd552537ace4e>)Â src, size_tÂ ByteCount, [CUstream](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gb946c7f02e09efd788a204718015d88a>)Â hStream )


Copies memory asynchronously.

######  Parameters

`dst`
    \- Destination unified virtual address space pointer
`src`
    \- Source unified virtual address space pointer
`ByteCount`
    \- Size of memory copy in bytes
`hStream`
    \- Stream identifier

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_DEINITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9acf52f132faf29b473cdda6061f0f44a>), [CUDA_ERROR_NOT_INITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e98feb999f0af99b4a25ab26b3866f4df8>), [CUDA_ERROR_INVALID_CONTEXT](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a484e9af32c1e9893ff21f0e0191a12d>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>), [CUDA_ERROR_INVALID_HANDLE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e90fd2e63260c6317ba943af0f7e4b8d21>)

###### Description

Copies data between two pointers. `dst` and `src` are base pointers of the destination and source, respectively. `ByteCount` specifies the number of bytes to copy. Note that this function infers the type of the transfer (host to host, host to device, device to device, or device to host) from the pointer values. This function is only allowed in contexts which support unified addressing.

Note:

  * Note that this function may also return error codes from previous, asynchronous launches.

  * This function exhibits [asynchronous](<api-sync-behavior.html#api-sync-behavior__memcpy-async>) behavior for most use cases.

  * This function uses standard [default stream](<stream-sync-behavior.html#stream-sync-behavior__default-stream>) semantics.

  * Memory regions requested must be either entirely registered with CUDA, or in the case of host pageable transfers, not registered at all. Memory regions spanning over allocations that are both registered and not registered with CUDA are not supported and will return CUDA_ERROR_INVALID_VALUE.


**See also:**

[cuArray3DCreate](<group__CUDA__MEM.html#group__CUDA__MEM_1gc2322c70b38c2984536c90ed118bb1d7> "Creates a 3D CUDA array."), [cuArray3DGetDescriptor](<group__CUDA__MEM.html#group__CUDA__MEM_1gb58549f2f3f390b9e0e7c8f3acd53857> "Get a 3D CUDA array descriptor."), [cuArrayCreate](<group__CUDA__MEM.html#group__CUDA__MEM_1g4192ff387a81c3bd5ed8c391ed62ca24> "Creates a 1D or 2D CUDA array."), [cuArrayDestroy](<group__CUDA__MEM.html#group__CUDA__MEM_1g982878affbbc023de84874faac838b0b> "Destroys a CUDA array."), [cuArrayGetDescriptor](<group__CUDA__MEM.html#group__CUDA__MEM_1g661fe823dbd37bf11f82a71bd4762acf> "Get a 1D or 2D CUDA array descriptor."), [cuMemAlloc](<group__CUDA__MEM.html#group__CUDA__MEM_1gb82d2a09844a58dd9e744dc31e8aa467> "Allocates device memory."), [cuMemAllocHost](<group__CUDA__MEM.html#group__CUDA__MEM_1gdd8311286d2c2691605362c689bc64e0> "Allocates page-locked host memory."), [cuMemAllocPitch](<group__CUDA__MEM.html#group__CUDA__MEM_1gcbe9b033f6c4de80f63cc6e58ed9a45a> "Allocates pitched device memory."), [cuMemcpy2D](<group__CUDA__MEM.html#group__CUDA__MEM_1g27f885b30c34cc20a663a671dbf6fc27> "Copies memory for 2D arrays."), [cuMemcpy2DAsync](<group__CUDA__MEM.html#group__CUDA__MEM_1g4acf155faeb969d9d21f5433d3d0f274> "Copies memory for 2D arrays."), [cuMemcpy2DUnaligned](<group__CUDA__MEM.html#group__CUDA__MEM_1g2fa285d47fd7020e596bfeab3deb651b> "Copies memory for 2D arrays."), [cuMemcpy3D](<group__CUDA__MEM.html#group__CUDA__MEM_1g4b5238975579f002c0199a3800ca44df> "Copies memory for 3D arrays."), [cuMemcpy3DAsync](<group__CUDA__MEM.html#group__CUDA__MEM_1g79f4f3fde6ae0f529568d881d9e11987> "Copies memory for 3D arrays."), [cuMemcpyAtoA](<group__CUDA__MEM.html#group__CUDA__MEM_1gf81b218c984a31436ec9e23a85fb604a> "Copies memory from Array to Array."), [cuMemcpyAtoD](<group__CUDA__MEM.html#group__CUDA__MEM_1g825b3f037f7f51382cae991bae8173fd> "Copies memory from Array to Device."), [cuMemcpyAtoH](<group__CUDA__MEM.html#group__CUDA__MEM_1gf7ad1edb2539cccc352c6b8b76f657f4> "Copies memory from Array to Host."), [cuMemcpyAtoHAsync](<group__CUDA__MEM.html#group__CUDA__MEM_1g64cbd2e60436699aebdd0bdbf14d0f01> "Copies memory from Array to Host."), [cuMemcpyDtoA](<group__CUDA__MEM.html#group__CUDA__MEM_1gad6827247af91600b56ce6e2ddb802e1> "Copies memory from Device to Array."), [cuMemcpyDtoD](<group__CUDA__MEM.html#group__CUDA__MEM_1g1725774abf8b51b91945f3336b778c8b> "Copies memory from Device to Device."), [cuMemcpyDtoH](<group__CUDA__MEM.html#group__CUDA__MEM_1g3480368ee0208a98f75019c9a8450893> "Copies memory from Device to Host."), [cuMemcpyDtoHAsync](<group__CUDA__MEM.html#group__CUDA__MEM_1g56f30236c7c5247f8e061b59d3268362> "Copies memory from Device to Host."), [cuMemcpyHtoA](<group__CUDA__MEM.html#group__CUDA__MEM_1g57d3d780d165ecc0e3b3ce08e141cd89> "Copies memory from Host to Array."), [cuMemcpyHtoAAsync](<group__CUDA__MEM.html#group__CUDA__MEM_1gb5c4863f64f132b4bc2661818b3fd188> "Copies memory from Host to Array."), [cuMemcpyHtoD](<group__CUDA__MEM.html#group__CUDA__MEM_1g4d32266788c440b0220b1a9ba5795169> "Copies memory from Host to Device."), [cuMemcpyHtoDAsync](<group__CUDA__MEM.html#group__CUDA__MEM_1g1572263fe2597d7ba4f6964597a354a3> "Copies memory from Host to Device."), [cuMemFree](<group__CUDA__MEM.html#group__CUDA__MEM_1g89b3f154e17cc89b6eea277dbdf5c93a> "Frees device memory."), [cuMemFreeHost](<group__CUDA__MEM.html#group__CUDA__MEM_1g62e0fdbe181dab6b1c90fa1a51c7b92c> "Frees page-locked host memory."), [cuMemGetAddressRange](<group__CUDA__MEM.html#group__CUDA__MEM_1g64fee5711274a2a0573a789c94d8299b> "Get information on memory allocations."), [cuMemGetInfo](<group__CUDA__MEM.html#group__CUDA__MEM_1g808f555540d0143a331cc42aa98835c0> "Gets free and total memory."), [cuMemHostAlloc](<group__CUDA__MEM.html#group__CUDA__MEM_1g572ca4011bfcb25034888a14d4e035b9> "Allocates page-locked host memory."), [cuMemHostGetDevicePointer](<group__CUDA__MEM.html#group__CUDA__MEM_1g57a39e5cba26af4d06be67fc77cc62f0> "Passes back device pointer of mapped pinned memory."), [cuMemsetD2D8](<group__CUDA__MEM.html#group__CUDA__MEM_1ge88b13e646e2be6ba0e0475ef5205974> "Initializes device memory."), [cuMemsetD2D8Async](<group__CUDA__MEM.html#group__CUDA__MEM_1g3f7b6924a3e49c3265b328f534102e97> "Sets device memory."), [cuMemsetD2D16](<group__CUDA__MEM.html#group__CUDA__MEM_1g7f561a15a66144fa9f6ab5350edc8a30> "Initializes device memory."), [cuMemsetD2D16Async](<group__CUDA__MEM.html#group__CUDA__MEM_1g64ee197befac3d74d9fefedcf6ef6b10> "Sets device memory."), [cuMemsetD2D32](<group__CUDA__MEM.html#group__CUDA__MEM_1g74b359b2d026bfeb7c795b5038d07523> "Initializes device memory."), [cuMemsetD2D32Async](<group__CUDA__MEM.html#group__CUDA__MEM_1g8a78d3147ac93fac955052c815d9ea3c> "Sets device memory."), [cuMemsetD8](<group__CUDA__MEM.html#group__CUDA__MEM_1g6e582bf866e9e2fb014297bfaf354d7b> "Initializes device memory."), [cuMemsetD8Async](<group__CUDA__MEM.html#group__CUDA__MEM_1gaef08a7ccd61112f94e82f2b30d43627> "Sets device memory."), [cuMemsetD16](<group__CUDA__MEM.html#group__CUDA__MEM_1g7d805e610054392a4d11e8a8bf5eb35c> "Initializes device memory."), [cuMemsetD16Async](<group__CUDA__MEM.html#group__CUDA__MEM_1gf731438877dd8ec875e4c43d848c878c> "Sets device memory."), [cuMemsetD32](<group__CUDA__MEM.html#group__CUDA__MEM_1g983e8d8759acd1b64326317481fbf132> "Initializes device memory."), [cuMemsetD32Async](<group__CUDA__MEM.html#group__CUDA__MEM_1g58229da5d30f1c0cdf667b320ec2c0f5> "Sets device memory."), [cudaMemcpyAsync](<../cuda-runtime-api/group__CUDART__MEMORY.html#group__CUDART__MEMORY_1g85073372f776b4c4d5f89f7124b7bf79>), [cudaMemcpyToSymbolAsync](<../cuda-runtime-api/group__CUDART__HIGHLEVEL.html#group__CUDART__HIGHLEVEL_1gd00b41ade29161aafbf6ff8aee3d6eb5>), [cudaMemcpyFromSymbolAsync](<../cuda-runtime-api/group__CUDART__HIGHLEVEL.html#group__CUDART__HIGHLEVEL_1g2d9f7a440f1e522555dfe994245a5946>)

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuMemcpyAtoA ( [CUarray](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gd550651524a56766b60f10f0e7628042>)Â dstArray, size_tÂ dstOffset, [CUarray](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gd550651524a56766b60f10f0e7628042>)Â srcArray, size_tÂ srcOffset, size_tÂ ByteCount )


Copies memory from Array to Array.

######  Parameters

`dstArray`
    \- Destination array
`dstOffset`
    \- Offset in bytes of destination array
`srcArray`
    \- Source array
`srcOffset`
    \- Offset in bytes of source array
`ByteCount`
    \- Size of memory copy in bytes

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_DEINITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9acf52f132faf29b473cdda6061f0f44a>), [CUDA_ERROR_NOT_INITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e98feb999f0af99b4a25ab26b3866f4df8>), [CUDA_ERROR_INVALID_CONTEXT](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a484e9af32c1e9893ff21f0e0191a12d>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>)

###### Description

Copies from one 1D CUDA array to another. `dstArray` and `srcArray` specify the handles of the destination and source CUDA arrays for the copy, respectively. `dstOffset` and `srcOffset` specify the destination and source offsets in bytes into the CUDA arrays. `ByteCount` is the number of bytes to be copied. The size of the elements in the CUDA arrays need not be the same format, but the elements must be the same size; and count must be evenly divisible by that size.

Note:

  * Note that this function may also return error codes from previous, asynchronous launches.

  * This function exhibits [synchronous](<api-sync-behavior.html#api-sync-behavior__memcpy-sync>) behavior for most use cases.


**See also:**

[cuArray3DCreate](<group__CUDA__MEM.html#group__CUDA__MEM_1gc2322c70b38c2984536c90ed118bb1d7> "Creates a 3D CUDA array."), [cuArray3DGetDescriptor](<group__CUDA__MEM.html#group__CUDA__MEM_1gb58549f2f3f390b9e0e7c8f3acd53857> "Get a 3D CUDA array descriptor."), [cuArrayCreate](<group__CUDA__MEM.html#group__CUDA__MEM_1g4192ff387a81c3bd5ed8c391ed62ca24> "Creates a 1D or 2D CUDA array."), [cuArrayDestroy](<group__CUDA__MEM.html#group__CUDA__MEM_1g982878affbbc023de84874faac838b0b> "Destroys a CUDA array."), [cuArrayGetDescriptor](<group__CUDA__MEM.html#group__CUDA__MEM_1g661fe823dbd37bf11f82a71bd4762acf> "Get a 1D or 2D CUDA array descriptor."), [cuMemAlloc](<group__CUDA__MEM.html#group__CUDA__MEM_1gb82d2a09844a58dd9e744dc31e8aa467> "Allocates device memory."), [cuMemAllocHost](<group__CUDA__MEM.html#group__CUDA__MEM_1gdd8311286d2c2691605362c689bc64e0> "Allocates page-locked host memory."), [cuMemAllocPitch](<group__CUDA__MEM.html#group__CUDA__MEM_1gcbe9b033f6c4de80f63cc6e58ed9a45a> "Allocates pitched device memory."), [cuMemcpy2D](<group__CUDA__MEM.html#group__CUDA__MEM_1g27f885b30c34cc20a663a671dbf6fc27> "Copies memory for 2D arrays."), [cuMemcpy2DAsync](<group__CUDA__MEM.html#group__CUDA__MEM_1g4acf155faeb969d9d21f5433d3d0f274> "Copies memory for 2D arrays."), [cuMemcpy2DUnaligned](<group__CUDA__MEM.html#group__CUDA__MEM_1g2fa285d47fd7020e596bfeab3deb651b> "Copies memory for 2D arrays."), [cuMemcpy3D](<group__CUDA__MEM.html#group__CUDA__MEM_1g4b5238975579f002c0199a3800ca44df> "Copies memory for 3D arrays."), [cuMemcpy3DAsync](<group__CUDA__MEM.html#group__CUDA__MEM_1g79f4f3fde6ae0f529568d881d9e11987> "Copies memory for 3D arrays."), [cuMemcpyAtoD](<group__CUDA__MEM.html#group__CUDA__MEM_1g825b3f037f7f51382cae991bae8173fd> "Copies memory from Array to Device."), [cuMemcpyAtoH](<group__CUDA__MEM.html#group__CUDA__MEM_1gf7ad1edb2539cccc352c6b8b76f657f4> "Copies memory from Array to Host."), [cuMemcpyAtoHAsync](<group__CUDA__MEM.html#group__CUDA__MEM_1g64cbd2e60436699aebdd0bdbf14d0f01> "Copies memory from Array to Host."), [cuMemcpyDtoA](<group__CUDA__MEM.html#group__CUDA__MEM_1gad6827247af91600b56ce6e2ddb802e1> "Copies memory from Device to Array."), [cuMemcpyDtoD](<group__CUDA__MEM.html#group__CUDA__MEM_1g1725774abf8b51b91945f3336b778c8b> "Copies memory from Device to Device."), [cuMemcpyDtoDAsync](<group__CUDA__MEM.html#group__CUDA__MEM_1g39ea09ba682b8eccc9c3e0c04319b5c8> "Copies memory from Device to Device."), [cuMemcpyDtoH](<group__CUDA__MEM.html#group__CUDA__MEM_1g3480368ee0208a98f75019c9a8450893> "Copies memory from Device to Host."), [cuMemcpyDtoHAsync](<group__CUDA__MEM.html#group__CUDA__MEM_1g56f30236c7c5247f8e061b59d3268362> "Copies memory from Device to Host."), [cuMemcpyHtoA](<group__CUDA__MEM.html#group__CUDA__MEM_1g57d3d780d165ecc0e3b3ce08e141cd89> "Copies memory from Host to Array."), [cuMemcpyHtoAAsync](<group__CUDA__MEM.html#group__CUDA__MEM_1gb5c4863f64f132b4bc2661818b3fd188> "Copies memory from Host to Array."), [cuMemcpyHtoD](<group__CUDA__MEM.html#group__CUDA__MEM_1g4d32266788c440b0220b1a9ba5795169> "Copies memory from Host to Device."), [cuMemcpyHtoDAsync](<group__CUDA__MEM.html#group__CUDA__MEM_1g1572263fe2597d7ba4f6964597a354a3> "Copies memory from Host to Device."), [cuMemFree](<group__CUDA__MEM.html#group__CUDA__MEM_1g89b3f154e17cc89b6eea277dbdf5c93a> "Frees device memory."), [cuMemFreeHost](<group__CUDA__MEM.html#group__CUDA__MEM_1g62e0fdbe181dab6b1c90fa1a51c7b92c> "Frees page-locked host memory."), [cuMemGetAddressRange](<group__CUDA__MEM.html#group__CUDA__MEM_1g64fee5711274a2a0573a789c94d8299b> "Get information on memory allocations."), [cuMemGetInfo](<group__CUDA__MEM.html#group__CUDA__MEM_1g808f555540d0143a331cc42aa98835c0> "Gets free and total memory."), [cuMemHostAlloc](<group__CUDA__MEM.html#group__CUDA__MEM_1g572ca4011bfcb25034888a14d4e035b9> "Allocates page-locked host memory."), [cuMemHostGetDevicePointer](<group__CUDA__MEM.html#group__CUDA__MEM_1g57a39e5cba26af4d06be67fc77cc62f0> "Passes back device pointer of mapped pinned memory."), [cuMemsetD2D8](<group__CUDA__MEM.html#group__CUDA__MEM_1ge88b13e646e2be6ba0e0475ef5205974> "Initializes device memory."), [cuMemsetD2D16](<group__CUDA__MEM.html#group__CUDA__MEM_1g7f561a15a66144fa9f6ab5350edc8a30> "Initializes device memory."), [cuMemsetD2D32](<group__CUDA__MEM.html#group__CUDA__MEM_1g74b359b2d026bfeb7c795b5038d07523> "Initializes device memory."), [cuMemsetD8](<group__CUDA__MEM.html#group__CUDA__MEM_1g6e582bf866e9e2fb014297bfaf354d7b> "Initializes device memory."), [cuMemsetD16](<group__CUDA__MEM.html#group__CUDA__MEM_1g7d805e610054392a4d11e8a8bf5eb35c> "Initializes device memory."), [cuMemsetD32](<group__CUDA__MEM.html#group__CUDA__MEM_1g983e8d8759acd1b64326317481fbf132> "Initializes device memory."), [cudaMemcpyArrayToArray](<../cuda-runtime-api/group__CUDART__MEMORY__DEPRECATED.html#group__CUDART__MEMORY__DEPRECATED_1g5daffa65811c6be7eba1ec3c6c19ddb0>)

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuMemcpyAtoD ( [CUdeviceptr](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g183f7b0d8ad008ea2a5fd552537ace4e>)Â dstDevice, [CUarray](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gd550651524a56766b60f10f0e7628042>)Â srcArray, size_tÂ srcOffset, size_tÂ ByteCount )


Copies memory from Array to Device.

######  Parameters

`dstDevice`
    \- Destination device pointer
`srcArray`
    \- Source array
`srcOffset`
    \- Offset in bytes of source array
`ByteCount`
    \- Size of memory copy in bytes

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_DEINITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9acf52f132faf29b473cdda6061f0f44a>), [CUDA_ERROR_NOT_INITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e98feb999f0af99b4a25ab26b3866f4df8>), [CUDA_ERROR_INVALID_CONTEXT](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a484e9af32c1e9893ff21f0e0191a12d>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>)

###### Description

Copies from one 1D CUDA array to device memory. `dstDevice` specifies the base pointer of the destination and must be naturally aligned with the CUDA array elements. `srcArray` and `srcOffset` specify the CUDA array handle and the offset in bytes into the array where the copy is to begin. `ByteCount` specifies the number of bytes to copy and must be evenly divisible by the array element size.

Note:

  * Note that this function may also return error codes from previous, asynchronous launches.

  * This function exhibits [synchronous](<api-sync-behavior.html#api-sync-behavior__memcpy-sync>) behavior for most use cases.


**See also:**

[cuArray3DCreate](<group__CUDA__MEM.html#group__CUDA__MEM_1gc2322c70b38c2984536c90ed118bb1d7> "Creates a 3D CUDA array."), [cuArray3DGetDescriptor](<group__CUDA__MEM.html#group__CUDA__MEM_1gb58549f2f3f390b9e0e7c8f3acd53857> "Get a 3D CUDA array descriptor."), [cuArrayCreate](<group__CUDA__MEM.html#group__CUDA__MEM_1g4192ff387a81c3bd5ed8c391ed62ca24> "Creates a 1D or 2D CUDA array."), [cuArrayDestroy](<group__CUDA__MEM.html#group__CUDA__MEM_1g982878affbbc023de84874faac838b0b> "Destroys a CUDA array."), [cuArrayGetDescriptor](<group__CUDA__MEM.html#group__CUDA__MEM_1g661fe823dbd37bf11f82a71bd4762acf> "Get a 1D or 2D CUDA array descriptor."), [cuMemAlloc](<group__CUDA__MEM.html#group__CUDA__MEM_1gb82d2a09844a58dd9e744dc31e8aa467> "Allocates device memory."), [cuMemAllocHost](<group__CUDA__MEM.html#group__CUDA__MEM_1gdd8311286d2c2691605362c689bc64e0> "Allocates page-locked host memory."), [cuMemAllocPitch](<group__CUDA__MEM.html#group__CUDA__MEM_1gcbe9b033f6c4de80f63cc6e58ed9a45a> "Allocates pitched device memory."), [cuMemcpy2D](<group__CUDA__MEM.html#group__CUDA__MEM_1g27f885b30c34cc20a663a671dbf6fc27> "Copies memory for 2D arrays."), [cuMemcpy2DAsync](<group__CUDA__MEM.html#group__CUDA__MEM_1g4acf155faeb969d9d21f5433d3d0f274> "Copies memory for 2D arrays."), [cuMemcpy2DUnaligned](<group__CUDA__MEM.html#group__CUDA__MEM_1g2fa285d47fd7020e596bfeab3deb651b> "Copies memory for 2D arrays."), [cuMemcpy3D](<group__CUDA__MEM.html#group__CUDA__MEM_1g4b5238975579f002c0199a3800ca44df> "Copies memory for 3D arrays."), [cuMemcpy3DAsync](<group__CUDA__MEM.html#group__CUDA__MEM_1g79f4f3fde6ae0f529568d881d9e11987> "Copies memory for 3D arrays."), [cuMemcpyAtoA](<group__CUDA__MEM.html#group__CUDA__MEM_1gf81b218c984a31436ec9e23a85fb604a> "Copies memory from Array to Array."), [cuMemcpyAtoH](<group__CUDA__MEM.html#group__CUDA__MEM_1gf7ad1edb2539cccc352c6b8b76f657f4> "Copies memory from Array to Host."), [cuMemcpyAtoHAsync](<group__CUDA__MEM.html#group__CUDA__MEM_1g64cbd2e60436699aebdd0bdbf14d0f01> "Copies memory from Array to Host."), [cuMemcpyDtoA](<group__CUDA__MEM.html#group__CUDA__MEM_1gad6827247af91600b56ce6e2ddb802e1> "Copies memory from Device to Array."), [cuMemcpyDtoD](<group__CUDA__MEM.html#group__CUDA__MEM_1g1725774abf8b51b91945f3336b778c8b> "Copies memory from Device to Device."), [cuMemcpyDtoDAsync](<group__CUDA__MEM.html#group__CUDA__MEM_1g39ea09ba682b8eccc9c3e0c04319b5c8> "Copies memory from Device to Device."), [cuMemcpyDtoH](<group__CUDA__MEM.html#group__CUDA__MEM_1g3480368ee0208a98f75019c9a8450893> "Copies memory from Device to Host."), [cuMemcpyDtoHAsync](<group__CUDA__MEM.html#group__CUDA__MEM_1g56f30236c7c5247f8e061b59d3268362> "Copies memory from Device to Host."), [cuMemcpyHtoA](<group__CUDA__MEM.html#group__CUDA__MEM_1g57d3d780d165ecc0e3b3ce08e141cd89> "Copies memory from Host to Array."), [cuMemcpyHtoAAsync](<group__CUDA__MEM.html#group__CUDA__MEM_1gb5c4863f64f132b4bc2661818b3fd188> "Copies memory from Host to Array."), [cuMemcpyHtoD](<group__CUDA__MEM.html#group__CUDA__MEM_1g4d32266788c440b0220b1a9ba5795169> "Copies memory from Host to Device."), [cuMemcpyHtoDAsync](<group__CUDA__MEM.html#group__CUDA__MEM_1g1572263fe2597d7ba4f6964597a354a3> "Copies memory from Host to Device."), [cuMemFree](<group__CUDA__MEM.html#group__CUDA__MEM_1g89b3f154e17cc89b6eea277dbdf5c93a> "Frees device memory."), [cuMemFreeHost](<group__CUDA__MEM.html#group__CUDA__MEM_1g62e0fdbe181dab6b1c90fa1a51c7b92c> "Frees page-locked host memory."), [cuMemGetAddressRange](<group__CUDA__MEM.html#group__CUDA__MEM_1g64fee5711274a2a0573a789c94d8299b> "Get information on memory allocations."), [cuMemGetInfo](<group__CUDA__MEM.html#group__CUDA__MEM_1g808f555540d0143a331cc42aa98835c0> "Gets free and total memory."), [cuMemHostAlloc](<group__CUDA__MEM.html#group__CUDA__MEM_1g572ca4011bfcb25034888a14d4e035b9> "Allocates page-locked host memory."), [cuMemHostGetDevicePointer](<group__CUDA__MEM.html#group__CUDA__MEM_1g57a39e5cba26af4d06be67fc77cc62f0> "Passes back device pointer of mapped pinned memory."), [cuMemsetD2D8](<group__CUDA__MEM.html#group__CUDA__MEM_1ge88b13e646e2be6ba0e0475ef5205974> "Initializes device memory."), [cuMemsetD2D16](<group__CUDA__MEM.html#group__CUDA__MEM_1g7f561a15a66144fa9f6ab5350edc8a30> "Initializes device memory."), [cuMemsetD2D32](<group__CUDA__MEM.html#group__CUDA__MEM_1g74b359b2d026bfeb7c795b5038d07523> "Initializes device memory."), [cuMemsetD8](<group__CUDA__MEM.html#group__CUDA__MEM_1g6e582bf866e9e2fb014297bfaf354d7b> "Initializes device memory."), [cuMemsetD16](<group__CUDA__MEM.html#group__CUDA__MEM_1g7d805e610054392a4d11e8a8bf5eb35c> "Initializes device memory."), [cuMemsetD32](<group__CUDA__MEM.html#group__CUDA__MEM_1g983e8d8759acd1b64326317481fbf132> "Initializes device memory."), [cudaMemcpyFromArray](<../cuda-runtime-api/group__CUDART__MEMORY__DEPRECATED.html#group__CUDART__MEMORY__DEPRECATED_1g6fbe8ed786061afaeaf79dc17eef15e9>)

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuMemcpyAtoH ( void*Â dstHost, [CUarray](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gd550651524a56766b60f10f0e7628042>)Â srcArray, size_tÂ srcOffset, size_tÂ ByteCount )


Copies memory from Array to Host.

######  Parameters

`dstHost`
    \- Destination device pointer
`srcArray`
    \- Source array
`srcOffset`
    \- Offset in bytes of source array
`ByteCount`
    \- Size of memory copy in bytes

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_DEINITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9acf52f132faf29b473cdda6061f0f44a>), [CUDA_ERROR_NOT_INITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e98feb999f0af99b4a25ab26b3866f4df8>), [CUDA_ERROR_INVALID_CONTEXT](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a484e9af32c1e9893ff21f0e0191a12d>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>)

###### Description

Copies from one 1D CUDA array to host memory. `dstHost` specifies the base pointer of the destination. `srcArray` and `srcOffset` specify the CUDA array handle and starting offset in bytes of the source data. `ByteCount` specifies the number of bytes to copy.

Note:

  * Note that this function may also return error codes from previous, asynchronous launches.

  * This function exhibits [synchronous](<api-sync-behavior.html#api-sync-behavior__memcpy-sync>) behavior for most use cases.

  * Memory regions requested must be either entirely registered with CUDA, or in the case of host pageable transfers, not registered at all. Memory regions spanning over allocations that are both registered and not registered with CUDA are not supported and will return CUDA_ERROR_INVALID_VALUE.


**See also:**

[cuArray3DCreate](<group__CUDA__MEM.html#group__CUDA__MEM_1gc2322c70b38c2984536c90ed118bb1d7> "Creates a 3D CUDA array."), [cuArray3DGetDescriptor](<group__CUDA__MEM.html#group__CUDA__MEM_1gb58549f2f3f390b9e0e7c8f3acd53857> "Get a 3D CUDA array descriptor."), [cuArrayCreate](<group__CUDA__MEM.html#group__CUDA__MEM_1g4192ff387a81c3bd5ed8c391ed62ca24> "Creates a 1D or 2D CUDA array."), [cuArrayDestroy](<group__CUDA__MEM.html#group__CUDA__MEM_1g982878affbbc023de84874faac838b0b> "Destroys a CUDA array."), [cuArrayGetDescriptor](<group__CUDA__MEM.html#group__CUDA__MEM_1g661fe823dbd37bf11f82a71bd4762acf> "Get a 1D or 2D CUDA array descriptor."), [cuMemAlloc](<group__CUDA__MEM.html#group__CUDA__MEM_1gb82d2a09844a58dd9e744dc31e8aa467> "Allocates device memory."), [cuMemAllocHost](<group__CUDA__MEM.html#group__CUDA__MEM_1gdd8311286d2c2691605362c689bc64e0> "Allocates page-locked host memory."), [cuMemAllocPitch](<group__CUDA__MEM.html#group__CUDA__MEM_1gcbe9b033f6c4de80f63cc6e58ed9a45a> "Allocates pitched device memory."), [cuMemcpy2D](<group__CUDA__MEM.html#group__CUDA__MEM_1g27f885b30c34cc20a663a671dbf6fc27> "Copies memory for 2D arrays."), [cuMemcpy2DAsync](<group__CUDA__MEM.html#group__CUDA__MEM_1g4acf155faeb969d9d21f5433d3d0f274> "Copies memory for 2D arrays."), [cuMemcpy2DUnaligned](<group__CUDA__MEM.html#group__CUDA__MEM_1g2fa285d47fd7020e596bfeab3deb651b> "Copies memory for 2D arrays."), [cuMemcpy3D](<group__CUDA__MEM.html#group__CUDA__MEM_1g4b5238975579f002c0199a3800ca44df> "Copies memory for 3D arrays."), [cuMemcpy3DAsync](<group__CUDA__MEM.html#group__CUDA__MEM_1g79f4f3fde6ae0f529568d881d9e11987> "Copies memory for 3D arrays."), [cuMemcpyAtoA](<group__CUDA__MEM.html#group__CUDA__MEM_1gf81b218c984a31436ec9e23a85fb604a> "Copies memory from Array to Array."), [cuMemcpyAtoD](<group__CUDA__MEM.html#group__CUDA__MEM_1g825b3f037f7f51382cae991bae8173fd> "Copies memory from Array to Device."), [cuMemcpyAtoHAsync](<group__CUDA__MEM.html#group__CUDA__MEM_1g64cbd2e60436699aebdd0bdbf14d0f01> "Copies memory from Array to Host."), [cuMemcpyDtoA](<group__CUDA__MEM.html#group__CUDA__MEM_1gad6827247af91600b56ce6e2ddb802e1> "Copies memory from Device to Array."), [cuMemcpyDtoD](<group__CUDA__MEM.html#group__CUDA__MEM_1g1725774abf8b51b91945f3336b778c8b> "Copies memory from Device to Device."), [cuMemcpyDtoDAsync](<group__CUDA__MEM.html#group__CUDA__MEM_1g39ea09ba682b8eccc9c3e0c04319b5c8> "Copies memory from Device to Device."), [cuMemcpyDtoH](<group__CUDA__MEM.html#group__CUDA__MEM_1g3480368ee0208a98f75019c9a8450893> "Copies memory from Device to Host."), [cuMemcpyDtoHAsync](<group__CUDA__MEM.html#group__CUDA__MEM_1g56f30236c7c5247f8e061b59d3268362> "Copies memory from Device to Host."), [cuMemcpyHtoA](<group__CUDA__MEM.html#group__CUDA__MEM_1g57d3d780d165ecc0e3b3ce08e141cd89> "Copies memory from Host to Array."), [cuMemcpyHtoAAsync](<group__CUDA__MEM.html#group__CUDA__MEM_1gb5c4863f64f132b4bc2661818b3fd188> "Copies memory from Host to Array."), [cuMemcpyHtoD](<group__CUDA__MEM.html#group__CUDA__MEM_1g4d32266788c440b0220b1a9ba5795169> "Copies memory from Host to Device."), [cuMemcpyHtoDAsync](<group__CUDA__MEM.html#group__CUDA__MEM_1g1572263fe2597d7ba4f6964597a354a3> "Copies memory from Host to Device."), [cuMemFree](<group__CUDA__MEM.html#group__CUDA__MEM_1g89b3f154e17cc89b6eea277dbdf5c93a> "Frees device memory."), [cuMemFreeHost](<group__CUDA__MEM.html#group__CUDA__MEM_1g62e0fdbe181dab6b1c90fa1a51c7b92c> "Frees page-locked host memory."), [cuMemGetAddressRange](<group__CUDA__MEM.html#group__CUDA__MEM_1g64fee5711274a2a0573a789c94d8299b> "Get information on memory allocations."), [cuMemGetInfo](<group__CUDA__MEM.html#group__CUDA__MEM_1g808f555540d0143a331cc42aa98835c0> "Gets free and total memory."), [cuMemHostAlloc](<group__CUDA__MEM.html#group__CUDA__MEM_1g572ca4011bfcb25034888a14d4e035b9> "Allocates page-locked host memory."), [cuMemHostGetDevicePointer](<group__CUDA__MEM.html#group__CUDA__MEM_1g57a39e5cba26af4d06be67fc77cc62f0> "Passes back device pointer of mapped pinned memory."), [cuMemsetD2D8](<group__CUDA__MEM.html#group__CUDA__MEM_1ge88b13e646e2be6ba0e0475ef5205974> "Initializes device memory."), [cuMemsetD2D16](<group__CUDA__MEM.html#group__CUDA__MEM_1g7f561a15a66144fa9f6ab5350edc8a30> "Initializes device memory."), [cuMemsetD2D32](<group__CUDA__MEM.html#group__CUDA__MEM_1g74b359b2d026bfeb7c795b5038d07523> "Initializes device memory."), [cuMemsetD8](<group__CUDA__MEM.html#group__CUDA__MEM_1g6e582bf866e9e2fb014297bfaf354d7b> "Initializes device memory."), [cuMemsetD16](<group__CUDA__MEM.html#group__CUDA__MEM_1g7d805e610054392a4d11e8a8bf5eb35c> "Initializes device memory."), [cuMemsetD32](<group__CUDA__MEM.html#group__CUDA__MEM_1g983e8d8759acd1b64326317481fbf132> "Initializes device memory."), [cudaMemcpyFromArray](<../cuda-runtime-api/group__CUDART__MEMORY__DEPRECATED.html#group__CUDART__MEMORY__DEPRECATED_1g6fbe8ed786061afaeaf79dc17eef15e9>)

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuMemcpyAtoHAsync ( void*Â dstHost, [CUarray](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gd550651524a56766b60f10f0e7628042>)Â srcArray, size_tÂ srcOffset, size_tÂ ByteCount, [CUstream](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gb946c7f02e09efd788a204718015d88a>)Â hStream )


Copies memory from Array to Host.

######  Parameters

`dstHost`
    \- Destination pointer
`srcArray`
    \- Source array
`srcOffset`
    \- Offset in bytes of source array
`ByteCount`
    \- Size of memory copy in bytes
`hStream`
    \- Stream identifier

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_DEINITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9acf52f132faf29b473cdda6061f0f44a>), [CUDA_ERROR_NOT_INITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e98feb999f0af99b4a25ab26b3866f4df8>), [CUDA_ERROR_INVALID_CONTEXT](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a484e9af32c1e9893ff21f0e0191a12d>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>), [CUDA_ERROR_INVALID_HANDLE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e90fd2e63260c6317ba943af0f7e4b8d21>)

###### Description

Copies from one 1D CUDA array to host memory. `dstHost` specifies the base pointer of the destination. `srcArray` and `srcOffset` specify the CUDA array handle and starting offset in bytes of the source data. `ByteCount` specifies the number of bytes to copy.

Note:

  * Note that this function may also return error codes from previous, asynchronous launches.

  * This function exhibits [asynchronous](<api-sync-behavior.html#api-sync-behavior__memcpy-async>) behavior for most use cases.

  * This function uses standard [default stream](<stream-sync-behavior.html#stream-sync-behavior__default-stream>) semantics.

  * Memory regions requested must be either entirely registered with CUDA, or in the case of host pageable transfers, not registered at all. Memory regions spanning over allocations that are both registered and not registered with CUDA are not supported and will return CUDA_ERROR_INVALID_VALUE.


**See also:**

[cuArray3DCreate](<group__CUDA__MEM.html#group__CUDA__MEM_1gc2322c70b38c2984536c90ed118bb1d7> "Creates a 3D CUDA array."), [cuArray3DGetDescriptor](<group__CUDA__MEM.html#group__CUDA__MEM_1gb58549f2f3f390b9e0e7c8f3acd53857> "Get a 3D CUDA array descriptor."), [cuArrayCreate](<group__CUDA__MEM.html#group__CUDA__MEM_1g4192ff387a81c3bd5ed8c391ed62ca24> "Creates a 1D or 2D CUDA array."), [cuArrayDestroy](<group__CUDA__MEM.html#group__CUDA__MEM_1g982878affbbc023de84874faac838b0b> "Destroys a CUDA array."), [cuArrayGetDescriptor](<group__CUDA__MEM.html#group__CUDA__MEM_1g661fe823dbd37bf11f82a71bd4762acf> "Get a 1D or 2D CUDA array descriptor."), [cuMemAlloc](<group__CUDA__MEM.html#group__CUDA__MEM_1gb82d2a09844a58dd9e744dc31e8aa467> "Allocates device memory."), [cuMemAllocHost](<group__CUDA__MEM.html#group__CUDA__MEM_1gdd8311286d2c2691605362c689bc64e0> "Allocates page-locked host memory."), [cuMemAllocPitch](<group__CUDA__MEM.html#group__CUDA__MEM_1gcbe9b033f6c4de80f63cc6e58ed9a45a> "Allocates pitched device memory."), [cuMemcpy2D](<group__CUDA__MEM.html#group__CUDA__MEM_1g27f885b30c34cc20a663a671dbf6fc27> "Copies memory for 2D arrays."), [cuMemcpy2DAsync](<group__CUDA__MEM.html#group__CUDA__MEM_1g4acf155faeb969d9d21f5433d3d0f274> "Copies memory for 2D arrays."), [cuMemcpy2DUnaligned](<group__CUDA__MEM.html#group__CUDA__MEM_1g2fa285d47fd7020e596bfeab3deb651b> "Copies memory for 2D arrays."), [cuMemcpy3D](<group__CUDA__MEM.html#group__CUDA__MEM_1g4b5238975579f002c0199a3800ca44df> "Copies memory for 3D arrays."), [cuMemcpy3DAsync](<group__CUDA__MEM.html#group__CUDA__MEM_1g79f4f3fde6ae0f529568d881d9e11987> "Copies memory for 3D arrays."), [cuMemcpyAtoA](<group__CUDA__MEM.html#group__CUDA__MEM_1gf81b218c984a31436ec9e23a85fb604a> "Copies memory from Array to Array."), [cuMemcpyAtoD](<group__CUDA__MEM.html#group__CUDA__MEM_1g825b3f037f7f51382cae991bae8173fd> "Copies memory from Array to Device."), [cuMemcpyAtoH](<group__CUDA__MEM.html#group__CUDA__MEM_1gf7ad1edb2539cccc352c6b8b76f657f4> "Copies memory from Array to Host."), [cuMemcpyDtoA](<group__CUDA__MEM.html#group__CUDA__MEM_1gad6827247af91600b56ce6e2ddb802e1> "Copies memory from Device to Array."), [cuMemcpyDtoD](<group__CUDA__MEM.html#group__CUDA__MEM_1g1725774abf8b51b91945f3336b778c8b> "Copies memory from Device to Device."), [cuMemcpyDtoDAsync](<group__CUDA__MEM.html#group__CUDA__MEM_1g39ea09ba682b8eccc9c3e0c04319b5c8> "Copies memory from Device to Device."), [cuMemcpyDtoH](<group__CUDA__MEM.html#group__CUDA__MEM_1g3480368ee0208a98f75019c9a8450893> "Copies memory from Device to Host."), [cuMemcpyDtoHAsync](<group__CUDA__MEM.html#group__CUDA__MEM_1g56f30236c7c5247f8e061b59d3268362> "Copies memory from Device to Host."), [cuMemcpyHtoA](<group__CUDA__MEM.html#group__CUDA__MEM_1g57d3d780d165ecc0e3b3ce08e141cd89> "Copies memory from Host to Array."), [cuMemcpyHtoAAsync](<group__CUDA__MEM.html#group__CUDA__MEM_1gb5c4863f64f132b4bc2661818b3fd188> "Copies memory from Host to Array."), [cuMemcpyHtoD](<group__CUDA__MEM.html#group__CUDA__MEM_1g4d32266788c440b0220b1a9ba5795169> "Copies memory from Host to Device."), [cuMemcpyHtoDAsync](<group__CUDA__MEM.html#group__CUDA__MEM_1g1572263fe2597d7ba4f6964597a354a3> "Copies memory from Host to Device."), [cuMemFree](<group__CUDA__MEM.html#group__CUDA__MEM_1g89b3f154e17cc89b6eea277dbdf5c93a> "Frees device memory."), [cuMemFreeHost](<group__CUDA__MEM.html#group__CUDA__MEM_1g62e0fdbe181dab6b1c90fa1a51c7b92c> "Frees page-locked host memory."), [cuMemGetAddressRange](<group__CUDA__MEM.html#group__CUDA__MEM_1g64fee5711274a2a0573a789c94d8299b> "Get information on memory allocations."), [cuMemGetInfo](<group__CUDA__MEM.html#group__CUDA__MEM_1g808f555540d0143a331cc42aa98835c0> "Gets free and total memory."), [cuMemHostAlloc](<group__CUDA__MEM.html#group__CUDA__MEM_1g572ca4011bfcb25034888a14d4e035b9> "Allocates page-locked host memory."), [cuMemHostGetDevicePointer](<group__CUDA__MEM.html#group__CUDA__MEM_1g57a39e5cba26af4d06be67fc77cc62f0> "Passes back device pointer of mapped pinned memory."), [cuMemsetD2D8](<group__CUDA__MEM.html#group__CUDA__MEM_1ge88b13e646e2be6ba0e0475ef5205974> "Initializes device memory."), [cuMemsetD2D8Async](<group__CUDA__MEM.html#group__CUDA__MEM_1g3f7b6924a3e49c3265b328f534102e97> "Sets device memory."), [cuMemsetD2D16](<group__CUDA__MEM.html#group__CUDA__MEM_1g7f561a15a66144fa9f6ab5350edc8a30> "Initializes device memory."), [cuMemsetD2D16Async](<group__CUDA__MEM.html#group__CUDA__MEM_1g64ee197befac3d74d9fefedcf6ef6b10> "Sets device memory."), [cuMemsetD2D32](<group__CUDA__MEM.html#group__CUDA__MEM_1g74b359b2d026bfeb7c795b5038d07523> "Initializes device memory."), [cuMemsetD2D32Async](<group__CUDA__MEM.html#group__CUDA__MEM_1g8a78d3147ac93fac955052c815d9ea3c> "Sets device memory."), [cuMemsetD8](<group__CUDA__MEM.html#group__CUDA__MEM_1g6e582bf866e9e2fb014297bfaf354d7b> "Initializes device memory."), [cuMemsetD8Async](<group__CUDA__MEM.html#group__CUDA__MEM_1gaef08a7ccd61112f94e82f2b30d43627> "Sets device memory."), [cuMemsetD16](<group__CUDA__MEM.html#group__CUDA__MEM_1g7d805e610054392a4d11e8a8bf5eb35c> "Initializes device memory."), [cuMemsetD16Async](<group__CUDA__MEM.html#group__CUDA__MEM_1gf731438877dd8ec875e4c43d848c878c> "Sets device memory."), [cuMemsetD32](<group__CUDA__MEM.html#group__CUDA__MEM_1g983e8d8759acd1b64326317481fbf132> "Initializes device memory."), [cuMemsetD32Async](<group__CUDA__MEM.html#group__CUDA__MEM_1g58229da5d30f1c0cdf667b320ec2c0f5> "Sets device memory."), [cudaMemcpyFromArrayAsync](<../cuda-runtime-api/group__CUDART__MEMORY__DEPRECATED.html#group__CUDART__MEMORY__DEPRECATED_1gfa22cfe6148b4c82593ecf3582f1dc33>)

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuMemcpyBatchAsync ( [CUdeviceptr](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g183f7b0d8ad008ea2a5fd552537ace4e>)*Â dsts, [CUdeviceptr](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g183f7b0d8ad008ea2a5fd552537ace4e>)*Â srcs, size_t*Â sizes, size_tÂ count, [CUmemcpyAttributes](<structCUmemcpyAttributes__v1.html#structCUmemcpyAttributes__v1>)*Â attrs, size_t*Â attrsIdxs, size_tÂ numAttrs, [CUstream](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gb946c7f02e09efd788a204718015d88a>)Â hStream )


Performs a batch of memory copies asynchronously.

######  Parameters

`dsts`
    \- Array of destination pointers.
`srcs`
    \- Array of memcpy source pointers.
`sizes`
    \- Array of sizes for memcpy operations.
`count`
    \- Size of `dsts`, `srcs` and `sizes` arrays
`attrs`
    \- Array of memcpy attributes.
`attrsIdxs`
    \- Array of indices to specify which copies each entry in the `attrs` array applies to. The attributes specified in attrs[k] will be applied to copies starting from attrsIdxs[k] through attrsIdxs[k+1] \- 1. Also attrs[numAttrs-1] will apply to copies starting from attrsIdxs[numAttrs-1] through count - 1.
`numAttrs`
    \- Size of `attrs` and `attrsIdxs` arrays.
`hStream`
    \- The stream to enqueue the operations in. Must not be legacy NULL stream.

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_DEINITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9acf52f132faf29b473cdda6061f0f44a>), [CUDA_ERROR_NOT_INITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e98feb999f0af99b4a25ab26b3866f4df8>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>)

###### Description

Performs a batch of memory copies. The batch as a whole executes in stream order but copies within a batch are not guaranteed to execute in any specific order. This API only supports pointer-to-pointer copies. For copies involving CUDA arrays, please see [cuMemcpy3DBatchAsync](<group__CUDA__MEM.html#group__CUDA__MEM_1g97dd29d0e3490379a5cbdb21deb41f12> "Performs a batch of 3D memory copies asynchronously.").

Performs memory copies from source buffers specified in `srcs` to destination buffers specified in `dsts`. The size of each copy is specified in `sizes`. All three arrays must be of the same length as specified by `count`. Since there are no ordering guarantees for copies within a batch, specifying any dependent copies within a batch will result in undefined behavior.

Every copy in the batch has to be associated with a set of attributes specified in the `attrs` array. Each entry in this array can apply to more than one copy. This can be done by specifying in the `attrsIdxs` array, the index of the first copy that the corresponding entry in the `attrs` array applies to. Both `attrs` and `attrsIdxs` must be of the same length as specified by `numAttrs`. For example, if a batch has 10 copies listed in dst/src/sizes, the first 6 of which have one set of attributes and the remaining 4 another, then `numAttrs` will be 2, `attrsIdxs` will be {0, 6} and `attrs` will contains the two sets of attributes. Note that the first entry in `attrsIdxs` must always be 0. Also, each entry must be greater than the previous entry and the last entry should be less than `count`. Furthermore, `numAttrs` must be lesser than or equal to `count`.

The [CUmemcpyAttributes::srcAccessOrder](<structCUmemcpyAttributes__v1.html#structCUmemcpyAttributes__v1_1d152922b22834808ca5714f688400761>) indicates the source access ordering to be observed for copies associated with the attribute. If the source access order is set to [CU_MEMCPY_SRC_ACCESS_ORDER_STREAM](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg88fcbe39c3714884fcd1ca9d3b9e425183a1e3dd6ef4b91364f645443d183c70>), then the source will be accessed in stream order. If the source access order is set to [CU_MEMCPY_SRC_ACCESS_ORDER_DURING_API_CALL](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg88fcbe39c3714884fcd1ca9d3b9e4251d05487493fc2a9ba99d4ccdc834a4266>) then it indicates that access to the source pointer can be out of stream order and all accesses must be complete before the API call returns. This flag is suited for ephemeral sources (ex., stack variables) when it's known that no prior operations in the stream can be accessing the memory and also that the lifetime of the memory is limited to the scope that the source variable was declared in. Specifying this flag allows the driver to optimize the copy and removes the need for the user to synchronize the stream after the API call. If the source access order is set to [CU_MEMCPY_SRC_ACCESS_ORDER_ANY](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg88fcbe39c3714884fcd1ca9d3b9e4251f9cb69c7dc969e7f9350e5749b310314>) then it indicates that access to the source pointer can be out of stream order and the accesses can happen even after the API call returns. This flag is suited for host pointers allocated outside CUDA (ex., via malloc) when it's known that no prior operations in the stream can be accessing the memory. Specifying this flag allows the driver to optimize the copy on certain platforms. Each memcpy operation in the batch must have a valid CUmemcpyAttributes corresponding to it including the appropriate srcAccessOrder setting, otherwise the API will return [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>).

The [CUmemcpyAttributes::srcLocHint](<structCUmemcpyAttributes__v1.html#structCUmemcpyAttributes__v1_12b2ea7d3968f58243d6d94f99bab6a55>) and [CUmemcpyAttributes::dstLocHint](<structCUmemcpyAttributes__v1.html#structCUmemcpyAttributes__v1_15ef6cafc9e673f19d946cd5517dd05ec>) allows applications to specify hint locations for operands of a copy when the operand doesn't have a fixed location. That is, these hints are only applicable for managed memory pointers on devices where [CU_DEVICE_ATTRIBUTE_CONCURRENT_MANAGED_ACCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gge12b8a782bebe21b1ac0091bf9f4e2a333110e44c9cb6ead02f03ff6f6fd495e>) is true or system-allocated pageable memory on devices where [CU_DEVICE_ATTRIBUTE_PAGEABLE_MEMORY_ACCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gge12b8a782bebe21b1ac0091bf9f4e2a35fdcdbe1dfc3ad5ec428c279e0efb9cd>) is true. For other cases, these hints are ignored.

The [CUmemcpyAttributes::flags](<structCUmemcpyAttributes__v1.html#structCUmemcpyAttributes__v1_10c9ad8770c38c992894a6870991127e4>) field can be used to specify certain flags for copies. Setting the [CU_MEMCPY_FLAG_PREFER_OVERLAP_WITH_COMPUTE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg0badb1f4f792793fdcf4a78593b4655a4c2b776afc2c1570cc93d48984b4d794>) flag indicates that the associated copies should preferably overlap with any compute work. Note that this flag is a hint and can be ignored depending on the platform and other parameters of the copy.

Note:

  * Note that this function may also return error codes from previous, asynchronous launches.

  * This function exhibits [asynchronous](<api-sync-behavior.html#api-sync-behavior__memcpy-async>) behavior for most use cases.

  * Memory regions requested must be either entirely registered with CUDA, or in the case of host pageable transfers, not registered at all. Memory regions spanning over allocations that are both registered and not registered with CUDA are not supported and will return CUDA_ERROR_INVALID_VALUE.


[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuMemcpyDtoA ( [CUarray](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gd550651524a56766b60f10f0e7628042>)Â dstArray, size_tÂ dstOffset, [CUdeviceptr](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g183f7b0d8ad008ea2a5fd552537ace4e>)Â srcDevice, size_tÂ ByteCount )


Copies memory from Device to Array.

######  Parameters

`dstArray`
    \- Destination array
`dstOffset`
    \- Offset in bytes of destination array
`srcDevice`
    \- Source device pointer
`ByteCount`
    \- Size of memory copy in bytes

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_DEINITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9acf52f132faf29b473cdda6061f0f44a>), [CUDA_ERROR_NOT_INITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e98feb999f0af99b4a25ab26b3866f4df8>), [CUDA_ERROR_INVALID_CONTEXT](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a484e9af32c1e9893ff21f0e0191a12d>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>)

###### Description

Copies from device memory to a 1D CUDA array. `dstArray` and `dstOffset` specify the CUDA array handle and starting index of the destination data. `srcDevice` specifies the base pointer of the source. `ByteCount` specifies the number of bytes to copy.

Note:

  * Note that this function may also return error codes from previous, asynchronous launches.

  * This function exhibits [synchronous](<api-sync-behavior.html#api-sync-behavior__memcpy-sync>) behavior for most use cases.


**See also:**

[cuArray3DCreate](<group__CUDA__MEM.html#group__CUDA__MEM_1gc2322c70b38c2984536c90ed118bb1d7> "Creates a 3D CUDA array."), [cuArray3DGetDescriptor](<group__CUDA__MEM.html#group__CUDA__MEM_1gb58549f2f3f390b9e0e7c8f3acd53857> "Get a 3D CUDA array descriptor."), [cuArrayCreate](<group__CUDA__MEM.html#group__CUDA__MEM_1g4192ff387a81c3bd5ed8c391ed62ca24> "Creates a 1D or 2D CUDA array."), [cuArrayDestroy](<group__CUDA__MEM.html#group__CUDA__MEM_1g982878affbbc023de84874faac838b0b> "Destroys a CUDA array."), [cuArrayGetDescriptor](<group__CUDA__MEM.html#group__CUDA__MEM_1g661fe823dbd37bf11f82a71bd4762acf> "Get a 1D or 2D CUDA array descriptor."), [cuMemAlloc](<group__CUDA__MEM.html#group__CUDA__MEM_1gb82d2a09844a58dd9e744dc31e8aa467> "Allocates device memory."), [cuMemAllocHost](<group__CUDA__MEM.html#group__CUDA__MEM_1gdd8311286d2c2691605362c689bc64e0> "Allocates page-locked host memory."), [cuMemAllocPitch](<group__CUDA__MEM.html#group__CUDA__MEM_1gcbe9b033f6c4de80f63cc6e58ed9a45a> "Allocates pitched device memory."), [cuMemcpy2D](<group__CUDA__MEM.html#group__CUDA__MEM_1g27f885b30c34cc20a663a671dbf6fc27> "Copies memory for 2D arrays."), [cuMemcpy2DAsync](<group__CUDA__MEM.html#group__CUDA__MEM_1g4acf155faeb969d9d21f5433d3d0f274> "Copies memory for 2D arrays."), [cuMemcpy2DUnaligned](<group__CUDA__MEM.html#group__CUDA__MEM_1g2fa285d47fd7020e596bfeab3deb651b> "Copies memory for 2D arrays."), [cuMemcpy3D](<group__CUDA__MEM.html#group__CUDA__MEM_1g4b5238975579f002c0199a3800ca44df> "Copies memory for 3D arrays."), [cuMemcpy3DAsync](<group__CUDA__MEM.html#group__CUDA__MEM_1g79f4f3fde6ae0f529568d881d9e11987> "Copies memory for 3D arrays."), [cuMemcpyAtoA](<group__CUDA__MEM.html#group__CUDA__MEM_1gf81b218c984a31436ec9e23a85fb604a> "Copies memory from Array to Array."), [cuMemcpyAtoD](<group__CUDA__MEM.html#group__CUDA__MEM_1g825b3f037f7f51382cae991bae8173fd> "Copies memory from Array to Device."), [cuMemcpyAtoH](<group__CUDA__MEM.html#group__CUDA__MEM_1gf7ad1edb2539cccc352c6b8b76f657f4> "Copies memory from Array to Host."), [cuMemcpyAtoHAsync](<group__CUDA__MEM.html#group__CUDA__MEM_1g64cbd2e60436699aebdd0bdbf14d0f01> "Copies memory from Array to Host."), [cuMemcpyDtoD](<group__CUDA__MEM.html#group__CUDA__MEM_1g1725774abf8b51b91945f3336b778c8b> "Copies memory from Device to Device."), [cuMemcpyDtoDAsync](<group__CUDA__MEM.html#group__CUDA__MEM_1g39ea09ba682b8eccc9c3e0c04319b5c8> "Copies memory from Device to Device."), [cuMemcpyDtoH](<group__CUDA__MEM.html#group__CUDA__MEM_1g3480368ee0208a98f75019c9a8450893> "Copies memory from Device to Host."), [cuMemcpyDtoHAsync](<group__CUDA__MEM.html#group__CUDA__MEM_1g56f30236c7c5247f8e061b59d3268362> "Copies memory from Device to Host."), [cuMemcpyHtoA](<group__CUDA__MEM.html#group__CUDA__MEM_1g57d3d780d165ecc0e3b3ce08e141cd89> "Copies memory from Host to Array."), [cuMemcpyHtoAAsync](<group__CUDA__MEM.html#group__CUDA__MEM_1gb5c4863f64f132b4bc2661818b3fd188> "Copies memory from Host to Array."), [cuMemcpyHtoD](<group__CUDA__MEM.html#group__CUDA__MEM_1g4d32266788c440b0220b1a9ba5795169> "Copies memory from Host to Device."), [cuMemcpyHtoDAsync](<group__CUDA__MEM.html#group__CUDA__MEM_1g1572263fe2597d7ba4f6964597a354a3> "Copies memory from Host to Device."), [cuMemFree](<group__CUDA__MEM.html#group__CUDA__MEM_1g89b3f154e17cc89b6eea277dbdf5c93a> "Frees device memory."), [cuMemFreeHost](<group__CUDA__MEM.html#group__CUDA__MEM_1g62e0fdbe181dab6b1c90fa1a51c7b92c> "Frees page-locked host memory."), [cuMemGetAddressRange](<group__CUDA__MEM.html#group__CUDA__MEM_1g64fee5711274a2a0573a789c94d8299b> "Get information on memory allocations."), [cuMemGetInfo](<group__CUDA__MEM.html#group__CUDA__MEM_1g808f555540d0143a331cc42aa98835c0> "Gets free and total memory."), [cuMemHostAlloc](<group__CUDA__MEM.html#group__CUDA__MEM_1g572ca4011bfcb25034888a14d4e035b9> "Allocates page-locked host memory."), [cuMemHostGetDevicePointer](<group__CUDA__MEM.html#group__CUDA__MEM_1g57a39e5cba26af4d06be67fc77cc62f0> "Passes back device pointer of mapped pinned memory."), [cuMemsetD2D8](<group__CUDA__MEM.html#group__CUDA__MEM_1ge88b13e646e2be6ba0e0475ef5205974> "Initializes device memory."), [cuMemsetD2D16](<group__CUDA__MEM.html#group__CUDA__MEM_1g7f561a15a66144fa9f6ab5350edc8a30> "Initializes device memory."), [cuMemsetD2D32](<group__CUDA__MEM.html#group__CUDA__MEM_1g74b359b2d026bfeb7c795b5038d07523> "Initializes device memory."), [cuMemsetD8](<group__CUDA__MEM.html#group__CUDA__MEM_1g6e582bf866e9e2fb014297bfaf354d7b> "Initializes device memory."), [cuMemsetD16](<group__CUDA__MEM.html#group__CUDA__MEM_1g7d805e610054392a4d11e8a8bf5eb35c> "Initializes device memory."), [cuMemsetD32](<group__CUDA__MEM.html#group__CUDA__MEM_1g983e8d8759acd1b64326317481fbf132> "Initializes device memory."), [cudaMemcpyToArray](<../cuda-runtime-api/group__CUDART__MEMORY__DEPRECATED.html#group__CUDART__MEMORY__DEPRECATED_1g15b5d20cedf31dd13801c6015da0e828>)

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuMemcpyDtoD ( [CUdeviceptr](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g183f7b0d8ad008ea2a5fd552537ace4e>)Â dstDevice, [CUdeviceptr](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g183f7b0d8ad008ea2a5fd552537ace4e>)Â srcDevice, size_tÂ ByteCount )


Copies memory from Device to Device.

######  Parameters

`dstDevice`
    \- Destination device pointer
`srcDevice`
    \- Source device pointer
`ByteCount`
    \- Size of memory copy in bytes

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_DEINITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9acf52f132faf29b473cdda6061f0f44a>), [CUDA_ERROR_NOT_INITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e98feb999f0af99b4a25ab26b3866f4df8>), [CUDA_ERROR_INVALID_CONTEXT](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a484e9af32c1e9893ff21f0e0191a12d>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>)

###### Description

Copies from device memory to device memory. `dstDevice` and `srcDevice` are the base pointers of the destination and source, respectively. `ByteCount` specifies the number of bytes to copy.

Note:

  * Note that this function may also return error codes from previous, asynchronous launches.

  * This function exhibits [synchronous](<api-sync-behavior.html#api-sync-behavior__memcpy-sync>) behavior for most use cases.


**See also:**

[cuArray3DCreate](<group__CUDA__MEM.html#group__CUDA__MEM_1gc2322c70b38c2984536c90ed118bb1d7> "Creates a 3D CUDA array."), [cuArray3DGetDescriptor](<group__CUDA__MEM.html#group__CUDA__MEM_1gb58549f2f3f390b9e0e7c8f3acd53857> "Get a 3D CUDA array descriptor."), [cuArrayCreate](<group__CUDA__MEM.html#group__CUDA__MEM_1g4192ff387a81c3bd5ed8c391ed62ca24> "Creates a 1D or 2D CUDA array."), [cuArrayDestroy](<group__CUDA__MEM.html#group__CUDA__MEM_1g982878affbbc023de84874faac838b0b> "Destroys a CUDA array."), [cuArrayGetDescriptor](<group__CUDA__MEM.html#group__CUDA__MEM_1g661fe823dbd37bf11f82a71bd4762acf> "Get a 1D or 2D CUDA array descriptor."), [cuMemAlloc](<group__CUDA__MEM.html#group__CUDA__MEM_1gb82d2a09844a58dd9e744dc31e8aa467> "Allocates device memory."), [cuMemAllocHost](<group__CUDA__MEM.html#group__CUDA__MEM_1gdd8311286d2c2691605362c689bc64e0> "Allocates page-locked host memory."), [cuMemAllocPitch](<group__CUDA__MEM.html#group__CUDA__MEM_1gcbe9b033f6c4de80f63cc6e58ed9a45a> "Allocates pitched device memory."), [cuMemcpy2D](<group__CUDA__MEM.html#group__CUDA__MEM_1g27f885b30c34cc20a663a671dbf6fc27> "Copies memory for 2D arrays."), [cuMemcpy2DAsync](<group__CUDA__MEM.html#group__CUDA__MEM_1g4acf155faeb969d9d21f5433d3d0f274> "Copies memory for 2D arrays."), [cuMemcpy2DUnaligned](<group__CUDA__MEM.html#group__CUDA__MEM_1g2fa285d47fd7020e596bfeab3deb651b> "Copies memory for 2D arrays."), [cuMemcpy3D](<group__CUDA__MEM.html#group__CUDA__MEM_1g4b5238975579f002c0199a3800ca44df> "Copies memory for 3D arrays."), [cuMemcpy3DAsync](<group__CUDA__MEM.html#group__CUDA__MEM_1g79f4f3fde6ae0f529568d881d9e11987> "Copies memory for 3D arrays."), [cuMemcpyAtoA](<group__CUDA__MEM.html#group__CUDA__MEM_1gf81b218c984a31436ec9e23a85fb604a> "Copies memory from Array to Array."), [cuMemcpyAtoD](<group__CUDA__MEM.html#group__CUDA__MEM_1g825b3f037f7f51382cae991bae8173fd> "Copies memory from Array to Device."), [cuMemcpyAtoH](<group__CUDA__MEM.html#group__CUDA__MEM_1gf7ad1edb2539cccc352c6b8b76f657f4> "Copies memory from Array to Host."), [cuMemcpyAtoHAsync](<group__CUDA__MEM.html#group__CUDA__MEM_1g64cbd2e60436699aebdd0bdbf14d0f01> "Copies memory from Array to Host."), [cuMemcpyDtoA](<group__CUDA__MEM.html#group__CUDA__MEM_1gad6827247af91600b56ce6e2ddb802e1> "Copies memory from Device to Array."), [cuMemcpyDtoH](<group__CUDA__MEM.html#group__CUDA__MEM_1g3480368ee0208a98f75019c9a8450893> "Copies memory from Device to Host."), [cuMemcpyDtoHAsync](<group__CUDA__MEM.html#group__CUDA__MEM_1g56f30236c7c5247f8e061b59d3268362> "Copies memory from Device to Host."), [cuMemcpyHtoA](<group__CUDA__MEM.html#group__CUDA__MEM_1g57d3d780d165ecc0e3b3ce08e141cd89> "Copies memory from Host to Array."), [cuMemcpyHtoAAsync](<group__CUDA__MEM.html#group__CUDA__MEM_1gb5c4863f64f132b4bc2661818b3fd188> "Copies memory from Host to Array."), [cuMemcpyHtoD](<group__CUDA__MEM.html#group__CUDA__MEM_1g4d32266788c440b0220b1a9ba5795169> "Copies memory from Host to Device."), [cuMemcpyHtoDAsync](<group__CUDA__MEM.html#group__CUDA__MEM_1g1572263fe2597d7ba4f6964597a354a3> "Copies memory from Host to Device."), [cuMemFree](<group__CUDA__MEM.html#group__CUDA__MEM_1g89b3f154e17cc89b6eea277dbdf5c93a> "Frees device memory."), [cuMemFreeHost](<group__CUDA__MEM.html#group__CUDA__MEM_1g62e0fdbe181dab6b1c90fa1a51c7b92c> "Frees page-locked host memory."), [cuMemGetAddressRange](<group__CUDA__MEM.html#group__CUDA__MEM_1g64fee5711274a2a0573a789c94d8299b> "Get information on memory allocations."), [cuMemGetInfo](<group__CUDA__MEM.html#group__CUDA__MEM_1g808f555540d0143a331cc42aa98835c0> "Gets free and total memory."), [cuMemHostAlloc](<group__CUDA__MEM.html#group__CUDA__MEM_1g572ca4011bfcb25034888a14d4e035b9> "Allocates page-locked host memory."), [cuMemHostGetDevicePointer](<group__CUDA__MEM.html#group__CUDA__MEM_1g57a39e5cba26af4d06be67fc77cc62f0> "Passes back device pointer of mapped pinned memory."), [cuMemsetD2D8](<group__CUDA__MEM.html#group__CUDA__MEM_1ge88b13e646e2be6ba0e0475ef5205974> "Initializes device memory."), [cuMemsetD2D16](<group__CUDA__MEM.html#group__CUDA__MEM_1g7f561a15a66144fa9f6ab5350edc8a30> "Initializes device memory."), [cuMemsetD2D32](<group__CUDA__MEM.html#group__CUDA__MEM_1g74b359b2d026bfeb7c795b5038d07523> "Initializes device memory."), [cuMemsetD8](<group__CUDA__MEM.html#group__CUDA__MEM_1g6e582bf866e9e2fb014297bfaf354d7b> "Initializes device memory."), [cuMemsetD16](<group__CUDA__MEM.html#group__CUDA__MEM_1g7d805e610054392a4d11e8a8bf5eb35c> "Initializes device memory."), [cuMemsetD32](<group__CUDA__MEM.html#group__CUDA__MEM_1g983e8d8759acd1b64326317481fbf132> "Initializes device memory."), [cudaMemcpy](<../cuda-runtime-api/group__CUDART__MEMORY.html#group__CUDART__MEMORY_1gc263dbe6574220cc776b45438fc351e8>), [cudaMemcpyToSymbol](<../cuda-runtime-api/group__CUDART__HIGHLEVEL.html#group__CUDART__HIGHLEVEL_1g4561bf9c99d91c92684a91a0bd356bfe>), [cudaMemcpyFromSymbol](<../cuda-runtime-api/group__CUDART__HIGHLEVEL.html#group__CUDART__HIGHLEVEL_1g99db510d18d37fbb0f5c075a8caf3b5f>)

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuMemcpyDtoDAsync ( [CUdeviceptr](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g183f7b0d8ad008ea2a5fd552537ace4e>)Â dstDevice, [CUdeviceptr](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g183f7b0d8ad008ea2a5fd552537ace4e>)Â srcDevice, size_tÂ ByteCount, [CUstream](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gb946c7f02e09efd788a204718015d88a>)Â hStream )


Copies memory from Device to Device.

######  Parameters

`dstDevice`
    \- Destination device pointer
`srcDevice`
    \- Source device pointer
`ByteCount`
    \- Size of memory copy in bytes
`hStream`
    \- Stream identifier

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_DEINITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9acf52f132faf29b473cdda6061f0f44a>), [CUDA_ERROR_NOT_INITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e98feb999f0af99b4a25ab26b3866f4df8>), [CUDA_ERROR_INVALID_CONTEXT](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a484e9af32c1e9893ff21f0e0191a12d>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>), [CUDA_ERROR_INVALID_HANDLE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e90fd2e63260c6317ba943af0f7e4b8d21>)

###### Description

Copies from device memory to device memory. `dstDevice` and `srcDevice` are the base pointers of the destination and source, respectively. `ByteCount` specifies the number of bytes to copy.

Note:

  * Note that this function may also return error codes from previous, asynchronous launches.

  * This function exhibits [asynchronous](<api-sync-behavior.html#api-sync-behavior__memcpy-async>) behavior for most use cases.

  * This function uses standard [default stream](<stream-sync-behavior.html#stream-sync-behavior__default-stream>) semantics.


**See also:**

[cuArray3DCreate](<group__CUDA__MEM.html#group__CUDA__MEM_1gc2322c70b38c2984536c90ed118bb1d7> "Creates a 3D CUDA array."), [cuArray3DGetDescriptor](<group__CUDA__MEM.html#group__CUDA__MEM_1gb58549f2f3f390b9e0e7c8f3acd53857> "Get a 3D CUDA array descriptor."), [cuArrayCreate](<group__CUDA__MEM.html#group__CUDA__MEM_1g4192ff387a81c3bd5ed8c391ed62ca24> "Creates a 1D or 2D CUDA array."), [cuArrayDestroy](<group__CUDA__MEM.html#group__CUDA__MEM_1g982878affbbc023de84874faac838b0b> "Destroys a CUDA array."), [cuArrayGetDescriptor](<group__CUDA__MEM.html#group__CUDA__MEM_1g661fe823dbd37bf11f82a71bd4762acf> "Get a 1D or 2D CUDA array descriptor."), [cuMemAlloc](<group__CUDA__MEM.html#group__CUDA__MEM_1gb82d2a09844a58dd9e744dc31e8aa467> "Allocates device memory."), [cuMemAllocHost](<group__CUDA__MEM.html#group__CUDA__MEM_1gdd8311286d2c2691605362c689bc64e0> "Allocates page-locked host memory."), [cuMemAllocPitch](<group__CUDA__MEM.html#group__CUDA__MEM_1gcbe9b033f6c4de80f63cc6e58ed9a45a> "Allocates pitched device memory."), [cuMemcpy2D](<group__CUDA__MEM.html#group__CUDA__MEM_1g27f885b30c34cc20a663a671dbf6fc27> "Copies memory for 2D arrays."), [cuMemcpy2DAsync](<group__CUDA__MEM.html#group__CUDA__MEM_1g4acf155faeb969d9d21f5433d3d0f274> "Copies memory for 2D arrays."), [cuMemcpy2DUnaligned](<group__CUDA__MEM.html#group__CUDA__MEM_1g2fa285d47fd7020e596bfeab3deb651b> "Copies memory for 2D arrays."), [cuMemcpy3D](<group__CUDA__MEM.html#group__CUDA__MEM_1g4b5238975579f002c0199a3800ca44df> "Copies memory for 3D arrays."), [cuMemcpy3DAsync](<group__CUDA__MEM.html#group__CUDA__MEM_1g79f4f3fde6ae0f529568d881d9e11987> "Copies memory for 3D arrays."), [cuMemcpyAtoA](<group__CUDA__MEM.html#group__CUDA__MEM_1gf81b218c984a31436ec9e23a85fb604a> "Copies memory from Array to Array."), [cuMemcpyAtoD](<group__CUDA__MEM.html#group__CUDA__MEM_1g825b3f037f7f51382cae991bae8173fd> "Copies memory from Array to Device."), [cuMemcpyAtoH](<group__CUDA__MEM.html#group__CUDA__MEM_1gf7ad1edb2539cccc352c6b8b76f657f4> "Copies memory from Array to Host."), [cuMemcpyAtoHAsync](<group__CUDA__MEM.html#group__CUDA__MEM_1g64cbd2e60436699aebdd0bdbf14d0f01> "Copies memory from Array to Host."), [cuMemcpyDtoA](<group__CUDA__MEM.html#group__CUDA__MEM_1gad6827247af91600b56ce6e2ddb802e1> "Copies memory from Device to Array."), [cuMemcpyDtoD](<group__CUDA__MEM.html#group__CUDA__MEM_1g1725774abf8b51b91945f3336b778c8b> "Copies memory from Device to Device."), [cuMemcpyDtoH](<group__CUDA__MEM.html#group__CUDA__MEM_1g3480368ee0208a98f75019c9a8450893> "Copies memory from Device to Host."), [cuMemcpyDtoHAsync](<group__CUDA__MEM.html#group__CUDA__MEM_1g56f30236c7c5247f8e061b59d3268362> "Copies memory from Device to Host."), [cuMemcpyHtoA](<group__CUDA__MEM.html#group__CUDA__MEM_1g57d3d780d165ecc0e3b3ce08e141cd89> "Copies memory from Host to Array."), [cuMemcpyHtoAAsync](<group__CUDA__MEM.html#group__CUDA__MEM_1gb5c4863f64f132b4bc2661818b3fd188> "Copies memory from Host to Array."), [cuMemcpyHtoD](<group__CUDA__MEM.html#group__CUDA__MEM_1g4d32266788c440b0220b1a9ba5795169> "Copies memory from Host to Device."), [cuMemcpyHtoDAsync](<group__CUDA__MEM.html#group__CUDA__MEM_1g1572263fe2597d7ba4f6964597a354a3> "Copies memory from Host to Device."), [cuMemFree](<group__CUDA__MEM.html#group__CUDA__MEM_1g89b3f154e17cc89b6eea277dbdf5c93a> "Frees device memory."), [cuMemFreeHost](<group__CUDA__MEM.html#group__CUDA__MEM_1g62e0fdbe181dab6b1c90fa1a51c7b92c> "Frees page-locked host memory."), [cuMemGetAddressRange](<group__CUDA__MEM.html#group__CUDA__MEM_1g64fee5711274a2a0573a789c94d8299b> "Get information on memory allocations."), [cuMemGetInfo](<group__CUDA__MEM.html#group__CUDA__MEM_1g808f555540d0143a331cc42aa98835c0> "Gets free and total memory."), [cuMemHostAlloc](<group__CUDA__MEM.html#group__CUDA__MEM_1g572ca4011bfcb25034888a14d4e035b9> "Allocates page-locked host memory."), [cuMemHostGetDevicePointer](<group__CUDA__MEM.html#group__CUDA__MEM_1g57a39e5cba26af4d06be67fc77cc62f0> "Passes back device pointer of mapped pinned memory."), [cuMemsetD2D8](<group__CUDA__MEM.html#group__CUDA__MEM_1ge88b13e646e2be6ba0e0475ef5205974> "Initializes device memory."), [cuMemsetD2D8Async](<group__CUDA__MEM.html#group__CUDA__MEM_1g3f7b6924a3e49c3265b328f534102e97> "Sets device memory."), [cuMemsetD2D16](<group__CUDA__MEM.html#group__CUDA__MEM_1g7f561a15a66144fa9f6ab5350edc8a30> "Initializes device memory."), [cuMemsetD2D16Async](<group__CUDA__MEM.html#group__CUDA__MEM_1g64ee197befac3d74d9fefedcf6ef6b10> "Sets device memory."), [cuMemsetD2D32](<group__CUDA__MEM.html#group__CUDA__MEM_1g74b359b2d026bfeb7c795b5038d07523> "Initializes device memory."), [cuMemsetD2D32Async](<group__CUDA__MEM.html#group__CUDA__MEM_1g8a78d3147ac93fac955052c815d9ea3c> "Sets device memory."), [cuMemsetD8](<group__CUDA__MEM.html#group__CUDA__MEM_1g6e582bf866e9e2fb014297bfaf354d7b> "Initializes device memory."), [cuMemsetD8Async](<group__CUDA__MEM.html#group__CUDA__MEM_1gaef08a7ccd61112f94e82f2b30d43627> "Sets device memory."), [cuMemsetD16](<group__CUDA__MEM.html#group__CUDA__MEM_1g7d805e610054392a4d11e8a8bf5eb35c> "Initializes device memory."), [cuMemsetD16Async](<group__CUDA__MEM.html#group__CUDA__MEM_1gf731438877dd8ec875e4c43d848c878c> "Sets device memory."), [cuMemsetD32](<group__CUDA__MEM.html#group__CUDA__MEM_1g983e8d8759acd1b64326317481fbf132> "Initializes device memory."), [cuMemsetD32Async](<group__CUDA__MEM.html#group__CUDA__MEM_1g58229da5d30f1c0cdf667b320ec2c0f5> "Sets device memory."), [cudaMemcpyAsync](<../cuda-runtime-api/group__CUDART__MEMORY.html#group__CUDART__MEMORY_1g85073372f776b4c4d5f89f7124b7bf79>), [cudaMemcpyToSymbolAsync](<../cuda-runtime-api/group__CUDART__HIGHLEVEL.html#group__CUDART__HIGHLEVEL_1gd00b41ade29161aafbf6ff8aee3d6eb5>), [cudaMemcpyFromSymbolAsync](<../cuda-runtime-api/group__CUDART__HIGHLEVEL.html#group__CUDART__HIGHLEVEL_1g2d9f7a440f1e522555dfe994245a5946>)

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuMemcpyDtoH ( void*Â dstHost, [CUdeviceptr](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g183f7b0d8ad008ea2a5fd552537ace4e>)Â srcDevice, size_tÂ ByteCount )


Copies memory from Device to Host.

######  Parameters

`dstHost`
    \- Destination host pointer
`srcDevice`
    \- Source device pointer
`ByteCount`
    \- Size of memory copy in bytes

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_DEINITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9acf52f132faf29b473cdda6061f0f44a>), [CUDA_ERROR_NOT_INITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e98feb999f0af99b4a25ab26b3866f4df8>), [CUDA_ERROR_INVALID_CONTEXT](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a484e9af32c1e9893ff21f0e0191a12d>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>)

###### Description

Copies from device to host memory. `dstHost` and `srcDevice` specify the base pointers of the destination and source, respectively. `ByteCount` specifies the number of bytes to copy.

Note:

  * Note that this function may also return error codes from previous, asynchronous launches.

  * This function exhibits [synchronous](<api-sync-behavior.html#api-sync-behavior__memcpy-sync>) behavior for most use cases.

  * Memory regions requested must be either entirely registered with CUDA, or in the case of host pageable transfers, not registered at all. Memory regions spanning over allocations that are both registered and not registered with CUDA are not supported and will return CUDA_ERROR_INVALID_VALUE.


**See also:**

[cuArray3DCreate](<group__CUDA__MEM.html#group__CUDA__MEM_1gc2322c70b38c2984536c90ed118bb1d7> "Creates a 3D CUDA array."), [cuArray3DGetDescriptor](<group__CUDA__MEM.html#group__CUDA__MEM_1gb58549f2f3f390b9e0e7c8f3acd53857> "Get a 3D CUDA array descriptor."), [cuArrayCreate](<group__CUDA__MEM.html#group__CUDA__MEM_1g4192ff387a81c3bd5ed8c391ed62ca24> "Creates a 1D or 2D CUDA array."), [cuArrayDestroy](<group__CUDA__MEM.html#group__CUDA__MEM_1g982878affbbc023de84874faac838b0b> "Destroys a CUDA array."), [cuArrayGetDescriptor](<group__CUDA__MEM.html#group__CUDA__MEM_1g661fe823dbd37bf11f82a71bd4762acf> "Get a 1D or 2D CUDA array descriptor."), [cuMemAlloc](<group__CUDA__MEM.html#group__CUDA__MEM_1gb82d2a09844a58dd9e744dc31e8aa467> "Allocates device memory."), [cuMemAllocHost](<group__CUDA__MEM.html#group__CUDA__MEM_1gdd8311286d2c2691605362c689bc64e0> "Allocates page-locked host memory."), [cuMemAllocPitch](<group__CUDA__MEM.html#group__CUDA__MEM_1gcbe9b033f6c4de80f63cc6e58ed9a45a> "Allocates pitched device memory."), [cuMemcpy2D](<group__CUDA__MEM.html#group__CUDA__MEM_1g27f885b30c34cc20a663a671dbf6fc27> "Copies memory for 2D arrays."), [cuMemcpy2DAsync](<group__CUDA__MEM.html#group__CUDA__MEM_1g4acf155faeb969d9d21f5433d3d0f274> "Copies memory for 2D arrays."), [cuMemcpy2DUnaligned](<group__CUDA__MEM.html#group__CUDA__MEM_1g2fa285d47fd7020e596bfeab3deb651b> "Copies memory for 2D arrays."), [cuMemcpy3D](<group__CUDA__MEM.html#group__CUDA__MEM_1g4b5238975579f002c0199a3800ca44df> "Copies memory for 3D arrays."), [cuMemcpy3DAsync](<group__CUDA__MEM.html#group__CUDA__MEM_1g79f4f3fde6ae0f529568d881d9e11987> "Copies memory for 3D arrays."), [cuMemcpyAtoA](<group__CUDA__MEM.html#group__CUDA__MEM_1gf81b218c984a31436ec9e23a85fb604a> "Copies memory from Array to Array."), [cuMemcpyAtoD](<group__CUDA__MEM.html#group__CUDA__MEM_1g825b3f037f7f51382cae991bae8173fd> "Copies memory from Array to Device."), [cuMemcpyAtoH](<group__CUDA__MEM.html#group__CUDA__MEM_1gf7ad1edb2539cccc352c6b8b76f657f4> "Copies memory from Array to Host."), [cuMemcpyAtoHAsync](<group__CUDA__MEM.html#group__CUDA__MEM_1g64cbd2e60436699aebdd0bdbf14d0f01> "Copies memory from Array to Host."), [cuMemcpyDtoA](<group__CUDA__MEM.html#group__CUDA__MEM_1gad6827247af91600b56ce6e2ddb802e1> "Copies memory from Device to Array."), [cuMemcpyDtoD](<group__CUDA__MEM.html#group__CUDA__MEM_1g1725774abf8b51b91945f3336b778c8b> "Copies memory from Device to Device."), [cuMemcpyDtoDAsync](<group__CUDA__MEM.html#group__CUDA__MEM_1g39ea09ba682b8eccc9c3e0c04319b5c8> "Copies memory from Device to Device."), [cuMemcpyDtoHAsync](<group__CUDA__MEM.html#group__CUDA__MEM_1g56f30236c7c5247f8e061b59d3268362> "Copies memory from Device to Host."), [cuMemcpyHtoA](<group__CUDA__MEM.html#group__CUDA__MEM_1g57d3d780d165ecc0e3b3ce08e141cd89> "Copies memory from Host to Array."), [cuMemcpyHtoAAsync](<group__CUDA__MEM.html#group__CUDA__MEM_1gb5c4863f64f132b4bc2661818b3fd188> "Copies memory from Host to Array."), [cuMemcpyHtoD](<group__CUDA__MEM.html#group__CUDA__MEM_1g4d32266788c440b0220b1a9ba5795169> "Copies memory from Host to Device."), [cuMemcpyHtoDAsync](<group__CUDA__MEM.html#group__CUDA__MEM_1g1572263fe2597d7ba4f6964597a354a3> "Copies memory from Host to Device."), [cuMemFree](<group__CUDA__MEM.html#group__CUDA__MEM_1g89b3f154e17cc89b6eea277dbdf5c93a> "Frees device memory."), [cuMemFreeHost](<group__CUDA__MEM.html#group__CUDA__MEM_1g62e0fdbe181dab6b1c90fa1a51c7b92c> "Frees page-locked host memory."), [cuMemGetAddressRange](<group__CUDA__MEM.html#group__CUDA__MEM_1g64fee5711274a2a0573a789c94d8299b> "Get information on memory allocations."), [cuMemGetInfo](<group__CUDA__MEM.html#group__CUDA__MEM_1g808f555540d0143a331cc42aa98835c0> "Gets free and total memory."), [cuMemHostAlloc](<group__CUDA__MEM.html#group__CUDA__MEM_1g572ca4011bfcb25034888a14d4e035b9> "Allocates page-locked host memory."), [cuMemHostGetDevicePointer](<group__CUDA__MEM.html#group__CUDA__MEM_1g57a39e5cba26af4d06be67fc77cc62f0> "Passes back device pointer of mapped pinned memory."), [cuMemsetD2D8](<group__CUDA__MEM.html#group__CUDA__MEM_1ge88b13e646e2be6ba0e0475ef5205974> "Initializes device memory."), [cuMemsetD2D16](<group__CUDA__MEM.html#group__CUDA__MEM_1g7f561a15a66144fa9f6ab5350edc8a30> "Initializes device memory."), [cuMemsetD2D32](<group__CUDA__MEM.html#group__CUDA__MEM_1g74b359b2d026bfeb7c795b5038d07523> "Initializes device memory."), [cuMemsetD8](<group__CUDA__MEM.html#group__CUDA__MEM_1g6e582bf866e9e2fb014297bfaf354d7b> "Initializes device memory."), [cuMemsetD16](<group__CUDA__MEM.html#group__CUDA__MEM_1g7d805e610054392a4d11e8a8bf5eb35c> "Initializes device memory."), [cuMemsetD32](<group__CUDA__MEM.html#group__CUDA__MEM_1g983e8d8759acd1b64326317481fbf132> "Initializes device memory."), [cudaMemcpy](<../cuda-runtime-api/group__CUDART__MEMORY.html#group__CUDART__MEMORY_1gc263dbe6574220cc776b45438fc351e8>), [cudaMemcpyFromSymbol](<../cuda-runtime-api/group__CUDART__HIGHLEVEL.html#group__CUDART__HIGHLEVEL_1g99db510d18d37fbb0f5c075a8caf3b5f>)

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuMemcpyDtoHAsync ( void*Â dstHost, [CUdeviceptr](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g183f7b0d8ad008ea2a5fd552537ace4e>)Â srcDevice, size_tÂ ByteCount, [CUstream](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gb946c7f02e09efd788a204718015d88a>)Â hStream )


Copies memory from Device to Host.

######  Parameters

`dstHost`
    \- Destination host pointer
`srcDevice`
    \- Source device pointer
`ByteCount`
    \- Size of memory copy in bytes
`hStream`
    \- Stream identifier

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_DEINITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9acf52f132faf29b473cdda6061f0f44a>), [CUDA_ERROR_NOT_INITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e98feb999f0af99b4a25ab26b3866f4df8>), [CUDA_ERROR_INVALID_CONTEXT](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a484e9af32c1e9893ff21f0e0191a12d>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>), [CUDA_ERROR_INVALID_HANDLE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e90fd2e63260c6317ba943af0f7e4b8d21>)

###### Description

Copies from device to host memory. `dstHost` and `srcDevice` specify the base pointers of the destination and source, respectively. `ByteCount` specifies the number of bytes to copy.

Note:

  * Note that this function may also return error codes from previous, asynchronous launches.

  * This function exhibits [asynchronous](<api-sync-behavior.html#api-sync-behavior__memcpy-async>) behavior for most use cases.

  * This function uses standard [default stream](<stream-sync-behavior.html#stream-sync-behavior__default-stream>) semantics.

  * Memory regions requested must be either entirely registered with CUDA, or in the case of host pageable transfers, not registered at all. Memory regions spanning over allocations that are both registered and not registered with CUDA are not supported and will return CUDA_ERROR_INVALID_VALUE.


**See also:**

[cuArray3DCreate](<group__CUDA__MEM.html#group__CUDA__MEM_1gc2322c70b38c2984536c90ed118bb1d7> "Creates a 3D CUDA array."), [cuArray3DGetDescriptor](<group__CUDA__MEM.html#group__CUDA__MEM_1gb58549f2f3f390b9e0e7c8f3acd53857> "Get a 3D CUDA array descriptor."), [cuArrayCreate](<group__CUDA__MEM.html#group__CUDA__MEM_1g4192ff387a81c3bd5ed8c391ed62ca24> "Creates a 1D or 2D CUDA array."), [cuArrayDestroy](<group__CUDA__MEM.html#group__CUDA__MEM_1g982878affbbc023de84874faac838b0b> "Destroys a CUDA array."), [cuArrayGetDescriptor](<group__CUDA__MEM.html#group__CUDA__MEM_1g661fe823dbd37bf11f82a71bd4762acf> "Get a 1D or 2D CUDA array descriptor."), [cuMemAlloc](<group__CUDA__MEM.html#group__CUDA__MEM_1gb82d2a09844a58dd9e744dc31e8aa467> "Allocates device memory."), [cuMemAllocHost](<group__CUDA__MEM.html#group__CUDA__MEM_1gdd8311286d2c2691605362c689bc64e0> "Allocates page-locked host memory."), [cuMemAllocPitch](<group__CUDA__MEM.html#group__CUDA__MEM_1gcbe9b033f6c4de80f63cc6e58ed9a45a> "Allocates pitched device memory."), [cuMemcpy2D](<group__CUDA__MEM.html#group__CUDA__MEM_1g27f885b30c34cc20a663a671dbf6fc27> "Copies memory for 2D arrays."), [cuMemcpy2DAsync](<group__CUDA__MEM.html#group__CUDA__MEM_1g4acf155faeb969d9d21f5433d3d0f274> "Copies memory for 2D arrays."), [cuMemcpy2DUnaligned](<group__CUDA__MEM.html#group__CUDA__MEM_1g2fa285d47fd7020e596bfeab3deb651b> "Copies memory for 2D arrays."), [cuMemcpy3D](<group__CUDA__MEM.html#group__CUDA__MEM_1g4b5238975579f002c0199a3800ca44df> "Copies memory for 3D arrays."), [cuMemcpy3DAsync](<group__CUDA__MEM.html#group__CUDA__MEM_1g79f4f3fde6ae0f529568d881d9e11987> "Copies memory for 3D arrays."), [cuMemcpyAtoA](<group__CUDA__MEM.html#group__CUDA__MEM_1gf81b218c984a31436ec9e23a85fb604a> "Copies memory from Array to Array."), [cuMemcpyAtoD](<group__CUDA__MEM.html#group__CUDA__MEM_1g825b3f037f7f51382cae991bae8173fd> "Copies memory from Array to Device."), [cuMemcpyAtoH](<group__CUDA__MEM.html#group__CUDA__MEM_1gf7ad1edb2539cccc352c6b8b76f657f4> "Copies memory from Array to Host."), [cuMemcpyAtoHAsync](<group__CUDA__MEM.html#group__CUDA__MEM_1g64cbd2e60436699aebdd0bdbf14d0f01> "Copies memory from Array to Host."), [cuMemcpyDtoA](<group__CUDA__MEM.html#group__CUDA__MEM_1gad6827247af91600b56ce6e2ddb802e1> "Copies memory from Device to Array."), [cuMemcpyDtoD](<group__CUDA__MEM.html#group__CUDA__MEM_1g1725774abf8b51b91945f3336b778c8b> "Copies memory from Device to Device."), [cuMemcpyDtoDAsync](<group__CUDA__MEM.html#group__CUDA__MEM_1g39ea09ba682b8eccc9c3e0c04319b5c8> "Copies memory from Device to Device."), [cuMemcpyDtoH](<group__CUDA__MEM.html#group__CUDA__MEM_1g3480368ee0208a98f75019c9a8450893> "Copies memory from Device to Host."), [cuMemcpyHtoA](<group__CUDA__MEM.html#group__CUDA__MEM_1g57d3d780d165ecc0e3b3ce08e141cd89> "Copies memory from Host to Array."), [cuMemcpyHtoAAsync](<group__CUDA__MEM.html#group__CUDA__MEM_1gb5c4863f64f132b4bc2661818b3fd188> "Copies memory from Host to Array."), [cuMemcpyHtoD](<group__CUDA__MEM.html#group__CUDA__MEM_1g4d32266788c440b0220b1a9ba5795169> "Copies memory from Host to Device."), [cuMemcpyHtoDAsync](<group__CUDA__MEM.html#group__CUDA__MEM_1g1572263fe2597d7ba4f6964597a354a3> "Copies memory from Host to Device."), [cuMemFree](<group__CUDA__MEM.html#group__CUDA__MEM_1g89b3f154e17cc89b6eea277dbdf5c93a> "Frees device memory."), [cuMemFreeHost](<group__CUDA__MEM.html#group__CUDA__MEM_1g62e0fdbe181dab6b1c90fa1a51c7b92c> "Frees page-locked host memory."), [cuMemGetAddressRange](<group__CUDA__MEM.html#group__CUDA__MEM_1g64fee5711274a2a0573a789c94d8299b> "Get information on memory allocations."), [cuMemGetInfo](<group__CUDA__MEM.html#group__CUDA__MEM_1g808f555540d0143a331cc42aa98835c0> "Gets free and total memory."), [cuMemHostAlloc](<group__CUDA__MEM.html#group__CUDA__MEM_1g572ca4011bfcb25034888a14d4e035b9> "Allocates page-locked host memory."), [cuMemHostGetDevicePointer](<group__CUDA__MEM.html#group__CUDA__MEM_1g57a39e5cba26af4d06be67fc77cc62f0> "Passes back device pointer of mapped pinned memory."), [cuMemsetD2D8](<group__CUDA__MEM.html#group__CUDA__MEM_1ge88b13e646e2be6ba0e0475ef5205974> "Initializes device memory."), [cuMemsetD2D8Async](<group__CUDA__MEM.html#group__CUDA__MEM_1g3f7b6924a3e49c3265b328f534102e97> "Sets device memory."), [cuMemsetD2D16](<group__CUDA__MEM.html#group__CUDA__MEM_1g7f561a15a66144fa9f6ab5350edc8a30> "Initializes device memory."), [cuMemsetD2D16Async](<group__CUDA__MEM.html#group__CUDA__MEM_1g64ee197befac3d74d9fefedcf6ef6b10> "Sets device memory."), [cuMemsetD2D32](<group__CUDA__MEM.html#group__CUDA__MEM_1g74b359b2d026bfeb7c795b5038d07523> "Initializes device memory."), [cuMemsetD2D32Async](<group__CUDA__MEM.html#group__CUDA__MEM_1g8a78d3147ac93fac955052c815d9ea3c> "Sets device memory."), [cuMemsetD8](<group__CUDA__MEM.html#group__CUDA__MEM_1g6e582bf866e9e2fb014297bfaf354d7b> "Initializes device memory."), [cuMemsetD8Async](<group__CUDA__MEM.html#group__CUDA__MEM_1gaef08a7ccd61112f94e82f2b30d43627> "Sets device memory."), [cuMemsetD16](<group__CUDA__MEM.html#group__CUDA__MEM_1g7d805e610054392a4d11e8a8bf5eb35c> "Initializes device memory."), [cuMemsetD16Async](<group__CUDA__MEM.html#group__CUDA__MEM_1gf731438877dd8ec875e4c43d848c878c> "Sets device memory."), [cuMemsetD32](<group__CUDA__MEM.html#group__CUDA__MEM_1g983e8d8759acd1b64326317481fbf132> "Initializes device memory."), [cuMemsetD32Async](<group__CUDA__MEM.html#group__CUDA__MEM_1g58229da5d30f1c0cdf667b320ec2c0f5> "Sets device memory."), [cudaMemcpyAsync](<../cuda-runtime-api/group__CUDART__MEMORY.html#group__CUDART__MEMORY_1g85073372f776b4c4d5f89f7124b7bf79>), [cudaMemcpyFromSymbolAsync](<../cuda-runtime-api/group__CUDART__HIGHLEVEL.html#group__CUDART__HIGHLEVEL_1g2d9f7a440f1e522555dfe994245a5946>)

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuMemcpyHtoA ( [CUarray](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gd550651524a56766b60f10f0e7628042>)Â dstArray, size_tÂ dstOffset, const void*Â srcHost, size_tÂ ByteCount )


Copies memory from Host to Array.

######  Parameters

`dstArray`
    \- Destination array
`dstOffset`
    \- Offset in bytes of destination array
`srcHost`
    \- Source host pointer
`ByteCount`
    \- Size of memory copy in bytes

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_DEINITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9acf52f132faf29b473cdda6061f0f44a>), [CUDA_ERROR_NOT_INITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e98feb999f0af99b4a25ab26b3866f4df8>), [CUDA_ERROR_INVALID_CONTEXT](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a484e9af32c1e9893ff21f0e0191a12d>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>)

###### Description

Copies from host memory to a 1D CUDA array. `dstArray` and `dstOffset` specify the CUDA array handle and starting offset in bytes of the destination data. `pSrc` specifies the base address of the source. `ByteCount` specifies the number of bytes to copy.

Note:

  * Note that this function may also return error codes from previous, asynchronous launches.

  * This function exhibits [synchronous](<api-sync-behavior.html#api-sync-behavior__memcpy-sync>) behavior for most use cases.

  * Memory regions requested must be either entirely registered with CUDA, or in the case of host pageable transfers, not registered at all. Memory regions spanning over allocations that are both registered and not registered with CUDA are not supported and will return CUDA_ERROR_INVALID_VALUE.


**See also:**

[cuArray3DCreate](<group__CUDA__MEM.html#group__CUDA__MEM_1gc2322c70b38c2984536c90ed118bb1d7> "Creates a 3D CUDA array."), [cuArray3DGetDescriptor](<group__CUDA__MEM.html#group__CUDA__MEM_1gb58549f2f3f390b9e0e7c8f3acd53857> "Get a 3D CUDA array descriptor."), [cuArrayCreate](<group__CUDA__MEM.html#group__CUDA__MEM_1g4192ff387a81c3bd5ed8c391ed62ca24> "Creates a 1D or 2D CUDA array."), [cuArrayDestroy](<group__CUDA__MEM.html#group__CUDA__MEM_1g982878affbbc023de84874faac838b0b> "Destroys a CUDA array."), [cuArrayGetDescriptor](<group__CUDA__MEM.html#group__CUDA__MEM_1g661fe823dbd37bf11f82a71bd4762acf> "Get a 1D or 2D CUDA array descriptor."), [cuMemAlloc](<group__CUDA__MEM.html#group__CUDA__MEM_1gb82d2a09844a58dd9e744dc31e8aa467> "Allocates device memory."), [cuMemAllocHost](<group__CUDA__MEM.html#group__CUDA__MEM_1gdd8311286d2c2691605362c689bc64e0> "Allocates page-locked host memory."), [cuMemAllocPitch](<group__CUDA__MEM.html#group__CUDA__MEM_1gcbe9b033f6c4de80f63cc6e58ed9a45a> "Allocates pitched device memory."), [cuMemcpy2D](<group__CUDA__MEM.html#group__CUDA__MEM_1g27f885b30c34cc20a663a671dbf6fc27> "Copies memory for 2D arrays."), [cuMemcpy2DAsync](<group__CUDA__MEM.html#group__CUDA__MEM_1g4acf155faeb969d9d21f5433d3d0f274> "Copies memory for 2D arrays."), [cuMemcpy2DUnaligned](<group__CUDA__MEM.html#group__CUDA__MEM_1g2fa285d47fd7020e596bfeab3deb651b> "Copies memory for 2D arrays."), [cuMemcpy3D](<group__CUDA__MEM.html#group__CUDA__MEM_1g4b5238975579f002c0199a3800ca44df> "Copies memory for 3D arrays."), [cuMemcpy3DAsync](<group__CUDA__MEM.html#group__CUDA__MEM_1g79f4f3fde6ae0f529568d881d9e11987> "Copies memory for 3D arrays."), [cuMemcpyAtoA](<group__CUDA__MEM.html#group__CUDA__MEM_1gf81b218c984a31436ec9e23a85fb604a> "Copies memory from Array to Array."), [cuMemcpyAtoD](<group__CUDA__MEM.html#group__CUDA__MEM_1g825b3f037f7f51382cae991bae8173fd> "Copies memory from Array to Device."), [cuMemcpyAtoH](<group__CUDA__MEM.html#group__CUDA__MEM_1gf7ad1edb2539cccc352c6b8b76f657f4> "Copies memory from Array to Host."), [cuMemcpyAtoHAsync](<group__CUDA__MEM.html#group__CUDA__MEM_1g64cbd2e60436699aebdd0bdbf14d0f01> "Copies memory from Array to Host."), [cuMemcpyDtoA](<group__CUDA__MEM.html#group__CUDA__MEM_1gad6827247af91600b56ce6e2ddb802e1> "Copies memory from Device to Array."), [cuMemcpyDtoD](<group__CUDA__MEM.html#group__CUDA__MEM_1g1725774abf8b51b91945f3336b778c8b> "Copies memory from Device to Device."), [cuMemcpyDtoDAsync](<group__CUDA__MEM.html#group__CUDA__MEM_1g39ea09ba682b8eccc9c3e0c04319b5c8> "Copies memory from Device to Device."), [cuMemcpyDtoH](<group__CUDA__MEM.html#group__CUDA__MEM_1g3480368ee0208a98f75019c9a8450893> "Copies memory from Device to Host."), [cuMemcpyDtoHAsync](<group__CUDA__MEM.html#group__CUDA__MEM_1g56f30236c7c5247f8e061b59d3268362> "Copies memory from Device to Host."), [cuMemcpyHtoAAsync](<group__CUDA__MEM.html#group__CUDA__MEM_1gb5c4863f64f132b4bc2661818b3fd188> "Copies memory from Host to Array."), [cuMemcpyHtoD](<group__CUDA__MEM.html#group__CUDA__MEM_1g4d32266788c440b0220b1a9ba5795169> "Copies memory from Host to Device."), [cuMemcpyHtoDAsync](<group__CUDA__MEM.html#group__CUDA__MEM_1g1572263fe2597d7ba4f6964597a354a3> "Copies memory from Host to Device."), [cuMemFree](<group__CUDA__MEM.html#group__CUDA__MEM_1g89b3f154e17cc89b6eea277dbdf5c93a> "Frees device memory."), [cuMemFreeHost](<group__CUDA__MEM.html#group__CUDA__MEM_1g62e0fdbe181dab6b1c90fa1a51c7b92c> "Frees page-locked host memory."), [cuMemGetAddressRange](<group__CUDA__MEM.html#group__CUDA__MEM_1g64fee5711274a2a0573a789c94d8299b> "Get information on memory allocations."), [cuMemGetInfo](<group__CUDA__MEM.html#group__CUDA__MEM_1g808f555540d0143a331cc42aa98835c0> "Gets free and total memory."), [cuMemHostAlloc](<group__CUDA__MEM.html#group__CUDA__MEM_1g572ca4011bfcb25034888a14d4e035b9> "Allocates page-locked host memory."), [cuMemHostGetDevicePointer](<group__CUDA__MEM.html#group__CUDA__MEM_1g57a39e5cba26af4d06be67fc77cc62f0> "Passes back device pointer of mapped pinned memory."), [cuMemsetD2D8](<group__CUDA__MEM.html#group__CUDA__MEM_1ge88b13e646e2be6ba0e0475ef5205974> "Initializes device memory."), [cuMemsetD2D16](<group__CUDA__MEM.html#group__CUDA__MEM_1g7f561a15a66144fa9f6ab5350edc8a30> "Initializes device memory."), [cuMemsetD2D32](<group__CUDA__MEM.html#group__CUDA__MEM_1g74b359b2d026bfeb7c795b5038d07523> "Initializes device memory."), [cuMemsetD8](<group__CUDA__MEM.html#group__CUDA__MEM_1g6e582bf866e9e2fb014297bfaf354d7b> "Initializes device memory."), [cuMemsetD16](<group__CUDA__MEM.html#group__CUDA__MEM_1g7d805e610054392a4d11e8a8bf5eb35c> "Initializes device memory."), [cuMemsetD32](<group__CUDA__MEM.html#group__CUDA__MEM_1g983e8d8759acd1b64326317481fbf132> "Initializes device memory."), [cudaMemcpyToArray](<../cuda-runtime-api/group__CUDART__MEMORY__DEPRECATED.html#group__CUDART__MEMORY__DEPRECATED_1g15b5d20cedf31dd13801c6015da0e828>)

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuMemcpyHtoAAsync ( [CUarray](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gd550651524a56766b60f10f0e7628042>)Â dstArray, size_tÂ dstOffset, const void*Â srcHost, size_tÂ ByteCount, [CUstream](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gb946c7f02e09efd788a204718015d88a>)Â hStream )


Copies memory from Host to Array.

######  Parameters

`dstArray`
    \- Destination array
`dstOffset`
    \- Offset in bytes of destination array
`srcHost`
    \- Source host pointer
`ByteCount`
    \- Size of memory copy in bytes
`hStream`
    \- Stream identifier

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_DEINITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9acf52f132faf29b473cdda6061f0f44a>), [CUDA_ERROR_NOT_INITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e98feb999f0af99b4a25ab26b3866f4df8>), [CUDA_ERROR_INVALID_CONTEXT](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a484e9af32c1e9893ff21f0e0191a12d>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>), [CUDA_ERROR_INVALID_HANDLE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e90fd2e63260c6317ba943af0f7e4b8d21>)

###### Description

Copies from host memory to a 1D CUDA array. `dstArray` and `dstOffset` specify the CUDA array handle and starting offset in bytes of the destination data. `srcHost` specifies the base address of the source. `ByteCount` specifies the number of bytes to copy.

Note:

  * Note that this function may also return error codes from previous, asynchronous launches.

  * This function exhibits [asynchronous](<api-sync-behavior.html#api-sync-behavior__memcpy-async>) behavior for most use cases.

  * This function uses standard [default stream](<stream-sync-behavior.html#stream-sync-behavior__default-stream>) semantics.

  * Memory regions requested must be either entirely registered with CUDA, or in the case of host pageable transfers, not registered at all. Memory regions spanning over allocations that are both registered and not registered with CUDA are not supported and will return CUDA_ERROR_INVALID_VALUE.


**See also:**

[cuArray3DCreate](<group__CUDA__MEM.html#group__CUDA__MEM_1gc2322c70b38c2984536c90ed118bb1d7> "Creates a 3D CUDA array."), [cuArray3DGetDescriptor](<group__CUDA__MEM.html#group__CUDA__MEM_1gb58549f2f3f390b9e0e7c8f3acd53857> "Get a 3D CUDA array descriptor."), [cuArrayCreate](<group__CUDA__MEM.html#group__CUDA__MEM_1g4192ff387a81c3bd5ed8c391ed62ca24> "Creates a 1D or 2D CUDA array."), [cuArrayDestroy](<group__CUDA__MEM.html#group__CUDA__MEM_1g982878affbbc023de84874faac838b0b> "Destroys a CUDA array."), [cuArrayGetDescriptor](<group__CUDA__MEM.html#group__CUDA__MEM_1g661fe823dbd37bf11f82a71bd4762acf> "Get a 1D or 2D CUDA array descriptor."), [cuMemAlloc](<group__CUDA__MEM.html#group__CUDA__MEM_1gb82d2a09844a58dd9e744dc31e8aa467> "Allocates device memory."), [cuMemAllocHost](<group__CUDA__MEM.html#group__CUDA__MEM_1gdd8311286d2c2691605362c689bc64e0> "Allocates page-locked host memory."), [cuMemAllocPitch](<group__CUDA__MEM.html#group__CUDA__MEM_1gcbe9b033f6c4de80f63cc6e58ed9a45a> "Allocates pitched device memory."), [cuMemcpy2D](<group__CUDA__MEM.html#group__CUDA__MEM_1g27f885b30c34cc20a663a671dbf6fc27> "Copies memory for 2D arrays."), [cuMemcpy2DAsync](<group__CUDA__MEM.html#group__CUDA__MEM_1g4acf155faeb969d9d21f5433d3d0f274> "Copies memory for 2D arrays."), [cuMemcpy2DUnaligned](<group__CUDA__MEM.html#group__CUDA__MEM_1g2fa285d47fd7020e596bfeab3deb651b> "Copies memory for 2D arrays."), [cuMemcpy3D](<group__CUDA__MEM.html#group__CUDA__MEM_1g4b5238975579f002c0199a3800ca44df> "Copies memory for 3D arrays."), [cuMemcpy3DAsync](<group__CUDA__MEM.html#group__CUDA__MEM_1g79f4f3fde6ae0f529568d881d9e11987> "Copies memory for 3D arrays."), [cuMemcpyAtoA](<group__CUDA__MEM.html#group__CUDA__MEM_1gf81b218c984a31436ec9e23a85fb604a> "Copies memory from Array to Array."), [cuMemcpyAtoD](<group__CUDA__MEM.html#group__CUDA__MEM_1g825b3f037f7f51382cae991bae8173fd> "Copies memory from Array to Device."), [cuMemcpyAtoH](<group__CUDA__MEM.html#group__CUDA__MEM_1gf7ad1edb2539cccc352c6b8b76f657f4> "Copies memory from Array to Host."), [cuMemcpyAtoHAsync](<group__CUDA__MEM.html#group__CUDA__MEM_1g64cbd2e60436699aebdd0bdbf14d0f01> "Copies memory from Array to Host."), [cuMemcpyDtoA](<group__CUDA__MEM.html#group__CUDA__MEM_1gad6827247af91600b56ce6e2ddb802e1> "Copies memory from Device to Array."), [cuMemcpyDtoD](<group__CUDA__MEM.html#group__CUDA__MEM_1g1725774abf8b51b91945f3336b778c8b> "Copies memory from Device to Device."), [cuMemcpyDtoDAsync](<group__CUDA__MEM.html#group__CUDA__MEM_1g39ea09ba682b8eccc9c3e0c04319b5c8> "Copies memory from Device to Device."), [cuMemcpyDtoH](<group__CUDA__MEM.html#group__CUDA__MEM_1g3480368ee0208a98f75019c9a8450893> "Copies memory from Device to Host."), [cuMemcpyDtoHAsync](<group__CUDA__MEM.html#group__CUDA__MEM_1g56f30236c7c5247f8e061b59d3268362> "Copies memory from Device to Host."), [cuMemcpyHtoA](<group__CUDA__MEM.html#group__CUDA__MEM_1g57d3d780d165ecc0e3b3ce08e141cd89> "Copies memory from Host to Array."), [cuMemcpyHtoD](<group__CUDA__MEM.html#group__CUDA__MEM_1g4d32266788c440b0220b1a9ba5795169> "Copies memory from Host to Device."), [cuMemcpyHtoDAsync](<group__CUDA__MEM.html#group__CUDA__MEM_1g1572263fe2597d7ba4f6964597a354a3> "Copies memory from Host to Device."), [cuMemFree](<group__CUDA__MEM.html#group__CUDA__MEM_1g89b3f154e17cc89b6eea277dbdf5c93a> "Frees device memory."), [cuMemFreeHost](<group__CUDA__MEM.html#group__CUDA__MEM_1g62e0fdbe181dab6b1c90fa1a51c7b92c> "Frees page-locked host memory."), [cuMemGetAddressRange](<group__CUDA__MEM.html#group__CUDA__MEM_1g64fee5711274a2a0573a789c94d8299b> "Get information on memory allocations."), [cuMemGetInfo](<group__CUDA__MEM.html#group__CUDA__MEM_1g808f555540d0143a331cc42aa98835c0> "Gets free and total memory."), [cuMemHostAlloc](<group__CUDA__MEM.html#group__CUDA__MEM_1g572ca4011bfcb25034888a14d4e035b9> "Allocates page-locked host memory."), [cuMemHostGetDevicePointer](<group__CUDA__MEM.html#group__CUDA__MEM_1g57a39e5cba26af4d06be67fc77cc62f0> "Passes back device pointer of mapped pinned memory."), [cuMemsetD2D8](<group__CUDA__MEM.html#group__CUDA__MEM_1ge88b13e646e2be6ba0e0475ef5205974> "Initializes device memory."), [cuMemsetD2D8Async](<group__CUDA__MEM.html#group__CUDA__MEM_1g3f7b6924a3e49c3265b328f534102e97> "Sets device memory."), [cuMemsetD2D16](<group__CUDA__MEM.html#group__CUDA__MEM_1g7f561a15a66144fa9f6ab5350edc8a30> "Initializes device memory."), [cuMemsetD2D16Async](<group__CUDA__MEM.html#group__CUDA__MEM_1g64ee197befac3d74d9fefedcf6ef6b10> "Sets device memory."), [cuMemsetD2D32](<group__CUDA__MEM.html#group__CUDA__MEM_1g74b359b2d026bfeb7c795b5038d07523> "Initializes device memory."), [cuMemsetD2D32Async](<group__CUDA__MEM.html#group__CUDA__MEM_1g8a78d3147ac93fac955052c815d9ea3c> "Sets device memory."), [cuMemsetD8](<group__CUDA__MEM.html#group__CUDA__MEM_1g6e582bf866e9e2fb014297bfaf354d7b> "Initializes device memory."), [cuMemsetD8Async](<group__CUDA__MEM.html#group__CUDA__MEM_1gaef08a7ccd61112f94e82f2b30d43627> "Sets device memory."), [cuMemsetD16](<group__CUDA__MEM.html#group__CUDA__MEM_1g7d805e610054392a4d11e8a8bf5eb35c> "Initializes device memory."), [cuMemsetD16Async](<group__CUDA__MEM.html#group__CUDA__MEM_1gf731438877dd8ec875e4c43d848c878c> "Sets device memory."), [cuMemsetD32](<group__CUDA__MEM.html#group__CUDA__MEM_1g983e8d8759acd1b64326317481fbf132> "Initializes device memory."), [cuMemsetD32Async](<group__CUDA__MEM.html#group__CUDA__MEM_1g58229da5d30f1c0cdf667b320ec2c0f5> "Sets device memory."), [cudaMemcpyToArrayAsync](<../cuda-runtime-api/group__CUDART__MEMORY__DEPRECATED.html#group__CUDART__MEMORY__DEPRECATED_1g92f0eaaaa772fd428dfc7c7ba699d272>)

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuMemcpyHtoD ( [CUdeviceptr](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g183f7b0d8ad008ea2a5fd552537ace4e>)Â dstDevice, const void*Â srcHost, size_tÂ ByteCount )


Copies memory from Host to Device.

######  Parameters

`dstDevice`
    \- Destination device pointer
`srcHost`
    \- Source host pointer
`ByteCount`
    \- Size of memory copy in bytes

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_DEINITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9acf52f132faf29b473cdda6061f0f44a>), [CUDA_ERROR_NOT_INITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e98feb999f0af99b4a25ab26b3866f4df8>), [CUDA_ERROR_INVALID_CONTEXT](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a484e9af32c1e9893ff21f0e0191a12d>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>)

###### Description

Copies from host memory to device memory. `dstDevice` and `srcHost` are the base addresses of the destination and source, respectively. `ByteCount` specifies the number of bytes to copy.

Note:

  * Note that this function may also return error codes from previous, asynchronous launches.

  * This function exhibits [synchronous](<api-sync-behavior.html#api-sync-behavior__memcpy-sync>) behavior for most use cases.

  * Memory regions requested must be either entirely registered with CUDA, or in the case of host pageable transfers, not registered at all. Memory regions spanning over allocations that are both registered and not registered with CUDA are not supported and will return CUDA_ERROR_INVALID_VALUE.


**See also:**

[cuArray3DCreate](<group__CUDA__MEM.html#group__CUDA__MEM_1gc2322c70b38c2984536c90ed118bb1d7> "Creates a 3D CUDA array."), [cuArray3DGetDescriptor](<group__CUDA__MEM.html#group__CUDA__MEM_1gb58549f2f3f390b9e0e7c8f3acd53857> "Get a 3D CUDA array descriptor."), [cuArrayCreate](<group__CUDA__MEM.html#group__CUDA__MEM_1g4192ff387a81c3bd5ed8c391ed62ca24> "Creates a 1D or 2D CUDA array."), [cuArrayDestroy](<group__CUDA__MEM.html#group__CUDA__MEM_1g982878affbbc023de84874faac838b0b> "Destroys a CUDA array."), [cuArrayGetDescriptor](<group__CUDA__MEM.html#group__CUDA__MEM_1g661fe823dbd37bf11f82a71bd4762acf> "Get a 1D or 2D CUDA array descriptor."), [cuMemAlloc](<group__CUDA__MEM.html#group__CUDA__MEM_1gb82d2a09844a58dd9e744dc31e8aa467> "Allocates device memory."), [cuMemAllocHost](<group__CUDA__MEM.html#group__CUDA__MEM_1gdd8311286d2c2691605362c689bc64e0> "Allocates page-locked host memory."), [cuMemAllocPitch](<group__CUDA__MEM.html#group__CUDA__MEM_1gcbe9b033f6c4de80f63cc6e58ed9a45a> "Allocates pitched device memory."), [cuMemcpy2D](<group__CUDA__MEM.html#group__CUDA__MEM_1g27f885b30c34cc20a663a671dbf6fc27> "Copies memory for 2D arrays."), [cuMemcpy2DAsync](<group__CUDA__MEM.html#group__CUDA__MEM_1g4acf155faeb969d9d21f5433d3d0f274> "Copies memory for 2D arrays."), [cuMemcpy2DUnaligned](<group__CUDA__MEM.html#group__CUDA__MEM_1g2fa285d47fd7020e596bfeab3deb651b> "Copies memory for 2D arrays."), [cuMemcpy3D](<group__CUDA__MEM.html#group__CUDA__MEM_1g4b5238975579f002c0199a3800ca44df> "Copies memory for 3D arrays."), [cuMemcpy3DAsync](<group__CUDA__MEM.html#group__CUDA__MEM_1g79f4f3fde6ae0f529568d881d9e11987> "Copies memory for 3D arrays."), [cuMemcpyAtoA](<group__CUDA__MEM.html#group__CUDA__MEM_1gf81b218c984a31436ec9e23a85fb604a> "Copies memory from Array to Array."), [cuMemcpyAtoD](<group__CUDA__MEM.html#group__CUDA__MEM_1g825b3f037f7f51382cae991bae8173fd> "Copies memory from Array to Device."), [cuMemcpyAtoH](<group__CUDA__MEM.html#group__CUDA__MEM_1gf7ad1edb2539cccc352c6b8b76f657f4> "Copies memory from Array to Host."), [cuMemcpyAtoHAsync](<group__CUDA__MEM.html#group__CUDA__MEM_1g64cbd2e60436699aebdd0bdbf14d0f01> "Copies memory from Array to Host."), [cuMemcpyDtoA](<group__CUDA__MEM.html#group__CUDA__MEM_1gad6827247af91600b56ce6e2ddb802e1> "Copies memory from Device to Array."), [cuMemcpyDtoD](<group__CUDA__MEM.html#group__CUDA__MEM_1g1725774abf8b51b91945f3336b778c8b> "Copies memory from Device to Device."), [cuMemcpyDtoDAsync](<group__CUDA__MEM.html#group__CUDA__MEM_1g39ea09ba682b8eccc9c3e0c04319b5c8> "Copies memory from Device to Device."), [cuMemcpyDtoH](<group__CUDA__MEM.html#group__CUDA__MEM_1g3480368ee0208a98f75019c9a8450893> "Copies memory from Device to Host."), [cuMemcpyDtoHAsync](<group__CUDA__MEM.html#group__CUDA__MEM_1g56f30236c7c5247f8e061b59d3268362> "Copies memory from Device to Host."), [cuMemcpyHtoA](<group__CUDA__MEM.html#group__CUDA__MEM_1g57d3d780d165ecc0e3b3ce08e141cd89> "Copies memory from Host to Array."), [cuMemcpyHtoAAsync](<group__CUDA__MEM.html#group__CUDA__MEM_1gb5c4863f64f132b4bc2661818b3fd188> "Copies memory from Host to Array."), [cuMemcpyHtoDAsync](<group__CUDA__MEM.html#group__CUDA__MEM_1g1572263fe2597d7ba4f6964597a354a3> "Copies memory from Host to Device."), [cuMemFree](<group__CUDA__MEM.html#group__CUDA__MEM_1g89b3f154e17cc89b6eea277dbdf5c93a> "Frees device memory."), [cuMemFreeHost](<group__CUDA__MEM.html#group__CUDA__MEM_1g62e0fdbe181dab6b1c90fa1a51c7b92c> "Frees page-locked host memory."), [cuMemGetAddressRange](<group__CUDA__MEM.html#group__CUDA__MEM_1g64fee5711274a2a0573a789c94d8299b> "Get information on memory allocations."), [cuMemGetInfo](<group__CUDA__MEM.html#group__CUDA__MEM_1g808f555540d0143a331cc42aa98835c0> "Gets free and total memory."), [cuMemHostAlloc](<group__CUDA__MEM.html#group__CUDA__MEM_1g572ca4011bfcb25034888a14d4e035b9> "Allocates page-locked host memory."), [cuMemHostGetDevicePointer](<group__CUDA__MEM.html#group__CUDA__MEM_1g57a39e5cba26af4d06be67fc77cc62f0> "Passes back device pointer of mapped pinned memory."), [cuMemsetD2D8](<group__CUDA__MEM.html#group__CUDA__MEM_1ge88b13e646e2be6ba0e0475ef5205974> "Initializes device memory."), [cuMemsetD2D16](<group__CUDA__MEM.html#group__CUDA__MEM_1g7f561a15a66144fa9f6ab5350edc8a30> "Initializes device memory."), [cuMemsetD2D32](<group__CUDA__MEM.html#group__CUDA__MEM_1g74b359b2d026bfeb7c795b5038d07523> "Initializes device memory."), [cuMemsetD8](<group__CUDA__MEM.html#group__CUDA__MEM_1g6e582bf866e9e2fb014297bfaf354d7b> "Initializes device memory."), [cuMemsetD16](<group__CUDA__MEM.html#group__CUDA__MEM_1g7d805e610054392a4d11e8a8bf5eb35c> "Initializes device memory."), [cuMemsetD32](<group__CUDA__MEM.html#group__CUDA__MEM_1g983e8d8759acd1b64326317481fbf132> "Initializes device memory."), [cudaMemcpy](<../cuda-runtime-api/group__CUDART__MEMORY.html#group__CUDART__MEMORY_1gc263dbe6574220cc776b45438fc351e8>), [cudaMemcpyToSymbol](<../cuda-runtime-api/group__CUDART__HIGHLEVEL.html#group__CUDART__HIGHLEVEL_1g4561bf9c99d91c92684a91a0bd356bfe>)

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuMemcpyHtoDAsync ( [CUdeviceptr](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g183f7b0d8ad008ea2a5fd552537ace4e>)Â dstDevice, const void*Â srcHost, size_tÂ ByteCount, [CUstream](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gb946c7f02e09efd788a204718015d88a>)Â hStream )


Copies memory from Host to Device.

######  Parameters

`dstDevice`
    \- Destination device pointer
`srcHost`
    \- Source host pointer
`ByteCount`
    \- Size of memory copy in bytes
`hStream`
    \- Stream identifier

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_DEINITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9acf52f132faf29b473cdda6061f0f44a>), [CUDA_ERROR_NOT_INITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e98feb999f0af99b4a25ab26b3866f4df8>), [CUDA_ERROR_INVALID_CONTEXT](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a484e9af32c1e9893ff21f0e0191a12d>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>), [CUDA_ERROR_INVALID_HANDLE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e90fd2e63260c6317ba943af0f7e4b8d21>)

###### Description

Copies from host memory to device memory. `dstDevice` and `srcHost` are the base addresses of the destination and source, respectively. `ByteCount` specifies the number of bytes to copy.

Note:

  * Note that this function may also return error codes from previous, asynchronous launches.

  * This function exhibits [asynchronous](<api-sync-behavior.html#api-sync-behavior__memcpy-async>) behavior for most use cases.

  * This function uses standard [default stream](<stream-sync-behavior.html#stream-sync-behavior__default-stream>) semantics.

  * Memory regions requested must be either entirely registered with CUDA, or in the case of host pageable transfers, not registered at all. Memory regions spanning over allocations that are both registered and not registered with CUDA are not supported and will return CUDA_ERROR_INVALID_VALUE.


**See also:**

[cuArray3DCreate](<group__CUDA__MEM.html#group__CUDA__MEM_1gc2322c70b38c2984536c90ed118bb1d7> "Creates a 3D CUDA array."), [cuArray3DGetDescriptor](<group__CUDA__MEM.html#group__CUDA__MEM_1gb58549f2f3f390b9e0e7c8f3acd53857> "Get a 3D CUDA array descriptor."), [cuArrayCreate](<group__CUDA__MEM.html#group__CUDA__MEM_1g4192ff387a81c3bd5ed8c391ed62ca24> "Creates a 1D or 2D CUDA array."), [cuArrayDestroy](<group__CUDA__MEM.html#group__CUDA__MEM_1g982878affbbc023de84874faac838b0b> "Destroys a CUDA array."), [cuArrayGetDescriptor](<group__CUDA__MEM.html#group__CUDA__MEM_1g661fe823dbd37bf11f82a71bd4762acf> "Get a 1D or 2D CUDA array descriptor."), [cuMemAlloc](<group__CUDA__MEM.html#group__CUDA__MEM_1gb82d2a09844a58dd9e744dc31e8aa467> "Allocates device memory."), [cuMemAllocHost](<group__CUDA__MEM.html#group__CUDA__MEM_1gdd8311286d2c2691605362c689bc64e0> "Allocates page-locked host memory."), [cuMemAllocPitch](<group__CUDA__MEM.html#group__CUDA__MEM_1gcbe9b033f6c4de80f63cc6e58ed9a45a> "Allocates pitched device memory."), [cuMemcpy2D](<group__CUDA__MEM.html#group__CUDA__MEM_1g27f885b30c34cc20a663a671dbf6fc27> "Copies memory for 2D arrays."), [cuMemcpy2DAsync](<group__CUDA__MEM.html#group__CUDA__MEM_1g4acf155faeb969d9d21f5433d3d0f274> "Copies memory for 2D arrays."), [cuMemcpy2DUnaligned](<group__CUDA__MEM.html#group__CUDA__MEM_1g2fa285d47fd7020e596bfeab3deb651b> "Copies memory for 2D arrays."), [cuMemcpy3D](<group__CUDA__MEM.html#group__CUDA__MEM_1g4b5238975579f002c0199a3800ca44df> "Copies memory for 3D arrays."), [cuMemcpy3DAsync](<group__CUDA__MEM.html#group__CUDA__MEM_1g79f4f3fde6ae0f529568d881d9e11987> "Copies memory for 3D arrays."), [cuMemcpyAtoA](<group__CUDA__MEM.html#group__CUDA__MEM_1gf81b218c984a31436ec9e23a85fb604a> "Copies memory from Array to Array."), [cuMemcpyAtoD](<group__CUDA__MEM.html#group__CUDA__MEM_1g825b3f037f7f51382cae991bae8173fd> "Copies memory from Array to Device."), [cuMemcpyAtoH](<group__CUDA__MEM.html#group__CUDA__MEM_1gf7ad1edb2539cccc352c6b8b76f657f4> "Copies memory from Array to Host."), [cuMemcpyAtoHAsync](<group__CUDA__MEM.html#group__CUDA__MEM_1g64cbd2e60436699aebdd0bdbf14d0f01> "Copies memory from Array to Host."), [cuMemcpyDtoA](<group__CUDA__MEM.html#group__CUDA__MEM_1gad6827247af91600b56ce6e2ddb802e1> "Copies memory from Device to Array."), [cuMemcpyDtoD](<group__CUDA__MEM.html#group__CUDA__MEM_1g1725774abf8b51b91945f3336b778c8b> "Copies memory from Device to Device."), [cuMemcpyDtoDAsync](<group__CUDA__MEM.html#group__CUDA__MEM_1g39ea09ba682b8eccc9c3e0c04319b5c8> "Copies memory from Device to Device."), [cuMemcpyDtoH](<group__CUDA__MEM.html#group__CUDA__MEM_1g3480368ee0208a98f75019c9a8450893> "Copies memory from Device to Host."), [cuMemcpyDtoHAsync](<group__CUDA__MEM.html#group__CUDA__MEM_1g56f30236c7c5247f8e061b59d3268362> "Copies memory from Device to Host."), [cuMemcpyHtoA](<group__CUDA__MEM.html#group__CUDA__MEM_1g57d3d780d165ecc0e3b3ce08e141cd89> "Copies memory from Host to Array."), [cuMemcpyHtoAAsync](<group__CUDA__MEM.html#group__CUDA__MEM_1gb5c4863f64f132b4bc2661818b3fd188> "Copies memory from Host to Array."), [cuMemcpyHtoD](<group__CUDA__MEM.html#group__CUDA__MEM_1g4d32266788c440b0220b1a9ba5795169> "Copies memory from Host to Device."), [cuMemFree](<group__CUDA__MEM.html#group__CUDA__MEM_1g89b3f154e17cc89b6eea277dbdf5c93a> "Frees device memory."), [cuMemFreeHost](<group__CUDA__MEM.html#group__CUDA__MEM_1g62e0fdbe181dab6b1c90fa1a51c7b92c> "Frees page-locked host memory."), [cuMemGetAddressRange](<group__CUDA__MEM.html#group__CUDA__MEM_1g64fee5711274a2a0573a789c94d8299b> "Get information on memory allocations."), [cuMemGetInfo](<group__CUDA__MEM.html#group__CUDA__MEM_1g808f555540d0143a331cc42aa98835c0> "Gets free and total memory."), [cuMemHostAlloc](<group__CUDA__MEM.html#group__CUDA__MEM_1g572ca4011bfcb25034888a14d4e035b9> "Allocates page-locked host memory."), [cuMemHostGetDevicePointer](<group__CUDA__MEM.html#group__CUDA__MEM_1g57a39e5cba26af4d06be67fc77cc62f0> "Passes back device pointer of mapped pinned memory."), [cuMemsetD2D8](<group__CUDA__MEM.html#group__CUDA__MEM_1ge88b13e646e2be6ba0e0475ef5205974> "Initializes device memory."), [cuMemsetD2D8Async](<group__CUDA__MEM.html#group__CUDA__MEM_1g3f7b6924a3e49c3265b328f534102e97> "Sets device memory."), [cuMemsetD2D16](<group__CUDA__MEM.html#group__CUDA__MEM_1g7f561a15a66144fa9f6ab5350edc8a30> "Initializes device memory."), [cuMemsetD2D16Async](<group__CUDA__MEM.html#group__CUDA__MEM_1g64ee197befac3d74d9fefedcf6ef6b10> "Sets device memory."), [cuMemsetD2D32](<group__CUDA__MEM.html#group__CUDA__MEM_1g74b359b2d026bfeb7c795b5038d07523> "Initializes device memory."), [cuMemsetD2D32Async](<group__CUDA__MEM.html#group__CUDA__MEM_1g8a78d3147ac93fac955052c815d9ea3c> "Sets device memory."), [cuMemsetD8](<group__CUDA__MEM.html#group__CUDA__MEM_1g6e582bf866e9e2fb014297bfaf354d7b> "Initializes device memory."), [cuMemsetD8Async](<group__CUDA__MEM.html#group__CUDA__MEM_1gaef08a7ccd61112f94e82f2b30d43627> "Sets device memory."), [cuMemsetD16](<group__CUDA__MEM.html#group__CUDA__MEM_1g7d805e610054392a4d11e8a8bf5eb35c> "Initializes device memory."), [cuMemsetD16Async](<group__CUDA__MEM.html#group__CUDA__MEM_1gf731438877dd8ec875e4c43d848c878c> "Sets device memory."), [cuMemsetD32](<group__CUDA__MEM.html#group__CUDA__MEM_1g983e8d8759acd1b64326317481fbf132> "Initializes device memory."), [cuMemsetD32Async](<group__CUDA__MEM.html#group__CUDA__MEM_1g58229da5d30f1c0cdf667b320ec2c0f5> "Sets device memory."), [cudaMemcpyAsync](<../cuda-runtime-api/group__CUDART__MEMORY.html#group__CUDART__MEMORY_1g85073372f776b4c4d5f89f7124b7bf79>), [cudaMemcpyToSymbolAsync](<../cuda-runtime-api/group__CUDART__HIGHLEVEL.html#group__CUDART__HIGHLEVEL_1gd00b41ade29161aafbf6ff8aee3d6eb5>)

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuMemcpyPeer ( [CUdeviceptr](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g183f7b0d8ad008ea2a5fd552537ace4e>)Â dstDevice, [CUcontext](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gf9f5bd81658f866613785b3a0bb7d7d9>)Â dstContext, [CUdeviceptr](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g183f7b0d8ad008ea2a5fd552537ace4e>)Â srcDevice, [CUcontext](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gf9f5bd81658f866613785b3a0bb7d7d9>)Â srcContext, size_tÂ ByteCount )


Copies device memory between two contexts.

######  Parameters

`dstDevice`
    \- Destination device pointer
`dstContext`
    \- Destination context
`srcDevice`
    \- Source device pointer
`srcContext`
    \- Source context
`ByteCount`
    \- Size of memory copy in bytes

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_DEINITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9acf52f132faf29b473cdda6061f0f44a>), [CUDA_ERROR_NOT_INITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e98feb999f0af99b4a25ab26b3866f4df8>), [CUDA_ERROR_INVALID_CONTEXT](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a484e9af32c1e9893ff21f0e0191a12d>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>)

###### Description

Copies from device memory in one context to device memory in another context. `dstDevice` is the base device pointer of the destination memory and `dstContext` is the destination context. `srcDevice` is the base device pointer of the source memory and `srcContext` is the source pointer. `ByteCount` specifies the number of bytes to copy.

Note:

  * Note that this function may also return error codes from previous, asynchronous launches.

  * This function exhibits [synchronous](<api-sync-behavior.html#api-sync-behavior__memcpy-sync>) behavior for most use cases.


**See also:**

[cuMemcpyDtoD](<group__CUDA__MEM.html#group__CUDA__MEM_1g1725774abf8b51b91945f3336b778c8b> "Copies memory from Device to Device."), [cuMemcpy3DPeer](<group__CUDA__MEM.html#group__CUDA__MEM_1g11466fd70cde9329a4e16eb1f258c433> "Copies memory between contexts."), [cuMemcpyDtoDAsync](<group__CUDA__MEM.html#group__CUDA__MEM_1g39ea09ba682b8eccc9c3e0c04319b5c8> "Copies memory from Device to Device."), [cuMemcpyPeerAsync](<group__CUDA__MEM.html#group__CUDA__MEM_1g82fcecb38018e64b98616a8ac30112f2> "Copies device memory between two contexts asynchronously."), [cuMemcpy3DPeerAsync](<group__CUDA__MEM.html#group__CUDA__MEM_1gc4e4bfd9f627d3aa3695979e058f1bb8> "Copies memory between contexts asynchronously."), [cudaMemcpyPeer](<../cuda-runtime-api/group__CUDART__MEMORY.html#group__CUDART__MEMORY_1g88fd1245b2cb10d2d30c74900b7dfb9c>)

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuMemcpyPeerAsync ( [CUdeviceptr](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g183f7b0d8ad008ea2a5fd552537ace4e>)Â dstDevice, [CUcontext](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gf9f5bd81658f866613785b3a0bb7d7d9>)Â dstContext, [CUdeviceptr](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g183f7b0d8ad008ea2a5fd552537ace4e>)Â srcDevice, [CUcontext](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gf9f5bd81658f866613785b3a0bb7d7d9>)Â srcContext, size_tÂ ByteCount, [CUstream](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gb946c7f02e09efd788a204718015d88a>)Â hStream )


Copies device memory between two contexts asynchronously.

######  Parameters

`dstDevice`
    \- Destination device pointer
`dstContext`
    \- Destination context
`srcDevice`
    \- Source device pointer
`srcContext`
    \- Source context
`ByteCount`
    \- Size of memory copy in bytes
`hStream`
    \- Stream identifier

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_DEINITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9acf52f132faf29b473cdda6061f0f44a>), [CUDA_ERROR_NOT_INITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e98feb999f0af99b4a25ab26b3866f4df8>), [CUDA_ERROR_INVALID_CONTEXT](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a484e9af32c1e9893ff21f0e0191a12d>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>), [CUDA_ERROR_INVALID_HANDLE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e90fd2e63260c6317ba943af0f7e4b8d21>)

###### Description

Copies from device memory in one context to device memory in another context. `dstDevice` is the base device pointer of the destination memory and `dstContext` is the destination context. `srcDevice` is the base device pointer of the source memory and `srcContext` is the source pointer. `ByteCount` specifies the number of bytes to copy.

Note:

  * Note that this function may also return error codes from previous, asynchronous launches.

  * This function exhibits [asynchronous](<api-sync-behavior.html#api-sync-behavior__memcpy-async>) behavior for most use cases.

  * This function uses standard [default stream](<stream-sync-behavior.html#stream-sync-behavior__default-stream>) semantics.


**See also:**

[cuMemcpyDtoD](<group__CUDA__MEM.html#group__CUDA__MEM_1g1725774abf8b51b91945f3336b778c8b> "Copies memory from Device to Device."), [cuMemcpyPeer](<group__CUDA__MEM.html#group__CUDA__MEM_1ge1f5c7771544fee150ada8853c7cbf4a> "Copies device memory between two contexts."), [cuMemcpy3DPeer](<group__CUDA__MEM.html#group__CUDA__MEM_1g11466fd70cde9329a4e16eb1f258c433> "Copies memory between contexts."), [cuMemcpyDtoDAsync](<group__CUDA__MEM.html#group__CUDA__MEM_1g39ea09ba682b8eccc9c3e0c04319b5c8> "Copies memory from Device to Device."), [cuMemcpy3DPeerAsync](<group__CUDA__MEM.html#group__CUDA__MEM_1gc4e4bfd9f627d3aa3695979e058f1bb8> "Copies memory between contexts asynchronously."), [cudaMemcpyPeerAsync](<../cuda-runtime-api/group__CUDART__MEMORY.html#group__CUDART__MEMORY_1gbfde4ace9ff4823f4ac45e5c6bdcd2ee>)

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuMemsetD16 ( [CUdeviceptr](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g183f7b0d8ad008ea2a5fd552537ace4e>)Â dstDevice, unsigned shortÂ us, size_tÂ N )


Initializes device memory.

######  Parameters

`dstDevice`
    \- Destination device pointer
`us`
    \- Value to set
`N`
    \- Number of elements

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_DEINITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9acf52f132faf29b473cdda6061f0f44a>), [CUDA_ERROR_NOT_INITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e98feb999f0af99b4a25ab26b3866f4df8>), [CUDA_ERROR_INVALID_CONTEXT](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a484e9af32c1e9893ff21f0e0191a12d>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>)

###### Description

Sets the memory range of `N` 16-bit values to the specified value `us`. The `dstDevice` pointer must be two byte aligned.

Note:

  * Note that this function may also return error codes from previous, asynchronous launches.

  * See also [memset synchronization details](<api-sync-behavior.html#api-sync-behavior__memset>).


**See also:**

[cuArray3DCreate](<group__CUDA__MEM.html#group__CUDA__MEM_1gc2322c70b38c2984536c90ed118bb1d7> "Creates a 3D CUDA array."), [cuArray3DGetDescriptor](<group__CUDA__MEM.html#group__CUDA__MEM_1gb58549f2f3f390b9e0e7c8f3acd53857> "Get a 3D CUDA array descriptor."), [cuArrayCreate](<group__CUDA__MEM.html#group__CUDA__MEM_1g4192ff387a81c3bd5ed8c391ed62ca24> "Creates a 1D or 2D CUDA array."), [cuArrayDestroy](<group__CUDA__MEM.html#group__CUDA__MEM_1g982878affbbc023de84874faac838b0b> "Destroys a CUDA array."), [cuArrayGetDescriptor](<group__CUDA__MEM.html#group__CUDA__MEM_1g661fe823dbd37bf11f82a71bd4762acf> "Get a 1D or 2D CUDA array descriptor."), [cuMemAlloc](<group__CUDA__MEM.html#group__CUDA__MEM_1gb82d2a09844a58dd9e744dc31e8aa467> "Allocates device memory."), [cuMemAllocHost](<group__CUDA__MEM.html#group__CUDA__MEM_1gdd8311286d2c2691605362c689bc64e0> "Allocates page-locked host memory."), [cuMemAllocPitch](<group__CUDA__MEM.html#group__CUDA__MEM_1gcbe9b033f6c4de80f63cc6e58ed9a45a> "Allocates pitched device memory."), [cuMemcpy2D](<group__CUDA__MEM.html#group__CUDA__MEM_1g27f885b30c34cc20a663a671dbf6fc27> "Copies memory for 2D arrays."), [cuMemcpy2DAsync](<group__CUDA__MEM.html#group__CUDA__MEM_1g4acf155faeb969d9d21f5433d3d0f274> "Copies memory for 2D arrays."), [cuMemcpy2DUnaligned](<group__CUDA__MEM.html#group__CUDA__MEM_1g2fa285d47fd7020e596bfeab3deb651b> "Copies memory for 2D arrays."), [cuMemcpy3D](<group__CUDA__MEM.html#group__CUDA__MEM_1g4b5238975579f002c0199a3800ca44df> "Copies memory for 3D arrays."), [cuMemcpy3DAsync](<group__CUDA__MEM.html#group__CUDA__MEM_1g79f4f3fde6ae0f529568d881d9e11987> "Copies memory for 3D arrays."), [cuMemcpyAtoA](<group__CUDA__MEM.html#group__CUDA__MEM_1gf81b218c984a31436ec9e23a85fb604a> "Copies memory from Array to Array."), [cuMemcpyAtoD](<group__CUDA__MEM.html#group__CUDA__MEM_1g825b3f037f7f51382cae991bae8173fd> "Copies memory from Array to Device."), [cuMemcpyAtoH](<group__CUDA__MEM.html#group__CUDA__MEM_1gf7ad1edb2539cccc352c6b8b76f657f4> "Copies memory from Array to Host."), [cuMemcpyAtoHAsync](<group__CUDA__MEM.html#group__CUDA__MEM_1g64cbd2e60436699aebdd0bdbf14d0f01> "Copies memory from Array to Host."), [cuMemcpyDtoA](<group__CUDA__MEM.html#group__CUDA__MEM_1gad6827247af91600b56ce6e2ddb802e1> "Copies memory from Device to Array."), [cuMemcpyDtoD](<group__CUDA__MEM.html#group__CUDA__MEM_1g1725774abf8b51b91945f3336b778c8b> "Copies memory from Device to Device."), [cuMemcpyDtoDAsync](<group__CUDA__MEM.html#group__CUDA__MEM_1g39ea09ba682b8eccc9c3e0c04319b5c8> "Copies memory from Device to Device."), [cuMemcpyDtoH](<group__CUDA__MEM.html#group__CUDA__MEM_1g3480368ee0208a98f75019c9a8450893> "Copies memory from Device to Host."), [cuMemcpyDtoHAsync](<group__CUDA__MEM.html#group__CUDA__MEM_1g56f30236c7c5247f8e061b59d3268362> "Copies memory from Device to Host."), [cuMemcpyHtoA](<group__CUDA__MEM.html#group__CUDA__MEM_1g57d3d780d165ecc0e3b3ce08e141cd89> "Copies memory from Host to Array."), [cuMemcpyHtoAAsync](<group__CUDA__MEM.html#group__CUDA__MEM_1gb5c4863f64f132b4bc2661818b3fd188> "Copies memory from Host to Array."), [cuMemcpyHtoD](<group__CUDA__MEM.html#group__CUDA__MEM_1g4d32266788c440b0220b1a9ba5795169> "Copies memory from Host to Device."), [cuMemcpyHtoDAsync](<group__CUDA__MEM.html#group__CUDA__MEM_1g1572263fe2597d7ba4f6964597a354a3> "Copies memory from Host to Device."), [cuMemFree](<group__CUDA__MEM.html#group__CUDA__MEM_1g89b3f154e17cc89b6eea277dbdf5c93a> "Frees device memory."), [cuMemFreeHost](<group__CUDA__MEM.html#group__CUDA__MEM_1g62e0fdbe181dab6b1c90fa1a51c7b92c> "Frees page-locked host memory."), [cuMemGetAddressRange](<group__CUDA__MEM.html#group__CUDA__MEM_1g64fee5711274a2a0573a789c94d8299b> "Get information on memory allocations."), [cuMemGetInfo](<group__CUDA__MEM.html#group__CUDA__MEM_1g808f555540d0143a331cc42aa98835c0> "Gets free and total memory."), [cuMemHostAlloc](<group__CUDA__MEM.html#group__CUDA__MEM_1g572ca4011bfcb25034888a14d4e035b9> "Allocates page-locked host memory."), [cuMemHostGetDevicePointer](<group__CUDA__MEM.html#group__CUDA__MEM_1g57a39e5cba26af4d06be67fc77cc62f0> "Passes back device pointer of mapped pinned memory."), [cuMemsetD2D8](<group__CUDA__MEM.html#group__CUDA__MEM_1ge88b13e646e2be6ba0e0475ef5205974> "Initializes device memory."), [cuMemsetD2D8Async](<group__CUDA__MEM.html#group__CUDA__MEM_1g3f7b6924a3e49c3265b328f534102e97> "Sets device memory."), [cuMemsetD2D16](<group__CUDA__MEM.html#group__CUDA__MEM_1g7f561a15a66144fa9f6ab5350edc8a30> "Initializes device memory."), [cuMemsetD2D16Async](<group__CUDA__MEM.html#group__CUDA__MEM_1g64ee197befac3d74d9fefedcf6ef6b10> "Sets device memory."), [cuMemsetD2D32](<group__CUDA__MEM.html#group__CUDA__MEM_1g74b359b2d026bfeb7c795b5038d07523> "Initializes device memory."), [cuMemsetD2D32Async](<group__CUDA__MEM.html#group__CUDA__MEM_1g8a78d3147ac93fac955052c815d9ea3c> "Sets device memory."), [cuMemsetD8](<group__CUDA__MEM.html#group__CUDA__MEM_1g6e582bf866e9e2fb014297bfaf354d7b> "Initializes device memory."), [cuMemsetD8Async](<group__CUDA__MEM.html#group__CUDA__MEM_1gaef08a7ccd61112f94e82f2b30d43627> "Sets device memory."), [cuMemsetD16Async](<group__CUDA__MEM.html#group__CUDA__MEM_1gf731438877dd8ec875e4c43d848c878c> "Sets device memory."), [cuMemsetD32](<group__CUDA__MEM.html#group__CUDA__MEM_1g983e8d8759acd1b64326317481fbf132> "Initializes device memory."), [cuMemsetD32Async](<group__CUDA__MEM.html#group__CUDA__MEM_1g58229da5d30f1c0cdf667b320ec2c0f5> "Sets device memory."), [cudaMemset](<../cuda-runtime-api/group__CUDART__MEMORY.html#group__CUDART__MEMORY_1gf7338650f7683c51ee26aadc6973c63a>)

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuMemsetD16Async ( [CUdeviceptr](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g183f7b0d8ad008ea2a5fd552537ace4e>)Â dstDevice, unsigned shortÂ us, size_tÂ N, [CUstream](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gb946c7f02e09efd788a204718015d88a>)Â hStream )


Sets device memory.

######  Parameters

`dstDevice`
    \- Destination device pointer
`us`
    \- Value to set
`N`
    \- Number of elements
`hStream`
    \- Stream identifier

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_DEINITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9acf52f132faf29b473cdda6061f0f44a>), [CUDA_ERROR_NOT_INITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e98feb999f0af99b4a25ab26b3866f4df8>), [CUDA_ERROR_INVALID_CONTEXT](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a484e9af32c1e9893ff21f0e0191a12d>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>)

###### Description

Sets the memory range of `N` 16-bit values to the specified value `us`. The `dstDevice` pointer must be two byte aligned.

Note:

  * Note that this function may also return error codes from previous, asynchronous launches.

  * See also [memset synchronization details](<api-sync-behavior.html#api-sync-behavior__memset>).

  * This function uses standard [default stream](<stream-sync-behavior.html#stream-sync-behavior__default-stream>) semantics.


**See also:**

[cuArray3DCreate](<group__CUDA__MEM.html#group__CUDA__MEM_1gc2322c70b38c2984536c90ed118bb1d7> "Creates a 3D CUDA array."), [cuArray3DGetDescriptor](<group__CUDA__MEM.html#group__CUDA__MEM_1gb58549f2f3f390b9e0e7c8f3acd53857> "Get a 3D CUDA array descriptor."), [cuArrayCreate](<group__CUDA__MEM.html#group__CUDA__MEM_1g4192ff387a81c3bd5ed8c391ed62ca24> "Creates a 1D or 2D CUDA array."), [cuArrayDestroy](<group__CUDA__MEM.html#group__CUDA__MEM_1g982878affbbc023de84874faac838b0b> "Destroys a CUDA array."), [cuArrayGetDescriptor](<group__CUDA__MEM.html#group__CUDA__MEM_1g661fe823dbd37bf11f82a71bd4762acf> "Get a 1D or 2D CUDA array descriptor."), [cuMemAlloc](<group__CUDA__MEM.html#group__CUDA__MEM_1gb82d2a09844a58dd9e744dc31e8aa467> "Allocates device memory."), [cuMemAllocHost](<group__CUDA__MEM.html#group__CUDA__MEM_1gdd8311286d2c2691605362c689bc64e0> "Allocates page-locked host memory."), [cuMemAllocPitch](<group__CUDA__MEM.html#group__CUDA__MEM_1gcbe9b033f6c4de80f63cc6e58ed9a45a> "Allocates pitched device memory."), [cuMemcpy2D](<group__CUDA__MEM.html#group__CUDA__MEM_1g27f885b30c34cc20a663a671dbf6fc27> "Copies memory for 2D arrays."), [cuMemcpy2DAsync](<group__CUDA__MEM.html#group__CUDA__MEM_1g4acf155faeb969d9d21f5433d3d0f274> "Copies memory for 2D arrays."), [cuMemcpy2DUnaligned](<group__CUDA__MEM.html#group__CUDA__MEM_1g2fa285d47fd7020e596bfeab3deb651b> "Copies memory for 2D arrays."), [cuMemcpy3D](<group__CUDA__MEM.html#group__CUDA__MEM_1g4b5238975579f002c0199a3800ca44df> "Copies memory for 3D arrays."), [cuMemcpy3DAsync](<group__CUDA__MEM.html#group__CUDA__MEM_1g79f4f3fde6ae0f529568d881d9e11987> "Copies memory for 3D arrays."), [cuMemcpyAtoA](<group__CUDA__MEM.html#group__CUDA__MEM_1gf81b218c984a31436ec9e23a85fb604a> "Copies memory from Array to Array."), [cuMemcpyAtoD](<group__CUDA__MEM.html#group__CUDA__MEM_1g825b3f037f7f51382cae991bae8173fd> "Copies memory from Array to Device."), [cuMemcpyAtoH](<group__CUDA__MEM.html#group__CUDA__MEM_1gf7ad1edb2539cccc352c6b8b76f657f4> "Copies memory from Array to Host."), [cuMemcpyAtoHAsync](<group__CUDA__MEM.html#group__CUDA__MEM_1g64cbd2e60436699aebdd0bdbf14d0f01> "Copies memory from Array to Host."), [cuMemcpyDtoA](<group__CUDA__MEM.html#group__CUDA__MEM_1gad6827247af91600b56ce6e2ddb802e1> "Copies memory from Device to Array."), [cuMemcpyDtoD](<group__CUDA__MEM.html#group__CUDA__MEM_1g1725774abf8b51b91945f3336b778c8b> "Copies memory from Device to Device."), [cuMemcpyDtoDAsync](<group__CUDA__MEM.html#group__CUDA__MEM_1g39ea09ba682b8eccc9c3e0c04319b5c8> "Copies memory from Device to Device."), [cuMemcpyDtoH](<group__CUDA__MEM.html#group__CUDA__MEM_1g3480368ee0208a98f75019c9a8450893> "Copies memory from Device to Host."), [cuMemcpyDtoHAsync](<group__CUDA__MEM.html#group__CUDA__MEM_1g56f30236c7c5247f8e061b59d3268362> "Copies memory from Device to Host."), [cuMemcpyHtoA](<group__CUDA__MEM.html#group__CUDA__MEM_1g57d3d780d165ecc0e3b3ce08e141cd89> "Copies memory from Host to Array."), [cuMemcpyHtoAAsync](<group__CUDA__MEM.html#group__CUDA__MEM_1gb5c4863f64f132b4bc2661818b3fd188> "Copies memory from Host to Array."), [cuMemcpyHtoD](<group__CUDA__MEM.html#group__CUDA__MEM_1g4d32266788c440b0220b1a9ba5795169> "Copies memory from Host to Device."), [cuMemcpyHtoDAsync](<group__CUDA__MEM.html#group__CUDA__MEM_1g1572263fe2597d7ba4f6964597a354a3> "Copies memory from Host to Device."), [cuMemFree](<group__CUDA__MEM.html#group__CUDA__MEM_1g89b3f154e17cc89b6eea277dbdf5c93a> "Frees device memory."), [cuMemFreeHost](<group__CUDA__MEM.html#group__CUDA__MEM_1g62e0fdbe181dab6b1c90fa1a51c7b92c> "Frees page-locked host memory."), [cuMemGetAddressRange](<group__CUDA__MEM.html#group__CUDA__MEM_1g64fee5711274a2a0573a789c94d8299b> "Get information on memory allocations."), [cuMemGetInfo](<group__CUDA__MEM.html#group__CUDA__MEM_1g808f555540d0143a331cc42aa98835c0> "Gets free and total memory."), [cuMemHostAlloc](<group__CUDA__MEM.html#group__CUDA__MEM_1g572ca4011bfcb25034888a14d4e035b9> "Allocates page-locked host memory."), [cuMemHostGetDevicePointer](<group__CUDA__MEM.html#group__CUDA__MEM_1g57a39e5cba26af4d06be67fc77cc62f0> "Passes back device pointer of mapped pinned memory."), [cuMemsetD2D8](<group__CUDA__MEM.html#group__CUDA__MEM_1ge88b13e646e2be6ba0e0475ef5205974> "Initializes device memory."), [cuMemsetD2D8Async](<group__CUDA__MEM.html#group__CUDA__MEM_1g3f7b6924a3e49c3265b328f534102e97> "Sets device memory."), [cuMemsetD2D16](<group__CUDA__MEM.html#group__CUDA__MEM_1g7f561a15a66144fa9f6ab5350edc8a30> "Initializes device memory."), [cuMemsetD2D16Async](<group__CUDA__MEM.html#group__CUDA__MEM_1g64ee197befac3d74d9fefedcf6ef6b10> "Sets device memory."), [cuMemsetD2D32](<group__CUDA__MEM.html#group__CUDA__MEM_1g74b359b2d026bfeb7c795b5038d07523> "Initializes device memory."), [cuMemsetD2D32Async](<group__CUDA__MEM.html#group__CUDA__MEM_1g8a78d3147ac93fac955052c815d9ea3c> "Sets device memory."), [cuMemsetD8](<group__CUDA__MEM.html#group__CUDA__MEM_1g6e582bf866e9e2fb014297bfaf354d7b> "Initializes device memory."), [cuMemsetD8Async](<group__CUDA__MEM.html#group__CUDA__MEM_1gaef08a7ccd61112f94e82f2b30d43627> "Sets device memory."), [cuMemsetD16](<group__CUDA__MEM.html#group__CUDA__MEM_1g7d805e610054392a4d11e8a8bf5eb35c> "Initializes device memory."), [cuMemsetD32](<group__CUDA__MEM.html#group__CUDA__MEM_1g983e8d8759acd1b64326317481fbf132> "Initializes device memory."), [cuMemsetD32Async](<group__CUDA__MEM.html#group__CUDA__MEM_1g58229da5d30f1c0cdf667b320ec2c0f5> "Sets device memory."), [cudaMemsetAsync](<../cuda-runtime-api/group__CUDART__MEMORY.html#group__CUDART__MEMORY_1g7c9761e21d9f0999fd136c51e7b9b2a0>)

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuMemsetD2D16 ( [CUdeviceptr](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g183f7b0d8ad008ea2a5fd552537ace4e>)Â dstDevice, size_tÂ dstPitch, unsigned shortÂ us, size_tÂ Width, size_tÂ Height )


Initializes device memory.

######  Parameters

`dstDevice`
    \- Destination device pointer
`dstPitch`
    \- Pitch of destination device pointer(Unused if `Height` is 1)
`us`
    \- Value to set
`Width`
    \- Width of row
`Height`
    \- Number of rows

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_DEINITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9acf52f132faf29b473cdda6061f0f44a>), [CUDA_ERROR_NOT_INITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e98feb999f0af99b4a25ab26b3866f4df8>), [CUDA_ERROR_INVALID_CONTEXT](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a484e9af32c1e9893ff21f0e0191a12d>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>)

###### Description

Sets the 2D memory range of `Width` 16-bit values to the specified value `us`. `Height` specifies the number of rows to set, and `dstPitch` specifies the number of bytes between each row. The `dstDevice` pointer and `dstPitch` offset must be two byte aligned. This function performs fastest when the pitch is one that has been passed back by [cuMemAllocPitch()](<group__CUDA__MEM.html#group__CUDA__MEM_1gcbe9b033f6c4de80f63cc6e58ed9a45a> "Allocates pitched device memory.").

Note:

  * Note that this function may also return error codes from previous, asynchronous launches.

  * See also [memset synchronization details](<api-sync-behavior.html#api-sync-behavior__memset>).


**See also:**

[cuArray3DCreate](<group__CUDA__MEM.html#group__CUDA__MEM_1gc2322c70b38c2984536c90ed118bb1d7> "Creates a 3D CUDA array."), [cuArray3DGetDescriptor](<group__CUDA__MEM.html#group__CUDA__MEM_1gb58549f2f3f390b9e0e7c8f3acd53857> "Get a 3D CUDA array descriptor."), [cuArrayCreate](<group__CUDA__MEM.html#group__CUDA__MEM_1g4192ff387a81c3bd5ed8c391ed62ca24> "Creates a 1D or 2D CUDA array."), [cuArrayDestroy](<group__CUDA__MEM.html#group__CUDA__MEM_1g982878affbbc023de84874faac838b0b> "Destroys a CUDA array."), [cuArrayGetDescriptor](<group__CUDA__MEM.html#group__CUDA__MEM_1g661fe823dbd37bf11f82a71bd4762acf> "Get a 1D or 2D CUDA array descriptor."), [cuMemAlloc](<group__CUDA__MEM.html#group__CUDA__MEM_1gb82d2a09844a58dd9e744dc31e8aa467> "Allocates device memory."), [cuMemAllocHost](<group__CUDA__MEM.html#group__CUDA__MEM_1gdd8311286d2c2691605362c689bc64e0> "Allocates page-locked host memory."), [cuMemAllocPitch](<group__CUDA__MEM.html#group__CUDA__MEM_1gcbe9b033f6c4de80f63cc6e58ed9a45a> "Allocates pitched device memory."), [cuMemcpy2D](<group__CUDA__MEM.html#group__CUDA__MEM_1g27f885b30c34cc20a663a671dbf6fc27> "Copies memory for 2D arrays."), [cuMemcpy2DAsync](<group__CUDA__MEM.html#group__CUDA__MEM_1g4acf155faeb969d9d21f5433d3d0f274> "Copies memory for 2D arrays."), [cuMemcpy2DUnaligned](<group__CUDA__MEM.html#group__CUDA__MEM_1g2fa285d47fd7020e596bfeab3deb651b> "Copies memory for 2D arrays."), [cuMemcpy3D](<group__CUDA__MEM.html#group__CUDA__MEM_1g4b5238975579f002c0199a3800ca44df> "Copies memory for 3D arrays."), [cuMemcpy3DAsync](<group__CUDA__MEM.html#group__CUDA__MEM_1g79f4f3fde6ae0f529568d881d9e11987> "Copies memory for 3D arrays."), [cuMemcpyAtoA](<group__CUDA__MEM.html#group__CUDA__MEM_1gf81b218c984a31436ec9e23a85fb604a> "Copies memory from Array to Array."), [cuMemcpyAtoD](<group__CUDA__MEM.html#group__CUDA__MEM_1g825b3f037f7f51382cae991bae8173fd> "Copies memory from Array to Device."), [cuMemcpyAtoH](<group__CUDA__MEM.html#group__CUDA__MEM_1gf7ad1edb2539cccc352c6b8b76f657f4> "Copies memory from Array to Host."), [cuMemcpyAtoHAsync](<group__CUDA__MEM.html#group__CUDA__MEM_1g64cbd2e60436699aebdd0bdbf14d0f01> "Copies memory from Array to Host."), [cuMemcpyDtoA](<group__CUDA__MEM.html#group__CUDA__MEM_1gad6827247af91600b56ce6e2ddb802e1> "Copies memory from Device to Array."), [cuMemcpyDtoD](<group__CUDA__MEM.html#group__CUDA__MEM_1g1725774abf8b51b91945f3336b778c8b> "Copies memory from Device to Device."), [cuMemcpyDtoDAsync](<group__CUDA__MEM.html#group__CUDA__MEM_1g39ea09ba682b8eccc9c3e0c04319b5c8> "Copies memory from Device to Device."), [cuMemcpyDtoH](<group__CUDA__MEM.html#group__CUDA__MEM_1g3480368ee0208a98f75019c9a8450893> "Copies memory from Device to Host."), [cuMemcpyDtoHAsync](<group__CUDA__MEM.html#group__CUDA__MEM_1g56f30236c7c5247f8e061b59d3268362> "Copies memory from Device to Host."), [cuMemcpyHtoA](<group__CUDA__MEM.html#group__CUDA__MEM_1g57d3d780d165ecc0e3b3ce08e141cd89> "Copies memory from Host to Array."), [cuMemcpyHtoAAsync](<group__CUDA__MEM.html#group__CUDA__MEM_1gb5c4863f64f132b4bc2661818b3fd188> "Copies memory from Host to Array."), [cuMemcpyHtoD](<group__CUDA__MEM.html#group__CUDA__MEM_1g4d32266788c440b0220b1a9ba5795169> "Copies memory from Host to Device."), [cuMemcpyHtoDAsync](<group__CUDA__MEM.html#group__CUDA__MEM_1g1572263fe2597d7ba4f6964597a354a3> "Copies memory from Host to Device."), [cuMemFree](<group__CUDA__MEM.html#group__CUDA__MEM_1g89b3f154e17cc89b6eea277dbdf5c93a> "Frees device memory."), [cuMemFreeHost](<group__CUDA__MEM.html#group__CUDA__MEM_1g62e0fdbe181dab6b1c90fa1a51c7b92c> "Frees page-locked host memory."), [cuMemGetAddressRange](<group__CUDA__MEM.html#group__CUDA__MEM_1g64fee5711274a2a0573a789c94d8299b> "Get information on memory allocations."), [cuMemGetInfo](<group__CUDA__MEM.html#group__CUDA__MEM_1g808f555540d0143a331cc42aa98835c0> "Gets free and total memory."), [cuMemHostAlloc](<group__CUDA__MEM.html#group__CUDA__MEM_1g572ca4011bfcb25034888a14d4e035b9> "Allocates page-locked host memory."), [cuMemHostGetDevicePointer](<group__CUDA__MEM.html#group__CUDA__MEM_1g57a39e5cba26af4d06be67fc77cc62f0> "Passes back device pointer of mapped pinned memory."), [cuMemsetD2D8](<group__CUDA__MEM.html#group__CUDA__MEM_1ge88b13e646e2be6ba0e0475ef5205974> "Initializes device memory."), [cuMemsetD2D8Async](<group__CUDA__MEM.html#group__CUDA__MEM_1g3f7b6924a3e49c3265b328f534102e97> "Sets device memory."), [cuMemsetD2D16Async](<group__CUDA__MEM.html#group__CUDA__MEM_1g64ee197befac3d74d9fefedcf6ef6b10> "Sets device memory."), [cuMemsetD2D32](<group__CUDA__MEM.html#group__CUDA__MEM_1g74b359b2d026bfeb7c795b5038d07523> "Initializes device memory."), [cuMemsetD2D32Async](<group__CUDA__MEM.html#group__CUDA__MEM_1g8a78d3147ac93fac955052c815d9ea3c> "Sets device memory."), [cuMemsetD8](<group__CUDA__MEM.html#group__CUDA__MEM_1g6e582bf866e9e2fb014297bfaf354d7b> "Initializes device memory."), [cuMemsetD8Async](<group__CUDA__MEM.html#group__CUDA__MEM_1gaef08a7ccd61112f94e82f2b30d43627> "Sets device memory."), [cuMemsetD16](<group__CUDA__MEM.html#group__CUDA__MEM_1g7d805e610054392a4d11e8a8bf5eb35c> "Initializes device memory."), [cuMemsetD16Async](<group__CUDA__MEM.html#group__CUDA__MEM_1gf731438877dd8ec875e4c43d848c878c> "Sets device memory."), [cuMemsetD32](<group__CUDA__MEM.html#group__CUDA__MEM_1g983e8d8759acd1b64326317481fbf132> "Initializes device memory."), [cuMemsetD32Async](<group__CUDA__MEM.html#group__CUDA__MEM_1g58229da5d30f1c0cdf667b320ec2c0f5> "Sets device memory."), [cudaMemset2D](<../cuda-runtime-api/group__CUDART__MEMORY.html#group__CUDART__MEMORY_1g120112b2bd627c7a896390efadc4d2c1>)

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuMemsetD2D16Async ( [CUdeviceptr](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g183f7b0d8ad008ea2a5fd552537ace4e>)Â dstDevice, size_tÂ dstPitch, unsigned shortÂ us, size_tÂ Width, size_tÂ Height, [CUstream](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gb946c7f02e09efd788a204718015d88a>)Â hStream )


Sets device memory.

######  Parameters

`dstDevice`
    \- Destination device pointer
`dstPitch`
    \- Pitch of destination device pointer(Unused if `Height` is 1)
`us`
    \- Value to set
`Width`
    \- Width of row
`Height`
    \- Number of rows
`hStream`
    \- Stream identifier

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_DEINITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9acf52f132faf29b473cdda6061f0f44a>), [CUDA_ERROR_NOT_INITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e98feb999f0af99b4a25ab26b3866f4df8>), [CUDA_ERROR_INVALID_CONTEXT](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a484e9af32c1e9893ff21f0e0191a12d>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>)

###### Description

Sets the 2D memory range of `Width` 16-bit values to the specified value `us`. `Height` specifies the number of rows to set, and `dstPitch` specifies the number of bytes between each row. The `dstDevice` pointer and `dstPitch` offset must be two byte aligned. This function performs fastest when the pitch is one that has been passed back by [cuMemAllocPitch()](<group__CUDA__MEM.html#group__CUDA__MEM_1gcbe9b033f6c4de80f63cc6e58ed9a45a> "Allocates pitched device memory.").

Note:

  * Note that this function may also return error codes from previous, asynchronous launches.

  * See also [memset synchronization details](<api-sync-behavior.html#api-sync-behavior__memset>).

  * This function uses standard [default stream](<stream-sync-behavior.html#stream-sync-behavior__default-stream>) semantics.


**See also:**

[cuArray3DCreate](<group__CUDA__MEM.html#group__CUDA__MEM_1gc2322c70b38c2984536c90ed118bb1d7> "Creates a 3D CUDA array."), [cuArray3DGetDescriptor](<group__CUDA__MEM.html#group__CUDA__MEM_1gb58549f2f3f390b9e0e7c8f3acd53857> "Get a 3D CUDA array descriptor."), [cuArrayCreate](<group__CUDA__MEM.html#group__CUDA__MEM_1g4192ff387a81c3bd5ed8c391ed62ca24> "Creates a 1D or 2D CUDA array."), [cuArrayDestroy](<group__CUDA__MEM.html#group__CUDA__MEM_1g982878affbbc023de84874faac838b0b> "Destroys a CUDA array."), [cuArrayGetDescriptor](<group__CUDA__MEM.html#group__CUDA__MEM_1g661fe823dbd37bf11f82a71bd4762acf> "Get a 1D or 2D CUDA array descriptor."), [cuMemAlloc](<group__CUDA__MEM.html#group__CUDA__MEM_1gb82d2a09844a58dd9e744dc31e8aa467> "Allocates device memory."), [cuMemAllocHost](<group__CUDA__MEM.html#group__CUDA__MEM_1gdd8311286d2c2691605362c689bc64e0> "Allocates page-locked host memory."), [cuMemAllocPitch](<group__CUDA__MEM.html#group__CUDA__MEM_1gcbe9b033f6c4de80f63cc6e58ed9a45a> "Allocates pitched device memory."), [cuMemcpy2D](<group__CUDA__MEM.html#group__CUDA__MEM_1g27f885b30c34cc20a663a671dbf6fc27> "Copies memory for 2D arrays."), [cuMemcpy2DAsync](<group__CUDA__MEM.html#group__CUDA__MEM_1g4acf155faeb969d9d21f5433d3d0f274> "Copies memory for 2D arrays."), [cuMemcpy2DUnaligned](<group__CUDA__MEM.html#group__CUDA__MEM_1g2fa285d47fd7020e596bfeab3deb651b> "Copies memory for 2D arrays."), [cuMemcpy3D](<group__CUDA__MEM.html#group__CUDA__MEM_1g4b5238975579f002c0199a3800ca44df> "Copies memory for 3D arrays."), [cuMemcpy3DAsync](<group__CUDA__MEM.html#group__CUDA__MEM_1g79f4f3fde6ae0f529568d881d9e11987> "Copies memory for 3D arrays."), [cuMemcpyAtoA](<group__CUDA__MEM.html#group__CUDA__MEM_1gf81b218c984a31436ec9e23a85fb604a> "Copies memory from Array to Array."), [cuMemcpyAtoD](<group__CUDA__MEM.html#group__CUDA__MEM_1g825b3f037f7f51382cae991bae8173fd> "Copies memory from Array to Device."), [cuMemcpyAtoH](<group__CUDA__MEM.html#group__CUDA__MEM_1gf7ad1edb2539cccc352c6b8b76f657f4> "Copies memory from Array to Host."), [cuMemcpyAtoHAsync](<group__CUDA__MEM.html#group__CUDA__MEM_1g64cbd2e60436699aebdd0bdbf14d0f01> "Copies memory from Array to Host."), [cuMemcpyDtoA](<group__CUDA__MEM.html#group__CUDA__MEM_1gad6827247af91600b56ce6e2ddb802e1> "Copies memory from Device to Array."), [cuMemcpyDtoD](<group__CUDA__MEM.html#group__CUDA__MEM_1g1725774abf8b51b91945f3336b778c8b> "Copies memory from Device to Device."), [cuMemcpyDtoDAsync](<group__CUDA__MEM.html#group__CUDA__MEM_1g39ea09ba682b8eccc9c3e0c04319b5c8> "Copies memory from Device to Device."), [cuMemcpyDtoH](<group__CUDA__MEM.html#group__CUDA__MEM_1g3480368ee0208a98f75019c9a8450893> "Copies memory from Device to Host."), [cuMemcpyDtoHAsync](<group__CUDA__MEM.html#group__CUDA__MEM_1g56f30236c7c5247f8e061b59d3268362> "Copies memory from Device to Host."), [cuMemcpyHtoA](<group__CUDA__MEM.html#group__CUDA__MEM_1g57d3d780d165ecc0e3b3ce08e141cd89> "Copies memory from Host to Array."), [cuMemcpyHtoAAsync](<group__CUDA__MEM.html#group__CUDA__MEM_1gb5c4863f64f132b4bc2661818b3fd188> "Copies memory from Host to Array."), [cuMemcpyHtoD](<group__CUDA__MEM.html#group__CUDA__MEM_1g4d32266788c440b0220b1a9ba5795169> "Copies memory from Host to Device."), [cuMemcpyHtoDAsync](<group__CUDA__MEM.html#group__CUDA__MEM_1g1572263fe2597d7ba4f6964597a354a3> "Copies memory from Host to Device."), [cuMemFree](<group__CUDA__MEM.html#group__CUDA__MEM_1g89b3f154e17cc89b6eea277dbdf5c93a> "Frees device memory."), [cuMemFreeHost](<group__CUDA__MEM.html#group__CUDA__MEM_1g62e0fdbe181dab6b1c90fa1a51c7b92c> "Frees page-locked host memory."), [cuMemGetAddressRange](<group__CUDA__MEM.html#group__CUDA__MEM_1g64fee5711274a2a0573a789c94d8299b> "Get information on memory allocations."), [cuMemGetInfo](<group__CUDA__MEM.html#group__CUDA__MEM_1g808f555540d0143a331cc42aa98835c0> "Gets free and total memory."), [cuMemHostAlloc](<group__CUDA__MEM.html#group__CUDA__MEM_1g572ca4011bfcb25034888a14d4e035b9> "Allocates page-locked host memory."), [cuMemHostGetDevicePointer](<group__CUDA__MEM.html#group__CUDA__MEM_1g57a39e5cba26af4d06be67fc77cc62f0> "Passes back device pointer of mapped pinned memory."), [cuMemsetD2D8](<group__CUDA__MEM.html#group__CUDA__MEM_1ge88b13e646e2be6ba0e0475ef5205974> "Initializes device memory."), [cuMemsetD2D8Async](<group__CUDA__MEM.html#group__CUDA__MEM_1g3f7b6924a3e49c3265b328f534102e97> "Sets device memory."), [cuMemsetD2D16](<group__CUDA__MEM.html#group__CUDA__MEM_1g7f561a15a66144fa9f6ab5350edc8a30> "Initializes device memory."), [cuMemsetD2D32](<group__CUDA__MEM.html#group__CUDA__MEM_1g74b359b2d026bfeb7c795b5038d07523> "Initializes device memory."), [cuMemsetD2D32Async](<group__CUDA__MEM.html#group__CUDA__MEM_1g8a78d3147ac93fac955052c815d9ea3c> "Sets device memory."), [cuMemsetD8](<group__CUDA__MEM.html#group__CUDA__MEM_1g6e582bf866e9e2fb014297bfaf354d7b> "Initializes device memory."), [cuMemsetD8Async](<group__CUDA__MEM.html#group__CUDA__MEM_1gaef08a7ccd61112f94e82f2b30d43627> "Sets device memory."), [cuMemsetD16](<group__CUDA__MEM.html#group__CUDA__MEM_1g7d805e610054392a4d11e8a8bf5eb35c> "Initializes device memory."), [cuMemsetD16Async](<group__CUDA__MEM.html#group__CUDA__MEM_1gf731438877dd8ec875e4c43d848c878c> "Sets device memory."), [cuMemsetD32](<group__CUDA__MEM.html#group__CUDA__MEM_1g983e8d8759acd1b64326317481fbf132> "Initializes device memory."), [cuMemsetD32Async](<group__CUDA__MEM.html#group__CUDA__MEM_1g58229da5d30f1c0cdf667b320ec2c0f5> "Sets device memory."), [cudaMemset2DAsync](<../cuda-runtime-api/group__CUDART__MEMORY.html#group__CUDART__MEMORY_1g8fdcc53996ff49c570f4b5ead0256ef0>)

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuMemsetD2D32 ( [CUdeviceptr](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g183f7b0d8ad008ea2a5fd552537ace4e>)Â dstDevice, size_tÂ dstPitch, unsigned int Â ui, size_tÂ Width, size_tÂ Height )


Initializes device memory.

######  Parameters

`dstDevice`
    \- Destination device pointer
`dstPitch`
    \- Pitch of destination device pointer(Unused if `Height` is 1)
`ui`
    \- Value to set
`Width`
    \- Width of row
`Height`
    \- Number of rows

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_DEINITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9acf52f132faf29b473cdda6061f0f44a>), [CUDA_ERROR_NOT_INITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e98feb999f0af99b4a25ab26b3866f4df8>), [CUDA_ERROR_INVALID_CONTEXT](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a484e9af32c1e9893ff21f0e0191a12d>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>)

###### Description

Sets the 2D memory range of `Width` 32-bit values to the specified value `ui`. `Height` specifies the number of rows to set, and `dstPitch` specifies the number of bytes between each row. The `dstDevice` pointer and `dstPitch` offset must be four byte aligned. This function performs fastest when the pitch is one that has been passed back by [cuMemAllocPitch()](<group__CUDA__MEM.html#group__CUDA__MEM_1gcbe9b033f6c4de80f63cc6e58ed9a45a> "Allocates pitched device memory.").

Note:

  * Note that this function may also return error codes from previous, asynchronous launches.

  * See also [memset synchronization details](<api-sync-behavior.html#api-sync-behavior__memset>).


**See also:**

[cuArray3DCreate](<group__CUDA__MEM.html#group__CUDA__MEM_1gc2322c70b38c2984536c90ed118bb1d7> "Creates a 3D CUDA array."), [cuArray3DGetDescriptor](<group__CUDA__MEM.html#group__CUDA__MEM_1gb58549f2f3f390b9e0e7c8f3acd53857> "Get a 3D CUDA array descriptor."), [cuArrayCreate](<group__CUDA__MEM.html#group__CUDA__MEM_1g4192ff387a81c3bd5ed8c391ed62ca24> "Creates a 1D or 2D CUDA array."), [cuArrayDestroy](<group__CUDA__MEM.html#group__CUDA__MEM_1g982878affbbc023de84874faac838b0b> "Destroys a CUDA array."), [cuArrayGetDescriptor](<group__CUDA__MEM.html#group__CUDA__MEM_1g661fe823dbd37bf11f82a71bd4762acf> "Get a 1D or 2D CUDA array descriptor."), [cuMemAlloc](<group__CUDA__MEM.html#group__CUDA__MEM_1gb82d2a09844a58dd9e744dc31e8aa467> "Allocates device memory."), [cuMemAllocHost](<group__CUDA__MEM.html#group__CUDA__MEM_1gdd8311286d2c2691605362c689bc64e0> "Allocates page-locked host memory."), [cuMemAllocPitch](<group__CUDA__MEM.html#group__CUDA__MEM_1gcbe9b033f6c4de80f63cc6e58ed9a45a> "Allocates pitched device memory."), [cuMemcpy2D](<group__CUDA__MEM.html#group__CUDA__MEM_1g27f885b30c34cc20a663a671dbf6fc27> "Copies memory for 2D arrays."), [cuMemcpy2DAsync](<group__CUDA__MEM.html#group__CUDA__MEM_1g4acf155faeb969d9d21f5433d3d0f274> "Copies memory for 2D arrays."), [cuMemcpy2DUnaligned](<group__CUDA__MEM.html#group__CUDA__MEM_1g2fa285d47fd7020e596bfeab3deb651b> "Copies memory for 2D arrays."), [cuMemcpy3D](<group__CUDA__MEM.html#group__CUDA__MEM_1g4b5238975579f002c0199a3800ca44df> "Copies memory for 3D arrays."), [cuMemcpy3DAsync](<group__CUDA__MEM.html#group__CUDA__MEM_1g79f4f3fde6ae0f529568d881d9e11987> "Copies memory for 3D arrays."), [cuMemcpyAtoA](<group__CUDA__MEM.html#group__CUDA__MEM_1gf81b218c984a31436ec9e23a85fb604a> "Copies memory from Array to Array."), [cuMemcpyAtoD](<group__CUDA__MEM.html#group__CUDA__MEM_1g825b3f037f7f51382cae991bae8173fd> "Copies memory from Array to Device."), [cuMemcpyAtoH](<group__CUDA__MEM.html#group__CUDA__MEM_1gf7ad1edb2539cccc352c6b8b76f657f4> "Copies memory from Array to Host."), [cuMemcpyAtoHAsync](<group__CUDA__MEM.html#group__CUDA__MEM_1g64cbd2e60436699aebdd0bdbf14d0f01> "Copies memory from Array to Host."), [cuMemcpyDtoA](<group__CUDA__MEM.html#group__CUDA__MEM_1gad6827247af91600b56ce6e2ddb802e1> "Copies memory from Device to Array."), [cuMemcpyDtoD](<group__CUDA__MEM.html#group__CUDA__MEM_1g1725774abf8b51b91945f3336b778c8b> "Copies memory from Device to Device."), [cuMemcpyDtoDAsync](<group__CUDA__MEM.html#group__CUDA__MEM_1g39ea09ba682b8eccc9c3e0c04319b5c8> "Copies memory from Device to Device."), [cuMemcpyDtoH](<group__CUDA__MEM.html#group__CUDA__MEM_1g3480368ee0208a98f75019c9a8450893> "Copies memory from Device to Host."), [cuMemcpyDtoHAsync](<group__CUDA__MEM.html#group__CUDA__MEM_1g56f30236c7c5247f8e061b59d3268362> "Copies memory from Device to Host."), [cuMemcpyHtoA](<group__CUDA__MEM.html#group__CUDA__MEM_1g57d3d780d165ecc0e3b3ce08e141cd89> "Copies memory from Host to Array."), [cuMemcpyHtoAAsync](<group__CUDA__MEM.html#group__CUDA__MEM_1gb5c4863f64f132b4bc2661818b3fd188> "Copies memory from Host to Array."), [cuMemcpyHtoD](<group__CUDA__MEM.html#group__CUDA__MEM_1g4d32266788c440b0220b1a9ba5795169> "Copies memory from Host to Device."), [cuMemcpyHtoDAsync](<group__CUDA__MEM.html#group__CUDA__MEM_1g1572263fe2597d7ba4f6964597a354a3> "Copies memory from Host to Device."), [cuMemFree](<group__CUDA__MEM.html#group__CUDA__MEM_1g89b3f154e17cc89b6eea277dbdf5c93a> "Frees device memory."), [cuMemFreeHost](<group__CUDA__MEM.html#group__CUDA__MEM_1g62e0fdbe181dab6b1c90fa1a51c7b92c> "Frees page-locked host memory."), [cuMemGetAddressRange](<group__CUDA__MEM.html#group__CUDA__MEM_1g64fee5711274a2a0573a789c94d8299b> "Get information on memory allocations."), [cuMemGetInfo](<group__CUDA__MEM.html#group__CUDA__MEM_1g808f555540d0143a331cc42aa98835c0> "Gets free and total memory."), [cuMemHostAlloc](<group__CUDA__MEM.html#group__CUDA__MEM_1g572ca4011bfcb25034888a14d4e035b9> "Allocates page-locked host memory."), [cuMemHostGetDevicePointer](<group__CUDA__MEM.html#group__CUDA__MEM_1g57a39e5cba26af4d06be67fc77cc62f0> "Passes back device pointer of mapped pinned memory."), [cuMemsetD2D8](<group__CUDA__MEM.html#group__CUDA__MEM_1ge88b13e646e2be6ba0e0475ef5205974> "Initializes device memory."), [cuMemsetD2D8Async](<group__CUDA__MEM.html#group__CUDA__MEM_1g3f7b6924a3e49c3265b328f534102e97> "Sets device memory."), [cuMemsetD2D16](<group__CUDA__MEM.html#group__CUDA__MEM_1g7f561a15a66144fa9f6ab5350edc8a30> "Initializes device memory."), [cuMemsetD2D16Async](<group__CUDA__MEM.html#group__CUDA__MEM_1g64ee197befac3d74d9fefedcf6ef6b10> "Sets device memory."), [cuMemsetD2D32Async](<group__CUDA__MEM.html#group__CUDA__MEM_1g8a78d3147ac93fac955052c815d9ea3c> "Sets device memory."), [cuMemsetD8](<group__CUDA__MEM.html#group__CUDA__MEM_1g6e582bf866e9e2fb014297bfaf354d7b> "Initializes device memory."), [cuMemsetD8Async](<group__CUDA__MEM.html#group__CUDA__MEM_1gaef08a7ccd61112f94e82f2b30d43627> "Sets device memory."), [cuMemsetD16](<group__CUDA__MEM.html#group__CUDA__MEM_1g7d805e610054392a4d11e8a8bf5eb35c> "Initializes device memory."), [cuMemsetD16Async](<group__CUDA__MEM.html#group__CUDA__MEM_1gf731438877dd8ec875e4c43d848c878c> "Sets device memory."), [cuMemsetD32](<group__CUDA__MEM.html#group__CUDA__MEM_1g983e8d8759acd1b64326317481fbf132> "Initializes device memory."), [cuMemsetD32Async](<group__CUDA__MEM.html#group__CUDA__MEM_1g58229da5d30f1c0cdf667b320ec2c0f5> "Sets device memory."), [cudaMemset2D](<../cuda-runtime-api/group__CUDART__MEMORY.html#group__CUDART__MEMORY_1g120112b2bd627c7a896390efadc4d2c1>)

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuMemsetD2D32Async ( [CUdeviceptr](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g183f7b0d8ad008ea2a5fd552537ace4e>)Â dstDevice, size_tÂ dstPitch, unsigned int Â ui, size_tÂ Width, size_tÂ Height, [CUstream](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gb946c7f02e09efd788a204718015d88a>)Â hStream )


Sets device memory.

######  Parameters

`dstDevice`
    \- Destination device pointer
`dstPitch`
    \- Pitch of destination device pointer(Unused if `Height` is 1)
`ui`
    \- Value to set
`Width`
    \- Width of row
`Height`
    \- Number of rows
`hStream`
    \- Stream identifier

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_DEINITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9acf52f132faf29b473cdda6061f0f44a>), [CUDA_ERROR_NOT_INITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e98feb999f0af99b4a25ab26b3866f4df8>), [CUDA_ERROR_INVALID_CONTEXT](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a484e9af32c1e9893ff21f0e0191a12d>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>)

###### Description

Sets the 2D memory range of `Width` 32-bit values to the specified value `ui`. `Height` specifies the number of rows to set, and `dstPitch` specifies the number of bytes between each row. The `dstDevice` pointer and `dstPitch` offset must be four byte aligned. This function performs fastest when the pitch is one that has been passed back by [cuMemAllocPitch()](<group__CUDA__MEM.html#group__CUDA__MEM_1gcbe9b033f6c4de80f63cc6e58ed9a45a> "Allocates pitched device memory.").

Note:

  * Note that this function may also return error codes from previous, asynchronous launches.

  * See also [memset synchronization details](<api-sync-behavior.html#api-sync-behavior__memset>).

  * This function uses standard [default stream](<stream-sync-behavior.html#stream-sync-behavior__default-stream>) semantics.


**See also:**

[cuArray3DCreate](<group__CUDA__MEM.html#group__CUDA__MEM_1gc2322c70b38c2984536c90ed118bb1d7> "Creates a 3D CUDA array."), [cuArray3DGetDescriptor](<group__CUDA__MEM.html#group__CUDA__MEM_1gb58549f2f3f390b9e0e7c8f3acd53857> "Get a 3D CUDA array descriptor."), [cuArrayCreate](<group__CUDA__MEM.html#group__CUDA__MEM_1g4192ff387a81c3bd5ed8c391ed62ca24> "Creates a 1D or 2D CUDA array."), [cuArrayDestroy](<group__CUDA__MEM.html#group__CUDA__MEM_1g982878affbbc023de84874faac838b0b> "Destroys a CUDA array."), [cuArrayGetDescriptor](<group__CUDA__MEM.html#group__CUDA__MEM_1g661fe823dbd37bf11f82a71bd4762acf> "Get a 1D or 2D CUDA array descriptor."), [cuMemAlloc](<group__CUDA__MEM.html#group__CUDA__MEM_1gb82d2a09844a58dd9e744dc31e8aa467> "Allocates device memory."), [cuMemAllocHost](<group__CUDA__MEM.html#group__CUDA__MEM_1gdd8311286d2c2691605362c689bc64e0> "Allocates page-locked host memory."), [cuMemAllocPitch](<group__CUDA__MEM.html#group__CUDA__MEM_1gcbe9b033f6c4de80f63cc6e58ed9a45a> "Allocates pitched device memory."), [cuMemcpy2D](<group__CUDA__MEM.html#group__CUDA__MEM_1g27f885b30c34cc20a663a671dbf6fc27> "Copies memory for 2D arrays."), [cuMemcpy2DAsync](<group__CUDA__MEM.html#group__CUDA__MEM_1g4acf155faeb969d9d21f5433d3d0f274> "Copies memory for 2D arrays."), [cuMemcpy2DUnaligned](<group__CUDA__MEM.html#group__CUDA__MEM_1g2fa285d47fd7020e596bfeab3deb651b> "Copies memory for 2D arrays."), [cuMemcpy3D](<group__CUDA__MEM.html#group__CUDA__MEM_1g4b5238975579f002c0199a3800ca44df> "Copies memory for 3D arrays."), [cuMemcpy3DAsync](<group__CUDA__MEM.html#group__CUDA__MEM_1g79f4f3fde6ae0f529568d881d9e11987> "Copies memory for 3D arrays."), [cuMemcpyAtoA](<group__CUDA__MEM.html#group__CUDA__MEM_1gf81b218c984a31436ec9e23a85fb604a> "Copies memory from Array to Array."), [cuMemcpyAtoD](<group__CUDA__MEM.html#group__CUDA__MEM_1g825b3f037f7f51382cae991bae8173fd> "Copies memory from Array to Device."), [cuMemcpyAtoH](<group__CUDA__MEM.html#group__CUDA__MEM_1gf7ad1edb2539cccc352c6b8b76f657f4> "Copies memory from Array to Host."), [cuMemcpyAtoHAsync](<group__CUDA__MEM.html#group__CUDA__MEM_1g64cbd2e60436699aebdd0bdbf14d0f01> "Copies memory from Array to Host."), [cuMemcpyDtoA](<group__CUDA__MEM.html#group__CUDA__MEM_1gad6827247af91600b56ce6e2ddb802e1> "Copies memory from Device to Array."), [cuMemcpyDtoD](<group__CUDA__MEM.html#group__CUDA__MEM_1g1725774abf8b51b91945f3336b778c8b> "Copies memory from Device to Device."), [cuMemcpyDtoDAsync](<group__CUDA__MEM.html#group__CUDA__MEM_1g39ea09ba682b8eccc9c3e0c04319b5c8> "Copies memory from Device to Device."), [cuMemcpyDtoH](<group__CUDA__MEM.html#group__CUDA__MEM_1g3480368ee0208a98f75019c9a8450893> "Copies memory from Device to Host."), [cuMemcpyDtoHAsync](<group__CUDA__MEM.html#group__CUDA__MEM_1g56f30236c7c5247f8e061b59d3268362> "Copies memory from Device to Host."), [cuMemcpyHtoA](<group__CUDA__MEM.html#group__CUDA__MEM_1g57d3d780d165ecc0e3b3ce08e141cd89> "Copies memory from Host to Array."), [cuMemcpyHtoAAsync](<group__CUDA__MEM.html#group__CUDA__MEM_1gb5c4863f64f132b4bc2661818b3fd188> "Copies memory from Host to Array."), [cuMemcpyHtoD](<group__CUDA__MEM.html#group__CUDA__MEM_1g4d32266788c440b0220b1a9ba5795169> "Copies memory from Host to Device."), [cuMemcpyHtoDAsync](<group__CUDA__MEM.html#group__CUDA__MEM_1g1572263fe2597d7ba4f6964597a354a3> "Copies memory from Host to Device."), [cuMemFree](<group__CUDA__MEM.html#group__CUDA__MEM_1g89b3f154e17cc89b6eea277dbdf5c93a> "Frees device memory."), [cuMemFreeHost](<group__CUDA__MEM.html#group__CUDA__MEM_1g62e0fdbe181dab6b1c90fa1a51c7b92c> "Frees page-locked host memory."), [cuMemGetAddressRange](<group__CUDA__MEM.html#group__CUDA__MEM_1g64fee5711274a2a0573a789c94d8299b> "Get information on memory allocations."), [cuMemGetInfo](<group__CUDA__MEM.html#group__CUDA__MEM_1g808f555540d0143a331cc42aa98835c0> "Gets free and total memory."), [cuMemHostAlloc](<group__CUDA__MEM.html#group__CUDA__MEM_1g572ca4011bfcb25034888a14d4e035b9> "Allocates page-locked host memory."), [cuMemHostGetDevicePointer](<group__CUDA__MEM.html#group__CUDA__MEM_1g57a39e5cba26af4d06be67fc77cc62f0> "Passes back device pointer of mapped pinned memory."), [cuMemsetD2D8](<group__CUDA__MEM.html#group__CUDA__MEM_1ge88b13e646e2be6ba0e0475ef5205974> "Initializes device memory."), [cuMemsetD2D8Async](<group__CUDA__MEM.html#group__CUDA__MEM_1g3f7b6924a3e49c3265b328f534102e97> "Sets device memory."), [cuMemsetD2D16](<group__CUDA__MEM.html#group__CUDA__MEM_1g7f561a15a66144fa9f6ab5350edc8a30> "Initializes device memory."), [cuMemsetD2D16Async](<group__CUDA__MEM.html#group__CUDA__MEM_1g64ee197befac3d74d9fefedcf6ef6b10> "Sets device memory."), [cuMemsetD2D32](<group__CUDA__MEM.html#group__CUDA__MEM_1g74b359b2d026bfeb7c795b5038d07523> "Initializes device memory."), [cuMemsetD8](<group__CUDA__MEM.html#group__CUDA__MEM_1g6e582bf866e9e2fb014297bfaf354d7b> "Initializes device memory."), [cuMemsetD8Async](<group__CUDA__MEM.html#group__CUDA__MEM_1gaef08a7ccd61112f94e82f2b30d43627> "Sets device memory."), [cuMemsetD16](<group__CUDA__MEM.html#group__CUDA__MEM_1g7d805e610054392a4d11e8a8bf5eb35c> "Initializes device memory."), [cuMemsetD16Async](<group__CUDA__MEM.html#group__CUDA__MEM_1gf731438877dd8ec875e4c43d848c878c> "Sets device memory."), [cuMemsetD32](<group__CUDA__MEM.html#group__CUDA__MEM_1g983e8d8759acd1b64326317481fbf132> "Initializes device memory."), [cuMemsetD32Async](<group__CUDA__MEM.html#group__CUDA__MEM_1g58229da5d30f1c0cdf667b320ec2c0f5> "Sets device memory."), [cudaMemset2DAsync](<../cuda-runtime-api/group__CUDART__MEMORY.html#group__CUDART__MEMORY_1g8fdcc53996ff49c570f4b5ead0256ef0>)

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuMemsetD2D8 ( [CUdeviceptr](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g183f7b0d8ad008ea2a5fd552537ace4e>)Â dstDevice, size_tÂ dstPitch, unsigned char Â uc, size_tÂ Width, size_tÂ Height )


Initializes device memory.

######  Parameters

`dstDevice`
    \- Destination device pointer
`dstPitch`
    \- Pitch of destination device pointer(Unused if `Height` is 1)
`uc`
    \- Value to set
`Width`
    \- Width of row
`Height`
    \- Number of rows

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_DEINITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9acf52f132faf29b473cdda6061f0f44a>), [CUDA_ERROR_NOT_INITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e98feb999f0af99b4a25ab26b3866f4df8>), [CUDA_ERROR_INVALID_CONTEXT](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a484e9af32c1e9893ff21f0e0191a12d>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>)

###### Description

Sets the 2D memory range of `Width` 8-bit values to the specified value `uc`. `Height` specifies the number of rows to set, and `dstPitch` specifies the number of bytes between each row. This function performs fastest when the pitch is one that has been passed back by [cuMemAllocPitch()](<group__CUDA__MEM.html#group__CUDA__MEM_1gcbe9b033f6c4de80f63cc6e58ed9a45a> "Allocates pitched device memory.").

Note:

  * Note that this function may also return error codes from previous, asynchronous launches.

  * See also [memset synchronization details](<api-sync-behavior.html#api-sync-behavior__memset>).


**See also:**

[cuArray3DCreate](<group__CUDA__MEM.html#group__CUDA__MEM_1gc2322c70b38c2984536c90ed118bb1d7> "Creates a 3D CUDA array."), [cuArray3DGetDescriptor](<group__CUDA__MEM.html#group__CUDA__MEM_1gb58549f2f3f390b9e0e7c8f3acd53857> "Get a 3D CUDA array descriptor."), [cuArrayCreate](<group__CUDA__MEM.html#group__CUDA__MEM_1g4192ff387a81c3bd5ed8c391ed62ca24> "Creates a 1D or 2D CUDA array."), [cuArrayDestroy](<group__CUDA__MEM.html#group__CUDA__MEM_1g982878affbbc023de84874faac838b0b> "Destroys a CUDA array."), [cuArrayGetDescriptor](<group__CUDA__MEM.html#group__CUDA__MEM_1g661fe823dbd37bf11f82a71bd4762acf> "Get a 1D or 2D CUDA array descriptor."), [cuMemAlloc](<group__CUDA__MEM.html#group__CUDA__MEM_1gb82d2a09844a58dd9e744dc31e8aa467> "Allocates device memory."), [cuMemAllocHost](<group__CUDA__MEM.html#group__CUDA__MEM_1gdd8311286d2c2691605362c689bc64e0> "Allocates page-locked host memory."), [cuMemAllocPitch](<group__CUDA__MEM.html#group__CUDA__MEM_1gcbe9b033f6c4de80f63cc6e58ed9a45a> "Allocates pitched device memory."), [cuMemcpy2D](<group__CUDA__MEM.html#group__CUDA__MEM_1g27f885b30c34cc20a663a671dbf6fc27> "Copies memory for 2D arrays."), [cuMemcpy2DAsync](<group__CUDA__MEM.html#group__CUDA__MEM_1g4acf155faeb969d9d21f5433d3d0f274> "Copies memory for 2D arrays."), [cuMemcpy2DUnaligned](<group__CUDA__MEM.html#group__CUDA__MEM_1g2fa285d47fd7020e596bfeab3deb651b> "Copies memory for 2D arrays."), [cuMemcpy3D](<group__CUDA__MEM.html#group__CUDA__MEM_1g4b5238975579f002c0199a3800ca44df> "Copies memory for 3D arrays."), [cuMemcpy3DAsync](<group__CUDA__MEM.html#group__CUDA__MEM_1g79f4f3fde6ae0f529568d881d9e11987> "Copies memory for 3D arrays."), [cuMemcpyAtoA](<group__CUDA__MEM.html#group__CUDA__MEM_1gf81b218c984a31436ec9e23a85fb604a> "Copies memory from Array to Array."), [cuMemcpyAtoD](<group__CUDA__MEM.html#group__CUDA__MEM_1g825b3f037f7f51382cae991bae8173fd> "Copies memory from Array to Device."), [cuMemcpyAtoH](<group__CUDA__MEM.html#group__CUDA__MEM_1gf7ad1edb2539cccc352c6b8b76f657f4> "Copies memory from Array to Host."), [cuMemcpyAtoHAsync](<group__CUDA__MEM.html#group__CUDA__MEM_1g64cbd2e60436699aebdd0bdbf14d0f01> "Copies memory from Array to Host."), [cuMemcpyDtoA](<group__CUDA__MEM.html#group__CUDA__MEM_1gad6827247af91600b56ce6e2ddb802e1> "Copies memory from Device to Array."), [cuMemcpyDtoD](<group__CUDA__MEM.html#group__CUDA__MEM_1g1725774abf8b51b91945f3336b778c8b> "Copies memory from Device to Device."), [cuMemcpyDtoDAsync](<group__CUDA__MEM.html#group__CUDA__MEM_1g39ea09ba682b8eccc9c3e0c04319b5c8> "Copies memory from Device to Device."), [cuMemcpyDtoH](<group__CUDA__MEM.html#group__CUDA__MEM_1g3480368ee0208a98f75019c9a8450893> "Copies memory from Device to Host."), [cuMemcpyDtoHAsync](<group__CUDA__MEM.html#group__CUDA__MEM_1g56f30236c7c5247f8e061b59d3268362> "Copies memory from Device to Host."), [cuMemcpyHtoA](<group__CUDA__MEM.html#group__CUDA__MEM_1g57d3d780d165ecc0e3b3ce08e141cd89> "Copies memory from Host to Array."), [cuMemcpyHtoAAsync](<group__CUDA__MEM.html#group__CUDA__MEM_1gb5c4863f64f132b4bc2661818b3fd188> "Copies memory from Host to Array."), [cuMemcpyHtoD](<group__CUDA__MEM.html#group__CUDA__MEM_1g4d32266788c440b0220b1a9ba5795169> "Copies memory from Host to Device."), [cuMemcpyHtoDAsync](<group__CUDA__MEM.html#group__CUDA__MEM_1g1572263fe2597d7ba4f6964597a354a3> "Copies memory from Host to Device."), [cuMemFree](<group__CUDA__MEM.html#group__CUDA__MEM_1g89b3f154e17cc89b6eea277dbdf5c93a> "Frees device memory."), [cuMemFreeHost](<group__CUDA__MEM.html#group__CUDA__MEM_1g62e0fdbe181dab6b1c90fa1a51c7b92c> "Frees page-locked host memory."), [cuMemGetAddressRange](<group__CUDA__MEM.html#group__CUDA__MEM_1g64fee5711274a2a0573a789c94d8299b> "Get information on memory allocations."), [cuMemGetInfo](<group__CUDA__MEM.html#group__CUDA__MEM_1g808f555540d0143a331cc42aa98835c0> "Gets free and total memory."), [cuMemHostAlloc](<group__CUDA__MEM.html#group__CUDA__MEM_1g572ca4011bfcb25034888a14d4e035b9> "Allocates page-locked host memory."), [cuMemHostGetDevicePointer](<group__CUDA__MEM.html#group__CUDA__MEM_1g57a39e5cba26af4d06be67fc77cc62f0> "Passes back device pointer of mapped pinned memory."), [cuMemsetD2D8Async](<group__CUDA__MEM.html#group__CUDA__MEM_1g3f7b6924a3e49c3265b328f534102e97> "Sets device memory."), [cuMemsetD2D16](<group__CUDA__MEM.html#group__CUDA__MEM_1g7f561a15a66144fa9f6ab5350edc8a30> "Initializes device memory."), [cuMemsetD2D16Async](<group__CUDA__MEM.html#group__CUDA__MEM_1g64ee197befac3d74d9fefedcf6ef6b10> "Sets device memory."), [cuMemsetD2D32](<group__CUDA__MEM.html#group__CUDA__MEM_1g74b359b2d026bfeb7c795b5038d07523> "Initializes device memory."), [cuMemsetD2D32Async](<group__CUDA__MEM.html#group__CUDA__MEM_1g8a78d3147ac93fac955052c815d9ea3c> "Sets device memory."), [cuMemsetD8](<group__CUDA__MEM.html#group__CUDA__MEM_1g6e582bf866e9e2fb014297bfaf354d7b> "Initializes device memory."), [cuMemsetD8Async](<group__CUDA__MEM.html#group__CUDA__MEM_1gaef08a7ccd61112f94e82f2b30d43627> "Sets device memory."), [cuMemsetD16](<group__CUDA__MEM.html#group__CUDA__MEM_1g7d805e610054392a4d11e8a8bf5eb35c> "Initializes device memory."), [cuMemsetD16Async](<group__CUDA__MEM.html#group__CUDA__MEM_1gf731438877dd8ec875e4c43d848c878c> "Sets device memory."), [cuMemsetD32](<group__CUDA__MEM.html#group__CUDA__MEM_1g983e8d8759acd1b64326317481fbf132> "Initializes device memory."), [cuMemsetD32Async](<group__CUDA__MEM.html#group__CUDA__MEM_1g58229da5d30f1c0cdf667b320ec2c0f5> "Sets device memory."), [cudaMemset2D](<../cuda-runtime-api/group__CUDART__MEMORY.html#group__CUDART__MEMORY_1g120112b2bd627c7a896390efadc4d2c1>)

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuMemsetD2D8Async ( [CUdeviceptr](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g183f7b0d8ad008ea2a5fd552537ace4e>)Â dstDevice, size_tÂ dstPitch, unsigned char Â uc, size_tÂ Width, size_tÂ Height, [CUstream](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gb946c7f02e09efd788a204718015d88a>)Â hStream )


Sets device memory.

######  Parameters

`dstDevice`
    \- Destination device pointer
`dstPitch`
    \- Pitch of destination device pointer(Unused if `Height` is 1)
`uc`
    \- Value to set
`Width`
    \- Width of row
`Height`
    \- Number of rows
`hStream`
    \- Stream identifier

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_DEINITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9acf52f132faf29b473cdda6061f0f44a>), [CUDA_ERROR_NOT_INITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e98feb999f0af99b4a25ab26b3866f4df8>), [CUDA_ERROR_INVALID_CONTEXT](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a484e9af32c1e9893ff21f0e0191a12d>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>)

###### Description

Sets the 2D memory range of `Width` 8-bit values to the specified value `uc`. `Height` specifies the number of rows to set, and `dstPitch` specifies the number of bytes between each row. This function performs fastest when the pitch is one that has been passed back by [cuMemAllocPitch()](<group__CUDA__MEM.html#group__CUDA__MEM_1gcbe9b033f6c4de80f63cc6e58ed9a45a> "Allocates pitched device memory.").

Note:

  * Note that this function may also return error codes from previous, asynchronous launches.

  * See also [memset synchronization details](<api-sync-behavior.html#api-sync-behavior__memset>).

  * This function uses standard [default stream](<stream-sync-behavior.html#stream-sync-behavior__default-stream>) semantics.


**See also:**

[cuArray3DCreate](<group__CUDA__MEM.html#group__CUDA__MEM_1gc2322c70b38c2984536c90ed118bb1d7> "Creates a 3D CUDA array."), [cuArray3DGetDescriptor](<group__CUDA__MEM.html#group__CUDA__MEM_1gb58549f2f3f390b9e0e7c8f3acd53857> "Get a 3D CUDA array descriptor."), [cuArrayCreate](<group__CUDA__MEM.html#group__CUDA__MEM_1g4192ff387a81c3bd5ed8c391ed62ca24> "Creates a 1D or 2D CUDA array."), [cuArrayDestroy](<group__CUDA__MEM.html#group__CUDA__MEM_1g982878affbbc023de84874faac838b0b> "Destroys a CUDA array."), [cuArrayGetDescriptor](<group__CUDA__MEM.html#group__CUDA__MEM_1g661fe823dbd37bf11f82a71bd4762acf> "Get a 1D or 2D CUDA array descriptor."), [cuMemAlloc](<group__CUDA__MEM.html#group__CUDA__MEM_1gb82d2a09844a58dd9e744dc31e8aa467> "Allocates device memory."), [cuMemAllocHost](<group__CUDA__MEM.html#group__CUDA__MEM_1gdd8311286d2c2691605362c689bc64e0> "Allocates page-locked host memory."), [cuMemAllocPitch](<group__CUDA__MEM.html#group__CUDA__MEM_1gcbe9b033f6c4de80f63cc6e58ed9a45a> "Allocates pitched device memory."), [cuMemcpy2D](<group__CUDA__MEM.html#group__CUDA__MEM_1g27f885b30c34cc20a663a671dbf6fc27> "Copies memory for 2D arrays."), [cuMemcpy2DAsync](<group__CUDA__MEM.html#group__CUDA__MEM_1g4acf155faeb969d9d21f5433d3d0f274> "Copies memory for 2D arrays."), [cuMemcpy2DUnaligned](<group__CUDA__MEM.html#group__CUDA__MEM_1g2fa285d47fd7020e596bfeab3deb651b> "Copies memory for 2D arrays."), [cuMemcpy3D](<group__CUDA__MEM.html#group__CUDA__MEM_1g4b5238975579f002c0199a3800ca44df> "Copies memory for 3D arrays."), [cuMemcpy3DAsync](<group__CUDA__MEM.html#group__CUDA__MEM_1g79f4f3fde6ae0f529568d881d9e11987> "Copies memory for 3D arrays."), [cuMemcpyAtoA](<group__CUDA__MEM.html#group__CUDA__MEM_1gf81b218c984a31436ec9e23a85fb604a> "Copies memory from Array to Array."), [cuMemcpyAtoD](<group__CUDA__MEM.html#group__CUDA__MEM_1g825b3f037f7f51382cae991bae8173fd> "Copies memory from Array to Device."), [cuMemcpyAtoH](<group__CUDA__MEM.html#group__CUDA__MEM_1gf7ad1edb2539cccc352c6b8b76f657f4> "Copies memory from Array to Host."), [cuMemcpyAtoHAsync](<group__CUDA__MEM.html#group__CUDA__MEM_1g64cbd2e60436699aebdd0bdbf14d0f01> "Copies memory from Array to Host."), [cuMemcpyDtoA](<group__CUDA__MEM.html#group__CUDA__MEM_1gad6827247af91600b56ce6e2ddb802e1> "Copies memory from Device to Array."), [cuMemcpyDtoD](<group__CUDA__MEM.html#group__CUDA__MEM_1g1725774abf8b51b91945f3336b778c8b> "Copies memory from Device to Device."), [cuMemcpyDtoDAsync](<group__CUDA__MEM.html#group__CUDA__MEM_1g39ea09ba682b8eccc9c3e0c04319b5c8> "Copies memory from Device to Device."), [cuMemcpyDtoH](<group__CUDA__MEM.html#group__CUDA__MEM_1g3480368ee0208a98f75019c9a8450893> "Copies memory from Device to Host."), [cuMemcpyDtoHAsync](<group__CUDA__MEM.html#group__CUDA__MEM_1g56f30236c7c5247f8e061b59d3268362> "Copies memory from Device to Host."), [cuMemcpyHtoA](<group__CUDA__MEM.html#group__CUDA__MEM_1g57d3d780d165ecc0e3b3ce08e141cd89> "Copies memory from Host to Array."), [cuMemcpyHtoAAsync](<group__CUDA__MEM.html#group__CUDA__MEM_1gb5c4863f64f132b4bc2661818b3fd188> "Copies memory from Host to Array."), [cuMemcpyHtoD](<group__CUDA__MEM.html#group__CUDA__MEM_1g4d32266788c440b0220b1a9ba5795169> "Copies memory from Host to Device."), [cuMemcpyHtoDAsync](<group__CUDA__MEM.html#group__CUDA__MEM_1g1572263fe2597d7ba4f6964597a354a3> "Copies memory from Host to Device."), [cuMemFree](<group__CUDA__MEM.html#group__CUDA__MEM_1g89b3f154e17cc89b6eea277dbdf5c93a> "Frees device memory."), [cuMemFreeHost](<group__CUDA__MEM.html#group__CUDA__MEM_1g62e0fdbe181dab6b1c90fa1a51c7b92c> "Frees page-locked host memory."), [cuMemGetAddressRange](<group__CUDA__MEM.html#group__CUDA__MEM_1g64fee5711274a2a0573a789c94d8299b> "Get information on memory allocations."), [cuMemGetInfo](<group__CUDA__MEM.html#group__CUDA__MEM_1g808f555540d0143a331cc42aa98835c0> "Gets free and total memory."), [cuMemHostAlloc](<group__CUDA__MEM.html#group__CUDA__MEM_1g572ca4011bfcb25034888a14d4e035b9> "Allocates page-locked host memory."), [cuMemHostGetDevicePointer](<group__CUDA__MEM.html#group__CUDA__MEM_1g57a39e5cba26af4d06be67fc77cc62f0> "Passes back device pointer of mapped pinned memory."), [cuMemsetD2D8](<group__CUDA__MEM.html#group__CUDA__MEM_1ge88b13e646e2be6ba0e0475ef5205974> "Initializes device memory."), [cuMemsetD2D16](<group__CUDA__MEM.html#group__CUDA__MEM_1g7f561a15a66144fa9f6ab5350edc8a30> "Initializes device memory."), [cuMemsetD2D16Async](<group__CUDA__MEM.html#group__CUDA__MEM_1g64ee197befac3d74d9fefedcf6ef6b10> "Sets device memory."), [cuMemsetD2D32](<group__CUDA__MEM.html#group__CUDA__MEM_1g74b359b2d026bfeb7c795b5038d07523> "Initializes device memory."), [cuMemsetD2D32Async](<group__CUDA__MEM.html#group__CUDA__MEM_1g8a78d3147ac93fac955052c815d9ea3c> "Sets device memory."), [cuMemsetD8](<group__CUDA__MEM.html#group__CUDA__MEM_1g6e582bf866e9e2fb014297bfaf354d7b> "Initializes device memory."), [cuMemsetD8Async](<group__CUDA__MEM.html#group__CUDA__MEM_1gaef08a7ccd61112f94e82f2b30d43627> "Sets device memory."), [cuMemsetD16](<group__CUDA__MEM.html#group__CUDA__MEM_1g7d805e610054392a4d11e8a8bf5eb35c> "Initializes device memory."), [cuMemsetD16Async](<group__CUDA__MEM.html#group__CUDA__MEM_1gf731438877dd8ec875e4c43d848c878c> "Sets device memory."), [cuMemsetD32](<group__CUDA__MEM.html#group__CUDA__MEM_1g983e8d8759acd1b64326317481fbf132> "Initializes device memory."), [cuMemsetD32Async](<group__CUDA__MEM.html#group__CUDA__MEM_1g58229da5d30f1c0cdf667b320ec2c0f5> "Sets device memory."), [cudaMemset2DAsync](<../cuda-runtime-api/group__CUDART__MEMORY.html#group__CUDART__MEMORY_1g8fdcc53996ff49c570f4b5ead0256ef0>)

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuMemsetD32 ( [CUdeviceptr](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g183f7b0d8ad008ea2a5fd552537ace4e>)Â dstDevice, unsigned int Â ui, size_tÂ N )


Initializes device memory.

######  Parameters

`dstDevice`
    \- Destination device pointer
`ui`
    \- Value to set
`N`
    \- Number of elements

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_DEINITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9acf52f132faf29b473cdda6061f0f44a>), [CUDA_ERROR_NOT_INITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e98feb999f0af99b4a25ab26b3866f4df8>), [CUDA_ERROR_INVALID_CONTEXT](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a484e9af32c1e9893ff21f0e0191a12d>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>)

###### Description

Sets the memory range of `N` 32-bit values to the specified value `ui`. The `dstDevice` pointer must be four byte aligned.

Note:

  * Note that this function may also return error codes from previous, asynchronous launches.

  * See also [memset synchronization details](<api-sync-behavior.html#api-sync-behavior__memset>).


**See also:**

[cuArray3DCreate](<group__CUDA__MEM.html#group__CUDA__MEM_1gc2322c70b38c2984536c90ed118bb1d7> "Creates a 3D CUDA array."), [cuArray3DGetDescriptor](<group__CUDA__MEM.html#group__CUDA__MEM_1gb58549f2f3f390b9e0e7c8f3acd53857> "Get a 3D CUDA array descriptor."), [cuArrayCreate](<group__CUDA__MEM.html#group__CUDA__MEM_1g4192ff387a81c3bd5ed8c391ed62ca24> "Creates a 1D or 2D CUDA array."), [cuArrayDestroy](<group__CUDA__MEM.html#group__CUDA__MEM_1g982878affbbc023de84874faac838b0b> "Destroys a CUDA array."), [cuArrayGetDescriptor](<group__CUDA__MEM.html#group__CUDA__MEM_1g661fe823dbd37bf11f82a71bd4762acf> "Get a 1D or 2D CUDA array descriptor."), [cuMemAlloc](<group__CUDA__MEM.html#group__CUDA__MEM_1gb82d2a09844a58dd9e744dc31e8aa467> "Allocates device memory."), [cuMemAllocHost](<group__CUDA__MEM.html#group__CUDA__MEM_1gdd8311286d2c2691605362c689bc64e0> "Allocates page-locked host memory."), [cuMemAllocPitch](<group__CUDA__MEM.html#group__CUDA__MEM_1gcbe9b033f6c4de80f63cc6e58ed9a45a> "Allocates pitched device memory."), [cuMemcpy2D](<group__CUDA__MEM.html#group__CUDA__MEM_1g27f885b30c34cc20a663a671dbf6fc27> "Copies memory for 2D arrays."), [cuMemcpy2DAsync](<group__CUDA__MEM.html#group__CUDA__MEM_1g4acf155faeb969d9d21f5433d3d0f274> "Copies memory for 2D arrays."), [cuMemcpy2DUnaligned](<group__CUDA__MEM.html#group__CUDA__MEM_1g2fa285d47fd7020e596bfeab3deb651b> "Copies memory for 2D arrays."), [cuMemcpy3D](<group__CUDA__MEM.html#group__CUDA__MEM_1g4b5238975579f002c0199a3800ca44df> "Copies memory for 3D arrays."), [cuMemcpy3DAsync](<group__CUDA__MEM.html#group__CUDA__MEM_1g79f4f3fde6ae0f529568d881d9e11987> "Copies memory for 3D arrays."), [cuMemcpyAtoA](<group__CUDA__MEM.html#group__CUDA__MEM_1gf81b218c984a31436ec9e23a85fb604a> "Copies memory from Array to Array."), [cuMemcpyAtoD](<group__CUDA__MEM.html#group__CUDA__MEM_1g825b3f037f7f51382cae991bae8173fd> "Copies memory from Array to Device."), [cuMemcpyAtoH](<group__CUDA__MEM.html#group__CUDA__MEM_1gf7ad1edb2539cccc352c6b8b76f657f4> "Copies memory from Array to Host."), [cuMemcpyAtoHAsync](<group__CUDA__MEM.html#group__CUDA__MEM_1g64cbd2e60436699aebdd0bdbf14d0f01> "Copies memory from Array to Host."), [cuMemcpyDtoA](<group__CUDA__MEM.html#group__CUDA__MEM_1gad6827247af91600b56ce6e2ddb802e1> "Copies memory from Device to Array."), [cuMemcpyDtoD](<group__CUDA__MEM.html#group__CUDA__MEM_1g1725774abf8b51b91945f3336b778c8b> "Copies memory from Device to Device."), [cuMemcpyDtoDAsync](<group__CUDA__MEM.html#group__CUDA__MEM_1g39ea09ba682b8eccc9c3e0c04319b5c8> "Copies memory from Device to Device."), [cuMemcpyDtoH](<group__CUDA__MEM.html#group__CUDA__MEM_1g3480368ee0208a98f75019c9a8450893> "Copies memory from Device to Host."), [cuMemcpyDtoHAsync](<group__CUDA__MEM.html#group__CUDA__MEM_1g56f30236c7c5247f8e061b59d3268362> "Copies memory from Device to Host."), [cuMemcpyHtoA](<group__CUDA__MEM.html#group__CUDA__MEM_1g57d3d780d165ecc0e3b3ce08e141cd89> "Copies memory from Host to Array."), [cuMemcpyHtoAAsync](<group__CUDA__MEM.html#group__CUDA__MEM_1gb5c4863f64f132b4bc2661818b3fd188> "Copies memory from Host to Array."), [cuMemcpyHtoD](<group__CUDA__MEM.html#group__CUDA__MEM_1g4d32266788c440b0220b1a9ba5795169> "Copies memory from Host to Device."), [cuMemcpyHtoDAsync](<group__CUDA__MEM.html#group__CUDA__MEM_1g1572263fe2597d7ba4f6964597a354a3> "Copies memory from Host to Device."), [cuMemFree](<group__CUDA__MEM.html#group__CUDA__MEM_1g89b3f154e17cc89b6eea277dbdf5c93a> "Frees device memory."), [cuMemFreeHost](<group__CUDA__MEM.html#group__CUDA__MEM_1g62e0fdbe181dab6b1c90fa1a51c7b92c> "Frees page-locked host memory."), [cuMemGetAddressRange](<group__CUDA__MEM.html#group__CUDA__MEM_1g64fee5711274a2a0573a789c94d8299b> "Get information on memory allocations."), [cuMemGetInfo](<group__CUDA__MEM.html#group__CUDA__MEM_1g808f555540d0143a331cc42aa98835c0> "Gets free and total memory."), [cuMemHostAlloc](<group__CUDA__MEM.html#group__CUDA__MEM_1g572ca4011bfcb25034888a14d4e035b9> "Allocates page-locked host memory."), [cuMemHostGetDevicePointer](<group__CUDA__MEM.html#group__CUDA__MEM_1g57a39e5cba26af4d06be67fc77cc62f0> "Passes back device pointer of mapped pinned memory."), [cuMemsetD2D8](<group__CUDA__MEM.html#group__CUDA__MEM_1ge88b13e646e2be6ba0e0475ef5205974> "Initializes device memory."), [cuMemsetD2D8Async](<group__CUDA__MEM.html#group__CUDA__MEM_1g3f7b6924a3e49c3265b328f534102e97> "Sets device memory."), [cuMemsetD2D16](<group__CUDA__MEM.html#group__CUDA__MEM_1g7f561a15a66144fa9f6ab5350edc8a30> "Initializes device memory."), [cuMemsetD2D16Async](<group__CUDA__MEM.html#group__CUDA__MEM_1g64ee197befac3d74d9fefedcf6ef6b10> "Sets device memory."), [cuMemsetD2D32](<group__CUDA__MEM.html#group__CUDA__MEM_1g74b359b2d026bfeb7c795b5038d07523> "Initializes device memory."), [cuMemsetD2D32Async](<group__CUDA__MEM.html#group__CUDA__MEM_1g8a78d3147ac93fac955052c815d9ea3c> "Sets device memory."), [cuMemsetD8](<group__CUDA__MEM.html#group__CUDA__MEM_1g6e582bf866e9e2fb014297bfaf354d7b> "Initializes device memory."), [cuMemsetD8Async](<group__CUDA__MEM.html#group__CUDA__MEM_1gaef08a7ccd61112f94e82f2b30d43627> "Sets device memory."), [cuMemsetD16](<group__CUDA__MEM.html#group__CUDA__MEM_1g7d805e610054392a4d11e8a8bf5eb35c> "Initializes device memory."), [cuMemsetD16Async](<group__CUDA__MEM.html#group__CUDA__MEM_1gf731438877dd8ec875e4c43d848c878c> "Sets device memory."), [cuMemsetD32Async](<group__CUDA__MEM.html#group__CUDA__MEM_1g58229da5d30f1c0cdf667b320ec2c0f5> "Sets device memory."), [cudaMemset](<../cuda-runtime-api/group__CUDART__MEMORY.html#group__CUDART__MEMORY_1gf7338650f7683c51ee26aadc6973c63a>)

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuMemsetD32Async ( [CUdeviceptr](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g183f7b0d8ad008ea2a5fd552537ace4e>)Â dstDevice, unsigned int Â ui, size_tÂ N, [CUstream](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gb946c7f02e09efd788a204718015d88a>)Â hStream )


Sets device memory.

######  Parameters

`dstDevice`
    \- Destination device pointer
`ui`
    \- Value to set
`N`
    \- Number of elements
`hStream`
    \- Stream identifier

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_DEINITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9acf52f132faf29b473cdda6061f0f44a>), [CUDA_ERROR_NOT_INITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e98feb999f0af99b4a25ab26b3866f4df8>), [CUDA_ERROR_INVALID_CONTEXT](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a484e9af32c1e9893ff21f0e0191a12d>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>)

###### Description

Sets the memory range of `N` 32-bit values to the specified value `ui`. The `dstDevice` pointer must be four byte aligned.

Note:

  * Note that this function may also return error codes from previous, asynchronous launches.

  * See also [memset synchronization details](<api-sync-behavior.html#api-sync-behavior__memset>).

  * This function uses standard [default stream](<stream-sync-behavior.html#stream-sync-behavior__default-stream>) semantics.


**See also:**

[cuArray3DCreate](<group__CUDA__MEM.html#group__CUDA__MEM_1gc2322c70b38c2984536c90ed118bb1d7> "Creates a 3D CUDA array."), [cuArray3DGetDescriptor](<group__CUDA__MEM.html#group__CUDA__MEM_1gb58549f2f3f390b9e0e7c8f3acd53857> "Get a 3D CUDA array descriptor."), [cuArrayCreate](<group__CUDA__MEM.html#group__CUDA__MEM_1g4192ff387a81c3bd5ed8c391ed62ca24> "Creates a 1D or 2D CUDA array."), [cuArrayDestroy](<group__CUDA__MEM.html#group__CUDA__MEM_1g982878affbbc023de84874faac838b0b> "Destroys a CUDA array."), [cuArrayGetDescriptor](<group__CUDA__MEM.html#group__CUDA__MEM_1g661fe823dbd37bf11f82a71bd4762acf> "Get a 1D or 2D CUDA array descriptor."), [cuMemAlloc](<group__CUDA__MEM.html#group__CUDA__MEM_1gb82d2a09844a58dd9e744dc31e8aa467> "Allocates device memory."), [cuMemAllocHost](<group__CUDA__MEM.html#group__CUDA__MEM_1gdd8311286d2c2691605362c689bc64e0> "Allocates page-locked host memory."), [cuMemAllocPitch](<group__CUDA__MEM.html#group__CUDA__MEM_1gcbe9b033f6c4de80f63cc6e58ed9a45a> "Allocates pitched device memory."), [cuMemcpy2D](<group__CUDA__MEM.html#group__CUDA__MEM_1g27f885b30c34cc20a663a671dbf6fc27> "Copies memory for 2D arrays."), [cuMemcpy2DAsync](<group__CUDA__MEM.html#group__CUDA__MEM_1g4acf155faeb969d9d21f5433d3d0f274> "Copies memory for 2D arrays."), [cuMemcpy2DUnaligned](<group__CUDA__MEM.html#group__CUDA__MEM_1g2fa285d47fd7020e596bfeab3deb651b> "Copies memory for 2D arrays."), [cuMemcpy3D](<group__CUDA__MEM.html#group__CUDA__MEM_1g4b5238975579f002c0199a3800ca44df> "Copies memory for 3D arrays."), [cuMemcpy3DAsync](<group__CUDA__MEM.html#group__CUDA__MEM_1g79f4f3fde6ae0f529568d881d9e11987> "Copies memory for 3D arrays."), [cuMemcpyAtoA](<group__CUDA__MEM.html#group__CUDA__MEM_1gf81b218c984a31436ec9e23a85fb604a> "Copies memory from Array to Array."), [cuMemcpyAtoD](<group__CUDA__MEM.html#group__CUDA__MEM_1g825b3f037f7f51382cae991bae8173fd> "Copies memory from Array to Device."), [cuMemcpyAtoH](<group__CUDA__MEM.html#group__CUDA__MEM_1gf7ad1edb2539cccc352c6b8b76f657f4> "Copies memory from Array to Host."), [cuMemcpyAtoHAsync](<group__CUDA__MEM.html#group__CUDA__MEM_1g64cbd2e60436699aebdd0bdbf14d0f01> "Copies memory from Array to Host."), [cuMemcpyDtoA](<group__CUDA__MEM.html#group__CUDA__MEM_1gad6827247af91600b56ce6e2ddb802e1> "Copies memory from Device to Array."), [cuMemcpyDtoD](<group__CUDA__MEM.html#group__CUDA__MEM_1g1725774abf8b51b91945f3336b778c8b> "Copies memory from Device to Device."), [cuMemcpyDtoDAsync](<group__CUDA__MEM.html#group__CUDA__MEM_1g39ea09ba682b8eccc9c3e0c04319b5c8> "Copies memory from Device to Device."), [cuMemcpyDtoH](<group__CUDA__MEM.html#group__CUDA__MEM_1g3480368ee0208a98f75019c9a8450893> "Copies memory from Device to Host."), [cuMemcpyDtoHAsync](<group__CUDA__MEM.html#group__CUDA__MEM_1g56f30236c7c5247f8e061b59d3268362> "Copies memory from Device to Host."), [cuMemcpyHtoA](<group__CUDA__MEM.html#group__CUDA__MEM_1g57d3d780d165ecc0e3b3ce08e141cd89> "Copies memory from Host to Array."), [cuMemcpyHtoAAsync](<group__CUDA__MEM.html#group__CUDA__MEM_1gb5c4863f64f132b4bc2661818b3fd188> "Copies memory from Host to Array."), [cuMemcpyHtoD](<group__CUDA__MEM.html#group__CUDA__MEM_1g4d32266788c440b0220b1a9ba5795169> "Copies memory from Host to Device."), [cuMemcpyHtoDAsync](<group__CUDA__MEM.html#group__CUDA__MEM_1g1572263fe2597d7ba4f6964597a354a3> "Copies memory from Host to Device."), [cuMemFree](<group__CUDA__MEM.html#group__CUDA__MEM_1g89b3f154e17cc89b6eea277dbdf5c93a> "Frees device memory."), [cuMemFreeHost](<group__CUDA__MEM.html#group__CUDA__MEM_1g62e0fdbe181dab6b1c90fa1a51c7b92c> "Frees page-locked host memory."), [cuMemGetAddressRange](<group__CUDA__MEM.html#group__CUDA__MEM_1g64fee5711274a2a0573a789c94d8299b> "Get information on memory allocations."), [cuMemGetInfo](<group__CUDA__MEM.html#group__CUDA__MEM_1g808f555540d0143a331cc42aa98835c0> "Gets free and total memory."), [cuMemHostAlloc](<group__CUDA__MEM.html#group__CUDA__MEM_1g572ca4011bfcb25034888a14d4e035b9> "Allocates page-locked host memory."), [cuMemHostGetDevicePointer](<group__CUDA__MEM.html#group__CUDA__MEM_1g57a39e5cba26af4d06be67fc77cc62f0> "Passes back device pointer of mapped pinned memory."), [cuMemsetD2D8](<group__CUDA__MEM.html#group__CUDA__MEM_1ge88b13e646e2be6ba0e0475ef5205974> "Initializes device memory."), [cuMemsetD2D8Async](<group__CUDA__MEM.html#group__CUDA__MEM_1g3f7b6924a3e49c3265b328f534102e97> "Sets device memory."), [cuMemsetD2D16](<group__CUDA__MEM.html#group__CUDA__MEM_1g7f561a15a66144fa9f6ab5350edc8a30> "Initializes device memory."), [cuMemsetD2D16Async](<group__CUDA__MEM.html#group__CUDA__MEM_1g64ee197befac3d74d9fefedcf6ef6b10> "Sets device memory."), [cuMemsetD2D32](<group__CUDA__MEM.html#group__CUDA__MEM_1g74b359b2d026bfeb7c795b5038d07523> "Initializes device memory."), [cuMemsetD2D32Async](<group__CUDA__MEM.html#group__CUDA__MEM_1g8a78d3147ac93fac955052c815d9ea3c> "Sets device memory."), [cuMemsetD8](<group__CUDA__MEM.html#group__CUDA__MEM_1g6e582bf866e9e2fb014297bfaf354d7b> "Initializes device memory."), [cuMemsetD8Async](<group__CUDA__MEM.html#group__CUDA__MEM_1gaef08a7ccd61112f94e82f2b30d43627> "Sets device memory."), [cuMemsetD16](<group__CUDA__MEM.html#group__CUDA__MEM_1g7d805e610054392a4d11e8a8bf5eb35c> "Initializes device memory."), [cuMemsetD16Async](<group__CUDA__MEM.html#group__CUDA__MEM_1gf731438877dd8ec875e4c43d848c878c> "Sets device memory."), [cuMemsetD32](<group__CUDA__MEM.html#group__CUDA__MEM_1g983e8d8759acd1b64326317481fbf132> "Initializes device memory."), [cudaMemsetAsync](<../cuda-runtime-api/group__CUDART__MEMORY.html#group__CUDART__MEMORY_1g7c9761e21d9f0999fd136c51e7b9b2a0>)

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuMemsetD8 ( [CUdeviceptr](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g183f7b0d8ad008ea2a5fd552537ace4e>)Â dstDevice, unsigned char Â uc, size_tÂ N )


Initializes device memory.

######  Parameters

`dstDevice`
    \- Destination device pointer
`uc`
    \- Value to set
`N`
    \- Number of elements

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_DEINITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9acf52f132faf29b473cdda6061f0f44a>), [CUDA_ERROR_NOT_INITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e98feb999f0af99b4a25ab26b3866f4df8>), [CUDA_ERROR_INVALID_CONTEXT](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a484e9af32c1e9893ff21f0e0191a12d>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>)

###### Description

Sets the memory range of `N` 8-bit values to the specified value `uc`.

Note:

  * Note that this function may also return error codes from previous, asynchronous launches.

  * See also [memset synchronization details](<api-sync-behavior.html#api-sync-behavior__memset>).


**See also:**

[cuArray3DCreate](<group__CUDA__MEM.html#group__CUDA__MEM_1gc2322c70b38c2984536c90ed118bb1d7> "Creates a 3D CUDA array."), [cuArray3DGetDescriptor](<group__CUDA__MEM.html#group__CUDA__MEM_1gb58549f2f3f390b9e0e7c8f3acd53857> "Get a 3D CUDA array descriptor."), [cuArrayCreate](<group__CUDA__MEM.html#group__CUDA__MEM_1g4192ff387a81c3bd5ed8c391ed62ca24> "Creates a 1D or 2D CUDA array."), [cuArrayDestroy](<group__CUDA__MEM.html#group__CUDA__MEM_1g982878affbbc023de84874faac838b0b> "Destroys a CUDA array."), [cuArrayGetDescriptor](<group__CUDA__MEM.html#group__CUDA__MEM_1g661fe823dbd37bf11f82a71bd4762acf> "Get a 1D or 2D CUDA array descriptor."), [cuMemAlloc](<group__CUDA__MEM.html#group__CUDA__MEM_1gb82d2a09844a58dd9e744dc31e8aa467> "Allocates device memory."), [cuMemAllocHost](<group__CUDA__MEM.html#group__CUDA__MEM_1gdd8311286d2c2691605362c689bc64e0> "Allocates page-locked host memory."), [cuMemAllocPitch](<group__CUDA__MEM.html#group__CUDA__MEM_1gcbe9b033f6c4de80f63cc6e58ed9a45a> "Allocates pitched device memory."), [cuMemcpy2D](<group__CUDA__MEM.html#group__CUDA__MEM_1g27f885b30c34cc20a663a671dbf6fc27> "Copies memory for 2D arrays."), [cuMemcpy2DAsync](<group__CUDA__MEM.html#group__CUDA__MEM_1g4acf155faeb969d9d21f5433d3d0f274> "Copies memory for 2D arrays."), [cuMemcpy2DUnaligned](<group__CUDA__MEM.html#group__CUDA__MEM_1g2fa285d47fd7020e596bfeab3deb651b> "Copies memory for 2D arrays."), [cuMemcpy3D](<group__CUDA__MEM.html#group__CUDA__MEM_1g4b5238975579f002c0199a3800ca44df> "Copies memory for 3D arrays."), [cuMemcpy3DAsync](<group__CUDA__MEM.html#group__CUDA__MEM_1g79f4f3fde6ae0f529568d881d9e11987> "Copies memory for 3D arrays."), [cuMemcpyAtoA](<group__CUDA__MEM.html#group__CUDA__MEM_1gf81b218c984a31436ec9e23a85fb604a> "Copies memory from Array to Array."), [cuMemcpyAtoD](<group__CUDA__MEM.html#group__CUDA__MEM_1g825b3f037f7f51382cae991bae8173fd> "Copies memory from Array to Device."), [cuMemcpyAtoH](<group__CUDA__MEM.html#group__CUDA__MEM_1gf7ad1edb2539cccc352c6b8b76f657f4> "Copies memory from Array to Host."), [cuMemcpyAtoHAsync](<group__CUDA__MEM.html#group__CUDA__MEM_1g64cbd2e60436699aebdd0bdbf14d0f01> "Copies memory from Array to Host."), [cuMemcpyDtoA](<group__CUDA__MEM.html#group__CUDA__MEM_1gad6827247af91600b56ce6e2ddb802e1> "Copies memory from Device to Array."), [cuMemcpyDtoD](<group__CUDA__MEM.html#group__CUDA__MEM_1g1725774abf8b51b91945f3336b778c8b> "Copies memory from Device to Device."), [cuMemcpyDtoDAsync](<group__CUDA__MEM.html#group__CUDA__MEM_1g39ea09ba682b8eccc9c3e0c04319b5c8> "Copies memory from Device to Device."), [cuMemcpyDtoH](<group__CUDA__MEM.html#group__CUDA__MEM_1g3480368ee0208a98f75019c9a8450893> "Copies memory from Device to Host."), [cuMemcpyDtoHAsync](<group__CUDA__MEM.html#group__CUDA__MEM_1g56f30236c7c5247f8e061b59d3268362> "Copies memory from Device to Host."), [cuMemcpyHtoA](<group__CUDA__MEM.html#group__CUDA__MEM_1g57d3d780d165ecc0e3b3ce08e141cd89> "Copies memory from Host to Array."), [cuMemcpyHtoAAsync](<group__CUDA__MEM.html#group__CUDA__MEM_1gb5c4863f64f132b4bc2661818b3fd188> "Copies memory from Host to Array."), [cuMemcpyHtoD](<group__CUDA__MEM.html#group__CUDA__MEM_1g4d32266788c440b0220b1a9ba5795169> "Copies memory from Host to Device."), [cuMemcpyHtoDAsync](<group__CUDA__MEM.html#group__CUDA__MEM_1g1572263fe2597d7ba4f6964597a354a3> "Copies memory from Host to Device."), [cuMemFree](<group__CUDA__MEM.html#group__CUDA__MEM_1g89b3f154e17cc89b6eea277dbdf5c93a> "Frees device memory."), [cuMemFreeHost](<group__CUDA__MEM.html#group__CUDA__MEM_1g62e0fdbe181dab6b1c90fa1a51c7b92c> "Frees page-locked host memory."), [cuMemGetAddressRange](<group__CUDA__MEM.html#group__CUDA__MEM_1g64fee5711274a2a0573a789c94d8299b> "Get information on memory allocations."), [cuMemGetInfo](<group__CUDA__MEM.html#group__CUDA__MEM_1g808f555540d0143a331cc42aa98835c0> "Gets free and total memory."), [cuMemHostAlloc](<group__CUDA__MEM.html#group__CUDA__MEM_1g572ca4011bfcb25034888a14d4e035b9> "Allocates page-locked host memory."), [cuMemHostGetDevicePointer](<group__CUDA__MEM.html#group__CUDA__MEM_1g57a39e5cba26af4d06be67fc77cc62f0> "Passes back device pointer of mapped pinned memory."), [cuMemsetD2D8](<group__CUDA__MEM.html#group__CUDA__MEM_1ge88b13e646e2be6ba0e0475ef5205974> "Initializes device memory."), [cuMemsetD2D8Async](<group__CUDA__MEM.html#group__CUDA__MEM_1g3f7b6924a3e49c3265b328f534102e97> "Sets device memory."), [cuMemsetD2D16](<group__CUDA__MEM.html#group__CUDA__MEM_1g7f561a15a66144fa9f6ab5350edc8a30> "Initializes device memory."), [cuMemsetD2D16Async](<group__CUDA__MEM.html#group__CUDA__MEM_1g64ee197befac3d74d9fefedcf6ef6b10> "Sets device memory."), [cuMemsetD2D32](<group__CUDA__MEM.html#group__CUDA__MEM_1g74b359b2d026bfeb7c795b5038d07523> "Initializes device memory."), [cuMemsetD2D32Async](<group__CUDA__MEM.html#group__CUDA__MEM_1g8a78d3147ac93fac955052c815d9ea3c> "Sets device memory."), [cuMemsetD8Async](<group__CUDA__MEM.html#group__CUDA__MEM_1gaef08a7ccd61112f94e82f2b30d43627> "Sets device memory."), [cuMemsetD16](<group__CUDA__MEM.html#group__CUDA__MEM_1g7d805e610054392a4d11e8a8bf5eb35c> "Initializes device memory."), [cuMemsetD16Async](<group__CUDA__MEM.html#group__CUDA__MEM_1gf731438877dd8ec875e4c43d848c878c> "Sets device memory."), [cuMemsetD32](<group__CUDA__MEM.html#group__CUDA__MEM_1g983e8d8759acd1b64326317481fbf132> "Initializes device memory."), [cuMemsetD32Async](<group__CUDA__MEM.html#group__CUDA__MEM_1g58229da5d30f1c0cdf667b320ec2c0f5> "Sets device memory."), [cudaMemset](<../cuda-runtime-api/group__CUDART__MEMORY.html#group__CUDART__MEMORY_1gf7338650f7683c51ee26aadc6973c63a>)

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuMemsetD8Async ( [CUdeviceptr](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g183f7b0d8ad008ea2a5fd552537ace4e>)Â dstDevice, unsigned char Â uc, size_tÂ N, [CUstream](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gb946c7f02e09efd788a204718015d88a>)Â hStream )


Sets device memory.

######  Parameters

`dstDevice`
    \- Destination device pointer
`uc`
    \- Value to set
`N`
    \- Number of elements
`hStream`
    \- Stream identifier

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_DEINITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9acf52f132faf29b473cdda6061f0f44a>), [CUDA_ERROR_NOT_INITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e98feb999f0af99b4a25ab26b3866f4df8>), [CUDA_ERROR_INVALID_CONTEXT](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a484e9af32c1e9893ff21f0e0191a12d>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>)

###### Description

Sets the memory range of `N` 8-bit values to the specified value `uc`.

Note:

  * Note that this function may also return error codes from previous, asynchronous launches.

  * See also [memset synchronization details](<api-sync-behavior.html#api-sync-behavior__memset>).

  * This function uses standard [default stream](<stream-sync-behavior.html#stream-sync-behavior__default-stream>) semantics.


**See also:**

[cuArray3DCreate](<group__CUDA__MEM.html#group__CUDA__MEM_1gc2322c70b38c2984536c90ed118bb1d7> "Creates a 3D CUDA array."), [cuArray3DGetDescriptor](<group__CUDA__MEM.html#group__CUDA__MEM_1gb58549f2f3f390b9e0e7c8f3acd53857> "Get a 3D CUDA array descriptor."), [cuArrayCreate](<group__CUDA__MEM.html#group__CUDA__MEM_1g4192ff387a81c3bd5ed8c391ed62ca24> "Creates a 1D or 2D CUDA array."), [cuArrayDestroy](<group__CUDA__MEM.html#group__CUDA__MEM_1g982878affbbc023de84874faac838b0b> "Destroys a CUDA array."), [cuArrayGetDescriptor](<group__CUDA__MEM.html#group__CUDA__MEM_1g661fe823dbd37bf11f82a71bd4762acf> "Get a 1D or 2D CUDA array descriptor."), [cuMemAlloc](<group__CUDA__MEM.html#group__CUDA__MEM_1gb82d2a09844a58dd9e744dc31e8aa467> "Allocates device memory."), [cuMemAllocHost](<group__CUDA__MEM.html#group__CUDA__MEM_1gdd8311286d2c2691605362c689bc64e0> "Allocates page-locked host memory."), [cuMemAllocPitch](<group__CUDA__MEM.html#group__CUDA__MEM_1gcbe9b033f6c4de80f63cc6e58ed9a45a> "Allocates pitched device memory."), [cuMemcpy2D](<group__CUDA__MEM.html#group__CUDA__MEM_1g27f885b30c34cc20a663a671dbf6fc27> "Copies memory for 2D arrays."), [cuMemcpy2DAsync](<group__CUDA__MEM.html#group__CUDA__MEM_1g4acf155faeb969d9d21f5433d3d0f274> "Copies memory for 2D arrays."), [cuMemcpy2DUnaligned](<group__CUDA__MEM.html#group__CUDA__MEM_1g2fa285d47fd7020e596bfeab3deb651b> "Copies memory for 2D arrays."), [cuMemcpy3D](<group__CUDA__MEM.html#group__CUDA__MEM_1g4b5238975579f002c0199a3800ca44df> "Copies memory for 3D arrays."), [cuMemcpy3DAsync](<group__CUDA__MEM.html#group__CUDA__MEM_1g79f4f3fde6ae0f529568d881d9e11987> "Copies memory for 3D arrays."), [cuMemcpyAtoA](<group__CUDA__MEM.html#group__CUDA__MEM_1gf81b218c984a31436ec9e23a85fb604a> "Copies memory from Array to Array."), [cuMemcpyAtoD](<group__CUDA__MEM.html#group__CUDA__MEM_1g825b3f037f7f51382cae991bae8173fd> "Copies memory from Array to Device."), [cuMemcpyAtoH](<group__CUDA__MEM.html#group__CUDA__MEM_1gf7ad1edb2539cccc352c6b8b76f657f4> "Copies memory from Array to Host."), [cuMemcpyAtoHAsync](<group__CUDA__MEM.html#group__CUDA__MEM_1g64cbd2e60436699aebdd0bdbf14d0f01> "Copies memory from Array to Host."), [cuMemcpyDtoA](<group__CUDA__MEM.html#group__CUDA__MEM_1gad6827247af91600b56ce6e2ddb802e1> "Copies memory from Device to Array."), [cuMemcpyDtoD](<group__CUDA__MEM.html#group__CUDA__MEM_1g1725774abf8b51b91945f3336b778c8b> "Copies memory from Device to Device."), [cuMemcpyDtoDAsync](<group__CUDA__MEM.html#group__CUDA__MEM_1g39ea09ba682b8eccc9c3e0c04319b5c8> "Copies memory from Device to Device."), [cuMemcpyDtoH](<group__CUDA__MEM.html#group__CUDA__MEM_1g3480368ee0208a98f75019c9a8450893> "Copies memory from Device to Host."), [cuMemcpyDtoHAsync](<group__CUDA__MEM.html#group__CUDA__MEM_1g56f30236c7c5247f8e061b59d3268362> "Copies memory from Device to Host."), [cuMemcpyHtoA](<group__CUDA__MEM.html#group__CUDA__MEM_1g57d3d780d165ecc0e3b3ce08e141cd89> "Copies memory from Host to Array."), [cuMemcpyHtoAAsync](<group__CUDA__MEM.html#group__CUDA__MEM_1gb5c4863f64f132b4bc2661818b3fd188> "Copies memory from Host to Array."), [cuMemcpyHtoD](<group__CUDA__MEM.html#group__CUDA__MEM_1g4d32266788c440b0220b1a9ba5795169> "Copies memory from Host to Device."), [cuMemcpyHtoDAsync](<group__CUDA__MEM.html#group__CUDA__MEM_1g1572263fe2597d7ba4f6964597a354a3> "Copies memory from Host to Device."), [cuMemFree](<group__CUDA__MEM.html#group__CUDA__MEM_1g89b3f154e17cc89b6eea277dbdf5c93a> "Frees device memory."), [cuMemFreeHost](<group__CUDA__MEM.html#group__CUDA__MEM_1g62e0fdbe181dab6b1c90fa1a51c7b92c> "Frees page-locked host memory."), [cuMemGetAddressRange](<group__CUDA__MEM.html#group__CUDA__MEM_1g64fee5711274a2a0573a789c94d8299b> "Get information on memory allocations."), [cuMemGetInfo](<group__CUDA__MEM.html#group__CUDA__MEM_1g808f555540d0143a331cc42aa98835c0> "Gets free and total memory."), [cuMemHostAlloc](<group__CUDA__MEM.html#group__CUDA__MEM_1g572ca4011bfcb25034888a14d4e035b9> "Allocates page-locked host memory."), [cuMemHostGetDevicePointer](<group__CUDA__MEM.html#group__CUDA__MEM_1g57a39e5cba26af4d06be67fc77cc62f0> "Passes back device pointer of mapped pinned memory."), [cuMemsetD2D8](<group__CUDA__MEM.html#group__CUDA__MEM_1ge88b13e646e2be6ba0e0475ef5205974> "Initializes device memory."), [cuMemsetD2D8Async](<group__CUDA__MEM.html#group__CUDA__MEM_1g3f7b6924a3e49c3265b328f534102e97> "Sets device memory."), [cuMemsetD2D16](<group__CUDA__MEM.html#group__CUDA__MEM_1g7f561a15a66144fa9f6ab5350edc8a30> "Initializes device memory."), [cuMemsetD2D16Async](<group__CUDA__MEM.html#group__CUDA__MEM_1g64ee197befac3d74d9fefedcf6ef6b10> "Sets device memory."), [cuMemsetD2D32](<group__CUDA__MEM.html#group__CUDA__MEM_1g74b359b2d026bfeb7c795b5038d07523> "Initializes device memory."), [cuMemsetD2D32Async](<group__CUDA__MEM.html#group__CUDA__MEM_1g8a78d3147ac93fac955052c815d9ea3c> "Sets device memory."), [cuMemsetD8](<group__CUDA__MEM.html#group__CUDA__MEM_1g6e582bf866e9e2fb014297bfaf354d7b> "Initializes device memory."), [cuMemsetD16](<group__CUDA__MEM.html#group__CUDA__MEM_1g7d805e610054392a4d11e8a8bf5eb35c> "Initializes device memory."), [cuMemsetD16Async](<group__CUDA__MEM.html#group__CUDA__MEM_1gf731438877dd8ec875e4c43d848c878c> "Sets device memory."), [cuMemsetD32](<group__CUDA__MEM.html#group__CUDA__MEM_1g983e8d8759acd1b64326317481fbf132> "Initializes device memory."), [cuMemsetD32Async](<group__CUDA__MEM.html#group__CUDA__MEM_1g58229da5d30f1c0cdf667b320ec2c0f5> "Sets device memory."), [cudaMemsetAsync](<../cuda-runtime-api/group__CUDART__MEMORY.html#group__CUDART__MEMORY_1g7c9761e21d9f0999fd136c51e7b9b2a0>)

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuMipmappedArrayCreate ( [CUmipmappedArray](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g96db856ab3d2940fb694ce4501d9b583>)*Â pHandle, const [CUDA_ARRAY3D_DESCRIPTOR](<structCUDA__ARRAY3D__DESCRIPTOR__v2.html#structCUDA__ARRAY3D__DESCRIPTOR__v2>)*Â pMipmappedArrayDesc, unsigned int Â numMipmapLevels )


Creates a CUDA mipmapped array.

######  Parameters

`pHandle`
    \- Returned mipmapped array
`pMipmappedArrayDesc`
    \- mipmapped array descriptor
`numMipmapLevels`
    \- Number of mipmap levels

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_DEINITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9acf52f132faf29b473cdda6061f0f44a>), [CUDA_ERROR_NOT_INITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e98feb999f0af99b4a25ab26b3866f4df8>), [CUDA_ERROR_INVALID_CONTEXT](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a484e9af32c1e9893ff21f0e0191a12d>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>), [CUDA_ERROR_OUT_OF_MEMORY](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9264c50688ed110e8476b591befe60c02>), [CUDA_ERROR_UNKNOWN](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9c5a6ab0245179d297f1fa56ed0097183>)

###### Description

Creates a CUDA mipmapped array according to the CUDA_ARRAY3D_DESCRIPTOR structure `pMipmappedArrayDesc` and returns a handle to the new CUDA mipmapped array in `*pHandle`. `numMipmapLevels` specifies the number of mipmap levels to be allocated. This value is clamped to the range [1, 1 + floor(log2(max(width, height, depth)))].

The CUDA_ARRAY3D_DESCRIPTOR is defined as:


    â    typedef struct {
                  unsigned int Width;
                  unsigned int Height;
                  unsigned int Depth;
                  [CUarray_format](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g9b009d9a6aa4c5765c8a00289b6068f9>) Format;
                  unsigned int NumChannels;
                  unsigned int Flags;
              } [CUDA_ARRAY3D_DESCRIPTOR](<structCUDA__ARRAY3D__DESCRIPTOR__v2.html#structCUDA__ARRAY3D__DESCRIPTOR__v2>);

where:

  * `Width`, `Height`, and `Depth` are the width, height, and depth of the CUDA array (in elements); the following types of CUDA arrays can be allocated:
    * A 1D mipmapped array is allocated if `Height` and `Depth` extents are both zero.

    * A 2D mipmapped array is allocated if only `Depth` extent is zero.

    * A 3D mipmapped array is allocated if all three extents are non-zero.

    * A 1D layered CUDA mipmapped array is allocated if only `Height` is zero and the [CUDA_ARRAY3D_LAYERED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ge4adf555c51852623a3dea962ab8ee85>) flag is set. Each layer is a 1D array. The number of layers is determined by the depth extent.

    * A 2D layered CUDA mipmapped array is allocated if all three extents are non-zero and the [CUDA_ARRAY3D_LAYERED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ge4adf555c51852623a3dea962ab8ee85>) flag is set. Each layer is a 2D array. The number of layers is determined by the depth extent.

    * A cubemap CUDA mipmapped array is allocated if all three extents are non-zero and the [CUDA_ARRAY3D_CUBEMAP](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gfce9ad9aa3df839571b84b47febfb7ae>) flag is set. `Width` must be equal to `Height`, and `Depth` must be six. A cubemap is a special type of 2D layered CUDA array, where the six layers represent the six faces of a cube. The order of the six layers in memory is the same as that listed in [CUarray_cubemap_face](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g012fda14b50e7db8798a340627c4c330>).

    * A cubemap layered CUDA mipmapped array is allocated if all three extents are non-zero, and both, [CUDA_ARRAY3D_CUBEMAP](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gfce9ad9aa3df839571b84b47febfb7ae>) and [CUDA_ARRAY3D_LAYERED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ge4adf555c51852623a3dea962ab8ee85>) flags are set. `Width` must be equal to `Height`, and `Depth` must be a multiple of six. A cubemap layered CUDA array is a special type of 2D layered CUDA array that consists of a collection of cubemaps. The first six layers represent the first cubemap, the next six layers form the second cubemap, and so on.


  * Format specifies the format of the elements; [CUarray_format](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g9b009d9a6aa4c5765c8a00289b6068f9>) is defined as:

        â    typedef enum CUarray_format_enum {
                      [CU_AD_FORMAT_UNSIGNED_INT8](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg9b009d9a6aa4c5765c8a00289b6068f9e0af5f5a0ffa8e16a5c720364ccd5dac>) = 0x01,
                      [CU_AD_FORMAT_UNSIGNED_INT16](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg9b009d9a6aa4c5765c8a00289b6068f9d0f11e851e891af6f204cf05503ba525>) = 0x02,
                      [CU_AD_FORMAT_UNSIGNED_INT32](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg9b009d9a6aa4c5765c8a00289b6068f952b891ad5d4080db0fb2e23fe71614a0>) = 0x03,
                      [CU_AD_FORMAT_SIGNED_INT8](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg9b009d9a6aa4c5765c8a00289b6068f9376b799ee12ce9e1de0c34cfa7839284>) = 0x08,
                      [CU_AD_FORMAT_SIGNED_INT16](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg9b009d9a6aa4c5765c8a00289b6068f980864598b1579bd90fab79369072478f>) = 0x09,
                      [CU_AD_FORMAT_SIGNED_INT32](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg9b009d9a6aa4c5765c8a00289b6068f96db055c31d053bd1d5ebbaa98de2bad3>) = 0x0a,
                      [CU_AD_FORMAT_HALF](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg9b009d9a6aa4c5765c8a00289b6068f995c97289b540ff36334722ec745f53a3>) = 0x10,
                      [CU_AD_FORMAT_FLOAT](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg9b009d9a6aa4c5765c8a00289b6068f98140f3b0de3d87bdbf26964c24840f3c>) = 0x20,
                      [CU_AD_FORMAT_NV12](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg9b009d9a6aa4c5765c8a00289b6068f964889c93ccc518395eb985203735d40c>) = 0xb0,
                      [CU_AD_FORMAT_UNORM_INT8X1](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg9b009d9a6aa4c5765c8a00289b6068f90dcb720ef3238f279ebd5a7eb7284137>) = 0xc0,
                      [CU_AD_FORMAT_UNORM_INT8X2](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg9b009d9a6aa4c5765c8a00289b6068f9e23c25eb679dd70676bd35b26041d21f>) = 0xc1,
                      [CU_AD_FORMAT_UNORM_INT8X4](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg9b009d9a6aa4c5765c8a00289b6068f939e6604652c4f7dfda35ef89bcf6a1c4>) = 0xc2,
                      [CU_AD_FORMAT_UNORM_INT16X1](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg9b009d9a6aa4c5765c8a00289b6068f9a593cb744213ab457d4ebaa261879816>) = 0xc3,
                      [CU_AD_FORMAT_UNORM_INT16X2](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg9b009d9a6aa4c5765c8a00289b6068f9fe334f0b162fd9ad3caad37a8c879d95>) = 0xc4,
                      [CU_AD_FORMAT_UNORM_INT16X4](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg9b009d9a6aa4c5765c8a00289b6068f965401cdeebbc53f7b02400ba14f940a4>) = 0xc5,
                      [CU_AD_FORMAT_SNORM_INT8X1](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg9b009d9a6aa4c5765c8a00289b6068f9f92943f83ded303df264a79ee11d1db0>) = 0xc6,
                      [CU_AD_FORMAT_SNORM_INT8X2](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg9b009d9a6aa4c5765c8a00289b6068f9b8194990a6e17d78be0de66deffdf02f>) = 0xc7,
                      [CU_AD_FORMAT_SNORM_INT8X4](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg9b009d9a6aa4c5765c8a00289b6068f9117a2e043203748187605ff8a71c2d1d>) = 0xc8,
                      [CU_AD_FORMAT_SNORM_INT16X1](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg9b009d9a6aa4c5765c8a00289b6068f95026e5e8783752bf8d3601dd4dbceb4c>) = 0xc9,
                      [CU_AD_FORMAT_SNORM_INT16X2](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg9b009d9a6aa4c5765c8a00289b6068f939f633274a07dbce442325c5d90bf294>) = 0xca,
                      [CU_AD_FORMAT_SNORM_INT16X4](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg9b009d9a6aa4c5765c8a00289b6068f99acc19038dc1e68170e485f739912d49>) = 0xcb,
                      [CU_AD_FORMAT_BC1_UNORM](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg9b009d9a6aa4c5765c8a00289b6068f9299d155257aa3c0b75634d9f9b1bfa72>) = 0x91,
                      [CU_AD_FORMAT_BC1_UNORM_SRGB](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg9b009d9a6aa4c5765c8a00289b6068f9afa18b300eb91ff879532a55d5aa191b>) = 0x92,
                      [CU_AD_FORMAT_BC2_UNORM](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg9b009d9a6aa4c5765c8a00289b6068f92b9cf00f8c6012ec679654c9f012a267>) = 0x93,
                      [CU_AD_FORMAT_BC2_UNORM_SRGB](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg9b009d9a6aa4c5765c8a00289b6068f9c38b5af7926b020202562d67ba7529c2>) = 0x94,
                      [CU_AD_FORMAT_BC3_UNORM](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg9b009d9a6aa4c5765c8a00289b6068f9b8473614347359cc74574899e2e65012>) = 0x95,
                      [CU_AD_FORMAT_BC3_UNORM_SRGB](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg9b009d9a6aa4c5765c8a00289b6068f94d158239dd6c825b4bd383ed66625257>) = 0x96,
                      [CU_AD_FORMAT_BC4_UNORM](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg9b009d9a6aa4c5765c8a00289b6068f9fe7527dfa2576595eea7463a1140058c>) = 0x97,
                      [CU_AD_FORMAT_BC4_SNORM](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg9b009d9a6aa4c5765c8a00289b6068f90627520c6fc707d63e9d3c66d307eec6>) = 0x98,
                      [CU_AD_FORMAT_BC5_UNORM](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg9b009d9a6aa4c5765c8a00289b6068f94b524073942ab7460b68a98da955e59e>) = 0x99,
                      [CU_AD_FORMAT_BC5_SNORM](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg9b009d9a6aa4c5765c8a00289b6068f907466b7b5b3d897a58fac1e9d2db163e>) = 0x9a,
                      [CU_AD_FORMAT_BC6H_UF16](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg9b009d9a6aa4c5765c8a00289b6068f94085af463b118d564873b8d275ac7912>) = 0x9b,
                      [CU_AD_FORMAT_BC6H_SF16](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg9b009d9a6aa4c5765c8a00289b6068f938c1d137a2663d5ddca5ae6aa49f612e>) = 0x9c,
                      [CU_AD_FORMAT_BC7_UNORM](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg9b009d9a6aa4c5765c8a00289b6068f9f03f9cbeee0911d3c77c08e6f5c7ff62>) = 0x9d,
                      [CU_AD_FORMAT_BC7_UNORM_SRGB](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg9b009d9a6aa4c5765c8a00289b6068f9ad5b0e1cd964cbd46270223f35651677>) = 0x9e,
                      [CU_AD_FORMAT_P010](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg9b009d9a6aa4c5765c8a00289b6068f9f0efd5417115904eb086f1df0046582e>) = 0x9f,
                      [CU_AD_FORMAT_P016](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg9b009d9a6aa4c5765c8a00289b6068f9b8511f36d0a010b8846c84309d8920d5>) = 0xa1,
                      [CU_AD_FORMAT_NV16](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg9b009d9a6aa4c5765c8a00289b6068f9e41b4351cb805f35130636b0aafca609>) = 0xa2,
                      [CU_AD_FORMAT_P210](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg9b009d9a6aa4c5765c8a00289b6068f9dc77f21be8b4ff4f23dcd450c3656409>) = 0xa3,
                      [CU_AD_FORMAT_P216](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg9b009d9a6aa4c5765c8a00289b6068f9a42b3a04e2f30a93e50d7d68026f1ba9>) = 0xa4,
                      [CU_AD_FORMAT_YUY2](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg9b009d9a6aa4c5765c8a00289b6068f961f757ee5f5c125b7be70e5b562826dc>) = 0xa5,
                      [CU_AD_FORMAT_Y210](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg9b009d9a6aa4c5765c8a00289b6068f9796d73bbcb63216f7dd4cc4d8016b74c>) = 0xa6,
                      [CU_AD_FORMAT_Y216](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg9b009d9a6aa4c5765c8a00289b6068f9c2081981924fa204383f1ee05de74d8e>) = 0xa7,
                      [CU_AD_FORMAT_AYUV](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg9b009d9a6aa4c5765c8a00289b6068f99dd6d4cac84e541d2b1ad34b263bc1bc>) = 0xa8,
                      [CU_AD_FORMAT_Y410](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg9b009d9a6aa4c5765c8a00289b6068f91917374a5915ee6a5e1ed23c57f43b75>) = 0xa9,
                      [CU_AD_FORMAT_Y416](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg9b009d9a6aa4c5765c8a00289b6068f941bdcafb69e249176af2e1cc5d6178be>) = 0xb1,
                      [CU_AD_FORMAT_Y444_PLANAR8](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg9b009d9a6aa4c5765c8a00289b6068f93af0d614c7c240194c402b6ca9b4909f>) = 0xb2,
                      [CU_AD_FORMAT_Y444_PLANAR10](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg9b009d9a6aa4c5765c8a00289b6068f916b3c04a1fba1562d548d4504f06a7aa>) = 0xb3,
                      [CU_AD_FORMAT_YUV444_8bit_SemiPlanar](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg9b009d9a6aa4c5765c8a00289b6068f945b7c15d0c8a42d569b20509e7e54e1d>) = 0xb4,
                      [CU_AD_FORMAT_YUV444_16bit_SemiPlanar](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg9b009d9a6aa4c5765c8a00289b6068f9cb653da3339b76b267a6fa8085513017>) = 0xb5,
                      [CU_AD_FORMAT_UNORM_INT_101010_2](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg9b009d9a6aa4c5765c8a00289b6068f93b3828154e807c69a6e0c7e0d54d31ea>) = 0x50,
                      [CU_AD_FORMAT_UINT8_PACKED_422](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg9b009d9a6aa4c5765c8a00289b6068f9c3e98982827e44204ed4a4d41031c135>) = 0x51,
                      [CU_AD_FORMAT_UINT8_PACKED_444](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg9b009d9a6aa4c5765c8a00289b6068f90cb5a5812940939b5f0eb0242a2146e7>) = 0x52,
                      [CU_AD_FORMAT_UINT8_SEMIPLANAR_420](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg9b009d9a6aa4c5765c8a00289b6068f9f212e89e226ee1d69ca4a47fba3c39c3>) = 0x53,
                      [CU_AD_FORMAT_UINT16_SEMIPLANAR_420](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg9b009d9a6aa4c5765c8a00289b6068f9e076ab1291241ef4c6c149b23321e1b5>) = 0x54,
                      [CU_AD_FORMAT_UINT8_SEMIPLANAR_422](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg9b009d9a6aa4c5765c8a00289b6068f959c089e74d94f90973118ef287d4f352>) = 0x55,
                      [CU_AD_FORMAT_UINT16_SEMIPLANAR_422](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg9b009d9a6aa4c5765c8a00289b6068f97f759c17c105bfa6fb486502fad3705e>) = 0x56,
                      [CU_AD_FORMAT_UINT8_SEMIPLANAR_444](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg9b009d9a6aa4c5765c8a00289b6068f90548d7ee27a7f9401064a4d3b3dfc528>) = 0x57,
                      [CU_AD_FORMAT_UINT16_SEMIPLANAR_444](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg9b009d9a6aa4c5765c8a00289b6068f90a4038e90a78ae9bf495d043c39a9e29>) = 0x58,
                      [CU_AD_FORMAT_UINT8_PLANAR_420](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg9b009d9a6aa4c5765c8a00289b6068f9d0f3182f705a6615ac5299de395cace8>) = 0x59,
                      [CU_AD_FORMAT_UINT16_PLANAR_420](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg9b009d9a6aa4c5765c8a00289b6068f97a9888731c72732a6880a18ef2f082cb>) = 0x5a,
                      [CU_AD_FORMAT_UINT8_PLANAR_422](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg9b009d9a6aa4c5765c8a00289b6068f932bb01870f63cd2d9949ccb2ea235ef1>) = 0x5b,
                      [CU_AD_FORMAT_UINT16_PLANAR_422](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg9b009d9a6aa4c5765c8a00289b6068f97a9a4abfb8ce20c04ddb47925cdf3752>) = 0x5c,
                      [CU_AD_FORMAT_UINT8_PLANAR_444](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg9b009d9a6aa4c5765c8a00289b6068f9922d032a80ac1229a05dae35c18c4b2e>) = 0x5d,
                      [CU_AD_FORMAT_UINT16_PLANAR_444](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg9b009d9a6aa4c5765c8a00289b6068f98ff25a5b7ff451a608b2ecca340b1f71>) = 0x5e,
                  } [CUarray_format](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g9b009d9a6aa4c5765c8a00289b6068f9>);


  * `NumChannels` specifies the number of packed components per CUDA array element; it may be 1, 2, or 4;


  * Flags may be set to
    * [CUDA_ARRAY3D_LAYERED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ge4adf555c51852623a3dea962ab8ee85>) to enable creation of layered CUDA mipmapped arrays. If this flag is set, `Depth` specifies the number of layers, not the depth of a 3D array.

    * [CUDA_ARRAY3D_SURFACE_LDST](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g7287c43cacf1ed05865d6bcad1a23cd9>) to enable surface references to be bound to individual mipmap levels of the CUDA mipmapped array. If this flag is not set, [cuSurfRefSetArray](<group__CUDA__SURFREF__DEPRECATED.html#group__CUDA__SURFREF__DEPRECATED_1g68abcde159fa897b1dfb23387926dd66> "Sets the CUDA array for a surface reference.") will fail when attempting to bind a mipmap level of the CUDA mipmapped array to a surface reference.

    * [CUDA_ARRAY3D_CUBEMAP](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gfce9ad9aa3df839571b84b47febfb7ae>) to enable creation of mipmapped cubemaps. If this flag is set, `Width` must be equal to `Height`, and `Depth` must be six. If the [CUDA_ARRAY3D_LAYERED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ge4adf555c51852623a3dea962ab8ee85>) flag is also set, then `Depth` must be a multiple of six.

    * [CUDA_ARRAY3D_TEXTURE_GATHER](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g0c929c92a91f4d9f9f49bae0131a6ccf>) to indicate that the CUDA mipmapped array will be used for texture gather. Texture gather can only be performed on 2D CUDA mipmapped arrays.


`Width`, `Height` and `Depth` must meet certain size requirements as listed in the following table. All values are specified in elements. Note that for brevity's sake, the full name of the device attribute is not specified. For ex., TEXTURE1D_MIPMAPPED_WIDTH refers to the device attribute [CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE1D_MIPMAPPED_WIDTH](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gge12b8a782bebe21b1ac0091bf9f4e2a373cf80abc3969a6a6a9be1b9f36d7f18>).

**CUDA array type** |  **Valid extents that must always be met {(width range in elements), (height range), (depth range)}** |  **Valid extents with CUDA_ARRAY3D_SURFACE_LDST set {(width range in elements), (height range), (depth range)}**
---|---|---
1D  |  { (1,TEXTURE1D_MIPMAPPED_WIDTH), 0, 0 }  |  { (1,SURFACE1D_WIDTH), 0, 0 }
2D  |  { (1,TEXTURE2D_MIPMAPPED_WIDTH), (1,TEXTURE2D_MIPMAPPED_HEIGHT), 0 }  |  { (1,SURFACE2D_WIDTH), (1,SURFACE2D_HEIGHT), 0 }
3D  |  { (1,TEXTURE3D_WIDTH), (1,TEXTURE3D_HEIGHT), (1,TEXTURE3D_DEPTH) } OR { (1,TEXTURE3D_WIDTH_ALTERNATE), (1,TEXTURE3D_HEIGHT_ALTERNATE), (1,TEXTURE3D_DEPTH_ALTERNATE) }  |  { (1,SURFACE3D_WIDTH), (1,SURFACE3D_HEIGHT), (1,SURFACE3D_DEPTH) }
1D Layered  |  { (1,TEXTURE1D_LAYERED_WIDTH), 0, (1,TEXTURE1D_LAYERED_LAYERS) }  |  { (1,SURFACE1D_LAYERED_WIDTH), 0, (1,SURFACE1D_LAYERED_LAYERS) }
2D Layered  |  { (1,TEXTURE2D_LAYERED_WIDTH), (1,TEXTURE2D_LAYERED_HEIGHT), (1,TEXTURE2D_LAYERED_LAYERS) }  |  { (1,SURFACE2D_LAYERED_WIDTH), (1,SURFACE2D_LAYERED_HEIGHT), (1,SURFACE2D_LAYERED_LAYERS) }
Cubemap  |  { (1,TEXTURECUBEMAP_WIDTH), (1,TEXTURECUBEMAP_WIDTH), 6 }  |  { (1,SURFACECUBEMAP_WIDTH), (1,SURFACECUBEMAP_WIDTH), 6 }
Cubemap Layered  |  { (1,TEXTURECUBEMAP_LAYERED_WIDTH), (1,TEXTURECUBEMAP_LAYERED_WIDTH), (1,TEXTURECUBEMAP_LAYERED_LAYERS) }  |  { (1,SURFACECUBEMAP_LAYERED_WIDTH), (1,SURFACECUBEMAP_LAYERED_WIDTH), (1,SURFACECUBEMAP_LAYERED_LAYERS) }

Note:

Note that this function may also return error codes from previous, asynchronous launches.

**See also:**

[cuMipmappedArrayDestroy](<group__CUDA__MEM.html#group__CUDA__MEM_1ge0d7c768b6a6963c4d4bde5bbc74f0ad> "Destroys a CUDA mipmapped array."), [cuMipmappedArrayGetLevel](<group__CUDA__MEM.html#group__CUDA__MEM_1g82f276659f05be14820e99346b0f86b7> "Gets a mipmap level of a CUDA mipmapped array."), [cuArrayCreate](<group__CUDA__MEM.html#group__CUDA__MEM_1g4192ff387a81c3bd5ed8c391ed62ca24> "Creates a 1D or 2D CUDA array."), [cudaMallocMipmappedArray](<../cuda-runtime-api/group__CUDART__MEMORY.html#group__CUDART__MEMORY_1g9abd550dd3f655473d2640dc85be9774>)

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuMipmappedArrayDestroy ( [CUmipmappedArray](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g96db856ab3d2940fb694ce4501d9b583>)Â hMipmappedArray )


Destroys a CUDA mipmapped array.

######  Parameters

`hMipmappedArray`
    \- Mipmapped array to destroy

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_DEINITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9acf52f132faf29b473cdda6061f0f44a>), [CUDA_ERROR_NOT_INITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e98feb999f0af99b4a25ab26b3866f4df8>), [CUDA_ERROR_INVALID_CONTEXT](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a484e9af32c1e9893ff21f0e0191a12d>), [CUDA_ERROR_INVALID_HANDLE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e90fd2e63260c6317ba943af0f7e4b8d21>), [CUDA_ERROR_ARRAY_IS_MAPPED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9b668b10d56232c51b67db40516cc6b5b>), [CUDA_ERROR_CONTEXT_IS_DESTROYED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9b27ac43f7ce8446f5c9636dd73fb2139>)

###### Description

Destroys the CUDA mipmapped array `hMipmappedArray`.

Note:

Note that this function may also return error codes from previous, asynchronous launches.

**See also:**

[cuMipmappedArrayCreate](<group__CUDA__MEM.html#group__CUDA__MEM_1ga5d2e311c7f9b0bc6d130af824a40bd3> "Creates a CUDA mipmapped array."), [cuMipmappedArrayGetLevel](<group__CUDA__MEM.html#group__CUDA__MEM_1g82f276659f05be14820e99346b0f86b7> "Gets a mipmap level of a CUDA mipmapped array."), [cuArrayCreate](<group__CUDA__MEM.html#group__CUDA__MEM_1g4192ff387a81c3bd5ed8c391ed62ca24> "Creates a 1D or 2D CUDA array."), [cudaFreeMipmappedArray](<../cuda-runtime-api/group__CUDART__MEMORY.html#group__CUDART__MEMORY_1g904669241eac5bdbfb410eb4124e4924>)

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuMipmappedArrayGetLevel ( [CUarray](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gd550651524a56766b60f10f0e7628042>)*Â pLevelArray, [CUmipmappedArray](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g96db856ab3d2940fb694ce4501d9b583>)Â hMipmappedArray, unsigned int Â level )


Gets a mipmap level of a CUDA mipmapped array.

######  Parameters

`pLevelArray`
    \- Returned mipmap level CUDA array
`hMipmappedArray`
    \- CUDA mipmapped array
`level`
    \- Mipmap level

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_DEINITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9acf52f132faf29b473cdda6061f0f44a>), [CUDA_ERROR_NOT_INITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e98feb999f0af99b4a25ab26b3866f4df8>), [CUDA_ERROR_INVALID_CONTEXT](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a484e9af32c1e9893ff21f0e0191a12d>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>), [CUDA_ERROR_INVALID_HANDLE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e90fd2e63260c6317ba943af0f7e4b8d21>)

###### Description

Returns in `*pLevelArray` a CUDA array that represents a single mipmap level of the CUDA mipmapped array `hMipmappedArray`.

If `level` is greater than the maximum number of levels in this mipmapped array, [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>) is returned.

Note:

Note that this function may also return error codes from previous, asynchronous launches.

**See also:**

[cuMipmappedArrayCreate](<group__CUDA__MEM.html#group__CUDA__MEM_1ga5d2e311c7f9b0bc6d130af824a40bd3> "Creates a CUDA mipmapped array."), [cuMipmappedArrayDestroy](<group__CUDA__MEM.html#group__CUDA__MEM_1ge0d7c768b6a6963c4d4bde5bbc74f0ad> "Destroys a CUDA mipmapped array."), [cuArrayCreate](<group__CUDA__MEM.html#group__CUDA__MEM_1g4192ff387a81c3bd5ed8c391ed62ca24> "Creates a 1D or 2D CUDA array."), [cudaGetMipmappedArrayLevel](<../cuda-runtime-api/group__CUDART__MEMORY.html#group__CUDART__MEMORY_1g7086e6f81e6dda1ddf4cdb6c1764094a>)

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuMipmappedArrayGetMemoryRequirements ( [CUDA_ARRAY_MEMORY_REQUIREMENTS](<structCUDA__ARRAY__MEMORY__REQUIREMENTS__v1.html#structCUDA__ARRAY__MEMORY__REQUIREMENTS__v1>)*Â memoryRequirements, [CUmipmappedArray](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g96db856ab3d2940fb694ce4501d9b583>)Â mipmap, [CUdevice](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g41ca2a24a242b36ef2ca77330b5fb72a>)Â device )


Returns the memory requirements of a CUDA mipmapped array.

######  Parameters

`memoryRequirements`
    \- Pointer to CUDA_ARRAY_MEMORY_REQUIREMENTS
`mipmap`
    \- CUDA mipmapped array to get the memory requirements of
`device`
    \- Device to get the memory requirements for

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>)[CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>)

###### Description

Returns the memory requirements of a CUDA mipmapped array in `memoryRequirements` If the CUDA mipmapped array is not allocated with flag [CUDA_ARRAY3D_DEFERRED_MAPPING](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g854c29dbc47d04a4e42863cb87487d55>)[CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>) will be returned.

The returned value in [CUDA_ARRAY_MEMORY_REQUIREMENTS::size](<structCUDA__ARRAY__MEMORY__REQUIREMENTS__v1.html#structCUDA__ARRAY__MEMORY__REQUIREMENTS__v1_17a2851735a1d2c11af797f01b1d4969e>) represents the total size of the CUDA mipmapped array. The returned value in [CUDA_ARRAY_MEMORY_REQUIREMENTS::alignment](<structCUDA__ARRAY__MEMORY__REQUIREMENTS__v1.html#structCUDA__ARRAY__MEMORY__REQUIREMENTS__v1_135c6c8106451b6313d1dffe9a28af755>) represents the alignment necessary for mapping the CUDA mipmapped array.

**See also:**

[cuArrayGetMemoryRequirements](<group__CUDA__MEM.html#group__CUDA__MEM_1gac8761ced0fa462e4762f6528073d9f4> "Returns the memory requirements of a CUDA array."), [cuMemMapArrayAsync](<group__CUDA__VA.html#group__CUDA__VA_1g5dc41a62a9feb68f2e943b438c83e5ab> "Maps or unmaps subregions of sparse CUDA arrays and sparse CUDA mipmapped arrays.")

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuMipmappedArrayGetSparseProperties ( [CUDA_ARRAY_SPARSE_PROPERTIES](<structCUDA__ARRAY__SPARSE__PROPERTIES__v1.html#structCUDA__ARRAY__SPARSE__PROPERTIES__v1>)*Â sparseProperties, [CUmipmappedArray](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g96db856ab3d2940fb694ce4501d9b583>)Â mipmap )


Returns the layout properties of a sparse CUDA mipmapped array.

######  Parameters

`sparseProperties`
    \- Pointer to CUDA_ARRAY_SPARSE_PROPERTIES
`mipmap`
    \- CUDA mipmapped array to get the sparse properties of

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>)[CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>)

###### Description

Returns the sparse array layout properties in `sparseProperties` If the CUDA mipmapped array is not allocated with flag [CUDA_ARRAY3D_SPARSE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g8e13c9d3ef98d1f3dce95901a115abc2>)[CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>) will be returned.

For non-layered CUDA mipmapped arrays, [CUDA_ARRAY_SPARSE_PROPERTIES::miptailSize](<structCUDA__ARRAY__SPARSE__PROPERTIES__v1.html#structCUDA__ARRAY__SPARSE__PROPERTIES__v1_1895ecb42681678271b0edba05bf1dcd9>) returns the size of the mip tail region. The mip tail region includes all mip levels whose width, height or depth is less than that of the tile. For layered CUDA mipmapped arrays, if [CUDA_ARRAY_SPARSE_PROPERTIES::flags](<structCUDA__ARRAY__SPARSE__PROPERTIES__v1.html#structCUDA__ARRAY__SPARSE__PROPERTIES__v1_10e842bb64091fa47809112c700cb5f0a>) contains [CU_ARRAY_SPARSE_PROPERTIES_SINGLE_MIPTAIL](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g0dcf4ba7e64caa5c1aa4e88caa7f659a>), then [CUDA_ARRAY_SPARSE_PROPERTIES::miptailSize](<structCUDA__ARRAY__SPARSE__PROPERTIES__v1.html#structCUDA__ARRAY__SPARSE__PROPERTIES__v1_1895ecb42681678271b0edba05bf1dcd9>) specifies the size of the mip tail of all layers combined. Otherwise, [CUDA_ARRAY_SPARSE_PROPERTIES::miptailSize](<structCUDA__ARRAY__SPARSE__PROPERTIES__v1.html#structCUDA__ARRAY__SPARSE__PROPERTIES__v1_1895ecb42681678271b0edba05bf1dcd9>) specifies mip tail size per layer. The returned value of [CUDA_ARRAY_SPARSE_PROPERTIES::miptailFirstLevel](<structCUDA__ARRAY__SPARSE__PROPERTIES__v1.html#structCUDA__ARRAY__SPARSE__PROPERTIES__v1_1edd0cca8fad1fcbb1789d537edd7e6b6>) is valid only if [CUDA_ARRAY_SPARSE_PROPERTIES::miptailSize](<structCUDA__ARRAY__SPARSE__PROPERTIES__v1.html#structCUDA__ARRAY__SPARSE__PROPERTIES__v1_1895ecb42681678271b0edba05bf1dcd9>) is non-zero.

**See also:**

[cuArrayGetSparseProperties](<group__CUDA__MEM.html#group__CUDA__MEM_1gf74df88a07404ee051f0e5b36647d8c7> "Returns the layout properties of a sparse CUDA array."), [cuMemMapArrayAsync](<group__CUDA__VA.html#group__CUDA__VA_1g5dc41a62a9feb68f2e943b438c83e5ab> "Maps or unmaps subregions of sparse CUDA arrays and sparse CUDA mipmapped arrays.")

* * *


---

# Virtual Memory Management

## 6.14.Â Virtual Memory Management

This section describes the virtual memory management functions of the low-level CUDA driver application programming interface.

### Functions

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuMemAddressFree](<#group__CUDA__VA_1g6993ecea2ea03e1b802b8255edc2da5b>) ( [CUdeviceptr](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g183f7b0d8ad008ea2a5fd552537ace4e>)Â ptr, size_tÂ size )
     Free an address range reservation.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuMemAddressReserve](<#group__CUDA__VA_1ge489256c107df2a07ddf96d80c86cd9b>) ( [CUdeviceptr](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g183f7b0d8ad008ea2a5fd552537ace4e>)*Â ptr, size_tÂ size, size_tÂ alignment, [CUdeviceptr](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g183f7b0d8ad008ea2a5fd552537ace4e>)Â addr, unsigned long longÂ flags )
     Allocate an address range reservation.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuMemCreate](<#group__CUDA__VA_1g899d69a862bba36449789c64b430dc7c>) ( CUmemGenericAllocationHandle*Â handle, size_tÂ size, const [CUmemAllocationProp](<structCUmemAllocationProp__v1.html#structCUmemAllocationProp__v1>)*Â prop, unsigned long longÂ flags )
     Create a CUDA memory handle representing a memory allocation of a given size described by the given properties.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuMemExportToShareableHandle](<#group__CUDA__VA_1g633f273b155815f23c1d70e7d9384c56>) ( void*Â shareableHandle, CUmemGenericAllocationHandleÂ handle, [CUmemAllocationHandleType](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g450a23153d86fce0afe30e25d63caef9>)Â handleType, unsigned long longÂ flags )
     Exports an allocation to a requested shareable handle type.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuMemGetAccess](<#group__CUDA__VA_1g4b5627b4f2d3972d0b62cc4ba1931125>) ( unsigned long long*Â flags, const [CUmemLocation](<structCUmemLocation__v1.html#structCUmemLocation__v1>)*Â location, [CUdeviceptr](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g183f7b0d8ad008ea2a5fd552537ace4e>)Â ptr )
     Get the access `flags` set for the given `location` and `ptr`.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuMemGetAllocationGranularity](<#group__CUDA__VA_1g30ee906c2cf66a0347b3dfec3d7eb31a>) ( size_t*Â granularity, const [CUmemAllocationProp](<structCUmemAllocationProp__v1.html#structCUmemAllocationProp__v1>)*Â prop, [CUmemAllocationGranularity_flags](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g3a202e4d32ae296db1af7efe75ce365d>)Â option )
     Calculates either the minimal or recommended granularity.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuMemGetAllocationPropertiesFromHandle](<#group__CUDA__VA_1gc1c4c812caba5a21401c2cb4ab4512b1>) ( [CUmemAllocationProp](<structCUmemAllocationProp__v1.html#structCUmemAllocationProp__v1>)*Â prop, CUmemGenericAllocationHandleÂ handle )
     Retrieve the contents of the property structure defining properties for this handle.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuMemImportFromShareableHandle](<#group__CUDA__VA_1g1577822cc83ea896b4892f2d69630463>) ( CUmemGenericAllocationHandle*Â handle, void*Â osHandle, [CUmemAllocationHandleType](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g450a23153d86fce0afe30e25d63caef9>)Â shHandleType )
     Imports an allocation from a requested shareable handle type.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuMemMap](<#group__CUDA__VA_1gff1d395423af5c5c75375516959dae56>) ( [CUdeviceptr](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g183f7b0d8ad008ea2a5fd552537ace4e>)Â ptr, size_tÂ size, size_tÂ offset, CUmemGenericAllocationHandleÂ handle, unsigned long longÂ flags )
     Maps an allocation handle to a reserved virtual address range.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuMemMapArrayAsync](<#group__CUDA__VA_1g5dc41a62a9feb68f2e943b438c83e5ab>) ( [CUarrayMapInfo](<structCUarrayMapInfo__v1.html#structCUarrayMapInfo__v1>)*Â mapInfoList, unsigned int Â count, [CUstream](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gb946c7f02e09efd788a204718015d88a>)Â hStream )
     Maps or unmaps subregions of sparse CUDA arrays and sparse CUDA mipmapped arrays.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuMemRelease](<#group__CUDA__VA_1g3014f0759f43a8d82db951b8e4b91d68>) ( CUmemGenericAllocationHandleÂ handle )
     Release a memory handle representing a memory allocation which was previously allocated through cuMemCreate.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuMemRetainAllocationHandle](<#group__CUDA__VA_1g1ddca5437c502782155f95bf98e775c6>) ( CUmemGenericAllocationHandle*Â handle, void*Â addr )
     Given an address `addr`, returns the allocation handle of the backing memory allocation.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuMemSetAccess](<#group__CUDA__VA_1g1b6b12b10e8324bf462ecab4e7ef30e1>) ( [CUdeviceptr](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g183f7b0d8ad008ea2a5fd552537ace4e>)Â ptr, size_tÂ size, const [CUmemAccessDesc](<structCUmemAccessDesc__v1.html#structCUmemAccessDesc__v1>)*Â desc, size_tÂ count )
     Set the access flags for each location specified in `desc` for the given virtual address range.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuMemUnmap](<#group__CUDA__VA_1gfb50aac00c848fd7087e858f59bf7e2a>) ( [CUdeviceptr](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g183f7b0d8ad008ea2a5fd552537ace4e>)Â ptr, size_tÂ size )
     Unmap the backing memory of a given address range.

### Functions

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuMemAddressFree ( [CUdeviceptr](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g183f7b0d8ad008ea2a5fd552537ace4e>)Â ptr, size_tÂ size )


Free an address range reservation.

######  Parameters

`ptr`
    \- Starting address of the virtual address range to free
`size`
    \- Size of the virtual address region to free

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>), [CUDA_ERROR_NOT_INITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e98feb999f0af99b4a25ab26b3866f4df8>), [CUDA_ERROR_DEINITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9acf52f132faf29b473cdda6061f0f44a>), [CUDA_ERROR_NOT_PERMITTED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9e23d0197c490ec332a43e55b167968a3>), [CUDA_ERROR_NOT_SUPPORTED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e954756ae7ade0dfd09faeccb513dd831b>)

###### Description

Frees a virtual address range reserved by cuMemAddressReserve. The size must match what was given to memAddressReserve and the ptr given must match what was returned from memAddressReserve.

**See also:**

[cuMemAddressReserve](<group__CUDA__VA.html#group__CUDA__VA_1ge489256c107df2a07ddf96d80c86cd9b> "Allocate an address range reservation.")

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuMemAddressReserve ( [CUdeviceptr](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g183f7b0d8ad008ea2a5fd552537ace4e>)*Â ptr, size_tÂ size, size_tÂ alignment, [CUdeviceptr](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g183f7b0d8ad008ea2a5fd552537ace4e>)Â addr, unsigned long longÂ flags )


Allocate an address range reservation.

######  Parameters

`ptr`
    \- Resulting pointer to start of virtual address range allocated
`size`
    \- Size of the reserved virtual address range requested
`alignment`
    \- Alignment of the reserved virtual address range requested
`addr`
    \- Hint address for the start of the address range
`flags`
    \- Currently unused, must be zero

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>), [CUDA_ERROR_OUT_OF_MEMORY](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9264c50688ed110e8476b591befe60c02>), [CUDA_ERROR_NOT_INITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e98feb999f0af99b4a25ab26b3866f4df8>), [CUDA_ERROR_DEINITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9acf52f132faf29b473cdda6061f0f44a>), [CUDA_ERROR_NOT_PERMITTED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9e23d0197c490ec332a43e55b167968a3>), [CUDA_ERROR_NOT_SUPPORTED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e954756ae7ade0dfd09faeccb513dd831b>)

###### Description

Reserves a virtual address range based on the given parameters, giving the starting address of the range in `ptr`. This API requires a system that supports UVA. The size and address parameters must be a multiple of the host page size and the alignment must be a power of two or zero for default alignment. If `addr` is 0, then the driver chooses the address at which to place the start of the reservation whereas when it is non-zero then the driver treats it as a hint about where to place the reservation.

**See also:**

[cuMemAddressFree](<group__CUDA__VA.html#group__CUDA__VA_1g6993ecea2ea03e1b802b8255edc2da5b> "Free an address range reservation.")

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuMemCreate ( CUmemGenericAllocationHandle*Â handle, size_tÂ size, const [CUmemAllocationProp](<structCUmemAllocationProp__v1.html#structCUmemAllocationProp__v1>)*Â prop, unsigned long longÂ flags )


Create a CUDA memory handle representing a memory allocation of a given size described by the given properties.

######  Parameters

`handle`
    \- Value of handle returned. All operations on this allocation are to be performed using this handle.
`size`
    \- Size of the allocation requested
`prop`
    \- Properties of the allocation to create.
`flags`
    \- flags for future use, must be zero now.

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>), [CUDA_ERROR_OUT_OF_MEMORY](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9264c50688ed110e8476b591befe60c02>), [CUDA_ERROR_INVALID_DEVICE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e96f047e7215788ca96c81af92a04bfb6c>), [CUDA_ERROR_NOT_INITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e98feb999f0af99b4a25ab26b3866f4df8>), [CUDA_ERROR_DEINITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9acf52f132faf29b473cdda6061f0f44a>), [CUDA_ERROR_NOT_PERMITTED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9e23d0197c490ec332a43e55b167968a3>), [CUDA_ERROR_NOT_SUPPORTED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e954756ae7ade0dfd09faeccb513dd831b>)

###### Description

This creates a memory allocation on the target device specified through the `prop` structure. The created allocation will not have any device or host mappings. The generic memory `handle` for the allocation can be mapped to the address space of calling process via [cuMemMap](<group__CUDA__VA.html#group__CUDA__VA_1gff1d395423af5c5c75375516959dae56> "Maps an allocation handle to a reserved virtual address range."). This handle cannot be transmitted directly to other processes (see [cuMemExportToShareableHandle](<group__CUDA__VA.html#group__CUDA__VA_1g633f273b155815f23c1d70e7d9384c56> "Exports an allocation to a requested shareable handle type.")). On Windows, the caller must also pass an LPSECURITYATTRIBUTE in `prop` to be associated with this handle which limits or allows access to this handle for a recipient process (see [CUmemAllocationProp::win32HandleMetaData](<structCUmemAllocationProp__v1.html#structCUmemAllocationProp__v1_1542262ad88e1d00f02b306c641270168>) for more). The `size` of this allocation must be a multiple of the the value given via [cuMemGetAllocationGranularity](<group__CUDA__VA.html#group__CUDA__VA_1g30ee906c2cf66a0347b3dfec3d7eb31a> "Calculates either the minimal or recommended granularity.") with the [CU_MEM_ALLOC_GRANULARITY_MINIMUM](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg3a202e4d32ae296db1af7efe75ce365dc74872d07341bb1ac24ccc4a1c9c2f56>) flag. To create a CPU allocation that doesn't target any specific NUMA nodes, applications must set CUmemAllocationProp::CUmemLocation::type to [CU_MEM_LOCATION_TYPE_HOST](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg75cfd5b9fa5c1c6ee2be2547bfbe882e46800776121a71c8dc2904518a21065a>). CUmemAllocationProp::CUmemLocation::id is ignored for HOST allocations. HOST allocations are not IPC capable and [CUmemAllocationProp::requestedHandleTypes](<structCUmemAllocationProp__v1.html#structCUmemAllocationProp__v1_1e2e852e72e5d2053b771fbac49495efd>) must be 0, any other value will result in [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>). To create a CPU allocation targeting a specific host NUMA node, applications must set CUmemAllocationProp::CUmemLocation::type to [CU_MEM_LOCATION_TYPE_HOST_NUMA](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg75cfd5b9fa5c1c6ee2be2547bfbe882eb61a1d3409ed83a43b5706cc004ac861>) and CUmemAllocationProp::CUmemLocation::id must specify the NUMA ID of the CPU. On systems where NUMA is not available CUmemAllocationProp::CUmemLocation::id must be set to 0. Specifying [CU_MEM_LOCATION_TYPE_HOST_NUMA_CURRENT](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg75cfd5b9fa5c1c6ee2be2547bfbe882e55b82116b2124510a1a3b6c52096daaa>) as the [CUmemLocation::type](<structCUmemLocation__v1.html#structCUmemLocation__v1_1a34fc29f2a55d501f00f912d92152d1b>) will result in [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>).

Applications that intend to use [CU_MEM_HANDLE_TYPE_FABRIC](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg450a23153d86fce0afe30e25d63caef9e38a182adb450da6c1a3f29cd5dca032>) based memory sharing must ensure: (1) `nvidia-caps-imex-channels` character device is created by the driver and is listed under /proc/devices (2) have at least one IMEX channel file accessible by the user launching the application.

When exporter and importer CUDA processes have been granted access to the same IMEX channel, they can securely share memory.

The IMEX channel security model works on a per user basis. Which means all processes under a user can share memory if the user has access to a valid IMEX channel. When multi-user isolation is desired, a separate IMEX channel is required for each user.

These channel files exist in /dev/nvidia-caps-imex-channels/channel* and can be created using standard OS native calls like mknod on Linux. For example: To create channel0 with the major number from /proc/devices users can execute the following command: `mknod /dev/nvidia-caps-imex-channels/channel0 c <major number>=""> 0`

If CUmemAllocationProp::allocFlags::usage contains [CU_MEM_CREATE_USAGE_TILE_POOL](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gb445d91d9773d728b1a9962184c05799>) flag then the memory allocation is intended only to be used as backing tile pool for sparse CUDA arrays and sparse CUDA mipmapped arrays. (see [cuMemMapArrayAsync](<group__CUDA__VA.html#group__CUDA__VA_1g5dc41a62a9feb68f2e943b438c83e5ab> "Maps or unmaps subregions of sparse CUDA arrays and sparse CUDA mipmapped arrays.")).

Note:

Note that this function may also return error codes from previous, asynchronous launches.

**See also:**

[cuMemRelease](<group__CUDA__VA.html#group__CUDA__VA_1g3014f0759f43a8d82db951b8e4b91d68> "Release a memory handle representing a memory allocation which was previously allocated through cuMemCreate."), [cuMemExportToShareableHandle](<group__CUDA__VA.html#group__CUDA__VA_1g633f273b155815f23c1d70e7d9384c56> "Exports an allocation to a requested shareable handle type."), [cuMemImportFromShareableHandle](<group__CUDA__VA.html#group__CUDA__VA_1g1577822cc83ea896b4892f2d69630463> "Imports an allocation from a requested shareable handle type.")

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuMemExportToShareableHandle ( void*Â shareableHandle, CUmemGenericAllocationHandleÂ handle, [CUmemAllocationHandleType](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g450a23153d86fce0afe30e25d63caef9>)Â handleType, unsigned long longÂ flags )


Exports an allocation to a requested shareable handle type.

######  Parameters

`shareableHandle`
    \- Pointer to the location in which to store the requested handle type
`handle`
    \- CUDA handle for the memory allocation
`handleType`
    \- Type of shareable handle requested (defines type and size of the `shareableHandle` output parameter)
`flags`
    \- Reserved, must be zero

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>), [CUDA_ERROR_NOT_INITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e98feb999f0af99b4a25ab26b3866f4df8>), [CUDA_ERROR_DEINITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9acf52f132faf29b473cdda6061f0f44a>), [CUDA_ERROR_NOT_PERMITTED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9e23d0197c490ec332a43e55b167968a3>), [CUDA_ERROR_NOT_SUPPORTED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e954756ae7ade0dfd09faeccb513dd831b>)

###### Description

Given a CUDA memory handle, create a shareable memory allocation handle that can be used to share the memory with other processes. The recipient process can convert the shareable handle back into a CUDA memory handle using [cuMemImportFromShareableHandle](<group__CUDA__VA.html#group__CUDA__VA_1g1577822cc83ea896b4892f2d69630463> "Imports an allocation from a requested shareable handle type.") and map it with [cuMemMap](<group__CUDA__VA.html#group__CUDA__VA_1gff1d395423af5c5c75375516959dae56> "Maps an allocation handle to a reserved virtual address range."). The implementation of what this handle is and how it can be transferred is defined by the requested handle type in `handleType`

Once all shareable handles are closed and the allocation is released, the allocated memory referenced will be released back to the OS and uses of the CUDA handle afterward will lead to undefined behavior.

This API can also be used in conjunction with other APIs (e.g. Vulkan, OpenGL) that support importing memory from the shareable type

**See also:**

[cuMemImportFromShareableHandle](<group__CUDA__VA.html#group__CUDA__VA_1g1577822cc83ea896b4892f2d69630463> "Imports an allocation from a requested shareable handle type.")

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuMemGetAccess ( unsigned long long*Â flags, const [CUmemLocation](<structCUmemLocation__v1.html#structCUmemLocation__v1>)*Â location, [CUdeviceptr](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g183f7b0d8ad008ea2a5fd552537ace4e>)Â ptr )


Get the access `flags` set for the given `location` and `ptr`.

######  Parameters

`flags`
    \- Flags set for this location
`location`
    \- Location in which to check the flags for
`ptr`
    \- Address in which to check the access flags for

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>), [CUDA_ERROR_INVALID_DEVICE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e96f047e7215788ca96c81af92a04bfb6c>), [CUDA_ERROR_NOT_INITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e98feb999f0af99b4a25ab26b3866f4df8>), [CUDA_ERROR_DEINITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9acf52f132faf29b473cdda6061f0f44a>), [CUDA_ERROR_NOT_PERMITTED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9e23d0197c490ec332a43e55b167968a3>), [CUDA_ERROR_NOT_SUPPORTED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e954756ae7ade0dfd09faeccb513dd831b>)

###### Description

**See also:**

[cuMemSetAccess](<group__CUDA__VA.html#group__CUDA__VA_1g1b6b12b10e8324bf462ecab4e7ef30e1> "Set the access flags for each location specified in desc for the given virtual address range.")

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuMemGetAllocationGranularity ( size_t*Â granularity, const [CUmemAllocationProp](<structCUmemAllocationProp__v1.html#structCUmemAllocationProp__v1>)*Â prop, [CUmemAllocationGranularity_flags](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g3a202e4d32ae296db1af7efe75ce365d>)Â option )


Calculates either the minimal or recommended granularity.

######  Parameters

`granularity`
    Returned granularity.
`prop`
    Property for which to determine the granularity for
`option`
    Determines which granularity to return

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>), [CUDA_ERROR_NOT_INITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e98feb999f0af99b4a25ab26b3866f4df8>), [CUDA_ERROR_DEINITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9acf52f132faf29b473cdda6061f0f44a>), [CUDA_ERROR_NOT_PERMITTED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9e23d0197c490ec332a43e55b167968a3>), [CUDA_ERROR_NOT_SUPPORTED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e954756ae7ade0dfd09faeccb513dd831b>)

###### Description

Calculates either the minimal or recommended granularity for a given allocation specification and returns it in granularity. This granularity can be used as a multiple for alignment, size, or address mapping.

**See also:**

[cuMemCreate](<group__CUDA__VA.html#group__CUDA__VA_1g899d69a862bba36449789c64b430dc7c> "Create a CUDA memory handle representing a memory allocation of a given size described by the given properties."), [cuMemMap](<group__CUDA__VA.html#group__CUDA__VA_1gff1d395423af5c5c75375516959dae56> "Maps an allocation handle to a reserved virtual address range.")

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuMemGetAllocationPropertiesFromHandle ( [CUmemAllocationProp](<structCUmemAllocationProp__v1.html#structCUmemAllocationProp__v1>)*Â prop, CUmemGenericAllocationHandleÂ handle )


Retrieve the contents of the property structure defining properties for this handle.

######  Parameters

`prop`
    \- Pointer to a properties structure which will hold the information about this handle
`handle`
    \- Handle which to perform the query on

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>), [CUDA_ERROR_NOT_INITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e98feb999f0af99b4a25ab26b3866f4df8>), [CUDA_ERROR_DEINITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9acf52f132faf29b473cdda6061f0f44a>), [CUDA_ERROR_NOT_PERMITTED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9e23d0197c490ec332a43e55b167968a3>), [CUDA_ERROR_NOT_SUPPORTED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e954756ae7ade0dfd09faeccb513dd831b>)

###### Description

**See also:**

[cuMemCreate](<group__CUDA__VA.html#group__CUDA__VA_1g899d69a862bba36449789c64b430dc7c> "Create a CUDA memory handle representing a memory allocation of a given size described by the given properties."), [cuMemImportFromShareableHandle](<group__CUDA__VA.html#group__CUDA__VA_1g1577822cc83ea896b4892f2d69630463> "Imports an allocation from a requested shareable handle type.")

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuMemImportFromShareableHandle ( CUmemGenericAllocationHandle*Â handle, void*Â osHandle, [CUmemAllocationHandleType](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g450a23153d86fce0afe30e25d63caef9>)Â shHandleType )


Imports an allocation from a requested shareable handle type.

######  Parameters

`handle`
    \- CUDA Memory handle for the memory allocation.
`osHandle`
    \- Shareable Handle representing the memory allocation that is to be imported.
`shHandleType`
    \- handle type of the exported handle [CUmemAllocationHandleType](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g450a23153d86fce0afe30e25d63caef9>).

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>), [CUDA_ERROR_NOT_INITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e98feb999f0af99b4a25ab26b3866f4df8>), [CUDA_ERROR_DEINITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9acf52f132faf29b473cdda6061f0f44a>), [CUDA_ERROR_NOT_PERMITTED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9e23d0197c490ec332a43e55b167968a3>), [CUDA_ERROR_NOT_SUPPORTED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e954756ae7ade0dfd09faeccb513dd831b>)

###### Description

If the current process cannot support the memory described by this shareable handle, this API will error as [CUDA_ERROR_NOT_SUPPORTED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e954756ae7ade0dfd09faeccb513dd831b>).

If `shHandleType` is [CU_MEM_HANDLE_TYPE_FABRIC](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg450a23153d86fce0afe30e25d63caef9e38a182adb450da6c1a3f29cd5dca032>) and the importer process has not been granted access to the same IMEX channel as the exporter process, this API will error as [CUDA_ERROR_NOT_PERMITTED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9e23d0197c490ec332a43e55b167968a3>).

Note:

Importing shareable handles exported from some graphics APIs(VUlkan, OpenGL, etc) created on devices under an SLI group may not be supported, and thus this API will return CUDA_ERROR_NOT_SUPPORTED. There is no guarantee that the contents of `handle` will be the same CUDA memory handle for the same given OS shareable handle, or the same underlying allocation.

**See also:**

[cuMemExportToShareableHandle](<group__CUDA__VA.html#group__CUDA__VA_1g633f273b155815f23c1d70e7d9384c56> "Exports an allocation to a requested shareable handle type."), [cuMemMap](<group__CUDA__VA.html#group__CUDA__VA_1gff1d395423af5c5c75375516959dae56> "Maps an allocation handle to a reserved virtual address range."), [cuMemRelease](<group__CUDA__VA.html#group__CUDA__VA_1g3014f0759f43a8d82db951b8e4b91d68> "Release a memory handle representing a memory allocation which was previously allocated through cuMemCreate.")

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuMemMap ( [CUdeviceptr](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g183f7b0d8ad008ea2a5fd552537ace4e>)Â ptr, size_tÂ size, size_tÂ offset, CUmemGenericAllocationHandleÂ handle, unsigned long longÂ flags )


Maps an allocation handle to a reserved virtual address range.

######  Parameters

`ptr`
    \- Address where memory will be mapped.
`size`
    \- Size of the memory mapping.
`offset`
    \- Offset into the memory represented by

  * `handle` from which to start mapping
  * Note: currently must be zero.


`handle`
    \- Handle to a shareable memory
`flags`
    \- flags for future use, must be zero now.

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>), [CUDA_ERROR_INVALID_DEVICE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e96f047e7215788ca96c81af92a04bfb6c>), [CUDA_ERROR_OUT_OF_MEMORY](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9264c50688ed110e8476b591befe60c02>), [CUDA_ERROR_NOT_INITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e98feb999f0af99b4a25ab26b3866f4df8>), [CUDA_ERROR_DEINITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9acf52f132faf29b473cdda6061f0f44a>), [CUDA_ERROR_NOT_PERMITTED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9e23d0197c490ec332a43e55b167968a3>), [CUDA_ERROR_NOT_SUPPORTED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e954756ae7ade0dfd09faeccb513dd831b>), [CUDA_ERROR_ILLEGAL_STATE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9f5fd9c15b97a258f341bab23b0b505a5>)

###### Description

Maps bytes of memory represented by `handle` starting from byte `offset` to `size` to address range [`addr`, `addr` \+ `size`]. This range must be an address reservation previously reserved with [cuMemAddressReserve](<group__CUDA__VA.html#group__CUDA__VA_1ge489256c107df2a07ddf96d80c86cd9b> "Allocate an address range reservation."), and `offset` \+ `size` must be less than the size of the memory allocation. Both `ptr`, `size`, and `offset` must be a multiple of the value given via [cuMemGetAllocationGranularity](<group__CUDA__VA.html#group__CUDA__VA_1g30ee906c2cf66a0347b3dfec3d7eb31a> "Calculates either the minimal or recommended granularity.") with the [CU_MEM_ALLOC_GRANULARITY_MINIMUM](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg3a202e4d32ae296db1af7efe75ce365dc74872d07341bb1ac24ccc4a1c9c2f56>) flag. If `handle` represents a multicast object, `ptr`, `size` and `offset` must be aligned to the value returned by [cuMulticastGetGranularity](<group__CUDA__MULTICAST.html#group__CUDA__MULTICAST_1g067a02ad98f4e01f149011f523fec547> "Calculates either the minimal or recommended granularity for multicast object.") with the flag CU_MULTICAST_MINIMUM_GRANULARITY. For best performance however, it is recommended that `ptr`, `size` and `offset` be aligned to the value returned by [cuMulticastGetGranularity](<group__CUDA__MULTICAST.html#group__CUDA__MULTICAST_1g067a02ad98f4e01f149011f523fec547> "Calculates either the minimal or recommended granularity for multicast object.") with the flag CU_MULTICAST_RECOMMENDED_GRANULARITY.

When `handle` represents a multicast object, this call may return CUDA_ERROR_ILLEGAL_STATE if the system configuration is in an illegal state. In such cases, to continue using multicast, verify that the system configuration is in a valid state and all required driver daemons are running properly.

Please note calling [cuMemMap](<group__CUDA__VA.html#group__CUDA__VA_1gff1d395423af5c5c75375516959dae56> "Maps an allocation handle to a reserved virtual address range.") does not make the address accessible, the caller needs to update accessibility of a contiguous mapped VA range by calling [cuMemSetAccess](<group__CUDA__VA.html#group__CUDA__VA_1g1b6b12b10e8324bf462ecab4e7ef30e1> "Set the access flags for each location specified in desc for the given virtual address range.").

Once a recipient process obtains a shareable memory handle from [cuMemImportFromShareableHandle](<group__CUDA__VA.html#group__CUDA__VA_1g1577822cc83ea896b4892f2d69630463> "Imports an allocation from a requested shareable handle type."), the process must use [cuMemMap](<group__CUDA__VA.html#group__CUDA__VA_1gff1d395423af5c5c75375516959dae56> "Maps an allocation handle to a reserved virtual address range.") to map the memory into its address ranges before setting accessibility with [cuMemSetAccess](<group__CUDA__VA.html#group__CUDA__VA_1g1b6b12b10e8324bf462ecab4e7ef30e1> "Set the access flags for each location specified in desc for the given virtual address range.").

[cuMemMap](<group__CUDA__VA.html#group__CUDA__VA_1gff1d395423af5c5c75375516959dae56> "Maps an allocation handle to a reserved virtual address range.") can only create mappings on VA range reservations that are not currently mapped.

Note:

Note that this function may also return error codes from previous, asynchronous launches.

**See also:**

[cuMemUnmap](<group__CUDA__VA.html#group__CUDA__VA_1gfb50aac00c848fd7087e858f59bf7e2a> "Unmap the backing memory of a given address range."), [cuMemSetAccess](<group__CUDA__VA.html#group__CUDA__VA_1g1b6b12b10e8324bf462ecab4e7ef30e1> "Set the access flags for each location specified in desc for the given virtual address range."), [cuMemCreate](<group__CUDA__VA.html#group__CUDA__VA_1g899d69a862bba36449789c64b430dc7c> "Create a CUDA memory handle representing a memory allocation of a given size described by the given properties."), [cuMemAddressReserve](<group__CUDA__VA.html#group__CUDA__VA_1ge489256c107df2a07ddf96d80c86cd9b> "Allocate an address range reservation."), [cuMemImportFromShareableHandle](<group__CUDA__VA.html#group__CUDA__VA_1g1577822cc83ea896b4892f2d69630463> "Imports an allocation from a requested shareable handle type.")

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuMemMapArrayAsync ( [CUarrayMapInfo](<structCUarrayMapInfo__v1.html#structCUarrayMapInfo__v1>)*Â mapInfoList, unsigned int Â count, [CUstream](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gb946c7f02e09efd788a204718015d88a>)Â hStream )


Maps or unmaps subregions of sparse CUDA arrays and sparse CUDA mipmapped arrays.

######  Parameters

`mapInfoList`
    \- List of CUarrayMapInfo
`count`
    \- Count of CUarrayMapInfo in `mapInfoList`
`hStream`
    \- Stream identifier for the stream to use for map or unmap operations

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>), [CUDA_ERROR_INVALID_HANDLE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e90fd2e63260c6317ba943af0f7e4b8d21>)

###### Description

Performs map or unmap operations on subregions of sparse CUDA arrays and sparse CUDA mipmapped arrays. Each operation is specified by a CUarrayMapInfo entry in the `mapInfoList` array of size `count`. The structure CUarrayMapInfo is defined as follow:


    â     typedef struct CUarrayMapInfo_st {
                  [CUresourcetype](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g9f0a76c9f6be437e75c8310aea5280f6>) resourceType;
                  union {
                      [CUmipmappedArray](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g96db856ab3d2940fb694ce4501d9b583>) mipmap;
                      [CUarray](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gd550651524a56766b60f10f0e7628042>) array;
                  } resource;

                  [CUarraySparseSubresourceType](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gb7f440dccee1200001e4b14f53785d0a>) subresourceType;
                  union {
                      struct {
                          unsigned int level;
                          unsigned int layer;
                          unsigned int offsetX;
                          unsigned int offsetY;
                          unsigned int offsetZ;
                          unsigned int extentWidth;
                          unsigned int extentHeight;
                          unsigned int extentDepth;
                      } sparseLevel;
                      struct {
                          unsigned int layer;
                          unsigned long long offset;
                          unsigned long long size;
                      } miptail;
                  } subresource;

                  [CUmemOperationType](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ge7469bd2e035fc9c937e84490fdcd349>) memOperationType;

                  [CUmemHandleType](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g31a65081da1729d11a1d6f5a433d93b0>) memHandleType;
                  union {
                      CUmemGenericAllocationHandle memHandle;
                  } memHandle;

                  unsigned long long offset;
                  unsigned int deviceBitMask;
                  unsigned int flags;
                  unsigned int reserved[2];
              } [CUarrayMapInfo](<structCUarrayMapInfo__v1.html#structCUarrayMapInfo__v1>);

where [CUarrayMapInfo::resourceType](<structCUarrayMapInfo__v1.html#structCUarrayMapInfo__v1_18cf3c7ba97c834ab8b0fcfb50fec578c>) specifies the type of resource to be operated on. If [CUarrayMapInfo::resourceType](<structCUarrayMapInfo__v1.html#structCUarrayMapInfo__v1_18cf3c7ba97c834ab8b0fcfb50fec578c>) is set to [CUresourcetype::CU_RESOURCE_TYPE_ARRAY](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg9f0a76c9f6be437e75c8310aea5280f68171f299e8447a926051e13d613d77b1>) then CUarrayMapInfo::resource::array must be set to a valid sparse CUDA array handle. The CUDA array must be either a 2D, 2D layered or 3D CUDA array and must have been allocated using [cuArrayCreate](<group__CUDA__MEM.html#group__CUDA__MEM_1g4192ff387a81c3bd5ed8c391ed62ca24> "Creates a 1D or 2D CUDA array.") or [cuArray3DCreate](<group__CUDA__MEM.html#group__CUDA__MEM_1gc2322c70b38c2984536c90ed118bb1d7> "Creates a 3D CUDA array.") with the flag [CUDA_ARRAY3D_SPARSE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g8e13c9d3ef98d1f3dce95901a115abc2>) or [CUDA_ARRAY3D_DEFERRED_MAPPING](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g854c29dbc47d04a4e42863cb87487d55>). For CUDA arrays obtained using [cuMipmappedArrayGetLevel](<group__CUDA__MEM.html#group__CUDA__MEM_1g82f276659f05be14820e99346b0f86b7> "Gets a mipmap level of a CUDA mipmapped array."), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>) will be returned. If [CUarrayMapInfo::resourceType](<structCUarrayMapInfo__v1.html#structCUarrayMapInfo__v1_18cf3c7ba97c834ab8b0fcfb50fec578c>) is set to [CUresourcetype::CU_RESOURCE_TYPE_MIPMAPPED_ARRAY](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg9f0a76c9f6be437e75c8310aea5280f642868e220af0309016ec733e37db7f24>) then CUarrayMapInfo::resource::mipmap must be set to a valid sparse CUDA mipmapped array handle. The CUDA mipmapped array must be either a 2D, 2D layered or 3D CUDA mipmapped array and must have been allocated using [cuMipmappedArrayCreate](<group__CUDA__MEM.html#group__CUDA__MEM_1ga5d2e311c7f9b0bc6d130af824a40bd3> "Creates a CUDA mipmapped array.") with the flag [CUDA_ARRAY3D_SPARSE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g8e13c9d3ef98d1f3dce95901a115abc2>) or [CUDA_ARRAY3D_DEFERRED_MAPPING](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g854c29dbc47d04a4e42863cb87487d55>).

[CUarrayMapInfo::subresourceType](<structCUarrayMapInfo__v1.html#structCUarrayMapInfo__v1_17a2fe272bd8e44af2386f1c20c3d3c68>) specifies the type of subresource within the resource. CUarraySparseSubresourceType_enum is defined as:


    â    typedef enum CUarraySparseSubresourceType_enum {
                  CU_ARRAY_SPARSE_SUBRESOURCE_TYPE_SPARSE_LEVEL = 0,
                  CU_ARRAY_SPARSE_SUBRESOURCE_TYPE_MIPTAIL = 1
              } [CUarraySparseSubresourceType](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gb7f440dccee1200001e4b14f53785d0a>);

where CUarraySparseSubresourceType::CU_ARRAY_SPARSE_SUBRESOURCE_TYPE_SPARSE_LEVEL indicates a sparse-miplevel which spans at least one tile in every dimension. The remaining miplevels which are too small to span at least one tile in any dimension constitute the mip tail region as indicated by CUarraySparseSubresourceType::CU_ARRAY_SPARSE_SUBRESOURCE_TYPE_MIPTAIL subresource type.

If [CUarrayMapInfo::subresourceType](<structCUarrayMapInfo__v1.html#structCUarrayMapInfo__v1_17a2fe272bd8e44af2386f1c20c3d3c68>) is set to CUarraySparseSubresourceType::CU_ARRAY_SPARSE_SUBRESOURCE_TYPE_SPARSE_LEVEL then CUarrayMapInfo::subresource::sparseLevel struct must contain valid array subregion offsets and extents. The CUarrayMapInfo::subresource::sparseLevel::offsetX, CUarrayMapInfo::subresource::sparseLevel::offsetY and CUarrayMapInfo::subresource::sparseLevel::offsetZ must specify valid X, Y and Z offsets respectively. The CUarrayMapInfo::subresource::sparseLevel::extentWidth, CUarrayMapInfo::subresource::sparseLevel::extentHeight and CUarrayMapInfo::subresource::sparseLevel::extentDepth must specify valid width, height and depth extents respectively. These offsets and extents must be aligned to the corresponding tile dimension. For CUDA mipmapped arrays CUarrayMapInfo::subresource::sparseLevel::level must specify a valid mip level index. Otherwise, must be zero. For layered CUDA arrays and layered CUDA mipmapped arrays CUarrayMapInfo::subresource::sparseLevel::layer must specify a valid layer index. Otherwise, must be zero. CUarrayMapInfo::subresource::sparseLevel::offsetZ must be zero and CUarrayMapInfo::subresource::sparseLevel::extentDepth must be set to 1 for 2D and 2D layered CUDA arrays and CUDA mipmapped arrays. Tile extents can be obtained by calling [cuArrayGetSparseProperties](<group__CUDA__MEM.html#group__CUDA__MEM_1gf74df88a07404ee051f0e5b36647d8c7> "Returns the layout properties of a sparse CUDA array.") and [cuMipmappedArrayGetSparseProperties](<group__CUDA__MEM.html#group__CUDA__MEM_1g55a16bd1780acb3cc94e8b88d5fe5e19> "Returns the layout properties of a sparse CUDA mipmapped array.")

If [CUarrayMapInfo::subresourceType](<structCUarrayMapInfo__v1.html#structCUarrayMapInfo__v1_17a2fe272bd8e44af2386f1c20c3d3c68>) is set to CUarraySparseSubresourceType::CU_ARRAY_SPARSE_SUBRESOURCE_TYPE_MIPTAIL then CUarrayMapInfo::subresource::miptail struct must contain valid mip tail offset in CUarrayMapInfo::subresource::miptail::offset and size in CUarrayMapInfo::subresource::miptail::size. Both, mip tail offset and mip tail size must be aligned to the tile size. For layered CUDA mipmapped arrays which don't have the flag [CU_ARRAY_SPARSE_PROPERTIES_SINGLE_MIPTAIL](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g0dcf4ba7e64caa5c1aa4e88caa7f659a>) set in [CUDA_ARRAY_SPARSE_PROPERTIES::flags](<structCUDA__ARRAY__SPARSE__PROPERTIES__v1.html#structCUDA__ARRAY__SPARSE__PROPERTIES__v1_10e842bb64091fa47809112c700cb5f0a>) as returned by [cuMipmappedArrayGetSparseProperties](<group__CUDA__MEM.html#group__CUDA__MEM_1g55a16bd1780acb3cc94e8b88d5fe5e19> "Returns the layout properties of a sparse CUDA mipmapped array."), CUarrayMapInfo::subresource::miptail::layer must specify a valid layer index. Otherwise, must be zero.

If CUarrayMapInfo::resource::array or CUarrayMapInfo::resource::mipmap was created with [CUDA_ARRAY3D_DEFERRED_MAPPING](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g854c29dbc47d04a4e42863cb87487d55>) flag set the [CUarrayMapInfo::subresourceType](<structCUarrayMapInfo__v1.html#structCUarrayMapInfo__v1_17a2fe272bd8e44af2386f1c20c3d3c68>) and the contents of CUarrayMapInfo::subresource will be ignored.

[CUarrayMapInfo::memOperationType](<structCUarrayMapInfo__v1.html#structCUarrayMapInfo__v1_1dd139e9655407264f2aeb812cec0f19e>) specifies the type of operation. [CUmemOperationType](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ge7469bd2e035fc9c937e84490fdcd349>) is defined as:


    â    typedef enum CUmemOperationType_enum {
                  CU_MEM_OPERATION_TYPE_MAP = 1,
                  CU_MEM_OPERATION_TYPE_UNMAP = 2
              } [CUmemOperationType](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ge7469bd2e035fc9c937e84490fdcd349>);

If [CUarrayMapInfo::memOperationType](<structCUarrayMapInfo__v1.html#structCUarrayMapInfo__v1_1dd139e9655407264f2aeb812cec0f19e>) is set to CUmemOperationType::CU_MEM_OPERATION_TYPE_MAP then the subresource will be mapped onto the tile pool memory specified by CUarrayMapInfo::memHandle at offset [CUarrayMapInfo::offset](<structCUarrayMapInfo__v1.html#structCUarrayMapInfo__v1_14aee5e358272af897aeaf8b44fd15bdb>). The tile pool allocation has to be created by specifying the [CU_MEM_CREATE_USAGE_TILE_POOL](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gb445d91d9773d728b1a9962184c05799>) flag when calling [cuMemCreate](<group__CUDA__VA.html#group__CUDA__VA_1g899d69a862bba36449789c64b430dc7c> "Create a CUDA memory handle representing a memory allocation of a given size described by the given properties."). Also, [CUarrayMapInfo::memHandleType](<structCUarrayMapInfo__v1.html#structCUarrayMapInfo__v1_1ed15e0aa10304948c68946fe8a5da161>) must be set to CUmemHandleType::CU_MEM_HANDLE_TYPE_GENERIC.

If [CUarrayMapInfo::memOperationType](<structCUarrayMapInfo__v1.html#structCUarrayMapInfo__v1_1dd139e9655407264f2aeb812cec0f19e>) is set to CUmemOperationType::CU_MEM_OPERATION_TYPE_UNMAP then an unmapping operation is performed. CUarrayMapInfo::memHandle must be NULL.

[CUarrayMapInfo::deviceBitMask](<structCUarrayMapInfo__v1.html#structCUarrayMapInfo__v1_1f2d14f719018cc1daa786f7fd0652c2c>) specifies the list of devices that must map or unmap physical memory. Currently, this mask must have exactly one bit set, and the corresponding device must match the device associated with the stream. If [CUarrayMapInfo::memOperationType](<structCUarrayMapInfo__v1.html#structCUarrayMapInfo__v1_1dd139e9655407264f2aeb812cec0f19e>) is set to CUmemOperationType::CU_MEM_OPERATION_TYPE_MAP, the device must also match the device associated with the tile pool memory allocation as specified by CUarrayMapInfo::memHandle.

[CUarrayMapInfo::flags](<structCUarrayMapInfo__v1.html#structCUarrayMapInfo__v1_12e36982c16390693a56807d0b8e6380f>) and [CUarrayMapInfo::reserved](<structCUarrayMapInfo__v1.html#structCUarrayMapInfo__v1_1cf7014dc4a157928de12563d0181ceba>)[] are unused and must be set to zero.

**See also:**

[cuMipmappedArrayCreate](<group__CUDA__MEM.html#group__CUDA__MEM_1ga5d2e311c7f9b0bc6d130af824a40bd3> "Creates a CUDA mipmapped array."), [cuArrayCreate](<group__CUDA__MEM.html#group__CUDA__MEM_1g4192ff387a81c3bd5ed8c391ed62ca24> "Creates a 1D or 2D CUDA array."), [cuArray3DCreate](<group__CUDA__MEM.html#group__CUDA__MEM_1gc2322c70b38c2984536c90ed118bb1d7> "Creates a 3D CUDA array."), [cuMemCreate](<group__CUDA__VA.html#group__CUDA__VA_1g899d69a862bba36449789c64b430dc7c> "Create a CUDA memory handle representing a memory allocation of a given size described by the given properties."), [cuArrayGetSparseProperties](<group__CUDA__MEM.html#group__CUDA__MEM_1gf74df88a07404ee051f0e5b36647d8c7> "Returns the layout properties of a sparse CUDA array."), [cuMipmappedArrayGetSparseProperties](<group__CUDA__MEM.html#group__CUDA__MEM_1g55a16bd1780acb3cc94e8b88d5fe5e19> "Returns the layout properties of a sparse CUDA mipmapped array.")

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuMemRelease ( CUmemGenericAllocationHandleÂ handle )


Release a memory handle representing a memory allocation which was previously allocated through cuMemCreate.

######  Parameters

`handle`
    Value of handle which was returned previously by cuMemCreate.

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>), [CUDA_ERROR_NOT_INITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e98feb999f0af99b4a25ab26b3866f4df8>), [CUDA_ERROR_DEINITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9acf52f132faf29b473cdda6061f0f44a>), [CUDA_ERROR_NOT_PERMITTED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9e23d0197c490ec332a43e55b167968a3>), [CUDA_ERROR_NOT_SUPPORTED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e954756ae7ade0dfd09faeccb513dd831b>)

###### Description

Frees the memory that was allocated on a device through cuMemCreate.

The memory allocation will be freed when all outstanding mappings to the memory are unmapped and when all outstanding references to the handle (including it's shareable counterparts) are also released. The generic memory handle can be freed when there are still outstanding mappings made with this handle. Each time a recipient process imports a shareable handle, it needs to pair it with [cuMemRelease](<group__CUDA__VA.html#group__CUDA__VA_1g3014f0759f43a8d82db951b8e4b91d68> "Release a memory handle representing a memory allocation which was previously allocated through cuMemCreate.") for the handle to be freed. If `handle` is not a valid handle the behavior is undefined.

Note:

Note that this function may also return error codes from previous, asynchronous launches.

**See also:**

[cuMemCreate](<group__CUDA__VA.html#group__CUDA__VA_1g899d69a862bba36449789c64b430dc7c> "Create a CUDA memory handle representing a memory allocation of a given size described by the given properties.")

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuMemRetainAllocationHandle ( CUmemGenericAllocationHandle*Â handle, void*Â addr )


Given an address `addr`, returns the allocation handle of the backing memory allocation.

######  Parameters

`handle`
    CUDA Memory handle for the backing memory allocation.
`addr`
    Memory address to query, that has been mapped previously.

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>), [CUDA_ERROR_NOT_INITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e98feb999f0af99b4a25ab26b3866f4df8>), [CUDA_ERROR_DEINITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9acf52f132faf29b473cdda6061f0f44a>), [CUDA_ERROR_NOT_PERMITTED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9e23d0197c490ec332a43e55b167968a3>), [CUDA_ERROR_NOT_SUPPORTED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e954756ae7ade0dfd09faeccb513dd831b>)

###### Description

The handle is guaranteed to be the same handle value used to map the memory. If the address requested is not mapped, the function will fail. The returned handle must be released with corresponding number of calls to [cuMemRelease](<group__CUDA__VA.html#group__CUDA__VA_1g3014f0759f43a8d82db951b8e4b91d68> "Release a memory handle representing a memory allocation which was previously allocated through cuMemCreate.").

Note:

The address `addr`, can be any address in a range previously mapped by [cuMemMap](<group__CUDA__VA.html#group__CUDA__VA_1gff1d395423af5c5c75375516959dae56> "Maps an allocation handle to a reserved virtual address range."), and not necessarily the start address.

**See also:**

[cuMemCreate](<group__CUDA__VA.html#group__CUDA__VA_1g899d69a862bba36449789c64b430dc7c> "Create a CUDA memory handle representing a memory allocation of a given size described by the given properties."), [cuMemRelease](<group__CUDA__VA.html#group__CUDA__VA_1g3014f0759f43a8d82db951b8e4b91d68> "Release a memory handle representing a memory allocation which was previously allocated through cuMemCreate."), [cuMemMap](<group__CUDA__VA.html#group__CUDA__VA_1gff1d395423af5c5c75375516959dae56> "Maps an allocation handle to a reserved virtual address range.")

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuMemSetAccess ( [CUdeviceptr](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g183f7b0d8ad008ea2a5fd552537ace4e>)Â ptr, size_tÂ size, const [CUmemAccessDesc](<structCUmemAccessDesc__v1.html#structCUmemAccessDesc__v1>)*Â desc, size_tÂ count )


Set the access flags for each location specified in `desc` for the given virtual address range.

######  Parameters

`ptr`
    \- Starting address for the virtual address range
`size`
    \- Length of the virtual address range
`desc`
    \- Array of CUmemAccessDesc that describe how to change the

  * mapping for each location specified


`count`
    \- Number of CUmemAccessDesc in `desc`

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>), [CUDA_ERROR_INVALID_DEVICE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e96f047e7215788ca96c81af92a04bfb6c>), [CUDA_ERROR_NOT_SUPPORTED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e954756ae7ade0dfd09faeccb513dd831b>)

###### Description

Given the virtual address range via `ptr` and `size`, and the locations in the array given by `desc` and `count`, set the access flags for the target locations. The range must be a fully mapped address range containing all allocations created by [cuMemMap](<group__CUDA__VA.html#group__CUDA__VA_1gff1d395423af5c5c75375516959dae56> "Maps an allocation handle to a reserved virtual address range.") / [cuMemCreate](<group__CUDA__VA.html#group__CUDA__VA_1g899d69a862bba36449789c64b430dc7c> "Create a CUDA memory handle representing a memory allocation of a given size described by the given properties."). Users cannot specify [CU_MEM_LOCATION_TYPE_HOST_NUMA](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg75cfd5b9fa5c1c6ee2be2547bfbe882eb61a1d3409ed83a43b5706cc004ac861>) accessibility for allocations created on with other location types. Note: When CUmemAccessDesc::CUmemLocation::type is [CU_MEM_LOCATION_TYPE_HOST_NUMA](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg75cfd5b9fa5c1c6ee2be2547bfbe882eb61a1d3409ed83a43b5706cc004ac861>), CUmemAccessDesc::CUmemLocation::id is ignored. When setting the access flags for a virtual address range mapping a multicast object, `ptr` and `size` must be aligned to the value returned by [cuMulticastGetGranularity](<group__CUDA__MULTICAST.html#group__CUDA__MULTICAST_1g067a02ad98f4e01f149011f523fec547> "Calculates either the minimal or recommended granularity for multicast object.") with the flag CU_MULTICAST_MINIMUM_GRANULARITY. For best performance however, it is recommended that `ptr` and `size` be aligned to the value returned by [cuMulticastGetGranularity](<group__CUDA__MULTICAST.html#group__CUDA__MULTICAST_1g067a02ad98f4e01f149011f523fec547> "Calculates either the minimal or recommended granularity for multicast object.") with the flag CU_MULTICAST_RECOMMENDED_GRANULARITY.

Note:

  * Note that this function may also return error codes from previous, asynchronous launches.

  * This function exhibits [synchronous](<api-sync-behavior.html#api-sync-behavior__memcpy-sync>) behavior for most use cases.


**See also:**

[cuMemSetAccess](<group__CUDA__VA.html#group__CUDA__VA_1g1b6b12b10e8324bf462ecab4e7ef30e1> "Set the access flags for each location specified in desc for the given virtual address range."), [cuMemCreate](<group__CUDA__VA.html#group__CUDA__VA_1g899d69a862bba36449789c64b430dc7c> "Create a CUDA memory handle representing a memory allocation of a given size described by the given properties."), :[cuMemMap](<group__CUDA__VA.html#group__CUDA__VA_1gff1d395423af5c5c75375516959dae56> "Maps an allocation handle to a reserved virtual address range.")

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuMemUnmap ( [CUdeviceptr](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g183f7b0d8ad008ea2a5fd552537ace4e>)Â ptr, size_tÂ size )


Unmap the backing memory of a given address range.

######  Parameters

`ptr`
    \- Starting address for the virtual address range to unmap
`size`
    \- Size of the virtual address range to unmap

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>), [CUDA_ERROR_NOT_INITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e98feb999f0af99b4a25ab26b3866f4df8>), [CUDA_ERROR_DEINITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9acf52f132faf29b473cdda6061f0f44a>), [CUDA_ERROR_NOT_PERMITTED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9e23d0197c490ec332a43e55b167968a3>), [CUDA_ERROR_NOT_SUPPORTED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e954756ae7ade0dfd09faeccb513dd831b>)

###### Description

The range must be the entire contiguous address range that was mapped to. In other words, [cuMemUnmap](<group__CUDA__VA.html#group__CUDA__VA_1gfb50aac00c848fd7087e858f59bf7e2a> "Unmap the backing memory of a given address range.") cannot unmap a sub-range of an address range mapped by [cuMemCreate](<group__CUDA__VA.html#group__CUDA__VA_1g899d69a862bba36449789c64b430dc7c> "Create a CUDA memory handle representing a memory allocation of a given size described by the given properties.") / [cuMemMap](<group__CUDA__VA.html#group__CUDA__VA_1gff1d395423af5c5c75375516959dae56> "Maps an allocation handle to a reserved virtual address range."). Any backing memory allocations will be freed if there are no existing mappings and there are no unreleased memory handles.

When [cuMemUnmap](<group__CUDA__VA.html#group__CUDA__VA_1gfb50aac00c848fd7087e858f59bf7e2a> "Unmap the backing memory of a given address range.") returns successfully the address range is converted to an address reservation and can be used for a future calls to [cuMemMap](<group__CUDA__VA.html#group__CUDA__VA_1gff1d395423af5c5c75375516959dae56> "Maps an allocation handle to a reserved virtual address range."). Any new mapping to this virtual address will need to have access granted through [cuMemSetAccess](<group__CUDA__VA.html#group__CUDA__VA_1g1b6b12b10e8324bf462ecab4e7ef30e1> "Set the access flags for each location specified in desc for the given virtual address range."), as all mappings start with no accessibility setup.

Note:

  * Note that this function may also return error codes from previous, asynchronous launches.

  * This function exhibits [synchronous](<api-sync-behavior.html#api-sync-behavior__memcpy-sync>) behavior for most use cases.


**See also:**

[cuMemCreate](<group__CUDA__VA.html#group__CUDA__VA_1g899d69a862bba36449789c64b430dc7c> "Create a CUDA memory handle representing a memory allocation of a given size described by the given properties."), [cuMemAddressReserve](<group__CUDA__VA.html#group__CUDA__VA_1ge489256c107df2a07ddf96d80c86cd9b> "Allocate an address range reservation.")

* * *


---

# Stream Ordered Memory Allocator

## 6.15.Â Stream Ordered Memory Allocator

This section describes the stream ordered memory allocator exposed by the low-level CUDA driver application programming interface.

**overview**

The asynchronous allocator allows the user to allocate and free in stream order. All asynchronous accesses of the allocation must happen between the stream executions of the allocation and the free. If the memory is accessed outside of the promised stream order, a use before allocation / use after free error will cause undefined behavior.

The allocator is free to reallocate the memory as long as it can guarantee that compliant memory accesses will not overlap temporally. The allocator may refer to internal stream ordering as well as inter-stream dependencies (such as CUDA events and null stream dependencies) when establishing the temporal guarantee. The allocator may also insert inter-stream dependencies to establish the temporal guarantee.

**Supported Platforms**

Whether or not a device supports the integrated stream ordered memory allocator may be queried by calling [cuDeviceGetAttribute()](<group__CUDA__DEVICE.html#group__CUDA__DEVICE_1g9c3e1414f0ad901d3278a4d6645fc266> "Returns information about the device.") with the device attribute [CU_DEVICE_ATTRIBUTE_MEMORY_POOLS_SUPPORTED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gge12b8a782bebe21b1ac0091bf9f4e2a3f867cfe1025bda03e88ee109eeaa178e>)

### Functions

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuMemAllocAsync](<#group__CUDA__MALLOC__ASYNC_1g13413273e84a641bce1929eae9e6501f>) ( [CUdeviceptr](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g183f7b0d8ad008ea2a5fd552537ace4e>)*Â dptr, size_tÂ bytesize, [CUstream](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gb946c7f02e09efd788a204718015d88a>)Â hStream )
     Allocates memory with stream ordered semantics.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuMemAllocFromPoolAsync](<#group__CUDA__MALLOC__ASYNC_1gf1dd6e1e2e8f767a5e0ea63f38ff260b>) ( [CUdeviceptr](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g183f7b0d8ad008ea2a5fd552537ace4e>)*Â dptr, size_tÂ bytesize, [CUmemoryPool](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g3b96b1ef79f0cb312b51169e9f50e722>)Â pool, [CUstream](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gb946c7f02e09efd788a204718015d88a>)Â hStream )
     Allocates memory from a specified pool with stream ordered semantics.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuMemFreeAsync](<#group__CUDA__MALLOC__ASYNC_1g41acf4131f672a2a75cd93d3241f10cf>) ( [CUdeviceptr](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g183f7b0d8ad008ea2a5fd552537ace4e>)Â dptr, [CUstream](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gb946c7f02e09efd788a204718015d88a>)Â hStream )
     Frees memory with stream ordered semantics.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuMemGetDefaultMemPool](<#group__CUDA__MALLOC__ASYNC_1gfe5111eb15c977cd8d87132ff481072f>) ( [CUmemoryPool](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g3b96b1ef79f0cb312b51169e9f50e722>)*Â pool_out, [CUmemLocation](<structCUmemLocation__v1.html#structCUmemLocation__v1>)*Â location, [CUmemAllocationType](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g7ed3482e0df8712d79a99bcb3bc4a95b>)Â type )
     Returns the default memory pool for a given location and allocation type.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuMemGetMemPool](<#group__CUDA__MALLOC__ASYNC_1g5283d28ee187477e1a2b06fd731ec575>) ( [CUmemoryPool](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g3b96b1ef79f0cb312b51169e9f50e722>)*Â pool, [CUmemLocation](<structCUmemLocation__v1.html#structCUmemLocation__v1>)*Â location, [CUmemAllocationType](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g7ed3482e0df8712d79a99bcb3bc4a95b>)Â type )
     Gets the current memory pool for a memory location and of a particular allocation type.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuMemPoolCreate](<#group__CUDA__MALLOC__ASYNC_1g8aa4c143dbc20293659cd883232b95f2>) ( [CUmemoryPool](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g3b96b1ef79f0cb312b51169e9f50e722>)*Â pool, const [CUmemPoolProps](<structCUmemPoolProps__v1.html#structCUmemPoolProps__v1>)*Â poolProps )
     Creates a memory pool.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuMemPoolDestroy](<#group__CUDA__MALLOC__ASYNC_1ge0e211115e5ad1c79250b9dd425b77f7>) ( [CUmemoryPool](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g3b96b1ef79f0cb312b51169e9f50e722>)Â pool )
     Destroys the specified memory pool.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuMemPoolExportPointer](<#group__CUDA__MALLOC__ASYNC_1gfe89f0478d26edaa91eb8a2e0349329d>) ( [CUmemPoolPtrExportData](<structCUmemPoolPtrExportData__v1.html#structCUmemPoolPtrExportData__v1>)*Â shareData_out, [CUdeviceptr](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g183f7b0d8ad008ea2a5fd552537ace4e>)Â ptr )
     Export data to share a memory pool allocation between processes.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuMemPoolExportToShareableHandle](<#group__CUDA__MALLOC__ASYNC_1g79ed285fdfffb76932871fb96fbba8f8>) ( void*Â handle_out, [CUmemoryPool](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g3b96b1ef79f0cb312b51169e9f50e722>)Â pool, [CUmemAllocationHandleType](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g450a23153d86fce0afe30e25d63caef9>)Â handleType, unsigned long longÂ flags )
     Exports a memory pool to the requested handle type.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuMemPoolGetAccess](<#group__CUDA__MALLOC__ASYNC_1g838f28fd535a1cbd06c5f7fe0edbdcc7>) ( [CUmemAccess_flags](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gfba87b8c4a8cd091554d8e2c3fc9b40a>)*Â flags, [CUmemoryPool](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g3b96b1ef79f0cb312b51169e9f50e722>)Â memPool, [CUmemLocation](<structCUmemLocation__v1.html#structCUmemLocation__v1>)*Â location )
     Returns the accessibility of a pool from a device.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuMemPoolGetAttribute](<#group__CUDA__MALLOC__ASYNC_1gd45ea7c43e4a1add4b971d06fa72eda4>) ( [CUmemoryPool](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g3b96b1ef79f0cb312b51169e9f50e722>)Â pool, [CUmemPool_attribute](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g5af6ea9ddd7633be98cb7de1bbf1d9f0>)Â attr, void*Â value )
     Gets attributes of a memory pool.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuMemPoolImportFromShareableHandle](<#group__CUDA__MALLOC__ASYNC_1g02b4f18dd8a1c45b7f302800e90cec5b>) ( [CUmemoryPool](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g3b96b1ef79f0cb312b51169e9f50e722>)*Â pool_out, void*Â handle, [CUmemAllocationHandleType](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g450a23153d86fce0afe30e25d63caef9>)Â handleType, unsigned long longÂ flags )
     imports a memory pool from a shared handle.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuMemPoolImportPointer](<#group__CUDA__MALLOC__ASYNC_1g2620bb972ed5edcce312d3689454acbd>) ( [CUdeviceptr](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g183f7b0d8ad008ea2a5fd552537ace4e>)*Â ptr_out, [CUmemoryPool](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g3b96b1ef79f0cb312b51169e9f50e722>)Â pool, [CUmemPoolPtrExportData](<structCUmemPoolPtrExportData__v1.html#structCUmemPoolPtrExportData__v1>)*Â shareData )
     Import a memory pool allocation from another process.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuMemPoolSetAccess](<#group__CUDA__MALLOC__ASYNC_1gff3ce33e252443f4b087b94e42913406>) ( [CUmemoryPool](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g3b96b1ef79f0cb312b51169e9f50e722>)Â pool, const [CUmemAccessDesc](<structCUmemAccessDesc__v1.html#structCUmemAccessDesc__v1>)*Â map, size_tÂ count )
     Controls visibility of pools between devices.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuMemPoolSetAttribute](<#group__CUDA__MALLOC__ASYNC_1g223e786cb217709235a06e41bccaec00>) ( [CUmemoryPool](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g3b96b1ef79f0cb312b51169e9f50e722>)Â pool, [CUmemPool_attribute](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g5af6ea9ddd7633be98cb7de1bbf1d9f0>)Â attr, void*Â value )
     Sets attributes of a memory pool.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuMemPoolTrimTo](<#group__CUDA__MALLOC__ASYNC_1g9c7e267e3460945b0ca76c48314bb669>) ( [CUmemoryPool](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g3b96b1ef79f0cb312b51169e9f50e722>)Â pool, size_tÂ minBytesToKeep )
     Tries to release memory back to the OS.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuMemSetMemPool](<#group__CUDA__MALLOC__ASYNC_1g779e76c810c5f088210ea907730e17c9>) ( [CUmemLocation](<structCUmemLocation__v1.html#structCUmemLocation__v1>)*Â location, [CUmemAllocationType](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g7ed3482e0df8712d79a99bcb3bc4a95b>)Â type, [CUmemoryPool](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g3b96b1ef79f0cb312b51169e9f50e722>)Â pool )
     Sets the current memory pool for a memory location and allocation type.

### Functions

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuMemAllocAsync ( [CUdeviceptr](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g183f7b0d8ad008ea2a5fd552537ace4e>)*Â dptr, size_tÂ bytesize, [CUstream](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gb946c7f02e09efd788a204718015d88a>)Â hStream )


Allocates memory with stream ordered semantics.

######  Parameters

`dptr`
    \- Returned device pointer
`bytesize`
    \- Number of bytes to allocate
`hStream`
    \- The stream establishing the stream ordering contract and the memory pool to allocate from

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>), [CUDA_ERROR_NOT_INITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e98feb999f0af99b4a25ab26b3866f4df8>), [CUDA_ERROR_INVALID_CONTEXT](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a484e9af32c1e9893ff21f0e0191a12d>) (default stream specified with no current context), [CUDA_ERROR_NOT_SUPPORTED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e954756ae7ade0dfd09faeccb513dd831b>), [CUDA_ERROR_OUT_OF_MEMORY](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9264c50688ed110e8476b591befe60c02>)

###### Description

Inserts an allocation operation into `hStream`. A pointer to the allocated memory is returned immediately in *dptr. The allocation must not be accessed until the the allocation operation completes. The allocation comes from the memory pool current to the stream's device.

Note:

  * The default memory pool of a device contains device memory from that device.

  * Basic stream ordering allows future work submitted into the same stream to use the allocation. Stream query, stream synchronize, and CUDA events can be used to guarantee that the allocation operation completes before work submitted in a separate stream runs.

  * During stream capture, this function results in the creation of an allocation node. In this case, the allocation is owned by the graph instead of the memory pool. The memory pool's properties are used to set the node's creation parameters.


**See also:**

[cuMemAllocFromPoolAsync](<group__CUDA__MALLOC__ASYNC.html#group__CUDA__MALLOC__ASYNC_1gf1dd6e1e2e8f767a5e0ea63f38ff260b> "Allocates memory from a specified pool with stream ordered semantics."), [cuMemFreeAsync](<group__CUDA__MALLOC__ASYNC.html#group__CUDA__MALLOC__ASYNC_1g41acf4131f672a2a75cd93d3241f10cf> "Frees memory with stream ordered semantics."), [cuDeviceSetMemPool](<group__CUDA__DEVICE.html#group__CUDA__DEVICE_1g4f2f276b84d9c2eaefdc76d6274db4a0> "Sets the current memory pool of a device."), [cuDeviceGetDefaultMemPool](<group__CUDA__DEVICE.html#group__CUDA__DEVICE_1gc8bca3c97a78816303b8aa5773b741f2> "Returns the default mempool of a device."), [cuDeviceGetMemPool](<group__CUDA__DEVICE.html#group__CUDA__DEVICE_1gdf186e9559d53a5eb18e572d48c1121b> "Gets the current mempool for a device."), [cuMemPoolCreate](<group__CUDA__MALLOC__ASYNC.html#group__CUDA__MALLOC__ASYNC_1g8aa4c143dbc20293659cd883232b95f2> "Creates a memory pool."), [cuMemPoolSetAccess](<group__CUDA__MALLOC__ASYNC.html#group__CUDA__MALLOC__ASYNC_1gff3ce33e252443f4b087b94e42913406> "Controls visibility of pools between devices."), [cuMemPoolSetAttribute](<group__CUDA__MALLOC__ASYNC.html#group__CUDA__MALLOC__ASYNC_1g223e786cb217709235a06e41bccaec00> "Sets attributes of a memory pool.")

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuMemAllocFromPoolAsync ( [CUdeviceptr](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g183f7b0d8ad008ea2a5fd552537ace4e>)*Â dptr, size_tÂ bytesize, [CUmemoryPool](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g3b96b1ef79f0cb312b51169e9f50e722>)Â pool, [CUstream](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gb946c7f02e09efd788a204718015d88a>)Â hStream )


Allocates memory from a specified pool with stream ordered semantics.

######  Parameters

`dptr`
    \- Returned device pointer
`bytesize`
    \- Number of bytes to allocate
`pool`
    \- The pool to allocate from
`hStream`
    \- The stream establishing the stream ordering semantic

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>), [CUDA_ERROR_NOT_INITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e98feb999f0af99b4a25ab26b3866f4df8>), [CUDA_ERROR_INVALID_CONTEXT](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a484e9af32c1e9893ff21f0e0191a12d>) (default stream specified with no current context), [CUDA_ERROR_NOT_SUPPORTED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e954756ae7ade0dfd09faeccb513dd831b>), [CUDA_ERROR_OUT_OF_MEMORY](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9264c50688ed110e8476b591befe60c02>)

###### Description

Inserts an allocation operation into `hStream`. A pointer to the allocated memory is returned immediately in *dptr. The allocation must not be accessed until the the allocation operation completes. The allocation comes from the specified memory pool.

Note:

  * The specified memory pool may be from a device different than that of the specified `hStream`.


  * Basic stream ordering allows future work submitted into the same stream to use the allocation. Stream query, stream synchronize, and CUDA events can be used to guarantee that the allocation operation completes before work submitted in a separate stream runs.


Note:

During stream capture, this function results in the creation of an allocation node. In this case, the allocation is owned by the graph instead of the memory pool. The memory pool's properties are used to set the node's creation parameters.

**See also:**

[cuMemAllocAsync](<group__CUDA__MALLOC__ASYNC.html#group__CUDA__MALLOC__ASYNC_1g13413273e84a641bce1929eae9e6501f> "Allocates memory with stream ordered semantics."), [cuMemFreeAsync](<group__CUDA__MALLOC__ASYNC.html#group__CUDA__MALLOC__ASYNC_1g41acf4131f672a2a75cd93d3241f10cf> "Frees memory with stream ordered semantics."), [cuDeviceGetDefaultMemPool](<group__CUDA__DEVICE.html#group__CUDA__DEVICE_1gc8bca3c97a78816303b8aa5773b741f2> "Returns the default mempool of a device."), [cuDeviceGetMemPool](<group__CUDA__DEVICE.html#group__CUDA__DEVICE_1gdf186e9559d53a5eb18e572d48c1121b> "Gets the current mempool for a device."), [cuMemPoolCreate](<group__CUDA__MALLOC__ASYNC.html#group__CUDA__MALLOC__ASYNC_1g8aa4c143dbc20293659cd883232b95f2> "Creates a memory pool."), [cuMemPoolSetAccess](<group__CUDA__MALLOC__ASYNC.html#group__CUDA__MALLOC__ASYNC_1gff3ce33e252443f4b087b94e42913406> "Controls visibility of pools between devices."), [cuMemPoolSetAttribute](<group__CUDA__MALLOC__ASYNC.html#group__CUDA__MALLOC__ASYNC_1g223e786cb217709235a06e41bccaec00> "Sets attributes of a memory pool.")

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuMemFreeAsync ( [CUdeviceptr](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g183f7b0d8ad008ea2a5fd552537ace4e>)Â dptr, [CUstream](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gb946c7f02e09efd788a204718015d88a>)Â hStream )


Frees memory with stream ordered semantics.

######  Parameters

`dptr`
    \- memory to free
`hStream`
    \- The stream establishing the stream ordering contract.

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>), [CUDA_ERROR_NOT_INITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e98feb999f0af99b4a25ab26b3866f4df8>), [CUDA_ERROR_INVALID_CONTEXT](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a484e9af32c1e9893ff21f0e0191a12d>) (default stream specified with no current context), [CUDA_ERROR_NOT_SUPPORTED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e954756ae7ade0dfd09faeccb513dd831b>)

###### Description

Inserts a free operation into `hStream`. The allocation must not be accessed after stream execution reaches the free. After this API returns, accessing the memory from any subsequent work launched on the GPU or querying its pointer attributes results in undefined behavior.

Note:

During stream capture, this function results in the creation of a free node and must therefore be passed the address of a graph allocation.

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuMemGetDefaultMemPool ( [CUmemoryPool](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g3b96b1ef79f0cb312b51169e9f50e722>)*Â pool_out, [CUmemLocation](<structCUmemLocation__v1.html#structCUmemLocation__v1>)*Â location, [CUmemAllocationType](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g7ed3482e0df8712d79a99bcb3bc4a95b>)Â type )


Returns the default memory pool for a given location and allocation type.

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_DEINITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9acf52f132faf29b473cdda6061f0f44a>)[CUDA_ERROR_NOT_INITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e98feb999f0af99b4a25ab26b3866f4df8>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>), [CUDA_ERROR_INVALID_DEVICE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e96f047e7215788ca96c81af92a04bfb6c>), [CUDA_ERROR_NOT_SUPPORTED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e954756ae7ade0dfd09faeccb513dd831b>)

###### Description

The memory location can be of one of [CU_MEM_LOCATION_TYPE_DEVICE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg75cfd5b9fa5c1c6ee2be2547bfbe882ea4409aa6b414995d628a320eafbbbb6e>), [CU_MEM_LOCATION_TYPE_HOST](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg75cfd5b9fa5c1c6ee2be2547bfbe882e46800776121a71c8dc2904518a21065a>) or [CU_MEM_LOCATION_TYPE_HOST_NUMA](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg75cfd5b9fa5c1c6ee2be2547bfbe882eb61a1d3409ed83a43b5706cc004ac861>). The allocation type can be one of [CU_MEM_ALLOCATION_TYPE_PINNED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg7ed3482e0df8712d79a99bcb3bc4a95b646624651d13be111040ffdf1161511c>) or [CU_MEM_ALLOCATION_TYPE_MANAGED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg7ed3482e0df8712d79a99bcb3bc4a95b774fc1109cfbb0a357d6701483177cc1>). When the allocation type is [CU_MEM_ALLOCATION_TYPE_MANAGED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg7ed3482e0df8712d79a99bcb3bc4a95b774fc1109cfbb0a357d6701483177cc1>), the location type can also be [CU_MEM_LOCATION_TYPE_NONE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg75cfd5b9fa5c1c6ee2be2547bfbe882ecfc8f2ab14e813f7afe8019052526fa4>) to indicate no preferred location for the managed memory pool. In all other cases, the call returns [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>).

Note:

Note that this function may also return error codes from previous, asynchronous launches.

**See also:**

[cuMemAllocAsync](<group__CUDA__MALLOC__ASYNC.html#group__CUDA__MALLOC__ASYNC_1g13413273e84a641bce1929eae9e6501f> "Allocates memory with stream ordered semantics."), [cuMemPoolTrimTo](<group__CUDA__MALLOC__ASYNC.html#group__CUDA__MALLOC__ASYNC_1g9c7e267e3460945b0ca76c48314bb669> "Tries to release memory back to the OS."), [cuMemPoolGetAttribute](<group__CUDA__MALLOC__ASYNC.html#group__CUDA__MALLOC__ASYNC_1gd45ea7c43e4a1add4b971d06fa72eda4> "Gets attributes of a memory pool."), [cuMemPoolSetAttribute](<group__CUDA__MALLOC__ASYNC.html#group__CUDA__MALLOC__ASYNC_1g223e786cb217709235a06e41bccaec00> "Sets attributes of a memory pool."), [cuMemPoolSetAccess](<group__CUDA__MALLOC__ASYNC.html#group__CUDA__MALLOC__ASYNC_1gff3ce33e252443f4b087b94e42913406> "Controls visibility of pools between devices."), [cuMemGetMemPool](<group__CUDA__MALLOC__ASYNC.html#group__CUDA__MALLOC__ASYNC_1g5283d28ee187477e1a2b06fd731ec575> "Gets the current memory pool for a memory location and of a particular allocation type."), [cuMemPoolCreate](<group__CUDA__MALLOC__ASYNC.html#group__CUDA__MALLOC__ASYNC_1g8aa4c143dbc20293659cd883232b95f2> "Creates a memory pool.")

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuMemGetMemPool ( [CUmemoryPool](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g3b96b1ef79f0cb312b51169e9f50e722>)*Â pool, [CUmemLocation](<structCUmemLocation__v1.html#structCUmemLocation__v1>)*Â location, [CUmemAllocationType](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g7ed3482e0df8712d79a99bcb3bc4a95b>)Â type )


Gets the current memory pool for a memory location and of a particular allocation type.

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>)

###### Description

The memory location can be of one of [CU_MEM_LOCATION_TYPE_DEVICE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg75cfd5b9fa5c1c6ee2be2547bfbe882ea4409aa6b414995d628a320eafbbbb6e>), [CU_MEM_LOCATION_TYPE_HOST](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg75cfd5b9fa5c1c6ee2be2547bfbe882e46800776121a71c8dc2904518a21065a>) or [CU_MEM_LOCATION_TYPE_HOST_NUMA](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg75cfd5b9fa5c1c6ee2be2547bfbe882eb61a1d3409ed83a43b5706cc004ac861>). The allocation type can be one of [CU_MEM_ALLOCATION_TYPE_PINNED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg7ed3482e0df8712d79a99bcb3bc4a95b646624651d13be111040ffdf1161511c>) or [CU_MEM_ALLOCATION_TYPE_MANAGED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg7ed3482e0df8712d79a99bcb3bc4a95b774fc1109cfbb0a357d6701483177cc1>). When the allocation type is [CU_MEM_ALLOCATION_TYPE_MANAGED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg7ed3482e0df8712d79a99bcb3bc4a95b774fc1109cfbb0a357d6701483177cc1>), the location type can also be [CU_MEM_LOCATION_TYPE_NONE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg75cfd5b9fa5c1c6ee2be2547bfbe882ecfc8f2ab14e813f7afe8019052526fa4>) to indicate no preferred location for the managed memory pool. In all other cases, the call returns [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>)

Returns the last pool provided to [cuMemSetMemPool](<group__CUDA__MALLOC__ASYNC.html#group__CUDA__MALLOC__ASYNC_1g779e76c810c5f088210ea907730e17c9> "Sets the current memory pool for a memory location and allocation type.") or [cuDeviceSetMemPool](<group__CUDA__DEVICE.html#group__CUDA__DEVICE_1g4f2f276b84d9c2eaefdc76d6274db4a0> "Sets the current memory pool of a device.") for this location and allocation type or the location's default memory pool if [cuMemSetMemPool](<group__CUDA__MALLOC__ASYNC.html#group__CUDA__MALLOC__ASYNC_1g779e76c810c5f088210ea907730e17c9> "Sets the current memory pool for a memory location and allocation type.") or [cuDeviceSetMemPool](<group__CUDA__DEVICE.html#group__CUDA__DEVICE_1g4f2f276b84d9c2eaefdc76d6274db4a0> "Sets the current memory pool of a device.") for that allocType and location has never been called. By default the current mempool of a location is the default mempool for a device. Otherwise the returned pool must have been set with [cuDeviceSetMemPool](<group__CUDA__DEVICE.html#group__CUDA__DEVICE_1g4f2f276b84d9c2eaefdc76d6274db4a0> "Sets the current memory pool of a device.").

**See also:**

[cuDeviceGetDefaultMemPool](<group__CUDA__DEVICE.html#group__CUDA__DEVICE_1gc8bca3c97a78816303b8aa5773b741f2> "Returns the default mempool of a device."), [cuMemPoolCreate](<group__CUDA__MALLOC__ASYNC.html#group__CUDA__MALLOC__ASYNC_1g8aa4c143dbc20293659cd883232b95f2> "Creates a memory pool."), [cuDeviceSetMemPool](<group__CUDA__DEVICE.html#group__CUDA__DEVICE_1g4f2f276b84d9c2eaefdc76d6274db4a0> "Sets the current memory pool of a device."), [cuMemSetMemPool](<group__CUDA__MALLOC__ASYNC.html#group__CUDA__MALLOC__ASYNC_1g779e76c810c5f088210ea907730e17c9> "Sets the current memory pool for a memory location and allocation type.")

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuMemPoolCreate ( [CUmemoryPool](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g3b96b1ef79f0cb312b51169e9f50e722>)*Â pool, const [CUmemPoolProps](<structCUmemPoolProps__v1.html#structCUmemPoolProps__v1>)*Â poolProps )


Creates a memory pool.

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_NOT_INITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e98feb999f0af99b4a25ab26b3866f4df8>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>), [CUDA_ERROR_OUT_OF_MEMORY](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9264c50688ed110e8476b591befe60c02>), [CUDA_ERROR_NOT_PERMITTED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9e23d0197c490ec332a43e55b167968a3>), [CUDA_ERROR_NOT_SUPPORTED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e954756ae7ade0dfd09faeccb513dd831b>)

###### Description

Creates a CUDA memory pool and returns the handle in `pool`. The `poolProps` determines the properties of the pool such as the backing device and IPC capabilities.

To create a memory pool for HOST memory not targeting a specific NUMA node, applications must set set CUmemPoolProps::CUmemLocation::type to [CU_MEM_LOCATION_TYPE_HOST](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg75cfd5b9fa5c1c6ee2be2547bfbe882e46800776121a71c8dc2904518a21065a>). CUmemPoolProps::CUmemLocation::id is ignored for such pools. Pools created with the type [CU_MEM_LOCATION_TYPE_HOST](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg75cfd5b9fa5c1c6ee2be2547bfbe882e46800776121a71c8dc2904518a21065a>) are not IPC capable and [CUmemPoolProps::handleTypes](<structCUmemPoolProps__v1.html#structCUmemPoolProps__v1_169e75d604b122dbd39a8e3e3eacbe660>) must be 0, any other values will result in [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>). To create a memory pool targeting a specific host NUMA node, applications must set CUmemPoolProps::CUmemLocation::type to [CU_MEM_LOCATION_TYPE_HOST_NUMA](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg75cfd5b9fa5c1c6ee2be2547bfbe882eb61a1d3409ed83a43b5706cc004ac861>) and CUmemPoolProps::CUmemLocation::id must specify the NUMA ID of the host memory node. Specifying [CU_MEM_LOCATION_TYPE_HOST_NUMA_CURRENT](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg75cfd5b9fa5c1c6ee2be2547bfbe882e55b82116b2124510a1a3b6c52096daaa>) as the CUmemPoolProps::CUmemLocation::type will result in [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>). By default, the pool's memory will be accessible from the device it is allocated on. In the case of pools created with [CU_MEM_LOCATION_TYPE_HOST_NUMA](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg75cfd5b9fa5c1c6ee2be2547bfbe882eb61a1d3409ed83a43b5706cc004ac861>) or [CU_MEM_LOCATION_TYPE_HOST](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg75cfd5b9fa5c1c6ee2be2547bfbe882e46800776121a71c8dc2904518a21065a>), their default accessibility will be from the host CPU. Applications can control the maximum size of the pool by specifying a non-zero value for [CUmemPoolProps::maxSize](<structCUmemPoolProps__v1.html#structCUmemPoolProps__v1_10f9278cc88653f1eee70ab6a7a2ad7f3>). If set to 0, the maximum size of the pool will default to a system dependent value.

Applications that intend to use [CU_MEM_HANDLE_TYPE_FABRIC](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg450a23153d86fce0afe30e25d63caef9e38a182adb450da6c1a3f29cd5dca032>) based memory sharing must ensure: (1) `nvidia-caps-imex-channels` character device is created by the driver and is listed under /proc/devices (2) have at least one IMEX channel file accessible by the user launching the application.

When exporter and importer CUDA processes have been granted access to the same IMEX channel, they can securely share memory.

The IMEX channel security model works on a per user basis. Which means all processes under a user can share memory if the user has access to a valid IMEX channel. When multi-user isolation is desired, a separate IMEX channel is required for each user.

These channel files exist in /dev/nvidia-caps-imex-channels/channel* and can be created using standard OS native calls like mknod on Linux. For example: To create channel0 with the major number from /proc/devices users can execute the following command: `mknod /dev/nvidia-caps-imex-channels/channel0 c <major number>=""> 0`

To create a managed memory pool, applications must set [CUmemPoolProps::CUmemAllocationType](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g7ed3482e0df8712d79a99bcb3bc4a95b>) to CU_MEM_ALLOCATION_TYPE_MANAGED. [CUmemPoolProps::CUmemAllocationHandleType](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g450a23153d86fce0afe30e25d63caef9>) must also be set to CU_MEM_HANDLE_TYPE_NONE since IPC is not supported. For managed memory pools, CUmemPoolProps::CUmemLocation will be treated as the preferred location for all allocations created from the pool. An application can also set CU_MEM_LOCATION_TYPE_NONE to indicate no preferred location. [CUmemPoolProps::maxSize](<structCUmemPoolProps__v1.html#structCUmemPoolProps__v1_10f9278cc88653f1eee70ab6a7a2ad7f3>) must be set to zero for managed memory pools. [CUmemPoolProps::usage](<structCUmemPoolProps__v1.html#structCUmemPoolProps__v1_181dcd809a228c4346f8e732bb8e9070b>) should be zero as decompress for managed memory is not supported. For managed memory pools, all devices on the system must have non-zero concurrentManagedAccess. If not, this call returns CUDA_ERROR_NOT_SUPPORTED

Note:

Specifying CU_MEM_HANDLE_TYPE_NONE creates a memory pool that will not support IPC.

**See also:**

[cuDeviceSetMemPool](<group__CUDA__DEVICE.html#group__CUDA__DEVICE_1g4f2f276b84d9c2eaefdc76d6274db4a0> "Sets the current memory pool of a device."), [cuDeviceGetMemPool](<group__CUDA__DEVICE.html#group__CUDA__DEVICE_1gdf186e9559d53a5eb18e572d48c1121b> "Gets the current mempool for a device."), [cuDeviceGetDefaultMemPool](<group__CUDA__DEVICE.html#group__CUDA__DEVICE_1gc8bca3c97a78816303b8aa5773b741f2> "Returns the default mempool of a device."), [cuMemAllocFromPoolAsync](<group__CUDA__MALLOC__ASYNC.html#group__CUDA__MALLOC__ASYNC_1gf1dd6e1e2e8f767a5e0ea63f38ff260b> "Allocates memory from a specified pool with stream ordered semantics."), [cuMemPoolExportToShareableHandle](<group__CUDA__MALLOC__ASYNC.html#group__CUDA__MALLOC__ASYNC_1g79ed285fdfffb76932871fb96fbba8f8> "Exports a memory pool to the requested handle type.")

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuMemPoolDestroy ( [CUmemoryPool](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g3b96b1ef79f0cb312b51169e9f50e722>)Â pool )


Destroys the specified memory pool.

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>)

###### Description

If any pointers obtained from this pool haven't been freed or the pool has free operations that haven't completed when [cuMemPoolDestroy](<group__CUDA__MALLOC__ASYNC.html#group__CUDA__MALLOC__ASYNC_1ge0e211115e5ad1c79250b9dd425b77f7> "Destroys the specified memory pool.") is invoked, the function will return immediately and the resources associated with the pool will be released automatically once there are no more outstanding allocations.

Destroying the current mempool of a device sets the default mempool of that device as the current mempool for that device.

Note:

A device's default memory pool cannot be destroyed.

**See also:**

[cuMemFreeAsync](<group__CUDA__MALLOC__ASYNC.html#group__CUDA__MALLOC__ASYNC_1g41acf4131f672a2a75cd93d3241f10cf> "Frees memory with stream ordered semantics."), [cuDeviceSetMemPool](<group__CUDA__DEVICE.html#group__CUDA__DEVICE_1g4f2f276b84d9c2eaefdc76d6274db4a0> "Sets the current memory pool of a device."), [cuDeviceGetMemPool](<group__CUDA__DEVICE.html#group__CUDA__DEVICE_1gdf186e9559d53a5eb18e572d48c1121b> "Gets the current mempool for a device."), [cuDeviceGetDefaultMemPool](<group__CUDA__DEVICE.html#group__CUDA__DEVICE_1gc8bca3c97a78816303b8aa5773b741f2> "Returns the default mempool of a device."), [cuMemPoolCreate](<group__CUDA__MALLOC__ASYNC.html#group__CUDA__MALLOC__ASYNC_1g8aa4c143dbc20293659cd883232b95f2> "Creates a memory pool.")

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuMemPoolExportPointer ( [CUmemPoolPtrExportData](<structCUmemPoolPtrExportData__v1.html#structCUmemPoolPtrExportData__v1>)*Â shareData_out, [CUdeviceptr](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g183f7b0d8ad008ea2a5fd552537ace4e>)Â ptr )


Export data to share a memory pool allocation between processes.

######  Parameters

`shareData_out`
    \- Returned export data
`ptr`
    \- pointer to memory being exported

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>), [CUDA_ERROR_NOT_INITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e98feb999f0af99b4a25ab26b3866f4df8>), [CUDA_ERROR_OUT_OF_MEMORY](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9264c50688ed110e8476b591befe60c02>)

###### Description

Constructs `shareData_out` for sharing a specific allocation from an already shared memory pool. The recipient process can import the allocation with the [cuMemPoolImportPointer](<group__CUDA__MALLOC__ASYNC.html#group__CUDA__MALLOC__ASYNC_1g2620bb972ed5edcce312d3689454acbd> "Import a memory pool allocation from another process.") api. The data is not a handle and may be shared through any IPC mechanism.

**See also:**

[cuMemPoolExportToShareableHandle](<group__CUDA__MALLOC__ASYNC.html#group__CUDA__MALLOC__ASYNC_1g79ed285fdfffb76932871fb96fbba8f8> "Exports a memory pool to the requested handle type."), [cuMemPoolImportFromShareableHandle](<group__CUDA__MALLOC__ASYNC.html#group__CUDA__MALLOC__ASYNC_1g02b4f18dd8a1c45b7f302800e90cec5b> "imports a memory pool from a shared handle."), [cuMemPoolImportPointer](<group__CUDA__MALLOC__ASYNC.html#group__CUDA__MALLOC__ASYNC_1g2620bb972ed5edcce312d3689454acbd> "Import a memory pool allocation from another process.")

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuMemPoolExportToShareableHandle ( void*Â handle_out, [CUmemoryPool](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g3b96b1ef79f0cb312b51169e9f50e722>)Â pool, [CUmemAllocationHandleType](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g450a23153d86fce0afe30e25d63caef9>)Â handleType, unsigned long longÂ flags )


Exports a memory pool to the requested handle type.

######  Parameters

`handle_out`
    \- Returned OS handle
`pool`
    \- pool to export
`handleType`
    \- the type of handle to create
`flags`
    \- must be 0

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>), [CUDA_ERROR_NOT_INITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e98feb999f0af99b4a25ab26b3866f4df8>), [CUDA_ERROR_OUT_OF_MEMORY](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9264c50688ed110e8476b591befe60c02>)

###### Description

Given an IPC capable mempool, create an OS handle to share the pool with another process. A recipient process can convert the shareable handle into a mempool with [cuMemPoolImportFromShareableHandle](<group__CUDA__MALLOC__ASYNC.html#group__CUDA__MALLOC__ASYNC_1g02b4f18dd8a1c45b7f302800e90cec5b> "imports a memory pool from a shared handle."). Individual pointers can then be shared with the [cuMemPoolExportPointer](<group__CUDA__MALLOC__ASYNC.html#group__CUDA__MALLOC__ASYNC_1gfe89f0478d26edaa91eb8a2e0349329d> "Export data to share a memory pool allocation between processes.") and [cuMemPoolImportPointer](<group__CUDA__MALLOC__ASYNC.html#group__CUDA__MALLOC__ASYNC_1g2620bb972ed5edcce312d3689454acbd> "Import a memory pool allocation from another process.") APIs. The implementation of what the shareable handle is and how it can be transferred is defined by the requested handle type.

Note:

: To create an IPC capable mempool, create a mempool with a CUmemAllocationHandleType other than CU_MEM_HANDLE_TYPE_NONE.

**See also:**

[cuMemPoolImportFromShareableHandle](<group__CUDA__MALLOC__ASYNC.html#group__CUDA__MALLOC__ASYNC_1g02b4f18dd8a1c45b7f302800e90cec5b> "imports a memory pool from a shared handle."), [cuMemPoolExportPointer](<group__CUDA__MALLOC__ASYNC.html#group__CUDA__MALLOC__ASYNC_1gfe89f0478d26edaa91eb8a2e0349329d> "Export data to share a memory pool allocation between processes."), [cuMemPoolImportPointer](<group__CUDA__MALLOC__ASYNC.html#group__CUDA__MALLOC__ASYNC_1g2620bb972ed5edcce312d3689454acbd> "Import a memory pool allocation from another process."), [cuMemAllocAsync](<group__CUDA__MALLOC__ASYNC.html#group__CUDA__MALLOC__ASYNC_1g13413273e84a641bce1929eae9e6501f> "Allocates memory with stream ordered semantics."), [cuMemFreeAsync](<group__CUDA__MALLOC__ASYNC.html#group__CUDA__MALLOC__ASYNC_1g41acf4131f672a2a75cd93d3241f10cf> "Frees memory with stream ordered semantics."), [cuDeviceGetDefaultMemPool](<group__CUDA__DEVICE.html#group__CUDA__DEVICE_1gc8bca3c97a78816303b8aa5773b741f2> "Returns the default mempool of a device."), [cuDeviceGetMemPool](<group__CUDA__DEVICE.html#group__CUDA__DEVICE_1gdf186e9559d53a5eb18e572d48c1121b> "Gets the current mempool for a device."), [cuMemPoolCreate](<group__CUDA__MALLOC__ASYNC.html#group__CUDA__MALLOC__ASYNC_1g8aa4c143dbc20293659cd883232b95f2> "Creates a memory pool."), [cuMemPoolSetAccess](<group__CUDA__MALLOC__ASYNC.html#group__CUDA__MALLOC__ASYNC_1gff3ce33e252443f4b087b94e42913406> "Controls visibility of pools between devices."), [cuMemPoolSetAttribute](<group__CUDA__MALLOC__ASYNC.html#group__CUDA__MALLOC__ASYNC_1g223e786cb217709235a06e41bccaec00> "Sets attributes of a memory pool.")

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuMemPoolGetAccess ( [CUmemAccess_flags](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gfba87b8c4a8cd091554d8e2c3fc9b40a>)*Â flags, [CUmemoryPool](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g3b96b1ef79f0cb312b51169e9f50e722>)Â memPool, [CUmemLocation](<structCUmemLocation__v1.html#structCUmemLocation__v1>)*Â location )


Returns the accessibility of a pool from a device.

######  Parameters

`flags`
    \- the accessibility of the pool from the specified location
`memPool`
    \- the pool being queried
`location`
    \- the location accessing the pool

###### Description

Returns the accessibility of the pool's memory from the specified location.

**See also:**

[cuMemAllocAsync](<group__CUDA__MALLOC__ASYNC.html#group__CUDA__MALLOC__ASYNC_1g13413273e84a641bce1929eae9e6501f> "Allocates memory with stream ordered semantics."), [cuMemFreeAsync](<group__CUDA__MALLOC__ASYNC.html#group__CUDA__MALLOC__ASYNC_1g41acf4131f672a2a75cd93d3241f10cf> "Frees memory with stream ordered semantics."), [cuDeviceGetDefaultMemPool](<group__CUDA__DEVICE.html#group__CUDA__DEVICE_1gc8bca3c97a78816303b8aa5773b741f2> "Returns the default mempool of a device."), [cuDeviceGetMemPool](<group__CUDA__DEVICE.html#group__CUDA__DEVICE_1gdf186e9559d53a5eb18e572d48c1121b> "Gets the current mempool for a device."), [cuMemPoolCreate](<group__CUDA__MALLOC__ASYNC.html#group__CUDA__MALLOC__ASYNC_1g8aa4c143dbc20293659cd883232b95f2> "Creates a memory pool.")

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuMemPoolGetAttribute ( [CUmemoryPool](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g3b96b1ef79f0cb312b51169e9f50e722>)Â pool, [CUmemPool_attribute](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g5af6ea9ddd7633be98cb7de1bbf1d9f0>)Â attr, void*Â value )


Gets attributes of a memory pool.

######  Parameters

`pool`
    \- The memory pool to get attributes of
`attr`
    \- The attribute to get
`value`
    \- Retrieved value

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_NOT_INITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e98feb999f0af99b4a25ab26b3866f4df8>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>)

###### Description

Supported attributes are:

  * [CU_MEMPOOL_ATTR_RELEASE_THRESHOLD](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg5af6ea9ddd7633be98cb7de1bbf1d9f050fa2c731b01422ffbeb8c16ce0ba9a8>): (value type = cuuint64_t) Amount of reserved memory in bytes to hold onto before trying to release memory back to the OS. When more than the release threshold bytes of memory are held by the memory pool, the allocator will try to release memory back to the OS on the next call to stream, event or context synchronize. (default 0)

  * [CU_MEMPOOL_ATTR_REUSE_FOLLOW_EVENT_DEPENDENCIES](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg5af6ea9ddd7633be98cb7de1bbf1d9f0e11d636e9d56f9ce8a449b887fe2917f>): (value type = int) Allow [cuMemAllocAsync](<group__CUDA__MALLOC__ASYNC.html#group__CUDA__MALLOC__ASYNC_1g13413273e84a641bce1929eae9e6501f> "Allocates memory with stream ordered semantics.") to use memory asynchronously freed in another stream as long as a stream ordering dependency of the allocating stream on the free action exists. Cuda events and null stream interactions can create the required stream ordered dependencies. (default enabled)

  * [CU_MEMPOOL_ATTR_REUSE_ALLOW_OPPORTUNISTIC](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg5af6ea9ddd7633be98cb7de1bbf1d9f0d1016ed326b53c1eb06e8da5d40359cb>): (value type = int) Allow reuse of already completed frees when there is no dependency between the free and allocation. (default enabled)

  * [CU_MEMPOOL_ATTR_REUSE_ALLOW_INTERNAL_DEPENDENCIES](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg5af6ea9ddd7633be98cb7de1bbf1d9f03b7973c1b89f3a05f26702ade1124e9f>): (value type = int) Allow [cuMemAllocAsync](<group__CUDA__MALLOC__ASYNC.html#group__CUDA__MALLOC__ASYNC_1g13413273e84a641bce1929eae9e6501f> "Allocates memory with stream ordered semantics.") to insert new stream dependencies in order to establish the stream ordering required to reuse a piece of memory released by [cuMemFreeAsync](<group__CUDA__MALLOC__ASYNC.html#group__CUDA__MALLOC__ASYNC_1g41acf4131f672a2a75cd93d3241f10cf> "Frees memory with stream ordered semantics.") (default enabled).

  * [CU_MEMPOOL_ATTR_RESERVED_MEM_CURRENT](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg5af6ea9ddd7633be98cb7de1bbf1d9f0ecd4938eb06ce224e04d4c56fea476c6>): (value type = cuuint64_t) Amount of backing memory currently allocated for the mempool

  * [CU_MEMPOOL_ATTR_RESERVED_MEM_HIGH](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg5af6ea9ddd7633be98cb7de1bbf1d9f05ccb2736772fd27a735f15905118cbf6>): (value type = cuuint64_t) High watermark of backing memory allocated for the mempool since the last time it was reset.

  * [CU_MEMPOOL_ATTR_USED_MEM_CURRENT](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg5af6ea9ddd7633be98cb7de1bbf1d9f03f17742ca47490659f188bc75be9b85c>): (value type = cuuint64_t) Amount of memory from the pool that is currently in use by the application.

  * [CU_MEMPOOL_ATTR_USED_MEM_HIGH](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg5af6ea9ddd7633be98cb7de1bbf1d9f027fd3cf6d5a152572e55e9736da6987b>): (value type = cuuint64_t) High watermark of the amount of memory from the pool that was in use by the application.


**See also:**

[cuMemAllocAsync](<group__CUDA__MALLOC__ASYNC.html#group__CUDA__MALLOC__ASYNC_1g13413273e84a641bce1929eae9e6501f> "Allocates memory with stream ordered semantics."), [cuMemFreeAsync](<group__CUDA__MALLOC__ASYNC.html#group__CUDA__MALLOC__ASYNC_1g41acf4131f672a2a75cd93d3241f10cf> "Frees memory with stream ordered semantics."), [cuDeviceGetDefaultMemPool](<group__CUDA__DEVICE.html#group__CUDA__DEVICE_1gc8bca3c97a78816303b8aa5773b741f2> "Returns the default mempool of a device."), [cuDeviceGetMemPool](<group__CUDA__DEVICE.html#group__CUDA__DEVICE_1gdf186e9559d53a5eb18e572d48c1121b> "Gets the current mempool for a device."), [cuMemPoolCreate](<group__CUDA__MALLOC__ASYNC.html#group__CUDA__MALLOC__ASYNC_1g8aa4c143dbc20293659cd883232b95f2> "Creates a memory pool.")

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuMemPoolImportFromShareableHandle ( [CUmemoryPool](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g3b96b1ef79f0cb312b51169e9f50e722>)*Â pool_out, void*Â handle, [CUmemAllocationHandleType](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g450a23153d86fce0afe30e25d63caef9>)Â handleType, unsigned long longÂ flags )


imports a memory pool from a shared handle.

######  Parameters

`pool_out`
    \- Returned memory pool
`handle`
    \- OS handle of the pool to open
`handleType`
    \- The type of handle being imported
`flags`
    \- must be 0

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>), [CUDA_ERROR_NOT_INITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e98feb999f0af99b4a25ab26b3866f4df8>), [CUDA_ERROR_OUT_OF_MEMORY](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9264c50688ed110e8476b591befe60c02>)

###### Description

Specific allocations can be imported from the imported pool with cuMemPoolImportPointer.

If `handleType` is [CU_MEM_HANDLE_TYPE_FABRIC](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg450a23153d86fce0afe30e25d63caef9e38a182adb450da6c1a3f29cd5dca032>) and the importer process has not been granted access to the same IMEX channel as the exporter process, this API will error as [CUDA_ERROR_NOT_PERMITTED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9e23d0197c490ec332a43e55b167968a3>).

Note:

Imported memory pools do not support creating new allocations. As such imported memory pools may not be used in cuDeviceSetMemPool or [cuMemAllocFromPoolAsync](<group__CUDA__MALLOC__ASYNC.html#group__CUDA__MALLOC__ASYNC_1gf1dd6e1e2e8f767a5e0ea63f38ff260b> "Allocates memory from a specified pool with stream ordered semantics.") calls.

**See also:**

[cuMemPoolExportToShareableHandle](<group__CUDA__MALLOC__ASYNC.html#group__CUDA__MALLOC__ASYNC_1g79ed285fdfffb76932871fb96fbba8f8> "Exports a memory pool to the requested handle type."), [cuMemPoolExportPointer](<group__CUDA__MALLOC__ASYNC.html#group__CUDA__MALLOC__ASYNC_1gfe89f0478d26edaa91eb8a2e0349329d> "Export data to share a memory pool allocation between processes."), [cuMemPoolImportPointer](<group__CUDA__MALLOC__ASYNC.html#group__CUDA__MALLOC__ASYNC_1g2620bb972ed5edcce312d3689454acbd> "Import a memory pool allocation from another process.")

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuMemPoolImportPointer ( [CUdeviceptr](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g183f7b0d8ad008ea2a5fd552537ace4e>)*Â ptr_out, [CUmemoryPool](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g3b96b1ef79f0cb312b51169e9f50e722>)Â pool, [CUmemPoolPtrExportData](<structCUmemPoolPtrExportData__v1.html#structCUmemPoolPtrExportData__v1>)*Â shareData )


Import a memory pool allocation from another process.

######  Parameters

`ptr_out`
    \- pointer to imported memory
`pool`
    \- pool from which to import
`shareData`
    \- data specifying the memory to import

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>), [CUDA_ERROR_NOT_INITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e98feb999f0af99b4a25ab26b3866f4df8>), [CUDA_ERROR_OUT_OF_MEMORY](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9264c50688ed110e8476b591befe60c02>)

###### Description

Returns in `ptr_out` a pointer to the imported memory. The imported memory must not be accessed before the allocation operation completes in the exporting process. The imported memory must be freed from all importing processes before being freed in the exporting process. The pointer may be freed with cuMemFree or cuMemFreeAsync. If cuMemFreeAsync is used, the free must be completed on the importing process before the free operation on the exporting process.

Note:

The cuMemFreeAsync api may be used in the exporting process before the cuMemFreeAsync operation completes in its stream as long as the cuMemFreeAsync in the exporting process specifies a stream with a stream dependency on the importing process's cuMemFreeAsync.

**See also:**

[cuMemPoolExportToShareableHandle](<group__CUDA__MALLOC__ASYNC.html#group__CUDA__MALLOC__ASYNC_1g79ed285fdfffb76932871fb96fbba8f8> "Exports a memory pool to the requested handle type."), [cuMemPoolImportFromShareableHandle](<group__CUDA__MALLOC__ASYNC.html#group__CUDA__MALLOC__ASYNC_1g02b4f18dd8a1c45b7f302800e90cec5b> "imports a memory pool from a shared handle."), [cuMemPoolExportPointer](<group__CUDA__MALLOC__ASYNC.html#group__CUDA__MALLOC__ASYNC_1gfe89f0478d26edaa91eb8a2e0349329d> "Export data to share a memory pool allocation between processes.")

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuMemPoolSetAccess ( [CUmemoryPool](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g3b96b1ef79f0cb312b51169e9f50e722>)Â pool, const [CUmemAccessDesc](<structCUmemAccessDesc__v1.html#structCUmemAccessDesc__v1>)*Â map, size_tÂ count )


Controls visibility of pools between devices.

######  Parameters

`pool`
    \- The pool being modified
`map`
    \- Array of access descriptors. Each descriptor instructs the access to enable for a single gpu.
`count`
    \- Number of descriptors in the map array.

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_NOT_INITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e98feb999f0af99b4a25ab26b3866f4df8>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>)

###### Description

**See also:**

[cuMemAllocAsync](<group__CUDA__MALLOC__ASYNC.html#group__CUDA__MALLOC__ASYNC_1g13413273e84a641bce1929eae9e6501f> "Allocates memory with stream ordered semantics."), [cuMemFreeAsync](<group__CUDA__MALLOC__ASYNC.html#group__CUDA__MALLOC__ASYNC_1g41acf4131f672a2a75cd93d3241f10cf> "Frees memory with stream ordered semantics."), [cuDeviceGetDefaultMemPool](<group__CUDA__DEVICE.html#group__CUDA__DEVICE_1gc8bca3c97a78816303b8aa5773b741f2> "Returns the default mempool of a device."), [cuDeviceGetMemPool](<group__CUDA__DEVICE.html#group__CUDA__DEVICE_1gdf186e9559d53a5eb18e572d48c1121b> "Gets the current mempool for a device."), [cuMemPoolCreate](<group__CUDA__MALLOC__ASYNC.html#group__CUDA__MALLOC__ASYNC_1g8aa4c143dbc20293659cd883232b95f2> "Creates a memory pool.")

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuMemPoolSetAttribute ( [CUmemoryPool](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g3b96b1ef79f0cb312b51169e9f50e722>)Â pool, [CUmemPool_attribute](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g5af6ea9ddd7633be98cb7de1bbf1d9f0>)Â attr, void*Â value )


Sets attributes of a memory pool.

######  Parameters

`pool`
    \- The memory pool to modify
`attr`
    \- The attribute to modify
`value`
    \- Pointer to the value to assign

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>)

###### Description

Supported attributes are:

  * [CU_MEMPOOL_ATTR_RELEASE_THRESHOLD](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg5af6ea9ddd7633be98cb7de1bbf1d9f050fa2c731b01422ffbeb8c16ce0ba9a8>): (value type = cuuint64_t) Amount of reserved memory in bytes to hold onto before trying to release memory back to the OS. When more than the release threshold bytes of memory are held by the memory pool, the allocator will try to release memory back to the OS on the next call to stream, event or context synchronize. (default 0)

  * [CU_MEMPOOL_ATTR_REUSE_FOLLOW_EVENT_DEPENDENCIES](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg5af6ea9ddd7633be98cb7de1bbf1d9f0e11d636e9d56f9ce8a449b887fe2917f>): (value type = int) Allow [cuMemAllocAsync](<group__CUDA__MALLOC__ASYNC.html#group__CUDA__MALLOC__ASYNC_1g13413273e84a641bce1929eae9e6501f> "Allocates memory with stream ordered semantics.") to use memory asynchronously freed in another stream as long as a stream ordering dependency of the allocating stream on the free action exists. Cuda events and null stream interactions can create the required stream ordered dependencies. (default enabled)

  * [CU_MEMPOOL_ATTR_REUSE_ALLOW_OPPORTUNISTIC](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg5af6ea9ddd7633be98cb7de1bbf1d9f0d1016ed326b53c1eb06e8da5d40359cb>): (value type = int) Allow reuse of already completed frees when there is no dependency between the free and allocation. (default enabled)

  * [CU_MEMPOOL_ATTR_REUSE_ALLOW_INTERNAL_DEPENDENCIES](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg5af6ea9ddd7633be98cb7de1bbf1d9f03b7973c1b89f3a05f26702ade1124e9f>): (value type = int) Allow [cuMemAllocAsync](<group__CUDA__MALLOC__ASYNC.html#group__CUDA__MALLOC__ASYNC_1g13413273e84a641bce1929eae9e6501f> "Allocates memory with stream ordered semantics.") to insert new stream dependencies in order to establish the stream ordering required to reuse a piece of memory released by [cuMemFreeAsync](<group__CUDA__MALLOC__ASYNC.html#group__CUDA__MALLOC__ASYNC_1g41acf4131f672a2a75cd93d3241f10cf> "Frees memory with stream ordered semantics.") (default enabled).

  * [CU_MEMPOOL_ATTR_RESERVED_MEM_HIGH](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg5af6ea9ddd7633be98cb7de1bbf1d9f05ccb2736772fd27a735f15905118cbf6>): (value type = cuuint64_t) Reset the high watermark that tracks the amount of backing memory that was allocated for the memory pool. It is illegal to set this attribute to a non-zero value.

  * [CU_MEMPOOL_ATTR_USED_MEM_HIGH](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg5af6ea9ddd7633be98cb7de1bbf1d9f027fd3cf6d5a152572e55e9736da6987b>): (value type = cuuint64_t) Reset the high watermark that tracks the amount of used memory that was allocated for the memory pool.


**See also:**

[cuMemAllocAsync](<group__CUDA__MALLOC__ASYNC.html#group__CUDA__MALLOC__ASYNC_1g13413273e84a641bce1929eae9e6501f> "Allocates memory with stream ordered semantics."), [cuMemFreeAsync](<group__CUDA__MALLOC__ASYNC.html#group__CUDA__MALLOC__ASYNC_1g41acf4131f672a2a75cd93d3241f10cf> "Frees memory with stream ordered semantics."), [cuDeviceGetDefaultMemPool](<group__CUDA__DEVICE.html#group__CUDA__DEVICE_1gc8bca3c97a78816303b8aa5773b741f2> "Returns the default mempool of a device."), [cuDeviceGetMemPool](<group__CUDA__DEVICE.html#group__CUDA__DEVICE_1gdf186e9559d53a5eb18e572d48c1121b> "Gets the current mempool for a device."), [cuMemPoolCreate](<group__CUDA__MALLOC__ASYNC.html#group__CUDA__MALLOC__ASYNC_1g8aa4c143dbc20293659cd883232b95f2> "Creates a memory pool.")

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuMemPoolTrimTo ( [CUmemoryPool](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g3b96b1ef79f0cb312b51169e9f50e722>)Â pool, size_tÂ minBytesToKeep )


Tries to release memory back to the OS.

######  Parameters

`pool`
    \- The memory pool to trim
`minBytesToKeep`
    \- If the pool has less than minBytesToKeep reserved, the TrimTo operation is a no-op. Otherwise the pool will be guaranteed to have at least minBytesToKeep bytes reserved after the operation.

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_NOT_INITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e98feb999f0af99b4a25ab26b3866f4df8>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>)

###### Description

Releases memory back to the OS until the pool contains fewer than minBytesToKeep reserved bytes, or there is no more memory that the allocator can safely release. The allocator cannot release OS allocations that back outstanding asynchronous allocations. The OS allocations may happen at different granularity from the user allocations.

Note:

  * : Allocations that have not been freed count as outstanding.

  * : Allocations that have been asynchronously freed but whose completion has not been observed on the host (eg. by a synchronize) can count as outstanding.


**See also:**

[cuMemAllocAsync](<group__CUDA__MALLOC__ASYNC.html#group__CUDA__MALLOC__ASYNC_1g13413273e84a641bce1929eae9e6501f> "Allocates memory with stream ordered semantics."), [cuMemFreeAsync](<group__CUDA__MALLOC__ASYNC.html#group__CUDA__MALLOC__ASYNC_1g41acf4131f672a2a75cd93d3241f10cf> "Frees memory with stream ordered semantics."), [cuDeviceGetDefaultMemPool](<group__CUDA__DEVICE.html#group__CUDA__DEVICE_1gc8bca3c97a78816303b8aa5773b741f2> "Returns the default mempool of a device."), [cuDeviceGetMemPool](<group__CUDA__DEVICE.html#group__CUDA__DEVICE_1gdf186e9559d53a5eb18e572d48c1121b> "Gets the current mempool for a device."), [cuMemPoolCreate](<group__CUDA__MALLOC__ASYNC.html#group__CUDA__MALLOC__ASYNC_1g8aa4c143dbc20293659cd883232b95f2> "Creates a memory pool.")

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuMemSetMemPool ( [CUmemLocation](<structCUmemLocation__v1.html#structCUmemLocation__v1>)*Â location, [CUmemAllocationType](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g7ed3482e0df8712d79a99bcb3bc4a95b>)Â type, [CUmemoryPool](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g3b96b1ef79f0cb312b51169e9f50e722>)Â pool )


Sets the current memory pool for a memory location and allocation type.

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>)

###### Description

The memory location can be of one of [CU_MEM_LOCATION_TYPE_DEVICE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg75cfd5b9fa5c1c6ee2be2547bfbe882ea4409aa6b414995d628a320eafbbbb6e>), [CU_MEM_LOCATION_TYPE_HOST](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg75cfd5b9fa5c1c6ee2be2547bfbe882e46800776121a71c8dc2904518a21065a>) or [CU_MEM_LOCATION_TYPE_HOST_NUMA](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg75cfd5b9fa5c1c6ee2be2547bfbe882eb61a1d3409ed83a43b5706cc004ac861>). The allocation type can be one of [CU_MEM_ALLOCATION_TYPE_PINNED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg7ed3482e0df8712d79a99bcb3bc4a95b646624651d13be111040ffdf1161511c>) or [CU_MEM_ALLOCATION_TYPE_MANAGED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg7ed3482e0df8712d79a99bcb3bc4a95b774fc1109cfbb0a357d6701483177cc1>). When the allocation type is [CU_MEM_ALLOCATION_TYPE_MANAGED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg7ed3482e0df8712d79a99bcb3bc4a95b774fc1109cfbb0a357d6701483177cc1>), the location type can also be [CU_MEM_LOCATION_TYPE_NONE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg75cfd5b9fa5c1c6ee2be2547bfbe882ecfc8f2ab14e813f7afe8019052526fa4>) to indicate no preferred location for the managed memory pool. In all other cases, the call returns [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>).

When a memory pool is set as the current memory pool, the location parameter should be the same as the location of the pool. The location and allocation type specified must match those of the pool otherwise [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>) is returned. By default, a memory location's current memory pool is its default memory pool that can be obtained via [cuMemGetDefaultMemPool](<group__CUDA__MALLOC__ASYNC.html#group__CUDA__MALLOC__ASYNC_1gfe5111eb15c977cd8d87132ff481072f> "Returns the default memory pool for a given location and allocation type."). If the location type is [CU_MEM_LOCATION_TYPE_DEVICE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg75cfd5b9fa5c1c6ee2be2547bfbe882ea4409aa6b414995d628a320eafbbbb6e>) and the allocation type is [CU_MEM_ALLOCATION_TYPE_PINNED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg7ed3482e0df8712d79a99bcb3bc4a95b646624651d13be111040ffdf1161511c>), then this API is the equivalent of calling [cuDeviceSetMemPool](<group__CUDA__DEVICE.html#group__CUDA__DEVICE_1g4f2f276b84d9c2eaefdc76d6274db4a0> "Sets the current memory pool of a device.") with the location id as the device. For further details on the implications, please refer to the documentation for [cuDeviceSetMemPool](<group__CUDA__DEVICE.html#group__CUDA__DEVICE_1g4f2f276b84d9c2eaefdc76d6274db4a0> "Sets the current memory pool of a device.").

Note:

Use [cuMemAllocFromPoolAsync](<group__CUDA__MALLOC__ASYNC.html#group__CUDA__MALLOC__ASYNC_1gf1dd6e1e2e8f767a5e0ea63f38ff260b> "Allocates memory from a specified pool with stream ordered semantics.") to specify asynchronous allocations from a device different than the one the stream runs on.

**See also:**

[cuDeviceGetDefaultMemPool](<group__CUDA__DEVICE.html#group__CUDA__DEVICE_1gc8bca3c97a78816303b8aa5773b741f2> "Returns the default mempool of a device."), [cuDeviceGetMemPool](<group__CUDA__DEVICE.html#group__CUDA__DEVICE_1gdf186e9559d53a5eb18e572d48c1121b> "Gets the current mempool for a device."), [cuMemGetMemPool](<group__CUDA__MALLOC__ASYNC.html#group__CUDA__MALLOC__ASYNC_1g5283d28ee187477e1a2b06fd731ec575> "Gets the current memory pool for a memory location and of a particular allocation type."), [cuMemPoolCreate](<group__CUDA__MALLOC__ASYNC.html#group__CUDA__MALLOC__ASYNC_1g8aa4c143dbc20293659cd883232b95f2> "Creates a memory pool."), [cuMemPoolDestroy](<group__CUDA__MALLOC__ASYNC.html#group__CUDA__MALLOC__ASYNC_1ge0e211115e5ad1c79250b9dd425b77f7> "Destroys the specified memory pool."), [cuMemAllocFromPoolAsync](<group__CUDA__MALLOC__ASYNC.html#group__CUDA__MALLOC__ASYNC_1gf1dd6e1e2e8f767a5e0ea63f38ff260b> "Allocates memory from a specified pool with stream ordered semantics.")

* * *


---

# Multicast Object Management

## 6.16.Â Multicast Object Management

This section describes the CUDA multicast object operations exposed by the low-level CUDA driver application programming interface.

**overview**

A multicast object created via [cuMulticastCreate](<group__CUDA__MULTICAST.html#group__CUDA__MULTICAST_1gd4413361f466d4ed86a93d8c309c0242> "Create a generic allocation handle representing a multicast object described by the given properties.") enables certain memory operations to be broadcast to a team of devices. Devices can be added to a multicast object via [cuMulticastAddDevice](<group__CUDA__MULTICAST.html#group__CUDA__MULTICAST_1g2df07b38ff506c519e9f799c5ddf7e5d> "Associate a device to a multicast object."). Memory can be bound on each participating device via [cuMulticastBindMem](<group__CUDA__MULTICAST.html#group__CUDA__MULTICAST_1gcadf88b616a3f766f6279288e435a4bb> "Bind a memory allocation represented by a handle to a multicast object."), [cuMulticastBindMem_v2](<group__CUDA__MULTICAST.html#group__CUDA__MULTICAST_1g0e0ed2e81af121bdcbb54e1a9c4e63a5> "Bind a memory allocation represented by a handle to a multicast object."), [cuMulticastBindAddr](<group__CUDA__MULTICAST.html#group__CUDA__MULTICAST_1g07c8cf1d3bf1d04a2d1867f09647b03f> "Bind a memory allocation represented by a virtual address to a multicast object."), or [cuMulticastBindAddr_v2](<group__CUDA__MULTICAST.html#group__CUDA__MULTICAST_1g0eb82d8911bf179ae239d522da049bed> "Bind a memory allocation represented by a virtual address to a multicast object."). Multicast objects can be mapped into a device's virtual address space using the virtual memmory management APIs (see [cuMemMap](<group__CUDA__VA.html#group__CUDA__VA_1gff1d395423af5c5c75375516959dae56> "Maps an allocation handle to a reserved virtual address range.") and [cuMemSetAccess](<group__CUDA__VA.html#group__CUDA__VA_1g1b6b12b10e8324bf462ecab4e7ef30e1> "Set the access flags for each location specified in desc for the given virtual address range.")).

**Supported Platforms**

Support for multicast on a specific device can be queried using the device attribute [CU_DEVICE_ATTRIBUTE_MULTICAST_SUPPORTED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gge12b8a782bebe21b1ac0091bf9f4e2a3ce470c9ff9166a3a8740bef623f5d299>)

### Functions

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuMulticastAddDevice](<#group__CUDA__MULTICAST_1g2df07b38ff506c519e9f799c5ddf7e5d>) ( CUmemGenericAllocationHandleÂ mcHandle, [CUdevice](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g41ca2a24a242b36ef2ca77330b5fb72a>)Â dev )
     Associate a device to a multicast object.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuMulticastBindAddr](<#group__CUDA__MULTICAST_1g07c8cf1d3bf1d04a2d1867f09647b03f>) ( CUmemGenericAllocationHandleÂ mcHandle, size_tÂ mcOffset, [CUdeviceptr](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g183f7b0d8ad008ea2a5fd552537ace4e>)Â memptr, size_tÂ size, unsigned long longÂ flags )
     Bind a memory allocation represented by a virtual address to a multicast object.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuMulticastBindAddr_v2](<#group__CUDA__MULTICAST_1g0eb82d8911bf179ae239d522da049bed>) ( CUmemGenericAllocationHandleÂ mcHandle, [CUdevice](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g41ca2a24a242b36ef2ca77330b5fb72a>)Â dev, size_tÂ mcOffset, [CUdeviceptr](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g183f7b0d8ad008ea2a5fd552537ace4e>)Â memptr, size_tÂ size, unsigned long longÂ flags )
     Bind a memory allocation represented by a virtual address to a multicast object.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuMulticastBindMem](<#group__CUDA__MULTICAST_1gcadf88b616a3f766f6279288e435a4bb>) ( CUmemGenericAllocationHandleÂ mcHandle, size_tÂ mcOffset, CUmemGenericAllocationHandleÂ memHandle, size_tÂ memOffset, size_tÂ size, unsigned long longÂ flags )
     Bind a memory allocation represented by a handle to a multicast object.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuMulticastBindMem_v2](<#group__CUDA__MULTICAST_1g0e0ed2e81af121bdcbb54e1a9c4e63a5>) ( CUmemGenericAllocationHandleÂ mcHandle, [CUdevice](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g41ca2a24a242b36ef2ca77330b5fb72a>)Â dev, size_tÂ mcOffset, CUmemGenericAllocationHandleÂ memHandle, size_tÂ memOffset, size_tÂ size, unsigned long longÂ flags )
     Bind a memory allocation represented by a handle to a multicast object.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuMulticastCreate](<#group__CUDA__MULTICAST_1gd4413361f466d4ed86a93d8c309c0242>) ( CUmemGenericAllocationHandle*Â mcHandle, const [CUmulticastObjectProp](<structCUmulticastObjectProp__v1.html#structCUmulticastObjectProp__v1>)*Â prop )
     Create a generic allocation handle representing a multicast object described by the given properties.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuMulticastGetGranularity](<#group__CUDA__MULTICAST_1g067a02ad98f4e01f149011f523fec547>) ( size_t*Â granularity, const [CUmulticastObjectProp](<structCUmulticastObjectProp__v1.html#structCUmulticastObjectProp__v1>)*Â prop, [CUmulticastGranularity_flags](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gcdeff171670a788001418262a0f88378>)Â option )
     Calculates either the minimal or recommended granularity for multicast object.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuMulticastUnbind](<#group__CUDA__MULTICAST_1g424b4563760cc5dab52ee9a8d28656ac>) ( CUmemGenericAllocationHandleÂ mcHandle, [CUdevice](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g41ca2a24a242b36ef2ca77330b5fb72a>)Â dev, size_tÂ mcOffset, size_tÂ size )
     Unbind any memory allocations bound to a multicast object at a given offset and upto a given size.

### Functions

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuMulticastAddDevice ( CUmemGenericAllocationHandleÂ mcHandle, [CUdevice](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g41ca2a24a242b36ef2ca77330b5fb72a>)Â dev )


Associate a device to a multicast object.

######  Parameters

`mcHandle`
    Handle representing a multicast object.
`dev`
    Device that will be associated to the multicast object.

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>), [CUDA_ERROR_OUT_OF_MEMORY](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9264c50688ed110e8476b591befe60c02>), [CUDA_ERROR_INVALID_DEVICE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e96f047e7215788ca96c81af92a04bfb6c>), [CUDA_ERROR_NOT_INITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e98feb999f0af99b4a25ab26b3866f4df8>), [CUDA_ERROR_DEINITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9acf52f132faf29b473cdda6061f0f44a>), [CUDA_ERROR_NOT_PERMITTED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9e23d0197c490ec332a43e55b167968a3>), [CUDA_ERROR_NOT_SUPPORTED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e954756ae7ade0dfd09faeccb513dd831b>)

###### Description

Associates a device to a multicast object. The added device will be a part of the multicast team of size specified by [CUmulticastObjectProp::numDevices](<structCUmulticastObjectProp__v1.html#structCUmulticastObjectProp__v1_1e5d44c9262847a6c74e4ae37acdc7478>) during [cuMulticastCreate](<group__CUDA__MULTICAST.html#group__CUDA__MULTICAST_1gd4413361f466d4ed86a93d8c309c0242> "Create a generic allocation handle representing a multicast object described by the given properties."). The association of the device to the multicast object is permanent during the life time of the multicast object. All devices must be added to the multicast team before any memory can be bound to any device in the team. Any calls to [cuMulticastBindMem](<group__CUDA__MULTICAST.html#group__CUDA__MULTICAST_1gcadf88b616a3f766f6279288e435a4bb> "Bind a memory allocation represented by a handle to a multicast object."), [cuMulticastBindMem_v2](<group__CUDA__MULTICAST.html#group__CUDA__MULTICAST_1g0e0ed2e81af121bdcbb54e1a9c4e63a5> "Bind a memory allocation represented by a handle to a multicast object."), [cuMulticastBindAddr](<group__CUDA__MULTICAST.html#group__CUDA__MULTICAST_1g07c8cf1d3bf1d04a2d1867f09647b03f> "Bind a memory allocation represented by a virtual address to a multicast object."), or [cuMulticastBindAddr_v2](<group__CUDA__MULTICAST.html#group__CUDA__MULTICAST_1g0eb82d8911bf179ae239d522da049bed> "Bind a memory allocation represented by a virtual address to a multicast object.") will block until all devices have been added. Similarly all devices must be added to the multicast team before a virtual address range can be mapped to the multicast object. A call to [cuMemMap](<group__CUDA__VA.html#group__CUDA__VA_1gff1d395423af5c5c75375516959dae56> "Maps an allocation handle to a reserved virtual address range.") will block until all devices have been added.

**See also:**

[cuMulticastCreate](<group__CUDA__MULTICAST.html#group__CUDA__MULTICAST_1gd4413361f466d4ed86a93d8c309c0242> "Create a generic allocation handle representing a multicast object described by the given properties."), [cuMulticastBindMem](<group__CUDA__MULTICAST.html#group__CUDA__MULTICAST_1gcadf88b616a3f766f6279288e435a4bb> "Bind a memory allocation represented by a handle to a multicast object."), [cuMulticastBindAddr](<group__CUDA__MULTICAST.html#group__CUDA__MULTICAST_1g07c8cf1d3bf1d04a2d1867f09647b03f> "Bind a memory allocation represented by a virtual address to a multicast object.")

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuMulticastBindAddr ( CUmemGenericAllocationHandleÂ mcHandle, size_tÂ mcOffset, [CUdeviceptr](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g183f7b0d8ad008ea2a5fd552537ace4e>)Â memptr, size_tÂ size, unsigned long longÂ flags )


Bind a memory allocation represented by a virtual address to a multicast object.

######  Parameters

`mcHandle`
    Handle representing a multicast object.
`mcOffset`
    Offset into multicast va range for attachment.
`memptr`
    Virtual address of the memory allocation.
`size`
    Size of memory that will be bound to the multicast object.
`flags`
    Flags for future use, must be zero now.

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>), [CUDA_ERROR_INVALID_DEVICE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e96f047e7215788ca96c81af92a04bfb6c>), [CUDA_ERROR_NOT_INITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e98feb999f0af99b4a25ab26b3866f4df8>), [CUDA_ERROR_DEINITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9acf52f132faf29b473cdda6061f0f44a>), [CUDA_ERROR_NOT_PERMITTED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9e23d0197c490ec332a43e55b167968a3>), [CUDA_ERROR_NOT_SUPPORTED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e954756ae7ade0dfd09faeccb513dd831b>), [CUDA_ERROR_OUT_OF_MEMORY](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9264c50688ed110e8476b591befe60c02>), [CUDA_ERROR_SYSTEM_NOT_READY](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9659c7730ee79fae8262043448f2ce1e3>), [CUDA_ERROR_ILLEGAL_STATE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9f5fd9c15b97a258f341bab23b0b505a5>)

###### Description

Binds a memory allocation specified by its mapped address `memptr` to a multicast object represented by `mcHandle`. The memory must have been allocated via [cuMemCreate](<group__CUDA__VA.html#group__CUDA__VA_1g899d69a862bba36449789c64b430dc7c> "Create a CUDA memory handle representing a memory allocation of a given size described by the given properties.") or [cudaMallocAsync](<../cuda-runtime-api/group__CUDART__HIGHLEVEL.html#group__CUDART__HIGHLEVEL_1ga31efcffc48981621feddd98d71a0feb>). The intended `size` of the bind, the offset in the multicast range `mcOffset` and `memptr` must be a multiple of the value returned by [cuMulticastGetGranularity](<group__CUDA__MULTICAST.html#group__CUDA__MULTICAST_1g067a02ad98f4e01f149011f523fec547> "Calculates either the minimal or recommended granularity for multicast object.") with the flag [CU_MULTICAST_GRANULARITY_MINIMUM](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggcdeff171670a788001418262a0f88378790ecc4b1f2c2f6e2c9bc21b230872a9>). For best performance however, `size`, `mcOffset` and `memptr` should be aligned to the value returned by [cuMulticastGetGranularity](<group__CUDA__MULTICAST.html#group__CUDA__MULTICAST_1g067a02ad98f4e01f149011f523fec547> "Calculates either the minimal or recommended granularity for multicast object.") with the flag [CU_MULTICAST_GRANULARITY_RECOMMENDED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggcdeff171670a788001418262a0f88378dfff741c8fa1dd2f96e584939b0c53ce>).

The `size` cannot be larger than the size of the allocated memory. Similarly the `size` \+ `mcOffset` cannot be larger than the total size of the multicast object. The memory allocation must have beeen created on one of the devices that was added to the multicast team via [cuMulticastAddDevice](<group__CUDA__MULTICAST.html#group__CUDA__MULTICAST_1g2df07b38ff506c519e9f799c5ddf7e5d> "Associate a device to a multicast object."). Externally shareable as well as imported multicast objects can be bound only to externally shareable memory. Note that this call will return CUDA_ERROR_OUT_OF_MEMORY if there are insufficient resources required to perform the bind. This call may also return CUDA_ERROR_SYSTEM_NOT_READY if the necessary system software is not initialized or running.

This call may return CUDA_ERROR_ILLEGAL_STATE if the system configuration is in an illegal state. In such cases, to continue using multicast, verify that the system configuration is in a valid state and all required driver daemons are running properly.

**See also:**

[cuMulticastCreate](<group__CUDA__MULTICAST.html#group__CUDA__MULTICAST_1gd4413361f466d4ed86a93d8c309c0242> "Create a generic allocation handle representing a multicast object described by the given properties."), [cuMulticastAddDevice](<group__CUDA__MULTICAST.html#group__CUDA__MULTICAST_1g2df07b38ff506c519e9f799c5ddf7e5d> "Associate a device to a multicast object."), [cuMemCreate](<group__CUDA__VA.html#group__CUDA__VA_1g899d69a862bba36449789c64b430dc7c> "Create a CUDA memory handle representing a memory allocation of a given size described by the given properties.")

[cuMulticastBindAddr_v2](<group__CUDA__MULTICAST.html#group__CUDA__MULTICAST_1g0eb82d8911bf179ae239d522da049bed> "Bind a memory allocation represented by a virtual address to a multicast object.")

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuMulticastBindAddr_v2 ( CUmemGenericAllocationHandleÂ mcHandle, [CUdevice](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g41ca2a24a242b36ef2ca77330b5fb72a>)Â dev, size_tÂ mcOffset, [CUdeviceptr](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g183f7b0d8ad008ea2a5fd552537ace4e>)Â memptr, size_tÂ size, unsigned long longÂ flags )


Bind a memory allocation represented by a virtual address to a multicast object.

######  Parameters

`mcHandle`
    Handle representing a multicast object.
`dev`
    The device that for which the multicast memory binding will be applicable.
`mcOffset`
    Offset into multicast va range for attachment.
`memptr`
    Virtual address of the memory allocation.
`size`
    Size of memory that will be bound to the multicast object.
`flags`
    Flags for future use, must be zero now.

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>), [CUDA_ERROR_INVALID_DEVICE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e96f047e7215788ca96c81af92a04bfb6c>), [CUDA_ERROR_NOT_INITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e98feb999f0af99b4a25ab26b3866f4df8>), [CUDA_ERROR_DEINITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9acf52f132faf29b473cdda6061f0f44a>), [CUDA_ERROR_NOT_PERMITTED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9e23d0197c490ec332a43e55b167968a3>), [CUDA_ERROR_NOT_SUPPORTED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e954756ae7ade0dfd09faeccb513dd831b>), [CUDA_ERROR_OUT_OF_MEMORY](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9264c50688ed110e8476b591befe60c02>), [CUDA_ERROR_SYSTEM_NOT_READY](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9659c7730ee79fae8262043448f2ce1e3>), [CUDA_ERROR_ILLEGAL_STATE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9f5fd9c15b97a258f341bab23b0b505a5>)

###### Description

Binds a memory allocation specified by its mapped address `memptr` to a multicast object represented by `mcHandle`. The binding will be applicable for the device `dev`. The memory must have been allocated via [cuMemCreate](<group__CUDA__VA.html#group__CUDA__VA_1g899d69a862bba36449789c64b430dc7c> "Create a CUDA memory handle representing a memory allocation of a given size described by the given properties.") or [cudaMallocAsync](<../cuda-runtime-api/group__CUDART__HIGHLEVEL.html#group__CUDART__HIGHLEVEL_1ga31efcffc48981621feddd98d71a0feb>). The intended `size` of the bind, the offset in the multicast range `mcOffset` and `memptr` must be a multiple of the value returned by [cuMulticastGetGranularity](<group__CUDA__MULTICAST.html#group__CUDA__MULTICAST_1g067a02ad98f4e01f149011f523fec547> "Calculates either the minimal or recommended granularity for multicast object.") with the flag [CU_MULTICAST_GRANULARITY_MINIMUM](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggcdeff171670a788001418262a0f88378790ecc4b1f2c2f6e2c9bc21b230872a9>). For best performance however, `size`, `mcOffset` and `memptr` should be aligned to the value returned by [cuMulticastGetGranularity](<group__CUDA__MULTICAST.html#group__CUDA__MULTICAST_1g067a02ad98f4e01f149011f523fec547> "Calculates either the minimal or recommended granularity for multicast object.") with the flag [CU_MULTICAST_GRANULARITY_RECOMMENDED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggcdeff171670a788001418262a0f88378dfff741c8fa1dd2f96e584939b0c53ce>).

The `size` cannot be larger than the size of the allocated memory. Similarly the `size` \+ `mcOffset` cannot be larger than the total size of the multicast object. For device memory, i.e., type [CU_MEM_LOCATION_TYPE_DEVICE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg75cfd5b9fa5c1c6ee2be2547bfbe882ea4409aa6b414995d628a320eafbbbb6e>), the memory allocation must have been created on the device specified by `dev`. For host NUMA memory, i.e., type [CU_MEM_LOCATION_TYPE_HOST_NUMA](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg75cfd5b9fa5c1c6ee2be2547bfbe882eb61a1d3409ed83a43b5706cc004ac861>), the memory allocation must have been created on the CPU NUMA node closest to `dev`. That is, the value returned when querying [CU_DEVICE_ATTRIBUTE_HOST_NUMA_ID](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gge12b8a782bebe21b1ac0091bf9f4e2a32583f8184b09441b3c83b1bee7849556>) for `dev`, must be the CPU NUMA node where the memory was allocated. In both cases, the device named by `dev` must have been added to the multicast team via [cuMulticastAddDevice](<group__CUDA__MULTICAST.html#group__CUDA__MULTICAST_1g2df07b38ff506c519e9f799c5ddf7e5d> "Associate a device to a multicast object."). Externally shareable as well as imported multicast objects can be bound only to externally shareable memory. Note that this call will return CUDA_ERROR_OUT_OF_MEMORY if there are insufficient resources required to perform the bind. This call may also return CUDA_ERROR_SYSTEM_NOT_READY if the necessary system software is not initialized or running.

This call may return CUDA_ERROR_ILLEGAL_STATE if the system configuration is in an illegal state. In such cases, to continue using multicast, verify that the system configuration is in a valid state and all required driver daemons are running properly.

**See also:**

[cuMulticastCreate](<group__CUDA__MULTICAST.html#group__CUDA__MULTICAST_1gd4413361f466d4ed86a93d8c309c0242> "Create a generic allocation handle representing a multicast object described by the given properties."), [cuMulticastAddDevice](<group__CUDA__MULTICAST.html#group__CUDA__MULTICAST_1g2df07b38ff506c519e9f799c5ddf7e5d> "Associate a device to a multicast object."), [cuMemCreate](<group__CUDA__VA.html#group__CUDA__VA_1g899d69a862bba36449789c64b430dc7c> "Create a CUDA memory handle representing a memory allocation of a given size described by the given properties.")

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuMulticastBindMem ( CUmemGenericAllocationHandleÂ mcHandle, size_tÂ mcOffset, CUmemGenericAllocationHandleÂ memHandle, size_tÂ memOffset, size_tÂ size, unsigned long longÂ flags )


Bind a memory allocation represented by a handle to a multicast object.

######  Parameters

`mcHandle`
    Handle representing a multicast object.
`mcOffset`
    Offset into the multicast object for attachment.
`memHandle`
    Handle representing a memory allocation.
`memOffset`
    Offset into the memory for attachment.
`size`
    Size of the memory that will be bound to the multicast object.
`flags`
    Flags for future use, must be zero for now.

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>), [CUDA_ERROR_INVALID_DEVICE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e96f047e7215788ca96c81af92a04bfb6c>), [CUDA_ERROR_NOT_INITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e98feb999f0af99b4a25ab26b3866f4df8>), [CUDA_ERROR_DEINITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9acf52f132faf29b473cdda6061f0f44a>), [CUDA_ERROR_NOT_PERMITTED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9e23d0197c490ec332a43e55b167968a3>), [CUDA_ERROR_NOT_SUPPORTED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e954756ae7ade0dfd09faeccb513dd831b>), [CUDA_ERROR_OUT_OF_MEMORY](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9264c50688ed110e8476b591befe60c02>), [CUDA_ERROR_SYSTEM_NOT_READY](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9659c7730ee79fae8262043448f2ce1e3>), [CUDA_ERROR_ILLEGAL_STATE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9f5fd9c15b97a258f341bab23b0b505a5>)

###### Description

Binds a memory allocation specified by `memHandle` and created via [cuMemCreate](<group__CUDA__VA.html#group__CUDA__VA_1g899d69a862bba36449789c64b430dc7c> "Create a CUDA memory handle representing a memory allocation of a given size described by the given properties.") to a multicast object represented by `mcHandle` and created via [cuMulticastCreate](<group__CUDA__MULTICAST.html#group__CUDA__MULTICAST_1gd4413361f466d4ed86a93d8c309c0242> "Create a generic allocation handle representing a multicast object described by the given properties."). The intended `size` of the bind, the offset in the multicast range `mcOffset` as well as the offset in the memory `memOffset` must be a multiple of the value returned by [cuMulticastGetGranularity](<group__CUDA__MULTICAST.html#group__CUDA__MULTICAST_1g067a02ad98f4e01f149011f523fec547> "Calculates either the minimal or recommended granularity for multicast object.") with the flag [CU_MULTICAST_GRANULARITY_MINIMUM](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggcdeff171670a788001418262a0f88378790ecc4b1f2c2f6e2c9bc21b230872a9>). For best performance however, `size`, `mcOffset` and `memOffset` should be aligned to the granularity of the memory allocation(see ::cuMemGetAllocationGranularity) or to the value returned by [cuMulticastGetGranularity](<group__CUDA__MULTICAST.html#group__CUDA__MULTICAST_1g067a02ad98f4e01f149011f523fec547> "Calculates either the minimal or recommended granularity for multicast object.") with the flag [CU_MULTICAST_GRANULARITY_RECOMMENDED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggcdeff171670a788001418262a0f88378dfff741c8fa1dd2f96e584939b0c53ce>).

The `size` \+ `memOffset` cannot be larger than the size of the allocated memory. Similarly the `size` \+ `mcOffset` cannot be larger than the size of the multicast object. The memory allocation must have beeen created on one of the devices that was added to the multicast team via [cuMulticastAddDevice](<group__CUDA__MULTICAST.html#group__CUDA__MULTICAST_1g2df07b38ff506c519e9f799c5ddf7e5d> "Associate a device to a multicast object."). Externally shareable as well as imported multicast objects can be bound only to externally shareable memory. Note that this call will return CUDA_ERROR_OUT_OF_MEMORY if there are insufficient resources required to perform the bind. This call may also return CUDA_ERROR_SYSTEM_NOT_READY if the necessary system software is not initialized or running.

This call may return CUDA_ERROR_ILLEGAL_STATE if the system configuration is in an illegal state. In such cases, to continue using multicast, verify that the system configuration is in a valid state and all required driver daemons are running properly.

**See also:**

[cuMulticastCreate](<group__CUDA__MULTICAST.html#group__CUDA__MULTICAST_1gd4413361f466d4ed86a93d8c309c0242> "Create a generic allocation handle representing a multicast object described by the given properties."), [cuMulticastAddDevice](<group__CUDA__MULTICAST.html#group__CUDA__MULTICAST_1g2df07b38ff506c519e9f799c5ddf7e5d> "Associate a device to a multicast object."), [cuMemCreate](<group__CUDA__VA.html#group__CUDA__VA_1g899d69a862bba36449789c64b430dc7c> "Create a CUDA memory handle representing a memory allocation of a given size described by the given properties.")

[cuMulticastBindMem_v2](<group__CUDA__MULTICAST.html#group__CUDA__MULTICAST_1g0e0ed2e81af121bdcbb54e1a9c4e63a5> "Bind a memory allocation represented by a handle to a multicast object.")

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuMulticastBindMem_v2 ( CUmemGenericAllocationHandleÂ mcHandle, [CUdevice](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g41ca2a24a242b36ef2ca77330b5fb72a>)Â dev, size_tÂ mcOffset, CUmemGenericAllocationHandleÂ memHandle, size_tÂ memOffset, size_tÂ size, unsigned long longÂ flags )


Bind a memory allocation represented by a handle to a multicast object.

######  Parameters

`mcHandle`
    Handle representing a multicast object.
`dev`
    The device that for which the multicast memory binding will be applicable.
`mcOffset`
    Offset into the multicast object for attachment.
`memHandle`
    Handle representing a memory allocation.
`memOffset`
    Offset into the memory for attachment.
`size`
    Size of the memory that will be bound to the multicast object.
`flags`
    Flags for future use, must be zero for now.

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>), [CUDA_ERROR_INVALID_DEVICE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e96f047e7215788ca96c81af92a04bfb6c>), [CUDA_ERROR_NOT_INITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e98feb999f0af99b4a25ab26b3866f4df8>), [CUDA_ERROR_DEINITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9acf52f132faf29b473cdda6061f0f44a>), [CUDA_ERROR_NOT_PERMITTED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9e23d0197c490ec332a43e55b167968a3>), [CUDA_ERROR_NOT_SUPPORTED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e954756ae7ade0dfd09faeccb513dd831b>), [CUDA_ERROR_OUT_OF_MEMORY](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9264c50688ed110e8476b591befe60c02>), [CUDA_ERROR_SYSTEM_NOT_READY](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9659c7730ee79fae8262043448f2ce1e3>), [CUDA_ERROR_ILLEGAL_STATE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9f5fd9c15b97a258f341bab23b0b505a5>)

###### Description

Binds a memory allocation specified by `memHandle` and created via [cuMemCreate](<group__CUDA__VA.html#group__CUDA__VA_1g899d69a862bba36449789c64b430dc7c> "Create a CUDA memory handle representing a memory allocation of a given size described by the given properties.") to a multicast object represented by `mcHandle` and created via [cuMulticastCreate](<group__CUDA__MULTICAST.html#group__CUDA__MULTICAST_1gd4413361f466d4ed86a93d8c309c0242> "Create a generic allocation handle representing a multicast object described by the given properties."). The binding will be applicable for the device `dev`. The intended `size` of the bind, the offset in the multicast range `mcOffset` as well as the offset in the memory `memOffset` must be a multiple of the value returned by [cuMulticastGetGranularity](<group__CUDA__MULTICAST.html#group__CUDA__MULTICAST_1g067a02ad98f4e01f149011f523fec547> "Calculates either the minimal or recommended granularity for multicast object.") with the flag [CU_MULTICAST_GRANULARITY_MINIMUM](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggcdeff171670a788001418262a0f88378790ecc4b1f2c2f6e2c9bc21b230872a9>). For best performance however, `size`, `mcOffset` and `memOffset` should be aligned to the granularity of the memory allocation(see ::cuMemGetAllocationGranularity) or to the value returned by [cuMulticastGetGranularity](<group__CUDA__MULTICAST.html#group__CUDA__MULTICAST_1g067a02ad98f4e01f149011f523fec547> "Calculates either the minimal or recommended granularity for multicast object.") with the flag [CU_MULTICAST_GRANULARITY_RECOMMENDED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggcdeff171670a788001418262a0f88378dfff741c8fa1dd2f96e584939b0c53ce>).

The `size` \+ `memOffset` cannot be larger than the size of the allocated memory. Similarly the `size` \+ `mcOffset` cannot be larger than the size of the multicast object. The memory allocation must have beeen created on one of the devices that was added to the multicast team via [cuMulticastAddDevice](<group__CUDA__MULTICAST.html#group__CUDA__MULTICAST_1g2df07b38ff506c519e9f799c5ddf7e5d> "Associate a device to a multicast object."). For device memory, i.e., type [CU_MEM_LOCATION_TYPE_DEVICE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg75cfd5b9fa5c1c6ee2be2547bfbe882ea4409aa6b414995d628a320eafbbbb6e>), the memory allocation must have been created on the device specified by `dev`. For host NUMA memory, i.e., type [CU_MEM_LOCATION_TYPE_HOST_NUMA](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg75cfd5b9fa5c1c6ee2be2547bfbe882eb61a1d3409ed83a43b5706cc004ac861>), the memory allocation must have been created on the CPU NUMA node closest to `dev`. That is, the value returned when querying [CU_DEVICE_ATTRIBUTE_HOST_NUMA_ID](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gge12b8a782bebe21b1ac0091bf9f4e2a32583f8184b09441b3c83b1bee7849556>) for `dev`, must be the CPU NUMA node where the memory was allocated. In both cases, the device named by `dev` must have been added to the multicast team via [cuMulticastAddDevice](<group__CUDA__MULTICAST.html#group__CUDA__MULTICAST_1g2df07b38ff506c519e9f799c5ddf7e5d> "Associate a device to a multicast object."). Externally shareable as well as imported multicast objects can be bound only to externally shareable memory. Note that this call will return CUDA_ERROR_OUT_OF_MEMORY if there are insufficient resources required to perform the bind. This call may also return CUDA_ERROR_SYSTEM_NOT_READY if the necessary system software is not initialized or running.

This call may return CUDA_ERROR_ILLEGAL_STATE if the system configuration is in an illegal state. In such cases, to continue using multicast, verify that the system configuration is in a valid state and all required driver daemons are running properly.

**See also:**

[cuMulticastCreate](<group__CUDA__MULTICAST.html#group__CUDA__MULTICAST_1gd4413361f466d4ed86a93d8c309c0242> "Create a generic allocation handle representing a multicast object described by the given properties."), [cuMulticastAddDevice](<group__CUDA__MULTICAST.html#group__CUDA__MULTICAST_1g2df07b38ff506c519e9f799c5ddf7e5d> "Associate a device to a multicast object."), [cuMemCreate](<group__CUDA__VA.html#group__CUDA__VA_1g899d69a862bba36449789c64b430dc7c> "Create a CUDA memory handle representing a memory allocation of a given size described by the given properties.")

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuMulticastCreate ( CUmemGenericAllocationHandle*Â mcHandle, const [CUmulticastObjectProp](<structCUmulticastObjectProp__v1.html#structCUmulticastObjectProp__v1>)*Â prop )


Create a generic allocation handle representing a multicast object described by the given properties.

######  Parameters

`mcHandle`
    Value of handle returned.
`prop`
    Properties of the multicast object to create.

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>), [CUDA_ERROR_OUT_OF_MEMORY](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9264c50688ed110e8476b591befe60c02>), [CUDA_ERROR_INVALID_DEVICE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e96f047e7215788ca96c81af92a04bfb6c>), [CUDA_ERROR_NOT_INITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e98feb999f0af99b4a25ab26b3866f4df8>), [CUDA_ERROR_DEINITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9acf52f132faf29b473cdda6061f0f44a>), [CUDA_ERROR_NOT_PERMITTED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9e23d0197c490ec332a43e55b167968a3>), [CUDA_ERROR_NOT_SUPPORTED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e954756ae7ade0dfd09faeccb513dd831b>)

###### Description

This creates a multicast object as described by `prop`. The number of participating devices is specified by [CUmulticastObjectProp::numDevices](<structCUmulticastObjectProp__v1.html#structCUmulticastObjectProp__v1_1e5d44c9262847a6c74e4ae37acdc7478>). Devices can be added to the multicast object via [cuMulticastAddDevice](<group__CUDA__MULTICAST.html#group__CUDA__MULTICAST_1g2df07b38ff506c519e9f799c5ddf7e5d> "Associate a device to a multicast object."). All participating devices must be added to the multicast object before memory can be bound to it. Memory is bound to the multicast object via [cuMulticastBindMem](<group__CUDA__MULTICAST.html#group__CUDA__MULTICAST_1gcadf88b616a3f766f6279288e435a4bb> "Bind a memory allocation represented by a handle to a multicast object."), [cuMulticastBindMem_v2](<group__CUDA__MULTICAST.html#group__CUDA__MULTICAST_1g0e0ed2e81af121bdcbb54e1a9c4e63a5> "Bind a memory allocation represented by a handle to a multicast object."), [cuMulticastBindAddr](<group__CUDA__MULTICAST.html#group__CUDA__MULTICAST_1g07c8cf1d3bf1d04a2d1867f09647b03f> "Bind a memory allocation represented by a virtual address to a multicast object."), or [cuMulticastBindAddr_v2](<group__CUDA__MULTICAST.html#group__CUDA__MULTICAST_1g0eb82d8911bf179ae239d522da049bed> "Bind a memory allocation represented by a virtual address to a multicast object."). and can be unbound via [cuMulticastUnbind](<group__CUDA__MULTICAST.html#group__CUDA__MULTICAST_1g424b4563760cc5dab52ee9a8d28656ac> "Unbind any memory allocations bound to a multicast object at a given offset and upto a given size."). The total amount of memory that can be bound per device is specified by :[CUmulticastObjectProp::size](<structCUmulticastObjectProp__v1.html#structCUmulticastObjectProp__v1_1a45dfd715e2e442fcc7e43f5ce2f8a46>). This size must be a multiple of the value returned by [cuMulticastGetGranularity](<group__CUDA__MULTICAST.html#group__CUDA__MULTICAST_1g067a02ad98f4e01f149011f523fec547> "Calculates either the minimal or recommended granularity for multicast object.") with the flag [CU_MULTICAST_GRANULARITY_MINIMUM](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggcdeff171670a788001418262a0f88378790ecc4b1f2c2f6e2c9bc21b230872a9>). For best performance however, the size should be aligned to the value returned by [cuMulticastGetGranularity](<group__CUDA__MULTICAST.html#group__CUDA__MULTICAST_1g067a02ad98f4e01f149011f523fec547> "Calculates either the minimal or recommended granularity for multicast object.") with the flag [CU_MULTICAST_GRANULARITY_RECOMMENDED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggcdeff171670a788001418262a0f88378dfff741c8fa1dd2f96e584939b0c53ce>).

After all participating devices have been added, multicast objects can also be mapped to a device's virtual address space using the virtual memory management APIs (see [cuMemMap](<group__CUDA__VA.html#group__CUDA__VA_1gff1d395423af5c5c75375516959dae56> "Maps an allocation handle to a reserved virtual address range.") and [cuMemSetAccess](<group__CUDA__VA.html#group__CUDA__VA_1g1b6b12b10e8324bf462ecab4e7ef30e1> "Set the access flags for each location specified in desc for the given virtual address range.")). Multicast objects can also be shared with other processes by requesting a shareable handle via [cuMemExportToShareableHandle](<group__CUDA__VA.html#group__CUDA__VA_1g633f273b155815f23c1d70e7d9384c56> "Exports an allocation to a requested shareable handle type."). Note that the desired types of shareable handles must be specified in the bitmask [CUmulticastObjectProp::handleTypes](<structCUmulticastObjectProp__v1.html#structCUmulticastObjectProp__v1_1705cc17eda91d960e96982f2fda52d55>). Multicast objects can be released using the virtual memory management API [cuMemRelease](<group__CUDA__VA.html#group__CUDA__VA_1g3014f0759f43a8d82db951b8e4b91d68> "Release a memory handle representing a memory allocation which was previously allocated through cuMemCreate.").

**See also:**

[cuMulticastAddDevice](<group__CUDA__MULTICAST.html#group__CUDA__MULTICAST_1g2df07b38ff506c519e9f799c5ddf7e5d> "Associate a device to a multicast object."), [cuMulticastBindMem](<group__CUDA__MULTICAST.html#group__CUDA__MULTICAST_1gcadf88b616a3f766f6279288e435a4bb> "Bind a memory allocation represented by a handle to a multicast object."), [cuMulticastBindAddr](<group__CUDA__MULTICAST.html#group__CUDA__MULTICAST_1g07c8cf1d3bf1d04a2d1867f09647b03f> "Bind a memory allocation represented by a virtual address to a multicast object."), [cuMulticastUnbind](<group__CUDA__MULTICAST.html#group__CUDA__MULTICAST_1g424b4563760cc5dab52ee9a8d28656ac> "Unbind any memory allocations bound to a multicast object at a given offset and upto a given size.")

[cuMemCreate](<group__CUDA__VA.html#group__CUDA__VA_1g899d69a862bba36449789c64b430dc7c> "Create a CUDA memory handle representing a memory allocation of a given size described by the given properties."), [cuMemRelease](<group__CUDA__VA.html#group__CUDA__VA_1g3014f0759f43a8d82db951b8e4b91d68> "Release a memory handle representing a memory allocation which was previously allocated through cuMemCreate."), [cuMemExportToShareableHandle](<group__CUDA__VA.html#group__CUDA__VA_1g633f273b155815f23c1d70e7d9384c56> "Exports an allocation to a requested shareable handle type."), [cuMemImportFromShareableHandle](<group__CUDA__VA.html#group__CUDA__VA_1g1577822cc83ea896b4892f2d69630463> "Imports an allocation from a requested shareable handle type.")

[cuMulticastBindAddr_v2](<group__CUDA__MULTICAST.html#group__CUDA__MULTICAST_1g0eb82d8911bf179ae239d522da049bed> "Bind a memory allocation represented by a virtual address to a multicast object."), [cuMulticastBindMem_v2](<group__CUDA__MULTICAST.html#group__CUDA__MULTICAST_1g0e0ed2e81af121bdcbb54e1a9c4e63a5> "Bind a memory allocation represented by a handle to a multicast object.")

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuMulticastGetGranularity ( size_t*Â granularity, const [CUmulticastObjectProp](<structCUmulticastObjectProp__v1.html#structCUmulticastObjectProp__v1>)*Â prop, [CUmulticastGranularity_flags](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gcdeff171670a788001418262a0f88378>)Â option )


Calculates either the minimal or recommended granularity for multicast object.

######  Parameters

`granularity`
    Returned granularity.
`prop`
    Properties of the multicast object.
`option`
    Determines which granularity to return.

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>), [CUDA_ERROR_NOT_INITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e98feb999f0af99b4a25ab26b3866f4df8>), [CUDA_ERROR_DEINITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9acf52f132faf29b473cdda6061f0f44a>), [CUDA_ERROR_NOT_PERMITTED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9e23d0197c490ec332a43e55b167968a3>), [CUDA_ERROR_NOT_SUPPORTED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e954756ae7ade0dfd09faeccb513dd831b>)

###### Description

Calculates either the minimal or recommended granularity for a given set of multicast object properties and returns it in granularity. This granularity can be used as a multiple for size, bind offsets and address mappings of the multicast object.

**See also:**

[cuMulticastCreate](<group__CUDA__MULTICAST.html#group__CUDA__MULTICAST_1gd4413361f466d4ed86a93d8c309c0242> "Create a generic allocation handle representing a multicast object described by the given properties."), [cuMulticastBindMem](<group__CUDA__MULTICAST.html#group__CUDA__MULTICAST_1gcadf88b616a3f766f6279288e435a4bb> "Bind a memory allocation represented by a handle to a multicast object."), [cuMulticastBindAddr](<group__CUDA__MULTICAST.html#group__CUDA__MULTICAST_1g07c8cf1d3bf1d04a2d1867f09647b03f> "Bind a memory allocation represented by a virtual address to a multicast object."), [cuMulticastUnbind](<group__CUDA__MULTICAST.html#group__CUDA__MULTICAST_1g424b4563760cc5dab52ee9a8d28656ac> "Unbind any memory allocations bound to a multicast object at a given offset and upto a given size.")

[cuMulticastBindMem_v2](<group__CUDA__MULTICAST.html#group__CUDA__MULTICAST_1g0e0ed2e81af121bdcbb54e1a9c4e63a5> "Bind a memory allocation represented by a handle to a multicast object."), [cuMulticastBindAddr_v2](<group__CUDA__MULTICAST.html#group__CUDA__MULTICAST_1g0eb82d8911bf179ae239d522da049bed> "Bind a memory allocation represented by a virtual address to a multicast object.")

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuMulticastUnbind ( CUmemGenericAllocationHandleÂ mcHandle, [CUdevice](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g41ca2a24a242b36ef2ca77330b5fb72a>)Â dev, size_tÂ mcOffset, size_tÂ size )


Unbind any memory allocations bound to a multicast object at a given offset and upto a given size.

######  Parameters

`mcHandle`
    Handle representing a multicast object.
`dev`
    Device that hosts the memory allocation.
`mcOffset`
    Offset into the multicast object.
`size`
    Desired size to unbind.

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>), [CUDA_ERROR_INVALID_DEVICE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e96f047e7215788ca96c81af92a04bfb6c>), [CUDA_ERROR_NOT_INITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e98feb999f0af99b4a25ab26b3866f4df8>), [CUDA_ERROR_DEINITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9acf52f132faf29b473cdda6061f0f44a>), [CUDA_ERROR_NOT_PERMITTED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9e23d0197c490ec332a43e55b167968a3>), [CUDA_ERROR_NOT_SUPPORTED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e954756ae7ade0dfd09faeccb513dd831b>)

###### Description

Unbinds any memory allocations hosted on `dev` and bound to a multicast object at `mcOffset` and upto a given `size`. The intended `size` of the unbind and the offset in the multicast range ( `mcOffset` ) must be a multiple of the value returned by [cuMulticastGetGranularity](<group__CUDA__MULTICAST.html#group__CUDA__MULTICAST_1g067a02ad98f4e01f149011f523fec547> "Calculates either the minimal or recommended granularity for multicast object.") flag [CU_MULTICAST_GRANULARITY_MINIMUM](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggcdeff171670a788001418262a0f88378790ecc4b1f2c2f6e2c9bc21b230872a9>). The `size` \+ `mcOffset` cannot be larger than the total size of the multicast object.

Note:

Warning: The `mcOffset` and the `size` must match the corresponding values specified during the bind call. Any other values may result in undefined behavior.

**See also:**

[cuMulticastBindMem](<group__CUDA__MULTICAST.html#group__CUDA__MULTICAST_1gcadf88b616a3f766f6279288e435a4bb> "Bind a memory allocation represented by a handle to a multicast object."), [cuMulticastBindAddr](<group__CUDA__MULTICAST.html#group__CUDA__MULTICAST_1g07c8cf1d3bf1d04a2d1867f09647b03f> "Bind a memory allocation represented by a virtual address to a multicast object.")

[cuMulticastBindMem_v2](<group__CUDA__MULTICAST.html#group__CUDA__MULTICAST_1g0e0ed2e81af121bdcbb54e1a9c4e63a5> "Bind a memory allocation represented by a handle to a multicast object."), [cuMulticastBindAddr_v2](<group__CUDA__MULTICAST.html#group__CUDA__MULTICAST_1g0eb82d8911bf179ae239d522da049bed> "Bind a memory allocation represented by a virtual address to a multicast object.")

* * *


---

# Unified Addressing

## 6.17.Â Unified Addressing

This section describes the unified addressing functions of the low-level CUDA driver application programming interface.

**Overview**

CUDA devices can share a unified address space with the host. For these devices there is no distinction between a device pointer and a host pointer -- the same pointer value may be used to access memory from the host program and from a kernel running on the device (with exceptions enumerated below).

**Supported Platforms**

Whether or not a device supports unified addressing may be queried by calling [cuDeviceGetAttribute()](<group__CUDA__DEVICE.html#group__CUDA__DEVICE_1g9c3e1414f0ad901d3278a4d6645fc266> "Returns information about the device.") with the device attribute [CU_DEVICE_ATTRIBUTE_UNIFIED_ADDRESSING](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gge12b8a782bebe21b1ac0091bf9f4e2a3dc11dd6d9f149a7bae32499f2b802c0d>).

Unified addressing is automatically enabled in 64-bit processes

**Looking Up Information from Pointer Values**

It is possible to look up information about the memory which backs a pointer value. For instance, one may want to know if a pointer points to host or device memory. As another example, in the case of device memory, one may want to know on which CUDA device the memory resides. These properties may be queried using the function [cuPointerGetAttribute()](<group__CUDA__UNIFIED.html#group__CUDA__UNIFIED_1g0c28ed0aff848042bc0533110e45820c> "Returns information about a pointer.")

Since pointers are unique, it is not necessary to specify information about the pointers specified to the various copy functions in the CUDA API. The function [cuMemcpy()](<group__CUDA__MEM.html#group__CUDA__MEM_1g8d0ff510f26d4b87bd3a51e731e7f698> "Copies memory.") may be used to perform a copy between two pointers, ignoring whether they point to host or device memory (making [cuMemcpyHtoD()](<group__CUDA__MEM.html#group__CUDA__MEM_1g4d32266788c440b0220b1a9ba5795169> "Copies memory from Host to Device."), [cuMemcpyDtoD()](<group__CUDA__MEM.html#group__CUDA__MEM_1g1725774abf8b51b91945f3336b778c8b> "Copies memory from Device to Device."), and [cuMemcpyDtoH()](<group__CUDA__MEM.html#group__CUDA__MEM_1g3480368ee0208a98f75019c9a8450893> "Copies memory from Device to Host.") unnecessary for devices supporting unified addressing). For multidimensional copies, the memory type [CU_MEMORYTYPE_UNIFIED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg8a114cc994ad2e865c44ef3838eaec727a47ca2de6db5cf82084ad80ce66aa71>) may be used to specify that the CUDA driver should infer the location of the pointer from its value.

**Automatic Mapping of Host Allocated Host Memory**

All host memory allocated in all contexts using [cuMemAllocHost()](<group__CUDA__MEM.html#group__CUDA__MEM_1gdd8311286d2c2691605362c689bc64e0> "Allocates page-locked host memory.") and [cuMemHostAlloc()](<group__CUDA__MEM.html#group__CUDA__MEM_1g572ca4011bfcb25034888a14d4e035b9> "Allocates page-locked host memory.") is always directly accessible from all contexts on all devices that support unified addressing. This is the case regardless of whether or not the flags [CU_MEMHOSTALLOC_PORTABLE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g50f4528d46bda58b592551654a7ee0ff>) and [CU_MEMHOSTALLOC_DEVICEMAP](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g054589ee2a0f188e664d93965d81113d>) are specified.

The pointer value through which allocated host memory may be accessed in kernels on all devices that support unified addressing is the same as the pointer value through which that memory is accessed on the host, so it is not necessary to call [cuMemHostGetDevicePointer()](<group__CUDA__MEM.html#group__CUDA__MEM_1g57a39e5cba26af4d06be67fc77cc62f0> "Passes back device pointer of mapped pinned memory.") to get the device pointer for these allocations.

Note that this is not the case for memory allocated using the flag [CU_MEMHOSTALLOC_WRITECOMBINED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g7361580951deecace15352c97a210038>), as discussed below.

**Automatic Registration of Peer Memory**

Upon enabling direct access from a context that supports unified addressing to another peer context that supports unified addressing using [cuCtxEnablePeerAccess()](<group__CUDA__PEER__ACCESS.html#group__CUDA__PEER__ACCESS_1g0889ec6728e61c05ed359551d67b3f5a> "Enables direct access to memory allocations in a peer context.") all memory allocated in the peer context using [cuMemAlloc()](<group__CUDA__MEM.html#group__CUDA__MEM_1gb82d2a09844a58dd9e744dc31e8aa467> "Allocates device memory.") and [cuMemAllocPitch()](<group__CUDA__MEM.html#group__CUDA__MEM_1gcbe9b033f6c4de80f63cc6e58ed9a45a> "Allocates pitched device memory.") will immediately be accessible by the current context. The device pointer value through which any peer memory may be accessed in the current context is the same pointer value through which that memory may be accessed in the peer context.

**Exceptions, Disjoint Addressing**

Not all memory may be accessed on devices through the same pointer value through which they are accessed on the host. These exceptions are host memory registered using [cuMemHostRegister()](<group__CUDA__MEM.html#group__CUDA__MEM_1gf0a9fe11544326dabd743b7aa6b54223> "Registers an existing host memory range for use by CUDA.") and host memory allocated using the flag [CU_MEMHOSTALLOC_WRITECOMBINED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g7361580951deecace15352c97a210038>). For these exceptions, there exists a distinct host and device address for the memory. The device address is guaranteed to not overlap any valid host pointer range and is guaranteed to have the same value across all contexts that support unified addressing.

This device address may be queried using [cuMemHostGetDevicePointer()](<group__CUDA__MEM.html#group__CUDA__MEM_1g57a39e5cba26af4d06be67fc77cc62f0> "Passes back device pointer of mapped pinned memory.") when a context using unified addressing is current. Either the host or the unified device pointer value may be used to refer to this memory through [cuMemcpy()](<group__CUDA__MEM.html#group__CUDA__MEM_1g8d0ff510f26d4b87bd3a51e731e7f698> "Copies memory.") and similar functions using the [CU_MEMORYTYPE_UNIFIED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg8a114cc994ad2e865c44ef3838eaec727a47ca2de6db5cf82084ad80ce66aa71>) memory type.

### Functions

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuMemAdvise](<#group__CUDA__UNIFIED_1gaac8924b2f5a2a93f8775fb81c1a643f>) ( [CUdeviceptr](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g183f7b0d8ad008ea2a5fd552537ace4e>)Â devPtr, size_tÂ count, [CUmem_advise](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gcfe2ed2d4567745dd4ad41034136fff3>)Â advice, [CUmemLocation](<structCUmemLocation__v1.html#structCUmemLocation__v1>)Â location )
     Advise about the usage of a given memory range.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuMemDiscardAndPrefetchBatchAsync](<#group__CUDA__UNIFIED_1g2a8dbb3c95608cff2269226298fd8f28>) ( [CUdeviceptr](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g183f7b0d8ad008ea2a5fd552537ace4e>)*Â dptrs, size_t*Â sizes, size_tÂ count, [CUmemLocation](<structCUmemLocation__v1.html#structCUmemLocation__v1>)*Â prefetchLocs, size_t*Â prefetchLocIdxs, size_tÂ numPrefetchLocs, unsigned long longÂ flags, [CUstream](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gb946c7f02e09efd788a204718015d88a>)Â hStream )
     Performs a batch of memory discards and prefetches asynchronously.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuMemDiscardBatchAsync](<#group__CUDA__UNIFIED_1gf517eb7d44e9bae70cf6a1ec8d9ece4e>) ( [CUdeviceptr](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g183f7b0d8ad008ea2a5fd552537ace4e>)*Â dptrs, size_t*Â sizes, size_tÂ count, unsigned long longÂ flags, [CUstream](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gb946c7f02e09efd788a204718015d88a>)Â hStream )
     Performs a batch of memory discards asynchronously.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuMemPrefetchAsync](<#group__CUDA__UNIFIED_1g45c0e085febc3be8fabf5c526355b6a3>) ( [CUdeviceptr](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g183f7b0d8ad008ea2a5fd552537ace4e>)Â devPtr, size_tÂ count, [CUmemLocation](<structCUmemLocation__v1.html#structCUmemLocation__v1>)Â location, unsigned int Â flags, [CUstream](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gb946c7f02e09efd788a204718015d88a>)Â hStream )
     Prefetches memory to the specified destination location.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuMemPrefetchBatchAsync](<#group__CUDA__UNIFIED_1g97fe632183ff5ff791813c3174fc5121>) ( [CUdeviceptr](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g183f7b0d8ad008ea2a5fd552537ace4e>)*Â dptrs, size_t*Â sizes, size_tÂ count, [CUmemLocation](<structCUmemLocation__v1.html#structCUmemLocation__v1>)*Â prefetchLocs, size_t*Â prefetchLocIdxs, size_tÂ numPrefetchLocs, unsigned long longÂ flags, [CUstream](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gb946c7f02e09efd788a204718015d88a>)Â hStream )
     Performs a batch of memory prefetches asynchronously.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuMemRangeGetAttribute](<#group__CUDA__UNIFIED_1g1c92408a7d0d8875e19b1a58af56f67d>) ( void*Â data, size_tÂ dataSize, [CUmem_range_attribute](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g3754eb90f64ed3c19b4e550d21d124fc>)Â attribute, [CUdeviceptr](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g183f7b0d8ad008ea2a5fd552537ace4e>)Â devPtr, size_tÂ count )
     Query an attribute of a given memory range.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuMemRangeGetAttributes](<#group__CUDA__UNIFIED_1gc7ce142e60f8613cfb7d722b87dc9d12>) ( void**Â data, size_t*Â dataSizes, [CUmem_range_attribute](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g3754eb90f64ed3c19b4e550d21d124fc>)*Â attributes, size_tÂ numAttributes, [CUdeviceptr](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g183f7b0d8ad008ea2a5fd552537ace4e>)Â devPtr, size_tÂ count )
     Query attributes of a given memory range.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuPointerGetAttribute](<#group__CUDA__UNIFIED_1g0c28ed0aff848042bc0533110e45820c>) ( void*Â data, [CUpointer_attribute](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc2cce590e35080745e72633dfc6e0b60>)Â attribute, [CUdeviceptr](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g183f7b0d8ad008ea2a5fd552537ace4e>)Â ptr )
     Returns information about a pointer.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuPointerGetAttributes](<#group__CUDA__UNIFIED_1gf65e9ea532e311dd049166e4894955ad>) ( unsigned int Â numAttributes, [CUpointer_attribute](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc2cce590e35080745e72633dfc6e0b60>)*Â attributes, void**Â data, [CUdeviceptr](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g183f7b0d8ad008ea2a5fd552537ace4e>)Â ptr )
     Returns information about a pointer.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuPointerSetAttribute](<#group__CUDA__UNIFIED_1g89f7ad29a657e574fdea2624b74d138e>) ( const void*Â value, [CUpointer_attribute](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc2cce590e35080745e72633dfc6e0b60>)Â attribute, [CUdeviceptr](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g183f7b0d8ad008ea2a5fd552537ace4e>)Â ptr )
     Set attributes on a previously allocated memory region.

### Functions

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuMemAdvise ( [CUdeviceptr](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g183f7b0d8ad008ea2a5fd552537ace4e>)Â devPtr, size_tÂ count, [CUmem_advise](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gcfe2ed2d4567745dd4ad41034136fff3>)Â advice, [CUmemLocation](<structCUmemLocation__v1.html#structCUmemLocation__v1>)Â location )


Advise about the usage of a given memory range.

######  Parameters

`devPtr`
    \- Pointer to memory to set the advice for
`count`
    \- Size in bytes of the memory range
`advice`
    \- Advice to be applied for the specified memory range
`location`
    \- location to apply the advice for

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>), [CUDA_ERROR_INVALID_DEVICE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e96f047e7215788ca96c81af92a04bfb6c>)

###### Description

Advise the Unified Memory subsystem about the usage pattern for the memory range starting at `devPtr` with a size of `count` bytes. The start address and end address of the memory range will be rounded down and rounded up respectively to be aligned to CPU page size before the advice is applied. The memory range must refer to managed memory allocated via [cuMemAllocManaged](<group__CUDA__MEM.html#group__CUDA__MEM_1gb347ded34dc326af404aa02af5388a32> "Allocates memory that will be automatically managed by the Unified Memory system.") or declared via __managed__ variables. The memory range could also refer to system-allocated pageable memory provided it represents a valid, host-accessible region of memory and all additional constraints imposed by `advice` as outlined below are also satisfied. Specifying an invalid system-allocated pageable memory range results in an error being returned.

The `advice` parameter can take the following values:

  * [CU_MEM_ADVISE_SET_READ_MOSTLY](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggcfe2ed2d4567745dd4ad41034136fff35a99fb44378c84c56668550b94157fc0>): This implies that the data is mostly going to be read from and only occasionally written to. Any read accesses from any processor to this region will create a read-only copy of at least the accessed pages in that processor's memory. Additionally, if [cuMemPrefetchAsync](<group__CUDA__UNIFIED.html#group__CUDA__UNIFIED_1g45c0e085febc3be8fabf5c526355b6a3> "Prefetches memory to the specified destination location.") is called on this region, it will create a read-only copy of the data on the destination processor. If the target location for [cuMemPrefetchAsync](<group__CUDA__UNIFIED.html#group__CUDA__UNIFIED_1g45c0e085febc3be8fabf5c526355b6a3> "Prefetches memory to the specified destination location.") is a host NUMA node and a read-only copy already exists on another host NUMA node, that copy will be migrated to the targeted host NUMA node. If any processor writes to this region, all copies of the corresponding page will be invalidated except for the one where the write occurred. If the writing processor is the CPU and the preferred location of the page is a host NUMA node, then the page will also be migrated to that host NUMA node. The `location` argument is ignored for this advice. Note that for a page to be read-duplicated, the accessing processor must either be the CPU or a GPU that has a non-zero value for the device attribute [CU_DEVICE_ATTRIBUTE_CONCURRENT_MANAGED_ACCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gge12b8a782bebe21b1ac0091bf9f4e2a333110e44c9cb6ead02f03ff6f6fd495e>). Also, if a context is created on a device that does not have the device attribute [CU_DEVICE_ATTRIBUTE_CONCURRENT_MANAGED_ACCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gge12b8a782bebe21b1ac0091bf9f4e2a333110e44c9cb6ead02f03ff6f6fd495e>) set, then read-duplication will not occur until all such contexts are destroyed. If the memory region refers to valid system-allocated pageable memory, then the accessing device must have a non-zero value for the device attribute [CU_DEVICE_ATTRIBUTE_PAGEABLE_MEMORY_ACCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gge12b8a782bebe21b1ac0091bf9f4e2a35fdcdbe1dfc3ad5ec428c279e0efb9cd>) for a read-only copy to be created on that device. Note however that if the accessing device also has a non-zero value for the device attribute [CU_DEVICE_ATTRIBUTE_PAGEABLE_MEMORY_ACCESS_USES_HOST_PAGE_TABLES](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gge12b8a782bebe21b1ac0091bf9f4e2a352c58d6fd1d3a72673cce199ab30cd40>), then setting this advice will not create a read-only copy when that device accesses this memory region.


  * [CU_MEM_ADVISE_UNSET_READ_MOSTLY](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggcfe2ed2d4567745dd4ad41034136fff383a9e9744ef151f7b25b5c902ba6baca>): Undoes the effect of [CU_MEM_ADVISE_SET_READ_MOSTLY](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggcfe2ed2d4567745dd4ad41034136fff35a99fb44378c84c56668550b94157fc0>) and also prevents the Unified Memory driver from attempting heuristic read-duplication on the memory range. Any read-duplicated copies of the data will be collapsed into a single copy. The location for the collapsed copy will be the preferred location if the page has a preferred location and one of the read-duplicated copies was resident at that location. Otherwise, the location chosen is arbitrary. Note: The `location` argument is ignored for this advice.


  * [CU_MEM_ADVISE_SET_PREFERRED_LOCATION](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggcfe2ed2d4567745dd4ad41034136fff3ddee285dc5e0e7d26469009ffd583cea>): This advice sets the preferred location for the data to be the memory belonging to `location`. When [CUmemLocation::type](<structCUmemLocation__v1.html#structCUmemLocation__v1_1a34fc29f2a55d501f00f912d92152d1b>) is [CU_MEM_LOCATION_TYPE_HOST](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg75cfd5b9fa5c1c6ee2be2547bfbe882e46800776121a71c8dc2904518a21065a>), [CUmemLocation::id](<structCUmemLocation__v1.html#structCUmemLocation__v1_11d7b65b482228d640b6f953196e460dc>) is ignored and the preferred location is set to be host memory. To set the preferred location to a specific host NUMA node, applications must set [CUmemLocation::type](<structCUmemLocation__v1.html#structCUmemLocation__v1_1a34fc29f2a55d501f00f912d92152d1b>) to [CU_MEM_LOCATION_TYPE_HOST_NUMA](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg75cfd5b9fa5c1c6ee2be2547bfbe882eb61a1d3409ed83a43b5706cc004ac861>) and [CUmemLocation::id](<structCUmemLocation__v1.html#structCUmemLocation__v1_11d7b65b482228d640b6f953196e460dc>) must specify the NUMA ID of the host NUMA node. If [CUmemLocation::type](<structCUmemLocation__v1.html#structCUmemLocation__v1_1a34fc29f2a55d501f00f912d92152d1b>) is set to [CU_MEM_LOCATION_TYPE_HOST_NUMA_CURRENT](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg75cfd5b9fa5c1c6ee2be2547bfbe882e55b82116b2124510a1a3b6c52096daaa>), [CUmemLocation::id](<structCUmemLocation__v1.html#structCUmemLocation__v1_11d7b65b482228d640b6f953196e460dc>) will be ignored and the the host NUMA node closest to the calling thread's CPU will be used as the preferred location. If [CUmemLocation::type](<structCUmemLocation__v1.html#structCUmemLocation__v1_1a34fc29f2a55d501f00f912d92152d1b>) is a [CU_MEM_LOCATION_TYPE_DEVICE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg75cfd5b9fa5c1c6ee2be2547bfbe882ea4409aa6b414995d628a320eafbbbb6e>), then [CUmemLocation::id](<structCUmemLocation__v1.html#structCUmemLocation__v1_11d7b65b482228d640b6f953196e460dc>) must be a valid device ordinal and the device must have a non-zero value for the device attribute [CU_DEVICE_ATTRIBUTE_CONCURRENT_MANAGED_ACCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gge12b8a782bebe21b1ac0091bf9f4e2a333110e44c9cb6ead02f03ff6f6fd495e>). Setting the preferred location does not cause data to migrate to that location immediately. Instead, it guides the migration policy when a fault occurs on that memory region. If the data is already in its preferred location and the faulting processor can establish a mapping without requiring the data to be migrated, then data migration will be avoided. On the other hand, if the data is not in its preferred location or if a direct mapping cannot be established, then it will be migrated to the processor accessing it. It is important to note that setting the preferred location does not prevent data prefetching done using [cuMemPrefetchAsync](<group__CUDA__UNIFIED.html#group__CUDA__UNIFIED_1g45c0e085febc3be8fabf5c526355b6a3> "Prefetches memory to the specified destination location."). Having a preferred location can override the page thrash detection and resolution logic in the Unified Memory driver. Normally, if a page is detected to be constantly thrashing between for example host and device memory, the page may eventually be pinned to host memory by the Unified Memory driver. But if the preferred location is set as device memory, then the page will continue to thrash indefinitely. If [CU_MEM_ADVISE_SET_READ_MOSTLY](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggcfe2ed2d4567745dd4ad41034136fff35a99fb44378c84c56668550b94157fc0>) is also set on this memory region or any subset of it, then the policies associated with that advice will override the policies of this advice, unless read accesses from `location` will not result in a read-only copy being created on that procesor as outlined in description for the advice [CU_MEM_ADVISE_SET_READ_MOSTLY](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggcfe2ed2d4567745dd4ad41034136fff35a99fb44378c84c56668550b94157fc0>). If the memory region refers to valid system-allocated pageable memory, and [CUmemLocation::type](<structCUmemLocation__v1.html#structCUmemLocation__v1_1a34fc29f2a55d501f00f912d92152d1b>) is CU_MEM_LOCATION_TYPE_DEVICE then [CUmemLocation::id](<structCUmemLocation__v1.html#structCUmemLocation__v1_11d7b65b482228d640b6f953196e460dc>) must be a valid device that has a non-zero alue for the device attribute [CU_DEVICE_ATTRIBUTE_PAGEABLE_MEMORY_ACCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gge12b8a782bebe21b1ac0091bf9f4e2a35fdcdbe1dfc3ad5ec428c279e0efb9cd>).


  * [CU_MEM_ADVISE_UNSET_PREFERRED_LOCATION](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggcfe2ed2d4567745dd4ad41034136fff31d0d3a6b5273abd3f758d55a020bb6ca>): Undoes the effect of [CU_MEM_ADVISE_SET_PREFERRED_LOCATION](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggcfe2ed2d4567745dd4ad41034136fff3ddee285dc5e0e7d26469009ffd583cea>) and changes the preferred location to none. The `location` argument is ignored for this advice.


  * [CU_MEM_ADVISE_SET_ACCESSED_BY](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggcfe2ed2d4567745dd4ad41034136fff3a44e5c0ad0a77d05332739848e181a2d>): This advice implies that the data will be accessed by processor `location`. The [CUmemLocation::type](<structCUmemLocation__v1.html#structCUmemLocation__v1_1a34fc29f2a55d501f00f912d92152d1b>) must be either [CU_MEM_LOCATION_TYPE_DEVICE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg75cfd5b9fa5c1c6ee2be2547bfbe882ea4409aa6b414995d628a320eafbbbb6e>) with [CUmemLocation::id](<structCUmemLocation__v1.html#structCUmemLocation__v1_11d7b65b482228d640b6f953196e460dc>) representing a valid device ordinal or [CU_MEM_LOCATION_TYPE_HOST](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg75cfd5b9fa5c1c6ee2be2547bfbe882e46800776121a71c8dc2904518a21065a>) and [CUmemLocation::id](<structCUmemLocation__v1.html#structCUmemLocation__v1_11d7b65b482228d640b6f953196e460dc>) will be ignored. All other location types are invalid. If [CUmemLocation::id](<structCUmemLocation__v1.html#structCUmemLocation__v1_11d7b65b482228d640b6f953196e460dc>) is a GPU, then the device attribute [CU_DEVICE_ATTRIBUTE_CONCURRENT_MANAGED_ACCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gge12b8a782bebe21b1ac0091bf9f4e2a333110e44c9cb6ead02f03ff6f6fd495e>) must be non-zero. This advice does not cause data migration and has no impact on the location of the data per se. Instead, it causes the data to always be mapped in the specified processor's page tables, as long as the location of the data permits a mapping to be established. If the data gets migrated for any reason, the mappings are updated accordingly. This advice is recommended in scenarios where data locality is not important, but avoiding faults is. Consider for example a system containing multiple GPUs with peer-to-peer access enabled, where the data located on one GPU is occasionally accessed by peer GPUs. In such scenarios, migrating data over to the other GPUs is not as important because the accesses are infrequent and the overhead of migration may be too high. But preventing faults can still help improve performance, and so having a mapping set up in advance is useful. Note that on CPU access of this data, the data may be migrated to host memory because the CPU typically cannot access device memory directly. Any GPU that had the [CU_MEM_ADVISE_SET_ACCESSED_BY](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggcfe2ed2d4567745dd4ad41034136fff3a44e5c0ad0a77d05332739848e181a2d>) flag set for this data will now have its mapping updated to point to the page in host memory. If [CU_MEM_ADVISE_SET_READ_MOSTLY](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggcfe2ed2d4567745dd4ad41034136fff35a99fb44378c84c56668550b94157fc0>) is also set on this memory region or any subset of it, then the policies associated with that advice will override the policies of this advice. Additionally, if the preferred location of this memory region or any subset of it is also `location`, then the policies associated with [CU_MEM_ADVISE_SET_PREFERRED_LOCATION](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggcfe2ed2d4567745dd4ad41034136fff3ddee285dc5e0e7d26469009ffd583cea>) will override the policies of this advice. If the memory region refers to valid system-allocated pageable memory, and [CUmemLocation::type](<structCUmemLocation__v1.html#structCUmemLocation__v1_1a34fc29f2a55d501f00f912d92152d1b>) is [CU_MEM_LOCATION_TYPE_DEVICE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg75cfd5b9fa5c1c6ee2be2547bfbe882ea4409aa6b414995d628a320eafbbbb6e>) then device in [CUmemLocation::id](<structCUmemLocation__v1.html#structCUmemLocation__v1_11d7b65b482228d640b6f953196e460dc>) must have a non-zero value for the device attribute [CU_DEVICE_ATTRIBUTE_PAGEABLE_MEMORY_ACCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gge12b8a782bebe21b1ac0091bf9f4e2a35fdcdbe1dfc3ad5ec428c279e0efb9cd>). Additionally, if [CUmemLocation::id](<structCUmemLocation__v1.html#structCUmemLocation__v1_11d7b65b482228d640b6f953196e460dc>) has a non-zero value for the device attribute [CU_DEVICE_ATTRIBUTE_PAGEABLE_MEMORY_ACCESS_USES_HOST_PAGE_TABLES](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gge12b8a782bebe21b1ac0091bf9f4e2a352c58d6fd1d3a72673cce199ab30cd40>), then this call has no effect.


  * [CU_MEM_ADVISE_UNSET_ACCESSED_BY](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggcfe2ed2d4567745dd4ad41034136fff3f8118635c5f39d76432654ec13a726a5>): Undoes the effect of [CU_MEM_ADVISE_SET_ACCESSED_BY](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggcfe2ed2d4567745dd4ad41034136fff3a44e5c0ad0a77d05332739848e181a2d>). Any mappings to the data from `location` may be removed at any time causing accesses to result in non-fatal page faults. If the memory region refers to valid system-allocated pageable memory, and [CUmemLocation::type](<structCUmemLocation__v1.html#structCUmemLocation__v1_1a34fc29f2a55d501f00f912d92152d1b>) is [CU_MEM_LOCATION_TYPE_DEVICE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg75cfd5b9fa5c1c6ee2be2547bfbe882ea4409aa6b414995d628a320eafbbbb6e>) then device in [CUmemLocation::id](<structCUmemLocation__v1.html#structCUmemLocation__v1_11d7b65b482228d640b6f953196e460dc>) must have a non-zero value for the device attribute [CU_DEVICE_ATTRIBUTE_PAGEABLE_MEMORY_ACCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gge12b8a782bebe21b1ac0091bf9f4e2a35fdcdbe1dfc3ad5ec428c279e0efb9cd>). Additionally, if [CUmemLocation::id](<structCUmemLocation__v1.html#structCUmemLocation__v1_11d7b65b482228d640b6f953196e460dc>) has a non-zero value for the device attribute [CU_DEVICE_ATTRIBUTE_PAGEABLE_MEMORY_ACCESS_USES_HOST_PAGE_TABLES](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gge12b8a782bebe21b1ac0091bf9f4e2a352c58d6fd1d3a72673cce199ab30cd40>), then this call has no effect.


Note:

  * Note that this function may also return error codes from previous, asynchronous launches.

  * This function exhibits [asynchronous](<api-sync-behavior.html#api-sync-behavior__memcpy-async>) behavior for most use cases.

  * This function uses standard [default stream](<stream-sync-behavior.html#stream-sync-behavior__default-stream>) semantics.


**See also:**

[cuMemcpy](<group__CUDA__MEM.html#group__CUDA__MEM_1g8d0ff510f26d4b87bd3a51e731e7f698> "Copies memory."), [cuMemcpyPeer](<group__CUDA__MEM.html#group__CUDA__MEM_1ge1f5c7771544fee150ada8853c7cbf4a> "Copies device memory between two contexts."), [cuMemcpyAsync](<group__CUDA__MEM.html#group__CUDA__MEM_1g5f26aaf5582ade791e5688727a178d78> "Copies memory asynchronously."), [cuMemcpy3DPeerAsync](<group__CUDA__MEM.html#group__CUDA__MEM_1gc4e4bfd9f627d3aa3695979e058f1bb8> "Copies memory between contexts asynchronously."), [cuMemPrefetchAsync](<group__CUDA__UNIFIED.html#group__CUDA__UNIFIED_1g45c0e085febc3be8fabf5c526355b6a3> "Prefetches memory to the specified destination location."), [cudaMemAdvise](<../cuda-runtime-api/group__CUDART__MEMORY.html#group__CUDART__MEMORY_1g5584e2dac446bebc695da3bb1c162607>)

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuMemDiscardAndPrefetchBatchAsync ( [CUdeviceptr](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g183f7b0d8ad008ea2a5fd552537ace4e>)*Â dptrs, size_t*Â sizes, size_tÂ count, [CUmemLocation](<structCUmemLocation__v1.html#structCUmemLocation__v1>)*Â prefetchLocs, size_t*Â prefetchLocIdxs, size_tÂ numPrefetchLocs, unsigned long longÂ flags, [CUstream](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gb946c7f02e09efd788a204718015d88a>)Â hStream )


Performs a batch of memory discards and prefetches asynchronously.

######  Parameters

`dptrs`
    \- Array of pointers to be discarded
`sizes`
    \- Array of sizes for memory discard operations.
`count`
    \- Size of `dptrs` and `sizes` arrays.
`prefetchLocs`
    \- Array of locations to prefetch to.
`prefetchLocIdxs`
    \- Array of indices to specify which operands each entry in the `prefetchLocs` array applies to. The locations specified in prefetchLocs[k] will be applied to operations starting from prefetchLocIdxs[k] through prefetchLocIdxs[k+1] - 1. Also prefetchLocs[numPrefetchLocs - 1] will apply to copies starting from prefetchLocIdxs[numPrefetchLocs \- 1] through count - 1.
`numPrefetchLocs`
    \- Size of `prefetchLocs` and `prefetchLocIdxs` arrays.
`flags`
    \- Flags reserved for future use. Must be zero.
`hStream`
    \- The stream to enqueue the operations in. Must not be legacy NULL stream.

###### Description

Performs a batch of memory discards followed by prefetches. The batch as a whole executes in stream order but operations within a batch are not guaranteed to execute in any specific order. All devices in the system must have a non-zero value for the device attribute [CU_DEVICE_ATTRIBUTE_CONCURRENT_MANAGED_ACCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gge12b8a782bebe21b1ac0091bf9f4e2a333110e44c9cb6ead02f03ff6f6fd495e>) otherwise the API will return an error.

Calling [cuMemDiscardAndPrefetchBatchAsync](<group__CUDA__UNIFIED.html#group__CUDA__UNIFIED_1g2a8dbb3c95608cff2269226298fd8f28> "Performs a batch of memory discards and prefetches asynchronously.") is semantically equivalent to calling [cuMemDiscardBatchAsync](<group__CUDA__UNIFIED.html#group__CUDA__UNIFIED_1gf517eb7d44e9bae70cf6a1ec8d9ece4e> "Performs a batch of memory discards asynchronously.") followed by [cuMemPrefetchBatchAsync](<group__CUDA__UNIFIED.html#group__CUDA__UNIFIED_1g97fe632183ff5ff791813c3174fc5121> "Performs a batch of memory prefetches asynchronously."), but is more optimal. For more details on what discarding and prefetching imply, please refer to [cuMemDiscardBatchAsync](<group__CUDA__UNIFIED.html#group__CUDA__UNIFIED_1gf517eb7d44e9bae70cf6a1ec8d9ece4e> "Performs a batch of memory discards asynchronously.") and [cuMemPrefetchBatchAsync](<group__CUDA__UNIFIED.html#group__CUDA__UNIFIED_1g97fe632183ff5ff791813c3174fc5121> "Performs a batch of memory prefetches asynchronously.") respectively. Note that any reads, writes or prefetches to any part of the memory range that occur simultaneously with this combined discard+prefetch operation result in undefined behavior.

Performs memory discard and prefetch on address ranges specified in `dptrs` and `sizes`. Both arrays must be of the same length as specified by `count`. Each memory range specified must refer to managed memory allocated via [cuMemAllocManaged](<group__CUDA__MEM.html#group__CUDA__MEM_1gb347ded34dc326af404aa02af5388a32> "Allocates memory that will be automatically managed by the Unified Memory system.") or declared via __managed__ variables or it may also refer to system-allocated memory when all devices have a non-zero value for [CU_DEVICE_ATTRIBUTE_PAGEABLE_MEMORY_ACCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gge12b8a782bebe21b1ac0091bf9f4e2a35fdcdbe1dfc3ad5ec428c279e0efb9cd>). Every operation in the batch has to be associated with a valid location to prefetch the address range to and specified in the `prefetchLocs` array. Each entry in this array can apply to more than one operation. This can be done by specifying in the `prefetchLocIdxs` array, the index of the first operation that the corresponding entry in the `prefetchLocs` array applies to. Both `prefetchLocs` and `prefetchLocIdxs` must be of the same length as specified by `numPrefetchLocs`. For example, if a batch has 10 operations listed in dptrs/sizes, the first 6 of which are to be prefetched to one location and the remaining 4 are to be prefetched to another, then `numPrefetchLocs` will be 2, `prefetchLocIdxs` will be {0, 6} and `prefetchLocs` will contain the two set of locations. Note the first entry in `prefetchLocIdxs` must always be 0. Also, each entry must be greater than the previous entry and the last entry should be less than `count`. Furthermore, `numPrefetchLocs` must be lesser than or equal to `count`.

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuMemDiscardBatchAsync ( [CUdeviceptr](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g183f7b0d8ad008ea2a5fd552537ace4e>)*Â dptrs, size_t*Â sizes, size_tÂ count, unsigned long longÂ flags, [CUstream](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gb946c7f02e09efd788a204718015d88a>)Â hStream )


Performs a batch of memory discards asynchronously.

######  Parameters

`dptrs`
    \- Array of pointers to be discarded
`sizes`
    \- Array of sizes for memory discard operations.
`count`
    \- Size of `dptrs` and `sizes` arrays.
`flags`
    \- Flags reserved for future use. Must be zero.
`hStream`
    \- The stream to enqueue the operations in. Must not be legacy NULL stream.

###### Description

Performs a batch of memory discards. The batch as a whole executes in stream order but operations within a batch are not guaranteed to execute in any specific order. All devices in the system must have a non-zero value for the device attribute [CU_DEVICE_ATTRIBUTE_CONCURRENT_MANAGED_ACCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gge12b8a782bebe21b1ac0091bf9f4e2a333110e44c9cb6ead02f03ff6f6fd495e>) otherwise the API will return an error.

Discarding a memory range informs the driver that the contents of that range are no longer useful. Discarding memory ranges allows the driver to optimize certain data migrations and can also help reduce memory pressure. This operation can be undone on any part of the range by either writing to it or prefetching it via [cuMemPrefetchAsync](<group__CUDA__UNIFIED.html#group__CUDA__UNIFIED_1g45c0e085febc3be8fabf5c526355b6a3> "Prefetches memory to the specified destination location.") or [cuMemPrefetchBatchAsync](<group__CUDA__UNIFIED.html#group__CUDA__UNIFIED_1g97fe632183ff5ff791813c3174fc5121> "Performs a batch of memory prefetches asynchronously."). Reading from a discarded range, without a subsequent write or prefetch to that part of the range, will return an indeterminate value. Note that any reads, writes or prefetches to any part of the memory range that occur simultaneously with the discard operation result in undefined behavior.

Performs memory discard on address ranges specified in `dptrs` and `sizes`. Both arrays must be of the same length as specified by `count`. Each memory range specified must refer to managed memory allocated via [cuMemAllocManaged](<group__CUDA__MEM.html#group__CUDA__MEM_1gb347ded34dc326af404aa02af5388a32> "Allocates memory that will be automatically managed by the Unified Memory system.") or declared via __managed__ variables or it may also refer to system-allocated memory when all devices have a non-zero value for [CU_DEVICE_ATTRIBUTE_PAGEABLE_MEMORY_ACCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gge12b8a782bebe21b1ac0091bf9f4e2a35fdcdbe1dfc3ad5ec428c279e0efb9cd>).

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuMemPrefetchAsync ( [CUdeviceptr](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g183f7b0d8ad008ea2a5fd552537ace4e>)Â devPtr, size_tÂ count, [CUmemLocation](<structCUmemLocation__v1.html#structCUmemLocation__v1>)Â location, unsigned int Â flags, [CUstream](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gb946c7f02e09efd788a204718015d88a>)Â hStream )


Prefetches memory to the specified destination location.

######  Parameters

`devPtr`
    \- Pointer to be prefetched
`count`
    \- Size in bytes
`location`
    \- Location to prefetch to
`flags`
    \- flags for future use, must be zero now.
`hStream`
    \- Stream to enqueue prefetch operation

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>), [CUDA_ERROR_INVALID_DEVICE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e96f047e7215788ca96c81af92a04bfb6c>)

###### Description

Prefetches memory to the specified destination location. `devPtr` is the base device pointer of the memory to be prefetched and `location` specifies the destination location. `count` specifies the number of bytes to copy. `hStream` is the stream in which the operation is enqueued. The memory range must refer to managed memory allocated via [cuMemAllocManaged](<group__CUDA__MEM.html#group__CUDA__MEM_1gb347ded34dc326af404aa02af5388a32> "Allocates memory that will be automatically managed by the Unified Memory system."), via cuMemAllocFromPool from a managed memory pool or declared via __managed__ variables.

Specifying [CU_MEM_LOCATION_TYPE_DEVICE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg75cfd5b9fa5c1c6ee2be2547bfbe882ea4409aa6b414995d628a320eafbbbb6e>) for [CUmemLocation::type](<structCUmemLocation__v1.html#structCUmemLocation__v1_1a34fc29f2a55d501f00f912d92152d1b>) will prefetch memory to GPU specified by device ordinal [CUmemLocation::id](<structCUmemLocation__v1.html#structCUmemLocation__v1_11d7b65b482228d640b6f953196e460dc>) which must have non-zero value for the device attribute [CU_DEVICE_ATTRIBUTE_CONCURRENT_MANAGED_ACCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gge12b8a782bebe21b1ac0091bf9f4e2a333110e44c9cb6ead02f03ff6f6fd495e>). Additionally, `hStream` must be associated with a device that has a non-zero value for the device attribute [CU_DEVICE_ATTRIBUTE_CONCURRENT_MANAGED_ACCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gge12b8a782bebe21b1ac0091bf9f4e2a333110e44c9cb6ead02f03ff6f6fd495e>). Specifying [CU_MEM_LOCATION_TYPE_HOST](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg75cfd5b9fa5c1c6ee2be2547bfbe882e46800776121a71c8dc2904518a21065a>) as [CUmemLocation::type](<structCUmemLocation__v1.html#structCUmemLocation__v1_1a34fc29f2a55d501f00f912d92152d1b>) will prefetch data to host memory. Applications can request prefetching memory to a specific host NUMA node by specifying [CU_MEM_LOCATION_TYPE_HOST_NUMA](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg75cfd5b9fa5c1c6ee2be2547bfbe882eb61a1d3409ed83a43b5706cc004ac861>) for [CUmemLocation::type](<structCUmemLocation__v1.html#structCUmemLocation__v1_1a34fc29f2a55d501f00f912d92152d1b>) and a valid host NUMA node id in [CUmemLocation::id](<structCUmemLocation__v1.html#structCUmemLocation__v1_11d7b65b482228d640b6f953196e460dc>) Users can also request prefetching memory to the host NUMA node closest to the current thread's CPU by specifying [CU_MEM_LOCATION_TYPE_HOST_NUMA_CURRENT](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg75cfd5b9fa5c1c6ee2be2547bfbe882e55b82116b2124510a1a3b6c52096daaa>) for [CUmemLocation::type](<structCUmemLocation__v1.html#structCUmemLocation__v1_1a34fc29f2a55d501f00f912d92152d1b>). Note when [CUmemLocation::type](<structCUmemLocation__v1.html#structCUmemLocation__v1_1a34fc29f2a55d501f00f912d92152d1b>) is etiher [CU_MEM_LOCATION_TYPE_HOST](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg75cfd5b9fa5c1c6ee2be2547bfbe882e46800776121a71c8dc2904518a21065a>) OR [CU_MEM_LOCATION_TYPE_HOST_NUMA_CURRENT](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg75cfd5b9fa5c1c6ee2be2547bfbe882e55b82116b2124510a1a3b6c52096daaa>), [CUmemLocation::id](<structCUmemLocation__v1.html#structCUmemLocation__v1_11d7b65b482228d640b6f953196e460dc>) will be ignored.

The start address and end address of the memory range will be rounded down and rounded up respectively to be aligned to CPU page size before the prefetch operation is enqueued in the stream.

If no physical memory has been allocated for this region, then this memory region will be populated and mapped on the destination device. If there's insufficient memory to prefetch the desired region, the Unified Memory driver may evict pages from other [cuMemAllocManaged](<group__CUDA__MEM.html#group__CUDA__MEM_1gb347ded34dc326af404aa02af5388a32> "Allocates memory that will be automatically managed by the Unified Memory system.") allocations to host memory in order to make room. Device memory allocated using [cuMemAlloc](<group__CUDA__MEM.html#group__CUDA__MEM_1gb82d2a09844a58dd9e744dc31e8aa467> "Allocates device memory.") or [cuArrayCreate](<group__CUDA__MEM.html#group__CUDA__MEM_1g4192ff387a81c3bd5ed8c391ed62ca24> "Creates a 1D or 2D CUDA array.") will not be evicted.

By default, any mappings to the previous location of the migrated pages are removed and mappings for the new location are only setup on the destination location. The exact behavior however also depends on the settings applied to this memory range via [cuMemAdvise](<group__CUDA__UNIFIED.html#group__CUDA__UNIFIED_1gaac8924b2f5a2a93f8775fb81c1a643f> "Advise about the usage of a given memory range.") as described below:

If [CU_MEM_ADVISE_SET_READ_MOSTLY](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggcfe2ed2d4567745dd4ad41034136fff35a99fb44378c84c56668550b94157fc0>) was set on any subset of this memory range, then that subset will create a read-only copy of the pages on destination location. If however the destination location is a host NUMA node, then any pages of that subset that are already in another host NUMA node will be transferred to the destination.

If [CU_MEM_ADVISE_SET_PREFERRED_LOCATION](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggcfe2ed2d4567745dd4ad41034136fff3ddee285dc5e0e7d26469009ffd583cea>) was called on any subset of this memory range, then the pages will be migrated to `location` even if `location` is not the preferred location of any pages in the memory range.

If [CU_MEM_ADVISE_SET_ACCESSED_BY](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggcfe2ed2d4567745dd4ad41034136fff3a44e5c0ad0a77d05332739848e181a2d>) was called on any subset of this memory range, then mappings to those pages from all the appropriate processors are updated to refer to the new location if establishing such a mapping is possible. Otherwise, those mappings are cleared.

Note that this API is not required for functionality and only serves to improve performance by allowing the application to migrate data to a suitable location before it is accessed. Memory accesses to this range are always coherent and are allowed even when the data is actively being migrated.

Note that this function is asynchronous with respect to the host and all work on other devices.

Note:

  * Note that this function may also return error codes from previous, asynchronous launches.

  * This function exhibits [asynchronous](<api-sync-behavior.html#api-sync-behavior__memcpy-async>) behavior for most use cases.

  * This function uses standard [default stream](<stream-sync-behavior.html#stream-sync-behavior__default-stream>) semantics.


**See also:**

[cuMemcpy](<group__CUDA__MEM.html#group__CUDA__MEM_1g8d0ff510f26d4b87bd3a51e731e7f698> "Copies memory."), [cuMemcpyPeer](<group__CUDA__MEM.html#group__CUDA__MEM_1ge1f5c7771544fee150ada8853c7cbf4a> "Copies device memory between two contexts."), [cuMemcpyAsync](<group__CUDA__MEM.html#group__CUDA__MEM_1g5f26aaf5582ade791e5688727a178d78> "Copies memory asynchronously."), [cuMemcpy3DPeerAsync](<group__CUDA__MEM.html#group__CUDA__MEM_1gc4e4bfd9f627d3aa3695979e058f1bb8> "Copies memory between contexts asynchronously."), [cuMemAdvise](<group__CUDA__UNIFIED.html#group__CUDA__UNIFIED_1gaac8924b2f5a2a93f8775fb81c1a643f> "Advise about the usage of a given memory range."), [cudaMemPrefetchAsync](<../cuda-runtime-api/group__CUDART__MEMORY.html#group__CUDART__MEMORY_1g856fa41c8c0d28655e37b778cb9ffc65>)

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuMemPrefetchBatchAsync ( [CUdeviceptr](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g183f7b0d8ad008ea2a5fd552537ace4e>)*Â dptrs, size_t*Â sizes, size_tÂ count, [CUmemLocation](<structCUmemLocation__v1.html#structCUmemLocation__v1>)*Â prefetchLocs, size_t*Â prefetchLocIdxs, size_tÂ numPrefetchLocs, unsigned long longÂ flags, [CUstream](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gb946c7f02e09efd788a204718015d88a>)Â hStream )


Performs a batch of memory prefetches asynchronously.

######  Parameters

`dptrs`
    \- Array of pointers to be prefetched
`sizes`
    \- Array of sizes for memory prefetch operations.
`count`
    \- Size of `dptrs` and `sizes` arrays.
`prefetchLocs`
    \- Array of locations to prefetch to.
`prefetchLocIdxs`
    \- Array of indices to specify which operands each entry in the `prefetchLocs` array applies to. The locations specified in prefetchLocs[k] will be applied to copies starting from prefetchLocIdxs[k] through prefetchLocIdxs[k+1] - 1. Also prefetchLocs[numPrefetchLocs - 1] will apply to prefetches starting from prefetchLocIdxs[numPrefetchLocs \- 1] through count - 1.
`numPrefetchLocs`
    \- Size of `prefetchLocs` and `prefetchLocIdxs` arrays.
`flags`
    \- Flags reserved for future use. Must be zero.
`hStream`
    \- The stream to enqueue the operations in. Must not be legacy NULL stream.

###### Description

Performs a batch of memory prefetches. The batch as a whole executes in stream order but operations within a batch are not guaranteed to execute in any specific order. All devices in the system must have a non-zero value for the device attribute [CU_DEVICE_ATTRIBUTE_CONCURRENT_MANAGED_ACCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gge12b8a782bebe21b1ac0091bf9f4e2a333110e44c9cb6ead02f03ff6f6fd495e>) otherwise the API will return an error.

The semantics of the individual prefetch operations are as described in [cuMemPrefetchAsync](<group__CUDA__UNIFIED.html#group__CUDA__UNIFIED_1g45c0e085febc3be8fabf5c526355b6a3> "Prefetches memory to the specified destination location.").

Performs memory prefetch on address ranges specified in `dptrs` and `sizes`. Both arrays must be of the same length as specified by `count`. Each memory range specified must refer to managed memory allocated via [cuMemAllocManaged](<group__CUDA__MEM.html#group__CUDA__MEM_1gb347ded34dc326af404aa02af5388a32> "Allocates memory that will be automatically managed by the Unified Memory system.") or declared via __managed__ variables or it may also refer to system-allocated memory when all devices have a non-zero value for [CU_DEVICE_ATTRIBUTE_PAGEABLE_MEMORY_ACCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gge12b8a782bebe21b1ac0091bf9f4e2a35fdcdbe1dfc3ad5ec428c279e0efb9cd>). The prefetch location for every operation in the batch is specified in the `prefetchLocs` array. Each entry in this array can apply to more than one operation. This can be done by specifying in the `prefetchLocIdxs` array, the index of the first prefetch operation that the corresponding entry in the `prefetchLocs` array applies to. Both `prefetchLocs` and `prefetchLocIdxs` must be of the same length as specified by `numPrefetchLocs`. For example, if a batch has 10 prefetches listed in dptrs/sizes, the first 4 of which are to be prefetched to one location and the remaining 6 are to be prefetched to another, then `numPrefetchLocs` will be 2, `prefetchLocIdxs` will be {0, 4} and `prefetchLocs` will contain the two locations. Note the first entry in `prefetchLocIdxs` must always be 0. Also, each entry must be greater than the previous entry and the last entry should be less than `count`. Furthermore, `numPrefetchLocs` must be lesser than or equal to `count`.

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuMemRangeGetAttribute ( void*Â data, size_tÂ dataSize, [CUmem_range_attribute](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g3754eb90f64ed3c19b4e550d21d124fc>)Â attribute, [CUdeviceptr](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g183f7b0d8ad008ea2a5fd552537ace4e>)Â devPtr, size_tÂ count )


Query an attribute of a given memory range.

######  Parameters

`data`
    \- A pointers to a memory location where the result of each attribute query will be written to.
`dataSize`
    \- Array containing the size of data
`attribute`
    \- The attribute to query
`devPtr`
    \- Start of the range to query
`count`
    \- Size of the range to query

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>), [CUDA_ERROR_INVALID_DEVICE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e96f047e7215788ca96c81af92a04bfb6c>)

###### Description

Query an attribute about the memory range starting at `devPtr` with a size of `count` bytes. The memory range must refer to managed memory allocated via [cuMemAllocManaged](<group__CUDA__MEM.html#group__CUDA__MEM_1gb347ded34dc326af404aa02af5388a32> "Allocates memory that will be automatically managed by the Unified Memory system.") or declared via __managed__ variables.

The `attribute` parameter can take the following values:

  * [CU_MEM_RANGE_ATTRIBUTE_READ_MOSTLY](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg3754eb90f64ed3c19b4e550d21d124fcb21856250c588cd795462323c71fef7b>): If this attribute is specified, `data` will be interpreted as a 32-bit integer, and `dataSize` must be 4. The result returned will be 1 if all pages in the given memory range have read-duplication enabled, or 0 otherwise.

  * [CU_MEM_RANGE_ATTRIBUTE_PREFERRED_LOCATION](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg3754eb90f64ed3c19b4e550d21d124fcc68a2f5771f8e1b83ad29c1d65ab4875>): If this attribute is specified, `data` will be interpreted as a 32-bit integer, and `dataSize` must be 4. The result returned will be a GPU device id if all pages in the memory range have that GPU as their preferred location, or it will be CU_DEVICE_CPU if all pages in the memory range have the CPU as their preferred location, or it will be CU_DEVICE_INVALID if either all the pages don't have the same preferred location or some of the pages don't have a preferred location at all. Note that the actual location of the pages in the memory range at the time of the query may be different from the preferred location.

  * [CU_MEM_RANGE_ATTRIBUTE_ACCESSED_BY](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg3754eb90f64ed3c19b4e550d21d124fc2511c59b3d309b83f410af68280891a4>): If this attribute is specified, `data` will be interpreted as an array of 32-bit integers, and `dataSize` must be a non-zero multiple of 4. The result returned will be a list of device ids that had [CU_MEM_ADVISE_SET_ACCESSED_BY](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggcfe2ed2d4567745dd4ad41034136fff3a44e5c0ad0a77d05332739848e181a2d>) set for that entire memory range. If any device does not have that advice set for the entire memory range, that device will not be included. If `data` is larger than the number of devices that have that advice set for that memory range, CU_DEVICE_INVALID will be returned in all the extra space provided. For ex., if `dataSize` is 12 (i.e. `data` has 3 elements) and only device 0 has the advice set, then the result returned will be { 0, CU_DEVICE_INVALID, CU_DEVICE_INVALID }. If `data` is smaller than the number of devices that have that advice set, then only as many devices will be returned as can fit in the array. There is no guarantee on which specific devices will be returned, however.

  * [CU_MEM_RANGE_ATTRIBUTE_LAST_PREFETCH_LOCATION](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg3754eb90f64ed3c19b4e550d21d124fc5213666bebedfcea6128fbebaa2f7ade>): If this attribute is specified, `data` will be interpreted as a 32-bit integer, and `dataSize` must be 4. The result returned will be the last location to which all pages in the memory range were prefetched explicitly via [cuMemPrefetchAsync](<group__CUDA__UNIFIED.html#group__CUDA__UNIFIED_1g45c0e085febc3be8fabf5c526355b6a3> "Prefetches memory to the specified destination location."). This will either be a GPU id or CU_DEVICE_CPU depending on whether the last location for prefetch was a GPU or the CPU respectively. If any page in the memory range was never explicitly prefetched or if all pages were not prefetched to the same location, CU_DEVICE_INVALID will be returned. Note that this simply returns the last location that the application requested to prefetch the memory range to. It gives no indication as to whether the prefetch operation to that location has completed or even begun.

  * [CU_MEM_RANGE_ATTRIBUTE_PREFERRED_LOCATION_TYPE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg3754eb90f64ed3c19b4e550d21d124fc4403ec1d9f21a5fd1d6eb7745d0aa5c3>): If this attribute is specified, `data` will be interpreted as a [CUmemLocationType](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g75cfd5b9fa5c1c6ee2be2547bfbe882e>), and `dataSize` must be sizeof(CUmemLocationType). The [CUmemLocationType](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g75cfd5b9fa5c1c6ee2be2547bfbe882e>) returned will be [CU_MEM_LOCATION_TYPE_DEVICE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg75cfd5b9fa5c1c6ee2be2547bfbe882ea4409aa6b414995d628a320eafbbbb6e>) if all pages in the memory range have the same GPU as their preferred location, or [CUmemLocationType](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g75cfd5b9fa5c1c6ee2be2547bfbe882e>) will be [CU_MEM_LOCATION_TYPE_HOST](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg75cfd5b9fa5c1c6ee2be2547bfbe882e46800776121a71c8dc2904518a21065a>) if all pages in the memory range have the CPU as their preferred location, or it will be [CU_MEM_LOCATION_TYPE_HOST_NUMA](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg75cfd5b9fa5c1c6ee2be2547bfbe882eb61a1d3409ed83a43b5706cc004ac861>) if all the pages in the memory range have the same host NUMA node ID as their preferred location or it will be CU_MEM_LOCATION_TYPE_INVALID if either all the pages don't have the same preferred location or some of the pages don't have a preferred location at all. Note that the actual location type of the pages in the memory range at the time of the query may be different from the preferred location type.
    * [CU_MEM_RANGE_ATTRIBUTE_PREFERRED_LOCATION_ID](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg3754eb90f64ed3c19b4e550d21d124fc7c9808f73124e7e13dfa7d0138fc3b3e>): If this attribute is specified, `data` will be interpreted as a 32-bit integer, and `dataSize` must be 4. If the [CU_MEM_RANGE_ATTRIBUTE_PREFERRED_LOCATION_TYPE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg3754eb90f64ed3c19b4e550d21d124fc4403ec1d9f21a5fd1d6eb7745d0aa5c3>) query for the same address range returns [CU_MEM_LOCATION_TYPE_DEVICE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg75cfd5b9fa5c1c6ee2be2547bfbe882ea4409aa6b414995d628a320eafbbbb6e>), it will be a valid device ordinal or if it returns [CU_MEM_LOCATION_TYPE_HOST_NUMA](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg75cfd5b9fa5c1c6ee2be2547bfbe882eb61a1d3409ed83a43b5706cc004ac861>), it will be a valid host NUMA node ID or if it returns any other location type, the id should be ignored.

  * [CU_MEM_RANGE_ATTRIBUTE_LAST_PREFETCH_LOCATION_TYPE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg3754eb90f64ed3c19b4e550d21d124fc74331e0361af97f526652db843f705f8>): If this attribute is specified, `data` will be interpreted as a [CUmemLocationType](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g75cfd5b9fa5c1c6ee2be2547bfbe882e>), and `dataSize` must be sizeof(CUmemLocationType). The result returned will be the last location to which all pages in the memory range were prefetched explicitly via [cuMemPrefetchAsync](<group__CUDA__UNIFIED.html#group__CUDA__UNIFIED_1g45c0e085febc3be8fabf5c526355b6a3> "Prefetches memory to the specified destination location."). The [CUmemLocationType](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g75cfd5b9fa5c1c6ee2be2547bfbe882e>) returned will be [CU_MEM_LOCATION_TYPE_DEVICE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg75cfd5b9fa5c1c6ee2be2547bfbe882ea4409aa6b414995d628a320eafbbbb6e>) if the last prefetch location was a GPU or [CU_MEM_LOCATION_TYPE_HOST](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg75cfd5b9fa5c1c6ee2be2547bfbe882e46800776121a71c8dc2904518a21065a>) if it was the CPU or [CU_MEM_LOCATION_TYPE_HOST_NUMA](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg75cfd5b9fa5c1c6ee2be2547bfbe882eb61a1d3409ed83a43b5706cc004ac861>) if the last prefetch location was a specific host NUMA node. If any page in the memory range was never explicitly prefetched or if all pages were not prefetched to the same location, [CUmemLocationType](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g75cfd5b9fa5c1c6ee2be2547bfbe882e>) will be CU_MEM_LOCATION_TYPE_INVALID. Note that this simply returns the last location type that the application requested to prefetch the memory range to. It gives no indication as to whether the prefetch operation to that location has completed or even begun.
    * [CU_MEM_RANGE_ATTRIBUTE_LAST_PREFETCH_LOCATION_ID](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg3754eb90f64ed3c19b4e550d21d124fcb31ca7fca0ad44f236bfed3e33790b35>): If this attribute is specified, `data` will be interpreted as a 32-bit integer, and `dataSize` must be 4. If the [CU_MEM_RANGE_ATTRIBUTE_LAST_PREFETCH_LOCATION_TYPE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg3754eb90f64ed3c19b4e550d21d124fc74331e0361af97f526652db843f705f8>) query for the same address range returns [CU_MEM_LOCATION_TYPE_DEVICE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg75cfd5b9fa5c1c6ee2be2547bfbe882ea4409aa6b414995d628a320eafbbbb6e>), it will be a valid device ordinal or if it returns [CU_MEM_LOCATION_TYPE_HOST_NUMA](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg75cfd5b9fa5c1c6ee2be2547bfbe882eb61a1d3409ed83a43b5706cc004ac861>), it will be a valid host NUMA node ID or if it returns any other location type, the id should be ignored.


Note:

  * Note that this function may also return error codes from previous, asynchronous launches.

  * This function exhibits [asynchronous](<api-sync-behavior.html#api-sync-behavior__memcpy-async>) behavior for most use cases.

  * This function uses standard [default stream](<stream-sync-behavior.html#stream-sync-behavior__default-stream>) semantics.


**See also:**

[cuMemRangeGetAttributes](<group__CUDA__UNIFIED.html#group__CUDA__UNIFIED_1gc7ce142e60f8613cfb7d722b87dc9d12> "Query attributes of a given memory range."), [cuMemPrefetchAsync](<group__CUDA__UNIFIED.html#group__CUDA__UNIFIED_1g45c0e085febc3be8fabf5c526355b6a3> "Prefetches memory to the specified destination location."), [cuMemAdvise](<group__CUDA__UNIFIED.html#group__CUDA__UNIFIED_1gaac8924b2f5a2a93f8775fb81c1a643f> "Advise about the usage of a given memory range."), [cudaMemRangeGetAttribute](<../cuda-runtime-api/group__CUDART__MEMORY.html#group__CUDART__MEMORY_1g8048f6ea5ad77917444567656c140c5a>)

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuMemRangeGetAttributes ( void**Â data, size_t*Â dataSizes, [CUmem_range_attribute](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g3754eb90f64ed3c19b4e550d21d124fc>)*Â attributes, size_tÂ numAttributes, [CUdeviceptr](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g183f7b0d8ad008ea2a5fd552537ace4e>)Â devPtr, size_tÂ count )


Query attributes of a given memory range.

######  Parameters

`data`
    \- A two-dimensional array containing pointers to memory locations where the result of each attribute query will be written to.
`dataSizes`
    \- Array containing the sizes of each result
`attributes`
    \- An array of attributes to query (numAttributes and the number of attributes in this array should match)
`numAttributes`
    \- Number of attributes to query
`devPtr`
    \- Start of the range to query
`count`
    \- Size of the range to query

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_DEINITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9acf52f132faf29b473cdda6061f0f44a>), [CUDA_ERROR_INVALID_CONTEXT](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a484e9af32c1e9893ff21f0e0191a12d>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>), [CUDA_ERROR_INVALID_DEVICE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e96f047e7215788ca96c81af92a04bfb6c>)

###### Description

Query attributes of the memory range starting at `devPtr` with a size of `count` bytes. The memory range must refer to managed memory allocated via [cuMemAllocManaged](<group__CUDA__MEM.html#group__CUDA__MEM_1gb347ded34dc326af404aa02af5388a32> "Allocates memory that will be automatically managed by the Unified Memory system.") or declared via __managed__ variables. The `attributes` array will be interpreted to have `numAttributes` entries. The `dataSizes` array will also be interpreted to have `numAttributes` entries. The results of the query will be stored in `data`.

The list of supported attributes are given below. Please refer to [cuMemRangeGetAttribute](<group__CUDA__UNIFIED.html#group__CUDA__UNIFIED_1g1c92408a7d0d8875e19b1a58af56f67d> "Query an attribute of a given memory range.") for attribute descriptions and restrictions.

  * [CU_MEM_RANGE_ATTRIBUTE_READ_MOSTLY](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg3754eb90f64ed3c19b4e550d21d124fcb21856250c588cd795462323c71fef7b>)

  * [CU_MEM_RANGE_ATTRIBUTE_PREFERRED_LOCATION](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg3754eb90f64ed3c19b4e550d21d124fcc68a2f5771f8e1b83ad29c1d65ab4875>)

  * [CU_MEM_RANGE_ATTRIBUTE_ACCESSED_BY](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg3754eb90f64ed3c19b4e550d21d124fc2511c59b3d309b83f410af68280891a4>)

  * [CU_MEM_RANGE_ATTRIBUTE_LAST_PREFETCH_LOCATION](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg3754eb90f64ed3c19b4e550d21d124fc5213666bebedfcea6128fbebaa2f7ade>)

  * [CU_MEM_RANGE_ATTRIBUTE_PREFERRED_LOCATION_TYPE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg3754eb90f64ed3c19b4e550d21d124fc4403ec1d9f21a5fd1d6eb7745d0aa5c3>)

  * [CU_MEM_RANGE_ATTRIBUTE_PREFERRED_LOCATION_ID](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg3754eb90f64ed3c19b4e550d21d124fc7c9808f73124e7e13dfa7d0138fc3b3e>)

  * [CU_MEM_RANGE_ATTRIBUTE_LAST_PREFETCH_LOCATION_TYPE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg3754eb90f64ed3c19b4e550d21d124fc74331e0361af97f526652db843f705f8>)

  * [CU_MEM_RANGE_ATTRIBUTE_LAST_PREFETCH_LOCATION_ID](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg3754eb90f64ed3c19b4e550d21d124fcb31ca7fca0ad44f236bfed3e33790b35>)


Note:

Note that this function may also return error codes from previous, asynchronous launches.

**See also:**

[cuMemRangeGetAttribute](<group__CUDA__UNIFIED.html#group__CUDA__UNIFIED_1g1c92408a7d0d8875e19b1a58af56f67d> "Query an attribute of a given memory range."), [cuMemAdvise](<group__CUDA__UNIFIED.html#group__CUDA__UNIFIED_1gaac8924b2f5a2a93f8775fb81c1a643f> "Advise about the usage of a given memory range."), [cuMemPrefetchAsync](<group__CUDA__UNIFIED.html#group__CUDA__UNIFIED_1g45c0e085febc3be8fabf5c526355b6a3> "Prefetches memory to the specified destination location."), [cudaMemRangeGetAttributes](<../cuda-runtime-api/group__CUDART__MEMORY.html#group__CUDART__MEMORY_1g1a9199e7709c7817d1c715cfbe174d05>)

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuPointerGetAttribute ( void*Â data, [CUpointer_attribute](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc2cce590e35080745e72633dfc6e0b60>)Â attribute, [CUdeviceptr](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g183f7b0d8ad008ea2a5fd552537ace4e>)Â ptr )


Returns information about a pointer.

######  Parameters

`data`
    \- Returned pointer attribute value
`attribute`
    \- Pointer attribute to query
`ptr`
    \- Pointer

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_DEINITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9acf52f132faf29b473cdda6061f0f44a>), [CUDA_ERROR_NOT_INITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e98feb999f0af99b4a25ab26b3866f4df8>), [CUDA_ERROR_INVALID_CONTEXT](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a484e9af32c1e9893ff21f0e0191a12d>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>), [CUDA_ERROR_INVALID_DEVICE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e96f047e7215788ca96c81af92a04bfb6c>)

###### Description

The supported attributes are:

  * [CU_POINTER_ATTRIBUTE_CONTEXT](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc2cce590e35080745e72633dfc6e0b60f0470fdbd1a5ff72c341f762f49506ab>):


Returns in `*data` the [CUcontext](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gf9f5bd81658f866613785b3a0bb7d7d9>) in which `ptr` was allocated or registered. The type of `data` must be [CUcontext](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gf9f5bd81658f866613785b3a0bb7d7d9>) *.

If `ptr` was not allocated by, mapped by, or registered with a [CUcontext](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gf9f5bd81658f866613785b3a0bb7d7d9>) which uses unified virtual addressing then [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>) is returned.

  * [CU_POINTER_ATTRIBUTE_MEMORY_TYPE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc2cce590e35080745e72633dfc6e0b600409e16293b60b383f30a9b417b2917c>):


Returns in `*data` the physical memory type of the memory that `ptr` addresses as a [CUmemorytype](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g8a114cc994ad2e865c44ef3838eaec72>) enumerated value. The type of `data` must be unsigned int.

If `ptr` addresses device memory then `*data` is set to [CU_MEMORYTYPE_DEVICE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg8a114cc994ad2e865c44ef3838eaec72ec7e15ba4b111a26adb3487023707299>). The particular [CUdevice](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g41ca2a24a242b36ef2ca77330b5fb72a>) on which the memory resides is the [CUdevice](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g41ca2a24a242b36ef2ca77330b5fb72a>) of the [CUcontext](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gf9f5bd81658f866613785b3a0bb7d7d9>) returned by the [CU_POINTER_ATTRIBUTE_CONTEXT](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc2cce590e35080745e72633dfc6e0b60f0470fdbd1a5ff72c341f762f49506ab>) attribute of `ptr`.

If `ptr` addresses host memory then `*data` is set to [CU_MEMORYTYPE_HOST](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg8a114cc994ad2e865c44ef3838eaec727f98a88f26eec8490bfc180c5a73e101>).

If `ptr` was not allocated by, mapped by, or registered with a [CUcontext](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gf9f5bd81658f866613785b3a0bb7d7d9>) which uses unified virtual addressing then [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>) is returned.

If the current [CUcontext](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gf9f5bd81658f866613785b3a0bb7d7d9>) does not support unified virtual addressing then [CUDA_ERROR_INVALID_CONTEXT](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a484e9af32c1e9893ff21f0e0191a12d>) is returned.

  * [CU_POINTER_ATTRIBUTE_DEVICE_POINTER](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc2cce590e35080745e72633dfc6e0b60b5446064bbfa484ea8d13025f1573d5d>):


Returns in `*data` the device pointer value through which `ptr` may be accessed by kernels running in the current [CUcontext](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gf9f5bd81658f866613785b3a0bb7d7d9>). The type of `data` must be CUdeviceptr *.

If there exists no device pointer value through which kernels running in the current [CUcontext](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gf9f5bd81658f866613785b3a0bb7d7d9>) may access `ptr` then [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>) is returned.

If there is no current [CUcontext](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gf9f5bd81658f866613785b3a0bb7d7d9>) then [CUDA_ERROR_INVALID_CONTEXT](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a484e9af32c1e9893ff21f0e0191a12d>) is returned.

Except in the exceptional disjoint addressing cases discussed below, the value returned in `*data` will equal the input value `ptr`.

  * [CU_POINTER_ATTRIBUTE_HOST_POINTER](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc2cce590e35080745e72633dfc6e0b60ab17d9902b1b631982ae6a3a9a436fdc>):


Returns in `*data` the host pointer value through which `ptr` may be accessed by by the host program. The type of `data` must be void **. If there exists no host pointer value through which the host program may directly access `ptr` then [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>) is returned.

Except in the exceptional disjoint addressing cases discussed below, the value returned in `*data` will equal the input value `ptr`.

  * [CU_POINTER_ATTRIBUTE_P2P_TOKENS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc2cce590e35080745e72633dfc6e0b60995003218508cc15bfcf197aa9b30a1b>):


Returns in `*data` two tokens for use with the nv-p2p.h Linux kernel interface. `data` must be a struct of type CUDA_POINTER_ATTRIBUTE_P2P_TOKENS.

`ptr` must be a pointer to memory obtained from :[cuMemAlloc()](<group__CUDA__MEM.html#group__CUDA__MEM_1gb82d2a09844a58dd9e744dc31e8aa467> "Allocates device memory."). Note that p2pToken and vaSpaceToken are only valid for the lifetime of the source allocation. A subsequent allocation at the same address may return completely different tokens. Querying this attribute has a side effect of setting the attribute [CU_POINTER_ATTRIBUTE_SYNC_MEMOPS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc2cce590e35080745e72633dfc6e0b60db5380c3201afdae3556cce8834504e1>) for the region of memory that `ptr` points to.

  * [CU_POINTER_ATTRIBUTE_SYNC_MEMOPS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc2cce590e35080745e72633dfc6e0b60db5380c3201afdae3556cce8834504e1>):


A boolean attribute which when set, ensures that synchronous memory operations initiated on the region of memory that `ptr` points to will always synchronize. See further documentation in the section titled "API synchronization behavior" to learn more about cases when synchronous memory operations can exhibit asynchronous behavior.

  * [CU_POINTER_ATTRIBUTE_BUFFER_ID](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc2cce590e35080745e72633dfc6e0b60d891336d10c16c3ea8140fa581c5446f>):


Returns in `*data` a buffer ID which is guaranteed to be unique within the process. `data` must point to an unsigned long long.

`ptr` must be a pointer to memory obtained from a CUDA memory allocation API. Every memory allocation from any of the CUDA memory allocation APIs will have a unique ID over a process lifetime. Subsequent allocations do not reuse IDs from previous freed allocations. IDs are only unique within a single process.

  * [CU_POINTER_ATTRIBUTE_IS_MANAGED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc2cce590e35080745e72633dfc6e0b60893cfce785d799fb93826537fbb72a1d>):


Returns in `*data` a boolean that indicates whether the pointer points to managed memory or not.

If `ptr` is not a valid CUDA pointer then [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>) is returned.

  * [CU_POINTER_ATTRIBUTE_DEVICE_ORDINAL](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc2cce590e35080745e72633dfc6e0b60cb7636b0198450ddb390ab87e98d83a0>):


Returns in `*data` an integer representing a device ordinal of a device against which the memory was allocated or registered.

  * [CU_POINTER_ATTRIBUTE_IS_LEGACY_CUDA_IPC_CAPABLE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc2cce590e35080745e72633dfc6e0b60b9f25a1b90274b624254eaaf836102fc>):


Returns in `*data` a boolean that indicates if this pointer maps to an allocation that is suitable for [cudaIpcGetMemHandle](<../cuda-runtime-api/group__CUDART__DEVICE.html#group__CUDART__DEVICE_1g8a37f7dfafaca652391d0758b3667539>).

  * [CU_POINTER_ATTRIBUTE_RANGE_START_ADDR](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc2cce590e35080745e72633dfc6e0b6060f2fa33283dda44d552e828bdcc4cdc>):


Returns in `*data` the starting address for the allocation referenced by the device pointer `ptr`. Note that this is not necessarily the address of the mapped region, but the address of the mappable address range `ptr` references (e.g. from [cuMemAddressReserve](<group__CUDA__VA.html#group__CUDA__VA_1ge489256c107df2a07ddf96d80c86cd9b> "Allocate an address range reservation.")).

  * [CU_POINTER_ATTRIBUTE_RANGE_SIZE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc2cce590e35080745e72633dfc6e0b60339f4a7e16696c0a2a4bcc4acf394ec4>):


Returns in `*data` the size for the allocation referenced by the device pointer `ptr`. Note that this is not necessarily the size of the mapped region, but the size of the mappable address range `ptr` references (e.g. from [cuMemAddressReserve](<group__CUDA__VA.html#group__CUDA__VA_1ge489256c107df2a07ddf96d80c86cd9b> "Allocate an address range reservation.")). To retrieve the size of the mapped region, see [cuMemGetAddressRange](<group__CUDA__MEM.html#group__CUDA__MEM_1g64fee5711274a2a0573a789c94d8299b> "Get information on memory allocations.")

  * [CU_POINTER_ATTRIBUTE_MAPPED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc2cce590e35080745e72633dfc6e0b600bae89da103451e804fc005fb5f3ea78>):


Returns in `*data` a boolean that indicates if this pointer is in a valid address range that is mapped to a backing allocation.

  * [CU_POINTER_ATTRIBUTE_ALLOWED_HANDLE_TYPES](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc2cce590e35080745e72633dfc6e0b60a1f518cc4336f0f286b36a748ad91a0e>):


Returns a bitmask of the allowed handle types for an allocation that may be passed to [cuMemExportToShareableHandle](<group__CUDA__VA.html#group__CUDA__VA_1g633f273b155815f23c1d70e7d9384c56> "Exports an allocation to a requested shareable handle type.").

  * [CU_POINTER_ATTRIBUTE_MEMPOOL_HANDLE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc2cce590e35080745e72633dfc6e0b6023a9869c7f811f700ed67dfd762c26e0>):


Returns in `*data` the handle to the mempool that the allocation was obtained from.

  * [CU_POINTER_ATTRIBUTE_IS_HW_DECOMPRESS_CAPABLE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc2cce590e35080745e72633dfc6e0b60820cbe95f809088e8045fcb1c9857bf5>):


Returns in `*data` a boolean that indicates whether the pointer points to memory that is capable to be used for hardware accelerated decompression.

Note that for most allocations in the unified virtual address space the host and device pointer for accessing the allocation will be the same. The exceptions to this are

  * user memory registered using [cuMemHostRegister](<group__CUDA__MEM.html#group__CUDA__MEM_1gf0a9fe11544326dabd743b7aa6b54223> "Registers an existing host memory range for use by CUDA.")

  * host memory allocated using [cuMemHostAlloc](<group__CUDA__MEM.html#group__CUDA__MEM_1g572ca4011bfcb25034888a14d4e035b9> "Allocates page-locked host memory.") with the [CU_MEMHOSTALLOC_WRITECOMBINED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g7361580951deecace15352c97a210038>) flag For these types of allocation there will exist separate, disjoint host and device addresses for accessing the allocation. In particular

  * The host address will correspond to an invalid unmapped device address (which will result in an exception if accessed from the device)

  * The device address will correspond to an invalid unmapped host address (which will result in an exception if accessed from the host). For these types of allocations, querying [CU_POINTER_ATTRIBUTE_HOST_POINTER](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc2cce590e35080745e72633dfc6e0b60ab17d9902b1b631982ae6a3a9a436fdc>) and [CU_POINTER_ATTRIBUTE_DEVICE_POINTER](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc2cce590e35080745e72633dfc6e0b60b5446064bbfa484ea8d13025f1573d5d>) may be used to retrieve the host and device addresses from either address.


Note:

Note that this function may also return error codes from previous, asynchronous launches.

**See also:**

[cuPointerSetAttribute](<group__CUDA__UNIFIED.html#group__CUDA__UNIFIED_1g89f7ad29a657e574fdea2624b74d138e> "Set attributes on a previously allocated memory region."), [cuMemAlloc](<group__CUDA__MEM.html#group__CUDA__MEM_1gb82d2a09844a58dd9e744dc31e8aa467> "Allocates device memory."), [cuMemFree](<group__CUDA__MEM.html#group__CUDA__MEM_1g89b3f154e17cc89b6eea277dbdf5c93a> "Frees device memory."), [cuMemAllocHost](<group__CUDA__MEM.html#group__CUDA__MEM_1gdd8311286d2c2691605362c689bc64e0> "Allocates page-locked host memory."), [cuMemFreeHost](<group__CUDA__MEM.html#group__CUDA__MEM_1g62e0fdbe181dab6b1c90fa1a51c7b92c> "Frees page-locked host memory."), [cuMemHostAlloc](<group__CUDA__MEM.html#group__CUDA__MEM_1g572ca4011bfcb25034888a14d4e035b9> "Allocates page-locked host memory."), [cuMemHostRegister](<group__CUDA__MEM.html#group__CUDA__MEM_1gf0a9fe11544326dabd743b7aa6b54223> "Registers an existing host memory range for use by CUDA."), [cuMemHostUnregister](<group__CUDA__MEM.html#group__CUDA__MEM_1g63f450c8125359be87b7623b1c0b2a14> "Unregisters a memory range that was registered with cuMemHostRegister."), [cudaPointerGetAttributes](<../cuda-runtime-api/group__CUDART__UNIFIED.html#group__CUDART__UNIFIED_1gd89830e17d399c064a2f3c3fa8bb4390>)

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuPointerGetAttributes ( unsigned int Â numAttributes, [CUpointer_attribute](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc2cce590e35080745e72633dfc6e0b60>)*Â attributes, void**Â data, [CUdeviceptr](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g183f7b0d8ad008ea2a5fd552537ace4e>)Â ptr )


Returns information about a pointer.

######  Parameters

`numAttributes`
    \- Number of attributes to query
`attributes`
    \- An array of attributes to query (numAttributes and the number of attributes in this array should match)
`data`
    \- A two-dimensional array containing pointers to memory locations where the result of each attribute query will be written to.
`ptr`
    \- Pointer to query

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_DEINITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9acf52f132faf29b473cdda6061f0f44a>), [CUDA_ERROR_INVALID_CONTEXT](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a484e9af32c1e9893ff21f0e0191a12d>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>), [CUDA_ERROR_INVALID_DEVICE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e96f047e7215788ca96c81af92a04bfb6c>)

###### Description

The supported attributes are (refer to [cuPointerGetAttribute](<group__CUDA__UNIFIED.html#group__CUDA__UNIFIED_1g0c28ed0aff848042bc0533110e45820c> "Returns information about a pointer.") for attribute descriptions and restrictions):

  * [CU_POINTER_ATTRIBUTE_CONTEXT](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc2cce590e35080745e72633dfc6e0b60f0470fdbd1a5ff72c341f762f49506ab>)

  * [CU_POINTER_ATTRIBUTE_MEMORY_TYPE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc2cce590e35080745e72633dfc6e0b600409e16293b60b383f30a9b417b2917c>)

  * [CU_POINTER_ATTRIBUTE_DEVICE_POINTER](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc2cce590e35080745e72633dfc6e0b60b5446064bbfa484ea8d13025f1573d5d>)

  * [CU_POINTER_ATTRIBUTE_HOST_POINTER](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc2cce590e35080745e72633dfc6e0b60ab17d9902b1b631982ae6a3a9a436fdc>)

  * [CU_POINTER_ATTRIBUTE_SYNC_MEMOPS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc2cce590e35080745e72633dfc6e0b60db5380c3201afdae3556cce8834504e1>)

  * [CU_POINTER_ATTRIBUTE_BUFFER_ID](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc2cce590e35080745e72633dfc6e0b60d891336d10c16c3ea8140fa581c5446f>)

  * [CU_POINTER_ATTRIBUTE_IS_MANAGED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc2cce590e35080745e72633dfc6e0b60893cfce785d799fb93826537fbb72a1d>)

  * [CU_POINTER_ATTRIBUTE_DEVICE_ORDINAL](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc2cce590e35080745e72633dfc6e0b60cb7636b0198450ddb390ab87e98d83a0>)

  * [CU_POINTER_ATTRIBUTE_RANGE_START_ADDR](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc2cce590e35080745e72633dfc6e0b6060f2fa33283dda44d552e828bdcc4cdc>)

  * [CU_POINTER_ATTRIBUTE_RANGE_SIZE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc2cce590e35080745e72633dfc6e0b60339f4a7e16696c0a2a4bcc4acf394ec4>)

  * [CU_POINTER_ATTRIBUTE_MAPPED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc2cce590e35080745e72633dfc6e0b600bae89da103451e804fc005fb5f3ea78>)

  * [CU_POINTER_ATTRIBUTE_IS_LEGACY_CUDA_IPC_CAPABLE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc2cce590e35080745e72633dfc6e0b60b9f25a1b90274b624254eaaf836102fc>)

  * [CU_POINTER_ATTRIBUTE_ALLOWED_HANDLE_TYPES](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc2cce590e35080745e72633dfc6e0b60a1f518cc4336f0f286b36a748ad91a0e>)

  * [CU_POINTER_ATTRIBUTE_MEMPOOL_HANDLE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc2cce590e35080745e72633dfc6e0b6023a9869c7f811f700ed67dfd762c26e0>)

  * [CU_POINTER_ATTRIBUTE_IS_HW_DECOMPRESS_CAPABLE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc2cce590e35080745e72633dfc6e0b60820cbe95f809088e8045fcb1c9857bf5>)


Unlike [cuPointerGetAttribute](<group__CUDA__UNIFIED.html#group__CUDA__UNIFIED_1g0c28ed0aff848042bc0533110e45820c> "Returns information about a pointer."), this function will not return an error when the `ptr` encountered is not a valid CUDA pointer. Instead, the attributes are assigned default NULL values and CUDA_SUCCESS is returned.

If `ptr` was not allocated by, mapped by, or registered with a [CUcontext](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gf9f5bd81658f866613785b3a0bb7d7d9>) which uses UVA (Unified Virtual Addressing), [CUDA_ERROR_INVALID_CONTEXT](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a484e9af32c1e9893ff21f0e0191a12d>) is returned.

Note:

Note that this function may also return error codes from previous, asynchronous launches.

**See also:**

[cuPointerGetAttribute](<group__CUDA__UNIFIED.html#group__CUDA__UNIFIED_1g0c28ed0aff848042bc0533110e45820c> "Returns information about a pointer."), [cuPointerSetAttribute](<group__CUDA__UNIFIED.html#group__CUDA__UNIFIED_1g89f7ad29a657e574fdea2624b74d138e> "Set attributes on a previously allocated memory region."), [cudaPointerGetAttributes](<../cuda-runtime-api/group__CUDART__UNIFIED.html#group__CUDART__UNIFIED_1gd89830e17d399c064a2f3c3fa8bb4390>)

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuPointerSetAttribute ( const void*Â value, [CUpointer_attribute](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc2cce590e35080745e72633dfc6e0b60>)Â attribute, [CUdeviceptr](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g183f7b0d8ad008ea2a5fd552537ace4e>)Â ptr )


Set attributes on a previously allocated memory region.

######  Parameters

`value`
    \- Pointer to memory containing the value to be set
`attribute`
    \- Pointer attribute to set
`ptr`
    \- Pointer to a memory region allocated using CUDA memory allocation APIs

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_DEINITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9acf52f132faf29b473cdda6061f0f44a>), [CUDA_ERROR_NOT_INITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e98feb999f0af99b4a25ab26b3866f4df8>), [CUDA_ERROR_INVALID_CONTEXT](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a484e9af32c1e9893ff21f0e0191a12d>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>), [CUDA_ERROR_INVALID_DEVICE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e96f047e7215788ca96c81af92a04bfb6c>)

###### Description

The supported attributes are:

  * [CU_POINTER_ATTRIBUTE_SYNC_MEMOPS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc2cce590e35080745e72633dfc6e0b60db5380c3201afdae3556cce8834504e1>):


A boolean attribute that can either be set (1) or unset (0). When set, the region of memory that `ptr` points to is guaranteed to always synchronize memory operations that are synchronous. If there are some previously initiated synchronous memory operations that are pending when this attribute is set, the function does not return until those memory operations are complete. See further documentation in the section titled "API synchronization behavior" to learn more about cases when synchronous memory operations can exhibit asynchronous behavior. `value` will be considered as a pointer to an unsigned integer to which this attribute is to be set.

Note:

Note that this function may also return error codes from previous, asynchronous launches.

**See also:**

[cuPointerGetAttribute](<group__CUDA__UNIFIED.html#group__CUDA__UNIFIED_1g0c28ed0aff848042bc0533110e45820c> "Returns information about a pointer."), [cuPointerGetAttributes](<group__CUDA__UNIFIED.html#group__CUDA__UNIFIED_1gf65e9ea532e311dd049166e4894955ad> "Returns information about a pointer."), [cuMemAlloc](<group__CUDA__MEM.html#group__CUDA__MEM_1gb82d2a09844a58dd9e744dc31e8aa467> "Allocates device memory."), [cuMemFree](<group__CUDA__MEM.html#group__CUDA__MEM_1g89b3f154e17cc89b6eea277dbdf5c93a> "Frees device memory."), [cuMemAllocHost](<group__CUDA__MEM.html#group__CUDA__MEM_1gdd8311286d2c2691605362c689bc64e0> "Allocates page-locked host memory."), [cuMemFreeHost](<group__CUDA__MEM.html#group__CUDA__MEM_1g62e0fdbe181dab6b1c90fa1a51c7b92c> "Frees page-locked host memory."), [cuMemHostAlloc](<group__CUDA__MEM.html#group__CUDA__MEM_1g572ca4011bfcb25034888a14d4e035b9> "Allocates page-locked host memory."), [cuMemHostRegister](<group__CUDA__MEM.html#group__CUDA__MEM_1gf0a9fe11544326dabd743b7aa6b54223> "Registers an existing host memory range for use by CUDA."), [cuMemHostUnregister](<group__CUDA__MEM.html#group__CUDA__MEM_1g63f450c8125359be87b7623b1c0b2a14> "Unregisters a memory range that was registered with cuMemHostRegister.")

* * *


---

# Stream Management

## 6.18.Â Stream Management

This section describes the stream management functions of the low-level CUDA driver application programming interface.

### Functions

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuStreamAddCallback](<#group__CUDA__STREAM_1g613d97a277d7640f4cb1c03bd51c2483>) ( [CUstream](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gb946c7f02e09efd788a204718015d88a>)Â hStream, [CUstreamCallback](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ge5743a8c48527f1040107a68205c5ba9>)Â callback, void*Â userData, unsigned int Â flags )
     Add a callback to a compute stream.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuStreamAttachMemAsync](<#group__CUDA__STREAM_1g6e468d680e263e7eba02a56643c50533>) ( [CUstream](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gb946c7f02e09efd788a204718015d88a>)Â hStream, [CUdeviceptr](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g183f7b0d8ad008ea2a5fd552537ace4e>)Â dptr, size_tÂ length, unsigned int Â flags )
     Attach memory to a stream asynchronously.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuStreamBeginCapture](<#group__CUDA__STREAM_1g767167da0bbf07157dc20b6c258a2143>) ( [CUstream](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gb946c7f02e09efd788a204718015d88a>)Â hStream, [CUstreamCaptureMode](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gd984ba65031d63f1ed11ec76728c2669>)Â mode )
     Begins graph capture on a stream.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuStreamBeginCaptureToGraph](<#group__CUDA__STREAM_1gac495e0527d1dd6437f95ee482f61865>) ( [CUstream](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gb946c7f02e09efd788a204718015d88a>)Â hStream, [CUgraph](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g69f555c38df5b3fa1ed25efef794739a>)Â hGraph, const [CUgraphNode](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc72514a94dacc85ed0617f979211079c>)*Â dependencies, const [CUgraphEdgeData](<structCUgraphEdgeData.html#structCUgraphEdgeData>)*Â dependencyData, size_tÂ numDependencies, [CUstreamCaptureMode](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gd984ba65031d63f1ed11ec76728c2669>)Â mode )
     Begins graph capture on a stream to an existing graph.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuStreamCopyAttributes](<#group__CUDA__STREAM_1g680f5399f6126cc4a99bc5eee4c2eff0>) ( [CUstream](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gb946c7f02e09efd788a204718015d88a>)Â dst, [CUstream](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gb946c7f02e09efd788a204718015d88a>)Â src )
     Copies attributes from source stream to destination stream.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuStreamCreate](<#group__CUDA__STREAM_1ga581f0c5833e21ded8b5a56594e243f4>) ( [CUstream](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gb946c7f02e09efd788a204718015d88a>)*Â phStream, unsigned int Â Flags )
     Create a stream.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuStreamCreateWithPriority](<#group__CUDA__STREAM_1g95c1a8c7c3dacb13091692dd9c7f7471>) ( [CUstream](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gb946c7f02e09efd788a204718015d88a>)*Â phStream, unsigned int Â flags, int Â priority )
     Create a stream with the given priority.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuStreamDestroy](<#group__CUDA__STREAM_1g244c8833de4596bcd31a06cdf21ee758>) ( [CUstream](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gb946c7f02e09efd788a204718015d88a>)Â hStream )
     Destroys a stream.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuStreamEndCapture](<#group__CUDA__STREAM_1g03dab8b2ba76b00718955177a929970c>) ( [CUstream](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gb946c7f02e09efd788a204718015d88a>)Â hStream, [CUgraph](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g69f555c38df5b3fa1ed25efef794739a>)*Â phGraph )
     Ends capture on a stream, returning the captured graph.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuStreamGetAttribute](<#group__CUDA__STREAM_1g0598bb5295f3a62761b93c2d63d2266c>) ( [CUstream](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gb946c7f02e09efd788a204718015d88a>)Â hStream, [CUstreamAttrID](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g6f6565b334be6bb3134868e10bbdd331>)Â attr, [CUstreamAttrValue](<unionCUlaunchAttributeValue.html#unionCUlaunchAttributeValue>)*Â value_out )
     Queries stream attribute.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuStreamGetCaptureInfo](<#group__CUDA__STREAM_1g85f03299332d6cf37578409d0e4b47ce>) ( [CUstream](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gb946c7f02e09efd788a204718015d88a>)Â hStream, [CUstreamCaptureStatus](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g7480c0f2bd19894e54fcd2c04d6efb91>)*Â captureStatus_out, cuuint64_t*Â id_out, [CUgraph](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g69f555c38df5b3fa1ed25efef794739a>)*Â graph_out, const [CUgraphNode](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc72514a94dacc85ed0617f979211079c>)**Â dependencies_out, const [CUgraphEdgeData](<structCUgraphEdgeData.html#structCUgraphEdgeData>)**Â edgeData_out, size_t*Â numDependencies_out )
     Query a stream's capture state.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuStreamGetCtx](<#group__CUDA__STREAM_1g1107907025eaa3387fdc590a9379a681>) ( [CUstream](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gb946c7f02e09efd788a204718015d88a>)Â hStream, [CUcontext](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gf9f5bd81658f866613785b3a0bb7d7d9>)*Â pctx )
     Query the context associated with a stream.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuStreamGetCtx_v2](<#group__CUDA__STREAM_1gd7eab81f618ec370a92c5e7d88ea11fa>) ( [CUstream](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gb946c7f02e09efd788a204718015d88a>)Â hStream, [CUcontext](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gf9f5bd81658f866613785b3a0bb7d7d9>)*Â pCtx, [CUgreenCtx](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g453cb79a1ceb13bec502a9c5f06a0268>)*Â pGreenCtx )
     Query the contexts associated with a stream.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuStreamGetDevice](<#group__CUDA__STREAM_1g1198995e0a122783ede50814b8c7a29b>) ( [CUstream](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gb946c7f02e09efd788a204718015d88a>)Â hStream, [CUdevice](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g41ca2a24a242b36ef2ca77330b5fb72a>)*Â device )
     Returns the device handle of the stream.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuStreamGetFlags](<#group__CUDA__STREAM_1g4d39786855a6bed01215c1907fbbfbb7>) ( [CUstream](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gb946c7f02e09efd788a204718015d88a>)Â hStream, unsigned int*Â flags )
     Query the flags of a given stream.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuStreamGetId](<#group__CUDA__STREAM_1g5dafd2b6f48caeb13d5110a7f21e60e3>) ( [CUstream](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gb946c7f02e09efd788a204718015d88a>)Â hStream, unsigned long long*Â streamId )
     Returns the unique Id associated with the stream handle supplied.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuStreamGetPriority](<#group__CUDA__STREAM_1g5bd5cb26915a2ecf1921807339488484>) ( [CUstream](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gb946c7f02e09efd788a204718015d88a>)Â hStream, int*Â priority )
     Query the priority of a given stream.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuStreamIsCapturing](<#group__CUDA__STREAM_1g37823c49206e3704ae23c7ad78560bca>) ( [CUstream](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gb946c7f02e09efd788a204718015d88a>)Â hStream, [CUstreamCaptureStatus](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g7480c0f2bd19894e54fcd2c04d6efb91>)*Â captureStatus )
     Returns a stream's capture status.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuStreamQuery](<#group__CUDA__STREAM_1g1b0d24bbe97fa68e4bc511fb6adfeb0b>) ( [CUstream](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gb946c7f02e09efd788a204718015d88a>)Â hStream )
     Determine status of a compute stream.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuStreamSetAttribute](<#group__CUDA__STREAM_1ga2c5fc0292861a42f264af6ca48be8c0>) ( [CUstream](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gb946c7f02e09efd788a204718015d88a>)Â hStream, [CUstreamAttrID](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g6f6565b334be6bb3134868e10bbdd331>)Â attr, const [CUstreamAttrValue](<unionCUlaunchAttributeValue.html#unionCUlaunchAttributeValue>)*Â value )
     Sets stream attribute.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuStreamSynchronize](<#group__CUDA__STREAM_1g15e49dd91ec15991eb7c0a741beb7dad>) ( [CUstream](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gb946c7f02e09efd788a204718015d88a>)Â hStream )
     Wait until a stream's tasks are completed.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuStreamUpdateCaptureDependencies](<#group__CUDA__STREAM_1g0cd3210434f3e0796c492cfa0d4b4bd1>) ( [CUstream](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gb946c7f02e09efd788a204718015d88a>)Â hStream, [CUgraphNode](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc72514a94dacc85ed0617f979211079c>)*Â dependencies, const [CUgraphEdgeData](<structCUgraphEdgeData.html#structCUgraphEdgeData>)*Â dependencyData, size_tÂ numDependencies, unsigned int Â flags )
     Update the set of dependencies in a capturing stream.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuStreamWaitEvent](<#group__CUDA__STREAM_1g6a898b652dfc6aa1d5c8d97062618b2f>) ( [CUstream](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gb946c7f02e09efd788a204718015d88a>)Â hStream, [CUevent](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g6d740185cf0953636d4ae37f68d7559b>)Â hEvent, unsigned int Â Flags )
     Make a compute stream wait on an event.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuThreadExchangeStreamCaptureMode](<#group__CUDA__STREAM_1g378135b262f02a43a7caeab239ae493d>) ( [CUstreamCaptureMode](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gd984ba65031d63f1ed11ec76728c2669>)*Â mode )
     Swaps the stream capture interaction mode for a thread.

### Functions

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuStreamAddCallback ( [CUstream](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gb946c7f02e09efd788a204718015d88a>)Â hStream, [CUstreamCallback](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ge5743a8c48527f1040107a68205c5ba9>)Â callback, void*Â userData, unsigned int Â flags )


Add a callback to a compute stream.

######  Parameters

`hStream`
    \- Stream to add callback to
`callback`
    \- The function to call once preceding stream operations are complete
`userData`
    \- User specified data to be passed to the callback function
`flags`
    \- Reserved for future use, must be 0

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_DEINITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9acf52f132faf29b473cdda6061f0f44a>), [CUDA_ERROR_NOT_INITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e98feb999f0af99b4a25ab26b3866f4df8>), [CUDA_ERROR_INVALID_CONTEXT](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a484e9af32c1e9893ff21f0e0191a12d>), [CUDA_ERROR_INVALID_HANDLE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e90fd2e63260c6317ba943af0f7e4b8d21>), [CUDA_ERROR_NOT_SUPPORTED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e954756ae7ade0dfd09faeccb513dd831b>)

###### Description

Note:

This function is slated for eventual deprecation and removal. If you do not require the callback to execute in case of a device error, consider using [cuLaunchHostFunc](<group__CUDA__EXEC.html#group__CUDA__EXEC_1gab95a78143bae7f21eebb978f91e7f3f> "Enqueues a host function call in a stream."). Additionally, this function is not supported with [cuStreamBeginCapture](<group__CUDA__STREAM.html#group__CUDA__STREAM_1g767167da0bbf07157dc20b6c258a2143> "Begins graph capture on a stream.") and [cuStreamEndCapture](<group__CUDA__STREAM.html#group__CUDA__STREAM_1g03dab8b2ba76b00718955177a929970c> "Ends capture on a stream, returning the captured graph."), unlike [cuLaunchHostFunc](<group__CUDA__EXEC.html#group__CUDA__EXEC_1gab95a78143bae7f21eebb978f91e7f3f> "Enqueues a host function call in a stream.").

Adds a callback to be called on the host after all currently enqueued items in the stream have completed. For each cuStreamAddCallback call, the callback will be executed exactly once. The callback will block later work in the stream until it is finished.

The callback may be passed [CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>) or an error code. In the event of a device error, all subsequently executed callbacks will receive an appropriate [CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>).

Callbacks must not make any CUDA API calls. Attempting to use a CUDA API will result in [CUDA_ERROR_NOT_PERMITTED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9e23d0197c490ec332a43e55b167968a3>). Callbacks must not perform any synchronization that may depend on outstanding device work or other callbacks that are not mandated to run earlier. Callbacks without a mandated order (in independent streams) execute in undefined order and may be serialized.

For the purposes of Unified Memory, callback execution makes a number of guarantees:

  * The callback stream is considered idle for the duration of the callback. Thus, for example, a callback may always use memory attached to the callback stream.

  * The start of execution of a callback has the same effect as synchronizing an event recorded in the same stream immediately prior to the callback. It thus synchronizes streams which have been "joined" prior to the callback.

  * Adding device work to any stream does not have the effect of making the stream active until all preceding host functions and stream callbacks have executed. Thus, for example, a callback might use global attached memory even if work has been added to another stream, if the work has been ordered behind the callback with an event.

  * Completion of a callback does not cause a stream to become active except as described above. The callback stream will remain idle if no device work follows the callback, and will remain idle across consecutive callbacks without device work in between. Thus, for example, stream synchronization can be done by signaling from a callback at the end of the stream.


Note:

  * This function uses standard [default stream](<stream-sync-behavior.html#stream-sync-behavior__default-stream>) semantics.

  * Note that this function may also return error codes from previous, asynchronous launches.


**See also:**

[cuStreamCreate](<group__CUDA__STREAM.html#group__CUDA__STREAM_1ga581f0c5833e21ded8b5a56594e243f4> "Create a stream."), [cuStreamQuery](<group__CUDA__STREAM.html#group__CUDA__STREAM_1g1b0d24bbe97fa68e4bc511fb6adfeb0b> "Determine status of a compute stream."), [cuStreamSynchronize](<group__CUDA__STREAM.html#group__CUDA__STREAM_1g15e49dd91ec15991eb7c0a741beb7dad> "Wait until a stream's tasks are completed."), [cuStreamWaitEvent](<group__CUDA__STREAM.html#group__CUDA__STREAM_1g6a898b652dfc6aa1d5c8d97062618b2f> "Make a compute stream wait on an event."), [cuStreamDestroy](<group__CUDA__STREAM.html#group__CUDA__STREAM_1g244c8833de4596bcd31a06cdf21ee758> "Destroys a stream."), [cuMemAllocManaged](<group__CUDA__MEM.html#group__CUDA__MEM_1gb347ded34dc326af404aa02af5388a32> "Allocates memory that will be automatically managed by the Unified Memory system."), [cuStreamAttachMemAsync](<group__CUDA__STREAM.html#group__CUDA__STREAM_1g6e468d680e263e7eba02a56643c50533> "Attach memory to a stream asynchronously."), [cuLaunchHostFunc](<group__CUDA__EXEC.html#group__CUDA__EXEC_1gab95a78143bae7f21eebb978f91e7f3f> "Enqueues a host function call in a stream."), [cudaStreamAddCallback](<../cuda-runtime-api/group__CUDART__STREAM.html#group__CUDART__STREAM_1g74aa9f4b1c2f12d994bf13876a5a2498>)

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuStreamAttachMemAsync ( [CUstream](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gb946c7f02e09efd788a204718015d88a>)Â hStream, [CUdeviceptr](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g183f7b0d8ad008ea2a5fd552537ace4e>)Â dptr, size_tÂ length, unsigned int Â flags )


Attach memory to a stream asynchronously.

######  Parameters

`hStream`
    \- Stream in which to enqueue the attach operation
`dptr`
    \- Pointer to memory (must be a pointer to managed memory or to a valid host-accessible region of system-allocated pageable memory)
`length`
    \- Length of memory
`flags`
    \- Must be one of [CUmemAttach_flags](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g17c5d5f9b585aa2d6f121847d1a78f4c>)

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_DEINITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9acf52f132faf29b473cdda6061f0f44a>), [CUDA_ERROR_NOT_INITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e98feb999f0af99b4a25ab26b3866f4df8>), [CUDA_ERROR_INVALID_CONTEXT](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a484e9af32c1e9893ff21f0e0191a12d>), [CUDA_ERROR_INVALID_HANDLE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e90fd2e63260c6317ba943af0f7e4b8d21>), [CUDA_ERROR_NOT_SUPPORTED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e954756ae7ade0dfd09faeccb513dd831b>)

###### Description

Enqueues an operation in `hStream` to specify stream association of `length` bytes of memory starting from `dptr`. This function is a stream-ordered operation, meaning that it is dependent on, and will only take effect when, previous work in stream has completed. Any previous association is automatically replaced.

`dptr` must point to one of the following types of memories:

  * managed memory declared using the __managed__ keyword or allocated with [cuMemAllocManaged](<group__CUDA__MEM.html#group__CUDA__MEM_1gb347ded34dc326af404aa02af5388a32> "Allocates memory that will be automatically managed by the Unified Memory system.").

  * a valid host-accessible region of system-allocated pageable memory. This type of memory may only be specified if the device associated with the stream reports a non-zero value for the device attribute [CU_DEVICE_ATTRIBUTE_PAGEABLE_MEMORY_ACCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gge12b8a782bebe21b1ac0091bf9f4e2a35fdcdbe1dfc3ad5ec428c279e0efb9cd>).


For managed allocations, `length` must be either zero or the entire allocation's size. Both indicate that the entire allocation's stream association is being changed. Currently, it is not possible to change stream association for a portion of a managed allocation.

For pageable host allocations, `length` must be non-zero.

The stream association is specified using `flags` which must be one of [CUmemAttach_flags](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g17c5d5f9b585aa2d6f121847d1a78f4c>). If the [CU_MEM_ATTACH_GLOBAL](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg17c5d5f9b585aa2d6f121847d1a78f4c0b42aae6a29b41b734d4c0dea6c33313>) flag is specified, the memory can be accessed by any stream on any device. If the [CU_MEM_ATTACH_HOST](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg17c5d5f9b585aa2d6f121847d1a78f4c8b59c62cab9c7a762338e5fae92e2e9c>) flag is specified, the program makes a guarantee that it won't access the memory on the device from any stream on a device that has a zero value for the device attribute [CU_DEVICE_ATTRIBUTE_CONCURRENT_MANAGED_ACCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gge12b8a782bebe21b1ac0091bf9f4e2a333110e44c9cb6ead02f03ff6f6fd495e>). If the [CU_MEM_ATTACH_SINGLE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg17c5d5f9b585aa2d6f121847d1a78f4c4b70b6a5e039f61eccc6b8db3dfac442>) flag is specified and `hStream` is associated with a device that has a zero value for the device attribute [CU_DEVICE_ATTRIBUTE_CONCURRENT_MANAGED_ACCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gge12b8a782bebe21b1ac0091bf9f4e2a333110e44c9cb6ead02f03ff6f6fd495e>), the program makes a guarantee that it will only access the memory on the device from `hStream`. It is illegal to attach singly to the NULL stream, because the NULL stream is a virtual global stream and not a specific stream. An error will be returned in this case.

When memory is associated with a single stream, the Unified Memory system will allow CPU access to this memory region so long as all operations in `hStream` have completed, regardless of whether other streams are active. In effect, this constrains exclusive ownership of the managed memory region by an active GPU to per-stream activity instead of whole-GPU activity.

Accessing memory on the device from streams that are not associated with it will produce undefined results. No error checking is performed by the Unified Memory system to ensure that kernels launched into other streams do not access this region.

It is a program's responsibility to order calls to [cuStreamAttachMemAsync](<group__CUDA__STREAM.html#group__CUDA__STREAM_1g6e468d680e263e7eba02a56643c50533> "Attach memory to a stream asynchronously.") via events, synchronization or other means to ensure legal access to memory at all times. Data visibility and coherency will be changed appropriately for all kernels which follow a stream-association change.

If `hStream` is destroyed while data is associated with it, the association is removed and the association reverts to the default visibility of the allocation as specified at [cuMemAllocManaged](<group__CUDA__MEM.html#group__CUDA__MEM_1gb347ded34dc326af404aa02af5388a32> "Allocates memory that will be automatically managed by the Unified Memory system."). For __managed__ variables, the default association is always [CU_MEM_ATTACH_GLOBAL](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg17c5d5f9b585aa2d6f121847d1a78f4c0b42aae6a29b41b734d4c0dea6c33313>). Note that destroying a stream is an asynchronous operation, and as a result, the change to default association won't happen until all work in the stream has completed.

Note:

  * This function uses standard [default stream](<stream-sync-behavior.html#stream-sync-behavior__default-stream>) semantics.

  * Note that this function may also return error codes from previous, asynchronous launches.


**See also:**

[cuStreamCreate](<group__CUDA__STREAM.html#group__CUDA__STREAM_1ga581f0c5833e21ded8b5a56594e243f4> "Create a stream."), [cuStreamQuery](<group__CUDA__STREAM.html#group__CUDA__STREAM_1g1b0d24bbe97fa68e4bc511fb6adfeb0b> "Determine status of a compute stream."), [cuStreamSynchronize](<group__CUDA__STREAM.html#group__CUDA__STREAM_1g15e49dd91ec15991eb7c0a741beb7dad> "Wait until a stream's tasks are completed."), [cuStreamWaitEvent](<group__CUDA__STREAM.html#group__CUDA__STREAM_1g6a898b652dfc6aa1d5c8d97062618b2f> "Make a compute stream wait on an event."), [cuStreamDestroy](<group__CUDA__STREAM.html#group__CUDA__STREAM_1g244c8833de4596bcd31a06cdf21ee758> "Destroys a stream."), [cuMemAllocManaged](<group__CUDA__MEM.html#group__CUDA__MEM_1gb347ded34dc326af404aa02af5388a32> "Allocates memory that will be automatically managed by the Unified Memory system."), [cudaStreamAttachMemAsync](<../cuda-runtime-api/group__CUDART__HIGHLEVEL.html#group__CUDART__HIGHLEVEL_1g496353d630c29c44a2e33f531a3944d1>)

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuStreamBeginCapture ( [CUstream](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gb946c7f02e09efd788a204718015d88a>)Â hStream, [CUstreamCaptureMode](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gd984ba65031d63f1ed11ec76728c2669>)Â mode )


Begins graph capture on a stream.

######  Parameters

`hStream`
    \- Stream in which to initiate capture
`mode`
    \- Controls the interaction of this capture sequence with other API calls that are potentially unsafe. For more details see [cuThreadExchangeStreamCaptureMode](<group__CUDA__STREAM.html#group__CUDA__STREAM_1g378135b262f02a43a7caeab239ae493d> "Swaps the stream capture interaction mode for a thread.").

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_DEINITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9acf52f132faf29b473cdda6061f0f44a>), [CUDA_ERROR_NOT_INITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e98feb999f0af99b4a25ab26b3866f4df8>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>)

###### Description

Begin graph capture on `hStream`. When a stream is in capture mode, all operations pushed into the stream will not be executed, but will instead be captured into a graph, which will be returned via [cuStreamEndCapture](<group__CUDA__STREAM.html#group__CUDA__STREAM_1g03dab8b2ba76b00718955177a929970c> "Ends capture on a stream, returning the captured graph."). Capture may not be initiated if `stream` is CU_STREAM_LEGACY. Capture must be ended on the same stream in which it was initiated, and it may only be initiated if the stream is not already in capture mode. The capture mode may be queried via [cuStreamIsCapturing](<group__CUDA__STREAM.html#group__CUDA__STREAM_1g37823c49206e3704ae23c7ad78560bca> "Returns a stream's capture status."). A unique id representing the capture sequence may be queried via [cuStreamGetCaptureInfo](<group__CUDA__STREAM.html#group__CUDA__STREAM_1g85f03299332d6cf37578409d0e4b47ce> "Query a stream's capture state.").

If `mode` is not CU_STREAM_CAPTURE_MODE_RELAXED, [cuStreamEndCapture](<group__CUDA__STREAM.html#group__CUDA__STREAM_1g03dab8b2ba76b00718955177a929970c> "Ends capture on a stream, returning the captured graph.") must be called on this stream from the same thread.

Note:

Kernels captured using this API must not use texture and surface references. Reading or writing through any texture or surface reference is undefined behavior. This restriction does not apply to texture and surface objects.

Note:

Note that this function may also return error codes from previous, asynchronous launches.

**See also:**

[cuStreamCreate](<group__CUDA__STREAM.html#group__CUDA__STREAM_1ga581f0c5833e21ded8b5a56594e243f4> "Create a stream."), [cuStreamIsCapturing](<group__CUDA__STREAM.html#group__CUDA__STREAM_1g37823c49206e3704ae23c7ad78560bca> "Returns a stream's capture status."), [cuStreamEndCapture](<group__CUDA__STREAM.html#group__CUDA__STREAM_1g03dab8b2ba76b00718955177a929970c> "Ends capture on a stream, returning the captured graph."), [cuThreadExchangeStreamCaptureMode](<group__CUDA__STREAM.html#group__CUDA__STREAM_1g378135b262f02a43a7caeab239ae493d> "Swaps the stream capture interaction mode for a thread.")

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuStreamBeginCaptureToGraph ( [CUstream](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gb946c7f02e09efd788a204718015d88a>)Â hStream, [CUgraph](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g69f555c38df5b3fa1ed25efef794739a>)Â hGraph, const [CUgraphNode](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc72514a94dacc85ed0617f979211079c>)*Â dependencies, const [CUgraphEdgeData](<structCUgraphEdgeData.html#structCUgraphEdgeData>)*Â dependencyData, size_tÂ numDependencies, [CUstreamCaptureMode](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gd984ba65031d63f1ed11ec76728c2669>)Â mode )


Begins graph capture on a stream to an existing graph.

######  Parameters

`hStream`
    \- Stream in which to initiate capture.
`hGraph`
    \- Graph to capture into.
`dependencies`
    \- Dependencies of the first node captured in the stream. Can be NULL if numDependencies is 0.
`dependencyData`
    \- Optional array of data associated with each dependency.
`numDependencies`
    \- Number of dependencies.
`mode`
    \- Controls the interaction of this capture sequence with other API calls that are potentially unsafe. For more details see [cuThreadExchangeStreamCaptureMode](<group__CUDA__STREAM.html#group__CUDA__STREAM_1g378135b262f02a43a7caeab239ae493d> "Swaps the stream capture interaction mode for a thread.").

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_DEINITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9acf52f132faf29b473cdda6061f0f44a>), [CUDA_ERROR_NOT_INITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e98feb999f0af99b4a25ab26b3866f4df8>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>)

###### Description

Begin graph capture on `hStream`, placing new nodes into an existing graph. When a stream is in capture mode, all operations pushed into the stream will not be executed, but will instead be captured into `hGraph`. The graph will not be instantiable until the user calls [cuStreamEndCapture](<group__CUDA__STREAM.html#group__CUDA__STREAM_1g03dab8b2ba76b00718955177a929970c> "Ends capture on a stream, returning the captured graph.").

Capture may not be initiated if `stream` is CU_STREAM_LEGACY. Capture must be ended on the same stream in which it was initiated, and it may only be initiated if the stream is not already in capture mode. The capture mode may be queried via [cuStreamIsCapturing](<group__CUDA__STREAM.html#group__CUDA__STREAM_1g37823c49206e3704ae23c7ad78560bca> "Returns a stream's capture status."). A unique id representing the capture sequence may be queried via [cuStreamGetCaptureInfo](<group__CUDA__STREAM.html#group__CUDA__STREAM_1g85f03299332d6cf37578409d0e4b47ce> "Query a stream's capture state.").

If `mode` is not CU_STREAM_CAPTURE_MODE_RELAXED, [cuStreamEndCapture](<group__CUDA__STREAM.html#group__CUDA__STREAM_1g03dab8b2ba76b00718955177a929970c> "Ends capture on a stream, returning the captured graph.") must be called on this stream from the same thread.

Note:

Kernels captured using this API must not use texture and surface references. Reading or writing through any texture or surface reference is undefined behavior. This restriction does not apply to texture and surface objects.

Note:

Note that this function may also return error codes from previous, asynchronous launches.

**See also:**

[cuStreamBeginCapture](<group__CUDA__STREAM.html#group__CUDA__STREAM_1g767167da0bbf07157dc20b6c258a2143> "Begins graph capture on a stream."), [cuStreamCreate](<group__CUDA__STREAM.html#group__CUDA__STREAM_1ga581f0c5833e21ded8b5a56594e243f4> "Create a stream."), [cuStreamIsCapturing](<group__CUDA__STREAM.html#group__CUDA__STREAM_1g37823c49206e3704ae23c7ad78560bca> "Returns a stream's capture status."), [cuStreamEndCapture](<group__CUDA__STREAM.html#group__CUDA__STREAM_1g03dab8b2ba76b00718955177a929970c> "Ends capture on a stream, returning the captured graph."), [cuThreadExchangeStreamCaptureMode](<group__CUDA__STREAM.html#group__CUDA__STREAM_1g378135b262f02a43a7caeab239ae493d> "Swaps the stream capture interaction mode for a thread."), [cuGraphAddNode](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1ge01208e62f72a53367a2af903bf17d23> "Adds a node of arbitrary type to a graph.")

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuStreamCopyAttributes ( [CUstream](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gb946c7f02e09efd788a204718015d88a>)Â dst, [CUstream](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gb946c7f02e09efd788a204718015d88a>)Â src )


Copies attributes from source stream to destination stream.

######  Parameters

`dst`
    Destination stream
`src`
    Source stream For list of attributes see CUstreamAttrID

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>)

###### Description

Copies attributes from source stream `src` to destination stream `dst`. Both streams must have the same context.

Note:

Note that this function may also return error codes from previous, asynchronous launches.

**See also:**

[CUaccessPolicyWindow](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g1838e6438f39944217e384bf2adad477>)

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuStreamCreate ( [CUstream](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gb946c7f02e09efd788a204718015d88a>)*Â phStream, unsigned int Â Flags )


Create a stream.

######  Parameters

`phStream`
    \- Returned newly created stream
`Flags`
    \- Parameters for stream creation

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_DEINITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9acf52f132faf29b473cdda6061f0f44a>), [CUDA_ERROR_NOT_INITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e98feb999f0af99b4a25ab26b3866f4df8>), [CUDA_ERROR_INVALID_CONTEXT](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a484e9af32c1e9893ff21f0e0191a12d>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>), [CUDA_ERROR_OUT_OF_MEMORY](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9264c50688ed110e8476b591befe60c02>)

###### Description

Creates a stream and returns a handle in `phStream`. The `Flags` argument determines behaviors of the stream.

Valid values for `Flags` are:

  * [CU_STREAM_DEFAULT](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg775cb4ffbb7adf91e190067d9ad1752aaa5df0ec96f491f1be1124fdf265a066>): Default stream creation flag.

  * [CU_STREAM_NON_BLOCKING](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg775cb4ffbb7adf91e190067d9ad1752a89727d1d315214a6301abe98b419aff6>): Specifies that work running in the created stream may run concurrently with work in stream 0 (the NULL stream), and that the created stream should perform no implicit synchronization with stream 0.


Note:

Note that this function may also return error codes from previous, asynchronous launches.

**See also:**

[cuStreamDestroy](<group__CUDA__STREAM.html#group__CUDA__STREAM_1g244c8833de4596bcd31a06cdf21ee758> "Destroys a stream."), [cuStreamCreateWithPriority](<group__CUDA__STREAM.html#group__CUDA__STREAM_1g95c1a8c7c3dacb13091692dd9c7f7471> "Create a stream with the given priority."), [cuGreenCtxStreamCreate](<group__CUDA__GREEN__CONTEXTS.html#group__CUDA__GREEN__CONTEXTS_1g569b9e947b0f143f6ed9397a12046a8a> "Create a stream for use in the green context."), [cuStreamGetPriority](<group__CUDA__STREAM.html#group__CUDA__STREAM_1g5bd5cb26915a2ecf1921807339488484> "Query the priority of a given stream."), [cuStreamGetFlags](<group__CUDA__STREAM.html#group__CUDA__STREAM_1g4d39786855a6bed01215c1907fbbfbb7> "Query the flags of a given stream."), [cuStreamGetDevice](<group__CUDA__STREAM.html#group__CUDA__STREAM_1g1198995e0a122783ede50814b8c7a29b> "Returns the device handle of the stream.")[cuStreamWaitEvent](<group__CUDA__STREAM.html#group__CUDA__STREAM_1g6a898b652dfc6aa1d5c8d97062618b2f> "Make a compute stream wait on an event."), [cuStreamQuery](<group__CUDA__STREAM.html#group__CUDA__STREAM_1g1b0d24bbe97fa68e4bc511fb6adfeb0b> "Determine status of a compute stream."), [cuStreamSynchronize](<group__CUDA__STREAM.html#group__CUDA__STREAM_1g15e49dd91ec15991eb7c0a741beb7dad> "Wait until a stream's tasks are completed."), [cuStreamAddCallback](<group__CUDA__STREAM.html#group__CUDA__STREAM_1g613d97a277d7640f4cb1c03bd51c2483> "Add a callback to a compute stream."), [cudaStreamCreate](<../cuda-runtime-api/group__CUDART__STREAM.html#group__CUDART__STREAM_1g6a3c4b819e6a994c26d0c4824a4c80da>), [cudaStreamCreateWithFlags](<../cuda-runtime-api/group__CUDART__STREAM.html#group__CUDART__STREAM_1gb1e32aff9f59119e4d0a9858991c4ad3>)

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuStreamCreateWithPriority ( [CUstream](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gb946c7f02e09efd788a204718015d88a>)*Â phStream, unsigned int Â flags, int Â priority )


Create a stream with the given priority.

######  Parameters

`phStream`
    \- Returned newly created stream
`flags`
    \- Flags for stream creation. See [cuStreamCreate](<group__CUDA__STREAM.html#group__CUDA__STREAM_1ga581f0c5833e21ded8b5a56594e243f4> "Create a stream.") for a list of valid flags
`priority`
    \- Stream priority. Lower numbers represent higher priorities. See [cuCtxGetStreamPriorityRange](<group__CUDA__CTX.html#group__CUDA__CTX_1g137920ab61a71be6ce67605b9f294091> "Returns numerical values that correspond to the least and greatest stream priorities.") for more information about meaningful stream priorities that can be passed.

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_DEINITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9acf52f132faf29b473cdda6061f0f44a>), [CUDA_ERROR_NOT_INITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e98feb999f0af99b4a25ab26b3866f4df8>), [CUDA_ERROR_INVALID_CONTEXT](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a484e9af32c1e9893ff21f0e0191a12d>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>), [CUDA_ERROR_OUT_OF_MEMORY](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9264c50688ed110e8476b591befe60c02>)

###### Description

Creates a stream with the specified priority and returns a handle in `phStream`. This affects the scheduling priority of work in the stream. Priorities provide a hint to preferentially run work with higher priority when possible, but do not preempt already-running work or provide any other functional guarantee on execution order.

`priority` follows a convention where lower numbers represent higher priorities. '0' represents default priority. The range of meaningful numerical priorities can be queried using [cuCtxGetStreamPriorityRange](<group__CUDA__CTX.html#group__CUDA__CTX_1g137920ab61a71be6ce67605b9f294091> "Returns numerical values that correspond to the least and greatest stream priorities."). If the specified priority is outside the numerical range returned by [cuCtxGetStreamPriorityRange](<group__CUDA__CTX.html#group__CUDA__CTX_1g137920ab61a71be6ce67605b9f294091> "Returns numerical values that correspond to the least and greatest stream priorities."), it will automatically be clamped to the lowest or the highest number in the range.

Note:

  * Note that this function may also return error codes from previous, asynchronous launches.

  * Stream priorities are supported only on GPUs with compute capability 3.5 or higher.

  * In the current implementation, only compute kernels launched in priority streams are affected by the stream's priority. Stream priorities have no effect on host-to-device and device-to-host memory operations.


**See also:**

[cuStreamDestroy](<group__CUDA__STREAM.html#group__CUDA__STREAM_1g244c8833de4596bcd31a06cdf21ee758> "Destroys a stream."), [cuStreamCreate](<group__CUDA__STREAM.html#group__CUDA__STREAM_1ga581f0c5833e21ded8b5a56594e243f4> "Create a stream."), [cuGreenCtxStreamCreate](<group__CUDA__GREEN__CONTEXTS.html#group__CUDA__GREEN__CONTEXTS_1g569b9e947b0f143f6ed9397a12046a8a> "Create a stream for use in the green context."), [cuStreamGetPriority](<group__CUDA__STREAM.html#group__CUDA__STREAM_1g5bd5cb26915a2ecf1921807339488484> "Query the priority of a given stream."), [cuCtxGetStreamPriorityRange](<group__CUDA__CTX.html#group__CUDA__CTX_1g137920ab61a71be6ce67605b9f294091> "Returns numerical values that correspond to the least and greatest stream priorities."), [cuStreamGetFlags](<group__CUDA__STREAM.html#group__CUDA__STREAM_1g4d39786855a6bed01215c1907fbbfbb7> "Query the flags of a given stream."), [cuStreamGetDevice](<group__CUDA__STREAM.html#group__CUDA__STREAM_1g1198995e0a122783ede50814b8c7a29b> "Returns the device handle of the stream."), [cuStreamWaitEvent](<group__CUDA__STREAM.html#group__CUDA__STREAM_1g6a898b652dfc6aa1d5c8d97062618b2f> "Make a compute stream wait on an event."), [cuStreamQuery](<group__CUDA__STREAM.html#group__CUDA__STREAM_1g1b0d24bbe97fa68e4bc511fb6adfeb0b> "Determine status of a compute stream."), [cuStreamSynchronize](<group__CUDA__STREAM.html#group__CUDA__STREAM_1g15e49dd91ec15991eb7c0a741beb7dad> "Wait until a stream's tasks are completed."), [cuStreamAddCallback](<group__CUDA__STREAM.html#group__CUDA__STREAM_1g613d97a277d7640f4cb1c03bd51c2483> "Add a callback to a compute stream."), [cudaStreamCreateWithPriority](<../cuda-runtime-api/group__CUDART__STREAM.html#group__CUDART__STREAM_1ge2be9e9858849bf62ba4a8b66d1c3540>)

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuStreamDestroy ( [CUstream](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gb946c7f02e09efd788a204718015d88a>)Â hStream )


Destroys a stream.

######  Parameters

`hStream`
    \- Stream to destroy

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_DEINITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9acf52f132faf29b473cdda6061f0f44a>), [CUDA_ERROR_NOT_INITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e98feb999f0af99b4a25ab26b3866f4df8>), [CUDA_ERROR_INVALID_CONTEXT](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a484e9af32c1e9893ff21f0e0191a12d>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>), [CUDA_ERROR_INVALID_HANDLE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e90fd2e63260c6317ba943af0f7e4b8d21>)

###### Description

Destroys the stream specified by `hStream`.

In case the device is still doing work in the stream `hStream` when [cuStreamDestroy()](<group__CUDA__STREAM.html#group__CUDA__STREAM_1g244c8833de4596bcd31a06cdf21ee758> "Destroys a stream.") is called, the function will return immediately and the resources associated with `hStream` will be released automatically once the device has completed all work in `hStream`.

Note:

Note that this function may also return error codes from previous, asynchronous launches.

**See also:**

[cuStreamCreate](<group__CUDA__STREAM.html#group__CUDA__STREAM_1ga581f0c5833e21ded8b5a56594e243f4> "Create a stream."), [cuStreamWaitEvent](<group__CUDA__STREAM.html#group__CUDA__STREAM_1g6a898b652dfc6aa1d5c8d97062618b2f> "Make a compute stream wait on an event."), [cuStreamQuery](<group__CUDA__STREAM.html#group__CUDA__STREAM_1g1b0d24bbe97fa68e4bc511fb6adfeb0b> "Determine status of a compute stream."), [cuStreamSynchronize](<group__CUDA__STREAM.html#group__CUDA__STREAM_1g15e49dd91ec15991eb7c0a741beb7dad> "Wait until a stream's tasks are completed."), [cuStreamAddCallback](<group__CUDA__STREAM.html#group__CUDA__STREAM_1g613d97a277d7640f4cb1c03bd51c2483> "Add a callback to a compute stream."), [cudaStreamDestroy](<../cuda-runtime-api/group__CUDART__STREAM.html#group__CUDART__STREAM_1gfda584f1788ca983cb21c5f4d2033a62>)

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuStreamEndCapture ( [CUstream](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gb946c7f02e09efd788a204718015d88a>)Â hStream, [CUgraph](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g69f555c38df5b3fa1ed25efef794739a>)*Â phGraph )


Ends capture on a stream, returning the captured graph.

######  Parameters

`hStream`
    \- Stream to query
`phGraph`
    \- The captured graph

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_DEINITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9acf52f132faf29b473cdda6061f0f44a>), [CUDA_ERROR_NOT_INITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e98feb999f0af99b4a25ab26b3866f4df8>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>), [CUDA_ERROR_STREAM_CAPTURE_WRONG_THREAD](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e979282fa9b0bd6a56167b5ddf44391440>)

###### Description

End capture on `hStream`, returning the captured graph via `phGraph`. Capture must have been initiated on `hStream` via a call to [cuStreamBeginCapture](<group__CUDA__STREAM.html#group__CUDA__STREAM_1g767167da0bbf07157dc20b6c258a2143> "Begins graph capture on a stream."). If capture was invalidated, due to a violation of the rules of stream capture, then a NULL graph will be returned.

If the `mode` argument to [cuStreamBeginCapture](<group__CUDA__STREAM.html#group__CUDA__STREAM_1g767167da0bbf07157dc20b6c258a2143> "Begins graph capture on a stream.") was not CU_STREAM_CAPTURE_MODE_RELAXED, this call must be from the same thread as [cuStreamBeginCapture](<group__CUDA__STREAM.html#group__CUDA__STREAM_1g767167da0bbf07157dc20b6c258a2143> "Begins graph capture on a stream.").

Note:

Note that this function may also return error codes from previous, asynchronous launches.

**See also:**

[cuStreamCreate](<group__CUDA__STREAM.html#group__CUDA__STREAM_1ga581f0c5833e21ded8b5a56594e243f4> "Create a stream."), [cuStreamBeginCapture](<group__CUDA__STREAM.html#group__CUDA__STREAM_1g767167da0bbf07157dc20b6c258a2143> "Begins graph capture on a stream."), [cuStreamIsCapturing](<group__CUDA__STREAM.html#group__CUDA__STREAM_1g37823c49206e3704ae23c7ad78560bca> "Returns a stream's capture status."), [cuGraphDestroy](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1g718cfd9681f078693d4be2426fd689c8> "Destroys a graph.")

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuStreamGetAttribute ( [CUstream](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gb946c7f02e09efd788a204718015d88a>)Â hStream, [CUstreamAttrID](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g6f6565b334be6bb3134868e10bbdd331>)Â attr, [CUstreamAttrValue](<unionCUlaunchAttributeValue.html#unionCUlaunchAttributeValue>)*Â value_out )


Queries stream attribute.

######  Parameters

`hStream`

`attr`

`value_out`


###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>), [CUDA_ERROR_INVALID_HANDLE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e90fd2e63260c6317ba943af0f7e4b8d21>)

###### Description

Queries attribute `attr` from `hStream` and stores it in corresponding member of `value_out`.

Note:

Note that this function may also return error codes from previous, asynchronous launches.

**See also:**

[CUaccessPolicyWindow](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g1838e6438f39944217e384bf2adad477>)

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuStreamGetCaptureInfo ( [CUstream](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gb946c7f02e09efd788a204718015d88a>)Â hStream, [CUstreamCaptureStatus](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g7480c0f2bd19894e54fcd2c04d6efb91>)*Â captureStatus_out, cuuint64_t*Â id_out, [CUgraph](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g69f555c38df5b3fa1ed25efef794739a>)*Â graph_out, const [CUgraphNode](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc72514a94dacc85ed0617f979211079c>)**Â dependencies_out, const [CUgraphEdgeData](<structCUgraphEdgeData.html#structCUgraphEdgeData>)**Â edgeData_out, size_t*Â numDependencies_out )


Query a stream's capture state.

######  Parameters

`hStream`
    \- The stream to query
`captureStatus_out`
    \- Location to return the capture status of the stream; required
`id_out`
    \- Optional location to return an id for the capture sequence, which is unique over the lifetime of the process
`graph_out`
    \- Optional location to return the graph being captured into. All operations other than destroy and node removal are permitted on the graph while the capture sequence is in progress. This API does not transfer ownership of the graph, which is transferred or destroyed at [cuStreamEndCapture](<group__CUDA__STREAM.html#group__CUDA__STREAM_1g03dab8b2ba76b00718955177a929970c> "Ends capture on a stream, returning the captured graph."). Note that the graph handle may be invalidated before end of capture for certain errors. Nodes that are or become unreachable from the original stream at [cuStreamEndCapture](<group__CUDA__STREAM.html#group__CUDA__STREAM_1g03dab8b2ba76b00718955177a929970c> "Ends capture on a stream, returning the captured graph.") due to direct actions on the graph do not trigger [CUDA_ERROR_STREAM_CAPTURE_UNJOINED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9426e5dd5af746f6ee25aeb0f9fd32402>).
`dependencies_out`
    \- Optional location to store a pointer to an array of nodes. The next node to be captured in the stream will depend on this set of nodes, absent operations such as event wait which modify this set. The array pointer is valid until the next API call which operates on the stream or until the capture is terminated. The node handles may be copied out and are valid until they or the graph is destroyed. The driver-owned array may also be passed directly to APIs that operate on the graph (not the stream) without copying.
`edgeData_out`
    \- Optional location to store a pointer to an array of graph edge data. This array parallels `dependencies_out`; the next node to be added has an edge to `dependencies_out`[i] with annotation `edgeData_out`[i] for each `i`. The array pointer is valid until the next API call which operates on the stream or until the capture is terminated.
`numDependencies_out`
    \- Optional location to store the size of the array returned in dependencies_out.

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>), [CUDA_ERROR_STREAM_CAPTURE_IMPLICIT](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9960a55453736ec87ca941f9bc2d80abe>), [CUDA_ERROR_LOSSY_QUERY](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e90c2195e65483c3e7f0ccbf52370c33f7>)

###### Description

Query stream state related to stream capture.

If called on [CU_STREAM_LEGACY](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ga53e8210837f039dd6434a3a4c3324aa>) (the "null stream") while a stream not created with [CU_STREAM_NON_BLOCKING](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg775cb4ffbb7adf91e190067d9ad1752a89727d1d315214a6301abe98b419aff6>) is capturing, returns [CUDA_ERROR_STREAM_CAPTURE_IMPLICIT](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9960a55453736ec87ca941f9bc2d80abe>).

Valid data (other than capture status) is returned only if both of the following are true:

  * the call returns CUDA_SUCCESS

  * the returned capture status is [CU_STREAM_CAPTURE_STATUS_ACTIVE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg7480c0f2bd19894e54fcd2c04d6efb91c799fa3d867e2b300dfc45a6e90bc15d>)


If `edgeData_out` is non-NULL then `dependencies_out` must be as well. If `dependencies_out` is non-NULL and `edgeData_out` is NULL, but there is non-zero edge data for one or more of the current stream dependencies, the call will return [CUDA_ERROR_LOSSY_QUERY](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e90c2195e65483c3e7f0ccbf52370c33f7>).

Note:

  * Graph objects are not threadsafe. [More here](<graphs-thread-safety.html#graphs-thread-safety>).

  * Note that this function may also return error codes from previous, asynchronous launches.


**See also:**

[cuStreamBeginCapture](<group__CUDA__STREAM.html#group__CUDA__STREAM_1g767167da0bbf07157dc20b6c258a2143> "Begins graph capture on a stream."), [cuStreamIsCapturing](<group__CUDA__STREAM.html#group__CUDA__STREAM_1g37823c49206e3704ae23c7ad78560bca> "Returns a stream's capture status."), [cuStreamUpdateCaptureDependencies](<group__CUDA__STREAM.html#group__CUDA__STREAM_1g0cd3210434f3e0796c492cfa0d4b4bd1> "Update the set of dependencies in a capturing stream.")

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuStreamGetCtx ( [CUstream](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gb946c7f02e09efd788a204718015d88a>)Â hStream, [CUcontext](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gf9f5bd81658f866613785b3a0bb7d7d9>)*Â pctx )


Query the context associated with a stream.

######  Parameters

`hStream`
    \- Handle to the stream to be queried
`pctx`
    \- Returned context associated with the stream

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_DEINITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9acf52f132faf29b473cdda6061f0f44a>), [CUDA_ERROR_NOT_INITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e98feb999f0af99b4a25ab26b3866f4df8>), [CUDA_ERROR_INVALID_CONTEXT](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a484e9af32c1e9893ff21f0e0191a12d>), [CUDA_ERROR_INVALID_HANDLE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e90fd2e63260c6317ba943af0f7e4b8d21>), [CUDA_ERROR_NOT_SUPPORTED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e954756ae7ade0dfd09faeccb513dd831b>)

###### Description

Returns the CUDA context that the stream is associated with.

If the stream was created via the API [cuGreenCtxStreamCreate](<group__CUDA__GREEN__CONTEXTS.html#group__CUDA__GREEN__CONTEXTS_1g569b9e947b0f143f6ed9397a12046a8a> "Create a stream for use in the green context."), the returned context is equivalent to the one returned by [cuCtxFromGreenCtx()](<group__CUDA__GREEN__CONTEXTS.html#group__CUDA__GREEN__CONTEXTS_1gf0779ec72ce1d5d7eb003d7d9b25afcb> "Converts a green context into the primary context.") on the green context associated with the stream at creation time.

The stream handle `hStream` can refer to any of the following:

  * a stream created via any of the CUDA driver APIs such as [cuStreamCreate](<group__CUDA__STREAM.html#group__CUDA__STREAM_1ga581f0c5833e21ded8b5a56594e243f4> "Create a stream.") and [cuStreamCreateWithPriority](<group__CUDA__STREAM.html#group__CUDA__STREAM_1g95c1a8c7c3dacb13091692dd9c7f7471> "Create a stream with the given priority."), or their runtime API equivalents such as [cudaStreamCreate](<../cuda-runtime-api/group__CUDART__STREAM.html#group__CUDART__STREAM_1g6a3c4b819e6a994c26d0c4824a4c80da>), [cudaStreamCreateWithFlags](<../cuda-runtime-api/group__CUDART__STREAM.html#group__CUDART__STREAM_1gb1e32aff9f59119e4d0a9858991c4ad3>) and [cudaStreamCreateWithPriority](<../cuda-runtime-api/group__CUDART__STREAM.html#group__CUDART__STREAM_1ge2be9e9858849bf62ba4a8b66d1c3540>). The returned context is the context that was active in the calling thread when the stream was created. Passing an invalid handle will result in undefined behavior.

  * any of the special streams such as the NULL stream, [CU_STREAM_LEGACY](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ga53e8210837f039dd6434a3a4c3324aa>) and [CU_STREAM_PER_THREAD](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g02e40b82600f62c42ed29abb150f857c>). The runtime API equivalents of these are also accepted, which are NULL, [cudaStreamLegacy](<../cuda-runtime-api/group__CUDART__TYPES.html#group__CUDART__TYPES_1g4e62d09dde16ba457b0a97f3a5262246>) and [cudaStreamPerThread](<../cuda-runtime-api/group__CUDART__TYPES.html#group__CUDART__TYPES_1g7b7129befd6f52708309acafd1c46197>) respectively. Specifying any of the special handles will return the context current to the calling thread. If no context is current to the calling thread, [CUDA_ERROR_INVALID_CONTEXT](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a484e9af32c1e9893ff21f0e0191a12d>) is returned.


Note:

Note that this function may also return error codes from previous, asynchronous launches.

**See also:**

[cuStreamDestroy](<group__CUDA__STREAM.html#group__CUDA__STREAM_1g244c8833de4596bcd31a06cdf21ee758> "Destroys a stream."), [cuStreamCreateWithPriority](<group__CUDA__STREAM.html#group__CUDA__STREAM_1g95c1a8c7c3dacb13091692dd9c7f7471> "Create a stream with the given priority."), [cuStreamGetPriority](<group__CUDA__STREAM.html#group__CUDA__STREAM_1g5bd5cb26915a2ecf1921807339488484> "Query the priority of a given stream."), [cuStreamGetFlags](<group__CUDA__STREAM.html#group__CUDA__STREAM_1g4d39786855a6bed01215c1907fbbfbb7> "Query the flags of a given stream."), [cuStreamGetDevice](<group__CUDA__STREAM.html#group__CUDA__STREAM_1g1198995e0a122783ede50814b8c7a29b> "Returns the device handle of the stream.")[cuStreamWaitEvent](<group__CUDA__STREAM.html#group__CUDA__STREAM_1g6a898b652dfc6aa1d5c8d97062618b2f> "Make a compute stream wait on an event."), [cuStreamQuery](<group__CUDA__STREAM.html#group__CUDA__STREAM_1g1b0d24bbe97fa68e4bc511fb6adfeb0b> "Determine status of a compute stream."), [cuStreamSynchronize](<group__CUDA__STREAM.html#group__CUDA__STREAM_1g15e49dd91ec15991eb7c0a741beb7dad> "Wait until a stream's tasks are completed."), [cuStreamAddCallback](<group__CUDA__STREAM.html#group__CUDA__STREAM_1g613d97a277d7640f4cb1c03bd51c2483> "Add a callback to a compute stream."), [cudaStreamCreate](<../cuda-runtime-api/group__CUDART__STREAM.html#group__CUDART__STREAM_1g6a3c4b819e6a994c26d0c4824a4c80da>), [cudaStreamCreateWithFlags](<../cuda-runtime-api/group__CUDART__STREAM.html#group__CUDART__STREAM_1gb1e32aff9f59119e4d0a9858991c4ad3>)

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuStreamGetCtx_v2 ( [CUstream](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gb946c7f02e09efd788a204718015d88a>)Â hStream, [CUcontext](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gf9f5bd81658f866613785b3a0bb7d7d9>)*Â pCtx, [CUgreenCtx](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g453cb79a1ceb13bec502a9c5f06a0268>)*Â pGreenCtx )


Query the contexts associated with a stream.

######  Parameters

`hStream`
    \- Handle to the stream to be queried
`pCtx`
    \- Returned regular context associated with the stream
`pGreenCtx`
    \- Returned green context if the stream is associated with a green context or NULL if not

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_DEINITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9acf52f132faf29b473cdda6061f0f44a>), [CUDA_ERROR_NOT_INITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e98feb999f0af99b4a25ab26b3866f4df8>), [CUDA_ERROR_INVALID_CONTEXT](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a484e9af32c1e9893ff21f0e0191a12d>), [CUDA_ERROR_INVALID_HANDLE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e90fd2e63260c6317ba943af0f7e4b8d21>)

###### Description

Returns the contexts that the stream is associated with.

If the stream is associated with a green context, the API returns the green context in `pGreenCtx` and the primary context of the associated device in `pCtx`.

If the stream is associated with a regular context, the API returns the regular context in `pCtx` and NULL in `pGreenCtx`.

The stream handle `hStream` can refer to any of the following:

  * a stream created via any of the CUDA driver APIs such as [cuStreamCreate](<group__CUDA__STREAM.html#group__CUDA__STREAM_1ga581f0c5833e21ded8b5a56594e243f4> "Create a stream."), [cuStreamCreateWithPriority](<group__CUDA__STREAM.html#group__CUDA__STREAM_1g95c1a8c7c3dacb13091692dd9c7f7471> "Create a stream with the given priority.") and [cuGreenCtxStreamCreate](<group__CUDA__GREEN__CONTEXTS.html#group__CUDA__GREEN__CONTEXTS_1g569b9e947b0f143f6ed9397a12046a8a> "Create a stream for use in the green context."), or their runtime API equivalents such as [cudaStreamCreate](<../cuda-runtime-api/group__CUDART__STREAM.html#group__CUDART__STREAM_1g6a3c4b819e6a994c26d0c4824a4c80da>), [cudaStreamCreateWithFlags](<../cuda-runtime-api/group__CUDART__STREAM.html#group__CUDART__STREAM_1gb1e32aff9f59119e4d0a9858991c4ad3>) and [cudaStreamCreateWithPriority](<../cuda-runtime-api/group__CUDART__STREAM.html#group__CUDART__STREAM_1ge2be9e9858849bf62ba4a8b66d1c3540>). Passing an invalid handle will result in undefined behavior.

  * any of the special streams such as the NULL stream, [CU_STREAM_LEGACY](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ga53e8210837f039dd6434a3a4c3324aa>) and [CU_STREAM_PER_THREAD](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g02e40b82600f62c42ed29abb150f857c>). The runtime API equivalents of these are also accepted, which are NULL, [cudaStreamLegacy](<../cuda-runtime-api/group__CUDART__TYPES.html#group__CUDART__TYPES_1g4e62d09dde16ba457b0a97f3a5262246>) and [cudaStreamPerThread](<../cuda-runtime-api/group__CUDART__TYPES.html#group__CUDART__TYPES_1g7b7129befd6f52708309acafd1c46197>) respectively. If any of the special handles are specified, the API will operate on the context current to the calling thread. If a green context (that was converted via [cuCtxFromGreenCtx()](<group__CUDA__GREEN__CONTEXTS.html#group__CUDA__GREEN__CONTEXTS_1gf0779ec72ce1d5d7eb003d7d9b25afcb> "Converts a green context into the primary context.") before setting it current) is current to the calling thread, the API will return the green context in `pGreenCtx` and the primary context of the associated device in `pCtx`. If a regular context is current, the API returns the regular context in `pCtx` and NULL in `pGreenCtx`. Note that specifying [CU_STREAM_PER_THREAD](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g02e40b82600f62c42ed29abb150f857c>) or [cudaStreamPerThread](<../cuda-runtime-api/group__CUDART__TYPES.html#group__CUDART__TYPES_1g7b7129befd6f52708309acafd1c46197>) will return [CUDA_ERROR_INVALID_HANDLE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e90fd2e63260c6317ba943af0f7e4b8d21>) if a green context is current to the calling thread. If no context is current to the calling thread, [CUDA_ERROR_INVALID_CONTEXT](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a484e9af32c1e9893ff21f0e0191a12d>) is returned.


Note:

Note that this function may also return error codes from previous, asynchronous launches.

**See also:**

[cuStreamDestroy](<group__CUDA__STREAM.html#group__CUDA__STREAM_1g244c8833de4596bcd31a06cdf21ee758> "Destroys a stream."), [cuStreamCreate](<group__CUDA__STREAM.html#group__CUDA__STREAM_1ga581f0c5833e21ded8b5a56594e243f4> "Create a stream.")[cuStreamCreateWithPriority](<group__CUDA__STREAM.html#group__CUDA__STREAM_1g95c1a8c7c3dacb13091692dd9c7f7471> "Create a stream with the given priority."), [cuGreenCtxStreamCreate](<group__CUDA__GREEN__CONTEXTS.html#group__CUDA__GREEN__CONTEXTS_1g569b9e947b0f143f6ed9397a12046a8a> "Create a stream for use in the green context."), [cuStreamGetPriority](<group__CUDA__STREAM.html#group__CUDA__STREAM_1g5bd5cb26915a2ecf1921807339488484> "Query the priority of a given stream."), [cuStreamGetFlags](<group__CUDA__STREAM.html#group__CUDA__STREAM_1g4d39786855a6bed01215c1907fbbfbb7> "Query the flags of a given stream."), [cuStreamGetDevice](<group__CUDA__STREAM.html#group__CUDA__STREAM_1g1198995e0a122783ede50814b8c7a29b> "Returns the device handle of the stream."), [cuStreamWaitEvent](<group__CUDA__STREAM.html#group__CUDA__STREAM_1g6a898b652dfc6aa1d5c8d97062618b2f> "Make a compute stream wait on an event."), [cuStreamQuery](<group__CUDA__STREAM.html#group__CUDA__STREAM_1g1b0d24bbe97fa68e4bc511fb6adfeb0b> "Determine status of a compute stream."), [cuStreamSynchronize](<group__CUDA__STREAM.html#group__CUDA__STREAM_1g15e49dd91ec15991eb7c0a741beb7dad> "Wait until a stream's tasks are completed."), [cuStreamAddCallback](<group__CUDA__STREAM.html#group__CUDA__STREAM_1g613d97a277d7640f4cb1c03bd51c2483> "Add a callback to a compute stream."), [cudaStreamCreate](<../cuda-runtime-api/group__CUDART__STREAM.html#group__CUDART__STREAM_1g6a3c4b819e6a994c26d0c4824a4c80da>), [cudaStreamCreateWithFlags](<../cuda-runtime-api/group__CUDART__STREAM.html#group__CUDART__STREAM_1gb1e32aff9f59119e4d0a9858991c4ad3>),

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuStreamGetDevice ( [CUstream](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gb946c7f02e09efd788a204718015d88a>)Â hStream, [CUdevice](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g41ca2a24a242b36ef2ca77330b5fb72a>)*Â device )


Returns the device handle of the stream.

######  Parameters

`hStream`
    \- Handle to the stream to be queried
`device`
    \- Returns the device to which a stream belongs

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_DEINITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9acf52f132faf29b473cdda6061f0f44a>), [CUDA_ERROR_NOT_INITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e98feb999f0af99b4a25ab26b3866f4df8>), [CUDA_ERROR_INVALID_CONTEXT](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a484e9af32c1e9893ff21f0e0191a12d>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>), [CUDA_ERROR_INVALID_HANDLE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e90fd2e63260c6317ba943af0f7e4b8d21>), [CUDA_ERROR_OUT_OF_MEMORY](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9264c50688ed110e8476b591befe60c02>)

###### Description

Returns in `*device` the device handle of the stream

Note:

Note that this function may also return error codes from previous, asynchronous launches.

**See also:**

[cuStreamDestroy](<group__CUDA__STREAM.html#group__CUDA__STREAM_1g244c8833de4596bcd31a06cdf21ee758> "Destroys a stream."), [cuStreamCreate](<group__CUDA__STREAM.html#group__CUDA__STREAM_1ga581f0c5833e21ded8b5a56594e243f4> "Create a stream."), [cuGreenCtxStreamCreate](<group__CUDA__GREEN__CONTEXTS.html#group__CUDA__GREEN__CONTEXTS_1g569b9e947b0f143f6ed9397a12046a8a> "Create a stream for use in the green context."), [cuStreamGetFlags](<group__CUDA__STREAM.html#group__CUDA__STREAM_1g4d39786855a6bed01215c1907fbbfbb7> "Query the flags of a given stream.")

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuStreamGetFlags ( [CUstream](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gb946c7f02e09efd788a204718015d88a>)Â hStream, unsigned int*Â flags )


Query the flags of a given stream.

######  Parameters

`hStream`
    \- Handle to the stream to be queried
`flags`
    \- Pointer to an unsigned integer in which the stream's flags are returned The value returned in `flags` is a logical 'OR' of all flags that were used while creating this stream. See [cuStreamCreate](<group__CUDA__STREAM.html#group__CUDA__STREAM_1ga581f0c5833e21ded8b5a56594e243f4> "Create a stream.") for the list of valid flags

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_DEINITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9acf52f132faf29b473cdda6061f0f44a>), [CUDA_ERROR_NOT_INITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e98feb999f0af99b4a25ab26b3866f4df8>), [CUDA_ERROR_INVALID_CONTEXT](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a484e9af32c1e9893ff21f0e0191a12d>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>), [CUDA_ERROR_INVALID_HANDLE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e90fd2e63260c6317ba943af0f7e4b8d21>), [CUDA_ERROR_OUT_OF_MEMORY](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9264c50688ed110e8476b591befe60c02>)

###### Description

Query the flags of a stream created using [cuStreamCreate](<group__CUDA__STREAM.html#group__CUDA__STREAM_1ga581f0c5833e21ded8b5a56594e243f4> "Create a stream."), [cuStreamCreateWithPriority](<group__CUDA__STREAM.html#group__CUDA__STREAM_1g95c1a8c7c3dacb13091692dd9c7f7471> "Create a stream with the given priority.") or [cuGreenCtxStreamCreate](<group__CUDA__GREEN__CONTEXTS.html#group__CUDA__GREEN__CONTEXTS_1g569b9e947b0f143f6ed9397a12046a8a> "Create a stream for use in the green context.") and return the flags in `flags`.

Note:

Note that this function may also return error codes from previous, asynchronous launches.

**See also:**

[cuStreamDestroy](<group__CUDA__STREAM.html#group__CUDA__STREAM_1g244c8833de4596bcd31a06cdf21ee758> "Destroys a stream."), [cuStreamCreate](<group__CUDA__STREAM.html#group__CUDA__STREAM_1ga581f0c5833e21ded8b5a56594e243f4> "Create a stream."), [cuGreenCtxStreamCreate](<group__CUDA__GREEN__CONTEXTS.html#group__CUDA__GREEN__CONTEXTS_1g569b9e947b0f143f6ed9397a12046a8a> "Create a stream for use in the green context."), [cuStreamGetPriority](<group__CUDA__STREAM.html#group__CUDA__STREAM_1g5bd5cb26915a2ecf1921807339488484> "Query the priority of a given stream."), [cudaStreamGetFlags](<../cuda-runtime-api/group__CUDART__STREAM.html#group__CUDART__STREAM_1ga7f311f88126d751b9a7d3302ad6d0f8>), [cuStreamGetDevice](<group__CUDA__STREAM.html#group__CUDA__STREAM_1g1198995e0a122783ede50814b8c7a29b> "Returns the device handle of the stream.")

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuStreamGetId ( [CUstream](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gb946c7f02e09efd788a204718015d88a>)Â hStream, unsigned long long*Â streamId )


Returns the unique Id associated with the stream handle supplied.

######  Parameters

`hStream`
    \- Handle to the stream to be queried
`streamId`
    \- Pointer to store the Id of the stream

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>), [CUDA_ERROR_INVALID_HANDLE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e90fd2e63260c6317ba943af0f7e4b8d21>)

###### Description

Returns in `streamId` the unique Id which is associated with the given stream handle. The Id is unique for the life of the program.

The stream handle `hStream` can refer to any of the following:

  * a stream created via any of the CUDA driver APIs such as [cuStreamCreate](<group__CUDA__STREAM.html#group__CUDA__STREAM_1ga581f0c5833e21ded8b5a56594e243f4> "Create a stream.") and [cuStreamCreateWithPriority](<group__CUDA__STREAM.html#group__CUDA__STREAM_1g95c1a8c7c3dacb13091692dd9c7f7471> "Create a stream with the given priority."), or their runtime API equivalents such as [cudaStreamCreate](<../cuda-runtime-api/group__CUDART__STREAM.html#group__CUDART__STREAM_1g6a3c4b819e6a994c26d0c4824a4c80da>), [cudaStreamCreateWithFlags](<../cuda-runtime-api/group__CUDART__STREAM.html#group__CUDART__STREAM_1gb1e32aff9f59119e4d0a9858991c4ad3>) and [cudaStreamCreateWithPriority](<../cuda-runtime-api/group__CUDART__STREAM.html#group__CUDART__STREAM_1ge2be9e9858849bf62ba4a8b66d1c3540>). Passing an invalid handle will result in undefined behavior.

  * any of the special streams such as the NULL stream, [CU_STREAM_LEGACY](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ga53e8210837f039dd6434a3a4c3324aa>) and [CU_STREAM_PER_THREAD](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g02e40b82600f62c42ed29abb150f857c>). The runtime API equivalents of these are also accepted, which are NULL, [cudaStreamLegacy](<../cuda-runtime-api/group__CUDART__TYPES.html#group__CUDART__TYPES_1g4e62d09dde16ba457b0a97f3a5262246>) and [cudaStreamPerThread](<../cuda-runtime-api/group__CUDART__TYPES.html#group__CUDART__TYPES_1g7b7129befd6f52708309acafd1c46197>) respectively.


Note:

Note that this function may also return error codes from previous, asynchronous launches.

**See also:**

[cuStreamDestroy](<group__CUDA__STREAM.html#group__CUDA__STREAM_1g244c8833de4596bcd31a06cdf21ee758> "Destroys a stream."), [cuStreamCreate](<group__CUDA__STREAM.html#group__CUDA__STREAM_1ga581f0c5833e21ded8b5a56594e243f4> "Create a stream."), [cuStreamGetPriority](<group__CUDA__STREAM.html#group__CUDA__STREAM_1g5bd5cb26915a2ecf1921807339488484> "Query the priority of a given stream."), [cudaStreamGetId](<../cuda-runtime-api/group__CUDART__STREAM.html#group__CUDART__STREAM_1g5799ae8dd744e561dfdeda02c53e82df>)

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuStreamGetPriority ( [CUstream](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gb946c7f02e09efd788a204718015d88a>)Â hStream, int*Â priority )


Query the priority of a given stream.

######  Parameters

`hStream`
    \- Handle to the stream to be queried
`priority`
    \- Pointer to a signed integer in which the stream's priority is returned

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_DEINITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9acf52f132faf29b473cdda6061f0f44a>), [CUDA_ERROR_NOT_INITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e98feb999f0af99b4a25ab26b3866f4df8>), [CUDA_ERROR_INVALID_CONTEXT](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a484e9af32c1e9893ff21f0e0191a12d>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>), [CUDA_ERROR_INVALID_HANDLE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e90fd2e63260c6317ba943af0f7e4b8d21>), [CUDA_ERROR_OUT_OF_MEMORY](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9264c50688ed110e8476b591befe60c02>)

###### Description

Query the priority of a stream created using [cuStreamCreate](<group__CUDA__STREAM.html#group__CUDA__STREAM_1ga581f0c5833e21ded8b5a56594e243f4> "Create a stream."), [cuStreamCreateWithPriority](<group__CUDA__STREAM.html#group__CUDA__STREAM_1g95c1a8c7c3dacb13091692dd9c7f7471> "Create a stream with the given priority.") or [cuGreenCtxStreamCreate](<group__CUDA__GREEN__CONTEXTS.html#group__CUDA__GREEN__CONTEXTS_1g569b9e947b0f143f6ed9397a12046a8a> "Create a stream for use in the green context.") and return the priority in `priority`. Note that if the stream was created with a priority outside the numerical range returned by [cuCtxGetStreamPriorityRange](<group__CUDA__CTX.html#group__CUDA__CTX_1g137920ab61a71be6ce67605b9f294091> "Returns numerical values that correspond to the least and greatest stream priorities."), this function returns the clamped priority. See [cuStreamCreateWithPriority](<group__CUDA__STREAM.html#group__CUDA__STREAM_1g95c1a8c7c3dacb13091692dd9c7f7471> "Create a stream with the given priority.") for details about priority clamping.

Note:

Note that this function may also return error codes from previous, asynchronous launches.

**See also:**

[cuStreamDestroy](<group__CUDA__STREAM.html#group__CUDA__STREAM_1g244c8833de4596bcd31a06cdf21ee758> "Destroys a stream."), [cuStreamCreate](<group__CUDA__STREAM.html#group__CUDA__STREAM_1ga581f0c5833e21ded8b5a56594e243f4> "Create a stream."), [cuStreamCreateWithPriority](<group__CUDA__STREAM.html#group__CUDA__STREAM_1g95c1a8c7c3dacb13091692dd9c7f7471> "Create a stream with the given priority."), [cuGreenCtxStreamCreate](<group__CUDA__GREEN__CONTEXTS.html#group__CUDA__GREEN__CONTEXTS_1g569b9e947b0f143f6ed9397a12046a8a> "Create a stream for use in the green context."), [cuCtxGetStreamPriorityRange](<group__CUDA__CTX.html#group__CUDA__CTX_1g137920ab61a71be6ce67605b9f294091> "Returns numerical values that correspond to the least and greatest stream priorities."), [cuStreamGetFlags](<group__CUDA__STREAM.html#group__CUDA__STREAM_1g4d39786855a6bed01215c1907fbbfbb7> "Query the flags of a given stream."), [cuStreamGetDevice](<group__CUDA__STREAM.html#group__CUDA__STREAM_1g1198995e0a122783ede50814b8c7a29b> "Returns the device handle of the stream."), [cudaStreamGetPriority](<../cuda-runtime-api/group__CUDART__STREAM.html#group__CUDART__STREAM_1g192bb727d15c4407c119747de7d198a6>)

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuStreamIsCapturing ( [CUstream](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gb946c7f02e09efd788a204718015d88a>)Â hStream, [CUstreamCaptureStatus](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g7480c0f2bd19894e54fcd2c04d6efb91>)*Â captureStatus )


Returns a stream's capture status.

######  Parameters

`hStream`
    \- Stream to query
`captureStatus`
    \- Returns the stream's capture status

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_DEINITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9acf52f132faf29b473cdda6061f0f44a>), [CUDA_ERROR_NOT_INITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e98feb999f0af99b4a25ab26b3866f4df8>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>), [CUDA_ERROR_STREAM_CAPTURE_IMPLICIT](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9960a55453736ec87ca941f9bc2d80abe>)

###### Description

Return the capture status of `hStream` via `captureStatus`. After a successful call, `*captureStatus` will contain one of the following:

  * [CU_STREAM_CAPTURE_STATUS_NONE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg7480c0f2bd19894e54fcd2c04d6efb91e4023001f651dbdd3e3f55a1afc87fb3>): The stream is not capturing.

  * [CU_STREAM_CAPTURE_STATUS_ACTIVE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg7480c0f2bd19894e54fcd2c04d6efb91c799fa3d867e2b300dfc45a6e90bc15d>): The stream is capturing.

  * [CU_STREAM_CAPTURE_STATUS_INVALIDATED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg7480c0f2bd19894e54fcd2c04d6efb916b8a69837a782cd52243d481a2c6f51a>): The stream was capturing but an error has invalidated the capture sequence. The capture sequence must be terminated with [cuStreamEndCapture](<group__CUDA__STREAM.html#group__CUDA__STREAM_1g03dab8b2ba76b00718955177a929970c> "Ends capture on a stream, returning the captured graph.") on the stream where it was initiated in order to continue using `hStream`.


Note that, if this is called on [CU_STREAM_LEGACY](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ga53e8210837f039dd6434a3a4c3324aa>) (the "null stream") while a blocking stream in the same context is capturing, it will return [CUDA_ERROR_STREAM_CAPTURE_IMPLICIT](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9960a55453736ec87ca941f9bc2d80abe>) and `*captureStatus` is unspecified after the call. The blocking stream capture is not invalidated.

When a blocking stream is capturing, the legacy stream is in an unusable state until the blocking stream capture is terminated. The legacy stream is not supported for stream capture, but attempted use would have an implicit dependency on the capturing stream(s).

Note:

Note that this function may also return error codes from previous, asynchronous launches.

**See also:**

[cuStreamCreate](<group__CUDA__STREAM.html#group__CUDA__STREAM_1ga581f0c5833e21ded8b5a56594e243f4> "Create a stream."), [cuStreamBeginCapture](<group__CUDA__STREAM.html#group__CUDA__STREAM_1g767167da0bbf07157dc20b6c258a2143> "Begins graph capture on a stream."), [cuStreamEndCapture](<group__CUDA__STREAM.html#group__CUDA__STREAM_1g03dab8b2ba76b00718955177a929970c> "Ends capture on a stream, returning the captured graph.")

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuStreamQuery ( [CUstream](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gb946c7f02e09efd788a204718015d88a>)Â hStream )


Determine status of a compute stream.

######  Parameters

`hStream`
    \- Stream to query status of

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_DEINITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9acf52f132faf29b473cdda6061f0f44a>), [CUDA_ERROR_NOT_INITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e98feb999f0af99b4a25ab26b3866f4df8>), [CUDA_ERROR_INVALID_CONTEXT](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a484e9af32c1e9893ff21f0e0191a12d>), [CUDA_ERROR_INVALID_HANDLE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e90fd2e63260c6317ba943af0f7e4b8d21>), [CUDA_ERROR_NOT_READY](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9edd9cef666ce620352e619a36b6c3f34>)

###### Description

Returns [CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>) if all operations in the stream specified by `hStream` have completed, or [CUDA_ERROR_NOT_READY](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9edd9cef666ce620352e619a36b6c3f34>) if not.

For the purposes of Unified Memory, a return value of [CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>) is equivalent to having called [cuStreamSynchronize()](<group__CUDA__STREAM.html#group__CUDA__STREAM_1g15e49dd91ec15991eb7c0a741beb7dad> "Wait until a stream's tasks are completed.").

Note:

  * This function uses standard [default stream](<stream-sync-behavior.html#stream-sync-behavior__default-stream>) semantics.

  * Note that this function may also return error codes from previous, asynchronous launches.


**See also:**

[cuStreamCreate](<group__CUDA__STREAM.html#group__CUDA__STREAM_1ga581f0c5833e21ded8b5a56594e243f4> "Create a stream."), [cuStreamWaitEvent](<group__CUDA__STREAM.html#group__CUDA__STREAM_1g6a898b652dfc6aa1d5c8d97062618b2f> "Make a compute stream wait on an event."), [cuStreamDestroy](<group__CUDA__STREAM.html#group__CUDA__STREAM_1g244c8833de4596bcd31a06cdf21ee758> "Destroys a stream."), [cuStreamSynchronize](<group__CUDA__STREAM.html#group__CUDA__STREAM_1g15e49dd91ec15991eb7c0a741beb7dad> "Wait until a stream's tasks are completed."), [cuStreamAddCallback](<group__CUDA__STREAM.html#group__CUDA__STREAM_1g613d97a277d7640f4cb1c03bd51c2483> "Add a callback to a compute stream."), [cudaStreamQuery](<../cuda-runtime-api/group__CUDART__STREAM.html#group__CUDART__STREAM_1g2021adeb17905c7ec2a3c1bf125c5435>)

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuStreamSetAttribute ( [CUstream](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gb946c7f02e09efd788a204718015d88a>)Â hStream, [CUstreamAttrID](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g6f6565b334be6bb3134868e10bbdd331>)Â attr, const [CUstreamAttrValue](<unionCUlaunchAttributeValue.html#unionCUlaunchAttributeValue>)*Â value )


Sets stream attribute.

######  Parameters

`hStream`

`attr`

`value`


###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>), [CUDA_ERROR_INVALID_HANDLE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e90fd2e63260c6317ba943af0f7e4b8d21>)

###### Description

Sets attribute `attr` on `hStream` from corresponding attribute of `value`. The updated attribute will be applied to subsequent work submitted to the stream. It will not affect previously submitted work.

Note:

Note that this function may also return error codes from previous, asynchronous launches.

**See also:**

[CUaccessPolicyWindow](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g1838e6438f39944217e384bf2adad477>)

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuStreamSynchronize ( [CUstream](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gb946c7f02e09efd788a204718015d88a>)Â hStream )


Wait until a stream's tasks are completed.

######  Parameters

`hStream`
    \- Stream to wait for

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_DEINITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9acf52f132faf29b473cdda6061f0f44a>), [CUDA_ERROR_NOT_INITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e98feb999f0af99b4a25ab26b3866f4df8>), [CUDA_ERROR_INVALID_CONTEXT](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a484e9af32c1e9893ff21f0e0191a12d>), [CUDA_ERROR_INVALID_HANDLE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e90fd2e63260c6317ba943af0f7e4b8d21>)

###### Description

Waits until the device has completed all operations in the stream specified by `hStream`. If the context was created with the [CU_CTX_SCHED_BLOCKING_SYNC](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg9f889e28a45a295b5c8ce13aa05f6cd462aebfe6432ade3feb32f1a409027852>) flag, the CPU thread will block until the stream is finished with all of its tasks.

Note:

  * This function uses standard [default stream](<stream-sync-behavior.html#stream-sync-behavior__default-stream>) semantics.

  * Note that this function may also return error codes from previous, asynchronous launches.


**See also:**

[cuStreamCreate](<group__CUDA__STREAM.html#group__CUDA__STREAM_1ga581f0c5833e21ded8b5a56594e243f4> "Create a stream."), [cuStreamDestroy](<group__CUDA__STREAM.html#group__CUDA__STREAM_1g244c8833de4596bcd31a06cdf21ee758> "Destroys a stream."), [cuStreamWaitEvent](<group__CUDA__STREAM.html#group__CUDA__STREAM_1g6a898b652dfc6aa1d5c8d97062618b2f> "Make a compute stream wait on an event."), [cuStreamQuery](<group__CUDA__STREAM.html#group__CUDA__STREAM_1g1b0d24bbe97fa68e4bc511fb6adfeb0b> "Determine status of a compute stream."), [cuStreamAddCallback](<group__CUDA__STREAM.html#group__CUDA__STREAM_1g613d97a277d7640f4cb1c03bd51c2483> "Add a callback to a compute stream."), [cudaStreamSynchronize](<../cuda-runtime-api/group__CUDART__STREAM.html#group__CUDART__STREAM_1g82b5784f674c17c6df64affe618bf45e>)

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuStreamUpdateCaptureDependencies ( [CUstream](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gb946c7f02e09efd788a204718015d88a>)Â hStream, [CUgraphNode](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc72514a94dacc85ed0617f979211079c>)*Â dependencies, const [CUgraphEdgeData](<structCUgraphEdgeData.html#structCUgraphEdgeData>)*Â dependencyData, size_tÂ numDependencies, unsigned int Â flags )


Update the set of dependencies in a capturing stream.

######  Parameters

`hStream`
    \- The stream to update
`dependencies`
    \- The set of dependencies to add
`dependencyData`
    \- Optional array of data associated with each dependency.
`numDependencies`
    \- The size of the dependencies array
`flags`
    \- See above

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>), [CUDA_ERROR_ILLEGAL_STATE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9f5fd9c15b97a258f341bab23b0b505a5>)

###### Description

Modifies the dependency set of a capturing stream. The dependency set is the set of nodes that the next captured node in the stream will depend on along with the edge data for those dependencies.

Valid flags are [CU_STREAM_ADD_CAPTURE_DEPENDENCIES](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggef58550e3d1f6d73c7e326455e744663bab808cd5e4e683f7000cb109973604e>) and [CU_STREAM_SET_CAPTURE_DEPENDENCIES](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggef58550e3d1f6d73c7e326455e744663e3ada3eef9666e592a2d4c3301d08fca>). These control whether the set passed to the API is added to the existing set or replaces it. A flags value of 0 defaults to [CU_STREAM_ADD_CAPTURE_DEPENDENCIES](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggef58550e3d1f6d73c7e326455e744663bab808cd5e4e683f7000cb109973604e>).

Nodes that are removed from the dependency set via this API do not result in [CUDA_ERROR_STREAM_CAPTURE_UNJOINED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9426e5dd5af746f6ee25aeb0f9fd32402>) if they are unreachable from the stream at [cuStreamEndCapture](<group__CUDA__STREAM.html#group__CUDA__STREAM_1g03dab8b2ba76b00718955177a929970c> "Ends capture on a stream, returning the captured graph.").

Returns [CUDA_ERROR_ILLEGAL_STATE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9f5fd9c15b97a258f341bab23b0b505a5>) if the stream is not capturing.

**See also:**

[cuStreamBeginCapture](<group__CUDA__STREAM.html#group__CUDA__STREAM_1g767167da0bbf07157dc20b6c258a2143> "Begins graph capture on a stream."), [cuStreamGetCaptureInfo](<group__CUDA__STREAM.html#group__CUDA__STREAM_1g85f03299332d6cf37578409d0e4b47ce> "Query a stream's capture state.")

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuStreamWaitEvent ( [CUstream](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gb946c7f02e09efd788a204718015d88a>)Â hStream, [CUevent](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g6d740185cf0953636d4ae37f68d7559b>)Â hEvent, unsigned int Â Flags )


Make a compute stream wait on an event.

######  Parameters

`hStream`
    \- Stream to wait
`hEvent`
    \- Event to wait on (may not be NULL)
`Flags`
    \- See CUevent_capture_flags

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_DEINITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9acf52f132faf29b473cdda6061f0f44a>), [CUDA_ERROR_NOT_INITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e98feb999f0af99b4a25ab26b3866f4df8>), [CUDA_ERROR_INVALID_CONTEXT](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a484e9af32c1e9893ff21f0e0191a12d>), [CUDA_ERROR_INVALID_HANDLE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e90fd2e63260c6317ba943af0f7e4b8d21>),

###### Description

Makes all future work submitted to `hStream` wait for all work captured in `hEvent`. See [cuEventRecord()](<group__CUDA__EVENT.html#group__CUDA__EVENT_1g95424d3be52c4eb95d83861b70fb89d1> "Records an event.") for details on what is captured by an event. The synchronization will be performed efficiently on the device when applicable. `hEvent` may be from a different context or device than `hStream`.

flags include:

  * [CU_EVENT_WAIT_DEFAULT](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg0dbe4cec219cab20846e3f269a5440d4ab2546b7da3337d9dd2bdec73c032e18>): Default event creation flag.

  * [CU_EVENT_WAIT_EXTERNAL](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg0dbe4cec219cab20846e3f269a5440d42e696252699844df830094402b2a83d7>): Event is captured in the graph as an external event node when performing stream capture. This flag is invalid outside of stream capture.


Note:

  * This function uses standard [default stream](<stream-sync-behavior.html#stream-sync-behavior__default-stream>) semantics.

  * Note that this function may also return error codes from previous, asynchronous launches.


**See also:**

[cuStreamCreate](<group__CUDA__STREAM.html#group__CUDA__STREAM_1ga581f0c5833e21ded8b5a56594e243f4> "Create a stream."), [cuEventRecord](<group__CUDA__EVENT.html#group__CUDA__EVENT_1g95424d3be52c4eb95d83861b70fb89d1> "Records an event."), [cuStreamQuery](<group__CUDA__STREAM.html#group__CUDA__STREAM_1g1b0d24bbe97fa68e4bc511fb6adfeb0b> "Determine status of a compute stream."), [cuStreamSynchronize](<group__CUDA__STREAM.html#group__CUDA__STREAM_1g15e49dd91ec15991eb7c0a741beb7dad> "Wait until a stream's tasks are completed."), [cuStreamAddCallback](<group__CUDA__STREAM.html#group__CUDA__STREAM_1g613d97a277d7640f4cb1c03bd51c2483> "Add a callback to a compute stream."), [cuStreamDestroy](<group__CUDA__STREAM.html#group__CUDA__STREAM_1g244c8833de4596bcd31a06cdf21ee758> "Destroys a stream."), [cudaStreamWaitEvent](<../cuda-runtime-api/group__CUDART__STREAM.html#group__CUDART__STREAM_1g7840e3984799941a61839de40413d1d9>)

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuThreadExchangeStreamCaptureMode ( [CUstreamCaptureMode](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gd984ba65031d63f1ed11ec76728c2669>)*Â mode )


Swaps the stream capture interaction mode for a thread.

######  Parameters

`mode`
    \- Pointer to mode value to swap with the current mode

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_DEINITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9acf52f132faf29b473cdda6061f0f44a>), [CUDA_ERROR_NOT_INITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e98feb999f0af99b4a25ab26b3866f4df8>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>)

###### Description

Sets the calling thread's stream capture interaction mode to the value contained in `*mode`, and overwrites `*mode` with the previous mode for the thread. To facilitate deterministic behavior across function or module boundaries, callers are encouraged to use this API in a push-pop fashion:


    â     [CUstreamCaptureMode](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gd984ba65031d63f1ed11ec76728c2669>) mode = desiredMode;
               [cuThreadExchangeStreamCaptureMode](<group__CUDA__STREAM.html#group__CUDA__STREAM_1g378135b262f02a43a7caeab239ae493d> "Swaps the stream capture interaction mode for a thread.")(&mode);
               ...
               [cuThreadExchangeStreamCaptureMode](<group__CUDA__STREAM.html#group__CUDA__STREAM_1g378135b262f02a43a7caeab239ae493d> "Swaps the stream capture interaction mode for a thread.")(&mode); // restore previous mode

During stream capture (see [cuStreamBeginCapture](<group__CUDA__STREAM.html#group__CUDA__STREAM_1g767167da0bbf07157dc20b6c258a2143> "Begins graph capture on a stream.")), some actions, such as a call to [cudaMalloc](<../cuda-runtime-api/group__CUDART__MEMORY.html#group__CUDART__MEMORY_1g37d37965bfb4803b6d4e59ff26856356>), may be unsafe. In the case of [cudaMalloc](<../cuda-runtime-api/group__CUDART__MEMORY.html#group__CUDART__MEMORY_1g37d37965bfb4803b6d4e59ff26856356>), the operation is not enqueued asynchronously to a stream, and is not observed by stream capture. Therefore, if the sequence of operations captured via [cuStreamBeginCapture](<group__CUDA__STREAM.html#group__CUDA__STREAM_1g767167da0bbf07157dc20b6c258a2143> "Begins graph capture on a stream.") depended on the allocation being replayed whenever the graph is launched, the captured graph would be invalid.

Therefore, stream capture places restrictions on API calls that can be made within or concurrently to a [cuStreamBeginCapture](<group__CUDA__STREAM.html#group__CUDA__STREAM_1g767167da0bbf07157dc20b6c258a2143> "Begins graph capture on a stream.")-[cuStreamEndCapture](<group__CUDA__STREAM.html#group__CUDA__STREAM_1g03dab8b2ba76b00718955177a929970c> "Ends capture on a stream, returning the captured graph.") sequence. This behavior can be controlled via this API and flags to [cuStreamBeginCapture](<group__CUDA__STREAM.html#group__CUDA__STREAM_1g767167da0bbf07157dc20b6c258a2143> "Begins graph capture on a stream.").

A thread's mode is one of the following:

  * `CU_STREAM_CAPTURE_MODE_GLOBAL:` This is the default mode. If the local thread has an ongoing capture sequence that was not initiated with `CU_STREAM_CAPTURE_MODE_RELAXED` at `cuStreamBeginCapture`, or if any other thread has a concurrent capture sequence initiated with `CU_STREAM_CAPTURE_MODE_GLOBAL`, this thread is prohibited from potentially unsafe API calls.

  * `CU_STREAM_CAPTURE_MODE_THREAD_LOCAL:` If the local thread has an ongoing capture sequence not initiated with `CU_STREAM_CAPTURE_MODE_RELAXED`, it is prohibited from potentially unsafe API calls. Concurrent capture sequences in other threads are ignored.

  * `CU_STREAM_CAPTURE_MODE_RELAXED:` The local thread is not prohibited from potentially unsafe API calls. Note that the thread is still prohibited from API calls which necessarily conflict with stream capture, for example, attempting [cuEventQuery](<group__CUDA__EVENT.html#group__CUDA__EVENT_1g6f0704d755066b0ee705749ae911deef> "Queries an event's status.") on an event that was last recorded inside a capture sequence.


Note:

Note that this function may also return error codes from previous, asynchronous launches.

**See also:**

[cuStreamBeginCapture](<group__CUDA__STREAM.html#group__CUDA__STREAM_1g767167da0bbf07157dc20b6c258a2143> "Begins graph capture on a stream.")

* * *


---

# Event Management

## 6.19.Â Event Management

This section describes the event management functions of the low-level CUDA driver application programming interface.

### Functions

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuEventCreate](<#group__CUDA__EVENT_1g450687e75f3ff992fe01662a43d9d3db>) ( [CUevent](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g6d740185cf0953636d4ae37f68d7559b>)*Â phEvent, unsigned int Â Flags )
     Creates an event.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuEventDestroy](<#group__CUDA__EVENT_1g593ec73a8ec5a5fc031311d3e4dca1ef>) ( [CUevent](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g6d740185cf0953636d4ae37f68d7559b>)Â hEvent )
     Destroys an event.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuEventElapsedTime](<#group__CUDA__EVENT_1gdfb1178807353bbcaa9e245da497cf97>) ( float*Â pMilliseconds, [CUevent](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g6d740185cf0953636d4ae37f68d7559b>)Â hStart, [CUevent](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g6d740185cf0953636d4ae37f68d7559b>)Â hEnd )
     Computes the elapsed time between two events.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuEventQuery](<#group__CUDA__EVENT_1g6f0704d755066b0ee705749ae911deef>) ( [CUevent](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g6d740185cf0953636d4ae37f68d7559b>)Â hEvent )
     Queries an event's status.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuEventRecord](<#group__CUDA__EVENT_1g95424d3be52c4eb95d83861b70fb89d1>) ( [CUevent](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g6d740185cf0953636d4ae37f68d7559b>)Â hEvent, [CUstream](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gb946c7f02e09efd788a204718015d88a>)Â hStream )
     Records an event.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuEventRecordWithFlags](<#group__CUDA__EVENT_1ge577e0c132d9c4961f220d79f6762c4b>) ( [CUevent](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g6d740185cf0953636d4ae37f68d7559b>)Â hEvent, [CUstream](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gb946c7f02e09efd788a204718015d88a>)Â hStream, unsigned int Â flags )
     Records an event.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuEventSynchronize](<#group__CUDA__EVENT_1g9e520d34e51af7f5375610bca4add99c>) ( [CUevent](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g6d740185cf0953636d4ae37f68d7559b>)Â hEvent )
     Waits for an event to complete.

### Functions

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuEventCreate ( [CUevent](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g6d740185cf0953636d4ae37f68d7559b>)*Â phEvent, unsigned int Â Flags )


Creates an event.

######  Parameters

`phEvent`
    \- Returns newly created event
`Flags`
    \- Event creation flags

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_DEINITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9acf52f132faf29b473cdda6061f0f44a>), [CUDA_ERROR_NOT_INITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e98feb999f0af99b4a25ab26b3866f4df8>), [CUDA_ERROR_INVALID_CONTEXT](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a484e9af32c1e9893ff21f0e0191a12d>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>), [CUDA_ERROR_OUT_OF_MEMORY](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9264c50688ed110e8476b591befe60c02>)

###### Description

Creates an event *phEvent for the current context with the flags specified via `Flags`. Valid flags include:

  * [CU_EVENT_DEFAULT](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg5ae04079c671c8e659a3a27c7b23f629e22adf5df73b0d43c6374a12ebee1333>): Default event creation flag.

  * [CU_EVENT_BLOCKING_SYNC](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg5ae04079c671c8e659a3a27c7b23f6296813b3b31fdb737133124f3c35044362>): Specifies that the created event should use blocking synchronization. A CPU thread that uses [cuEventSynchronize()](<group__CUDA__EVENT.html#group__CUDA__EVENT_1g9e520d34e51af7f5375610bca4add99c> "Waits for an event to complete.") to wait on an event created with this flag will block until the event has actually been recorded.

  * [CU_EVENT_DISABLE_TIMING](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg5ae04079c671c8e659a3a27c7b23f629daa5463f64794c10b78c603d23c0bff2>): Specifies that the created event does not need to record timing data. Events created with this flag specified and the [CU_EVENT_BLOCKING_SYNC](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg5ae04079c671c8e659a3a27c7b23f6296813b3b31fdb737133124f3c35044362>) flag not specified will provide the best performance when used with [cuStreamWaitEvent()](<group__CUDA__STREAM.html#group__CUDA__STREAM_1g6a898b652dfc6aa1d5c8d97062618b2f> "Make a compute stream wait on an event.") and [cuEventQuery()](<group__CUDA__EVENT.html#group__CUDA__EVENT_1g6f0704d755066b0ee705749ae911deef> "Queries an event's status.").

  * [CU_EVENT_INTERPROCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg5ae04079c671c8e659a3a27c7b23f629adab662356d24cf59f3d7de07c3cd52e>): Specifies that the created event may be used as an interprocess event by [cuIpcGetEventHandle()](<group__CUDA__MEM.html#group__CUDA__MEM_1gea02eadd12483de5305878b13288a86c> "Gets an interprocess handle for a previously allocated event."). [CU_EVENT_INTERPROCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg5ae04079c671c8e659a3a27c7b23f629adab662356d24cf59f3d7de07c3cd52e>) must be specified along with [CU_EVENT_DISABLE_TIMING](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg5ae04079c671c8e659a3a27c7b23f629daa5463f64794c10b78c603d23c0bff2>).


Note:

Note that this function may also return error codes from previous, asynchronous launches.

**See also:**

[cuEventRecord](<group__CUDA__EVENT.html#group__CUDA__EVENT_1g95424d3be52c4eb95d83861b70fb89d1> "Records an event."), [cuEventQuery](<group__CUDA__EVENT.html#group__CUDA__EVENT_1g6f0704d755066b0ee705749ae911deef> "Queries an event's status."), [cuEventSynchronize](<group__CUDA__EVENT.html#group__CUDA__EVENT_1g9e520d34e51af7f5375610bca4add99c> "Waits for an event to complete."), [cuEventDestroy](<group__CUDA__EVENT.html#group__CUDA__EVENT_1g593ec73a8ec5a5fc031311d3e4dca1ef> "Destroys an event."), [cuEventElapsedTime](<group__CUDA__EVENT.html#group__CUDA__EVENT_1gdfb1178807353bbcaa9e245da497cf97> "Computes the elapsed time between two events."), [cudaEventCreate](<../cuda-runtime-api/group__CUDART__HIGHLEVEL.html#group__CUDART__HIGHLEVEL_1g4b5fdb19d7fb5f6f8862559f9279f6c3>), [cudaEventCreateWithFlags](<../cuda-runtime-api/group__CUDART__EVENT.html#group__CUDART__EVENT_1g7b317e07ff385d85aa656204b971a042>)

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuEventDestroy ( [CUevent](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g6d740185cf0953636d4ae37f68d7559b>)Â hEvent )


Destroys an event.

######  Parameters

`hEvent`
    \- Event to destroy

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_DEINITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9acf52f132faf29b473cdda6061f0f44a>), [CUDA_ERROR_NOT_INITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e98feb999f0af99b4a25ab26b3866f4df8>), [CUDA_ERROR_INVALID_CONTEXT](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a484e9af32c1e9893ff21f0e0191a12d>), [CUDA_ERROR_INVALID_HANDLE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e90fd2e63260c6317ba943af0f7e4b8d21>)

###### Description

Destroys the event specified by `hEvent`.

An event may be destroyed before it is complete (i.e., while [cuEventQuery()](<group__CUDA__EVENT.html#group__CUDA__EVENT_1g6f0704d755066b0ee705749ae911deef> "Queries an event's status.") would return [CUDA_ERROR_NOT_READY](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9edd9cef666ce620352e619a36b6c3f34>)). In this case, the call does not block on completion of the event, and any associated resources will automatically be released asynchronously at completion.

Note:

Note that this function may also return error codes from previous, asynchronous launches.

**See also:**

[cuEventCreate](<group__CUDA__EVENT.html#group__CUDA__EVENT_1g450687e75f3ff992fe01662a43d9d3db> "Creates an event."), [cuEventRecord](<group__CUDA__EVENT.html#group__CUDA__EVENT_1g95424d3be52c4eb95d83861b70fb89d1> "Records an event."), [cuEventQuery](<group__CUDA__EVENT.html#group__CUDA__EVENT_1g6f0704d755066b0ee705749ae911deef> "Queries an event's status."), [cuEventSynchronize](<group__CUDA__EVENT.html#group__CUDA__EVENT_1g9e520d34e51af7f5375610bca4add99c> "Waits for an event to complete."), [cuEventElapsedTime](<group__CUDA__EVENT.html#group__CUDA__EVENT_1gdfb1178807353bbcaa9e245da497cf97> "Computes the elapsed time between two events."), [cudaEventDestroy](<../cuda-runtime-api/group__CUDART__EVENT.html#group__CUDART__EVENT_1g2cb6baa0830a1cd0bd957bfd8705045b>)

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuEventElapsedTime ( float*Â pMilliseconds, [CUevent](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g6d740185cf0953636d4ae37f68d7559b>)Â hStart, [CUevent](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g6d740185cf0953636d4ae37f68d7559b>)Â hEnd )


Computes the elapsed time between two events.

######  Parameters

`pMilliseconds`
    \- Time between `hStart` and `hEnd` in ms
`hStart`
    \- Starting event
`hEnd`
    \- Ending event

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_DEINITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9acf52f132faf29b473cdda6061f0f44a>), [CUDA_ERROR_NOT_INITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e98feb999f0af99b4a25ab26b3866f4df8>), [CUDA_ERROR_INVALID_CONTEXT](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a484e9af32c1e9893ff21f0e0191a12d>), [CUDA_ERROR_INVALID_HANDLE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e90fd2e63260c6317ba943af0f7e4b8d21>), [CUDA_ERROR_NOT_READY](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9edd9cef666ce620352e619a36b6c3f34>), [CUDA_ERROR_UNKNOWN](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9c5a6ab0245179d297f1fa56ed0097183>)

###### Description

Computes the elapsed time between two events (in milliseconds with a resolution of around 0.5 microseconds). Note this API is not guaranteed to return the latest errors for pending work. As such this API is intended to serve as an elapsed time calculation only and any polling for completion on the events to be compared should be done with [cuEventQuery](<group__CUDA__EVENT.html#group__CUDA__EVENT_1g6f0704d755066b0ee705749ae911deef> "Queries an event's status.") instead.

If either event was last recorded in a non-NULL stream, the resulting time may be greater than expected (even if both used the same stream handle). This happens because the [cuEventRecord()](<group__CUDA__EVENT.html#group__CUDA__EVENT_1g95424d3be52c4eb95d83861b70fb89d1> "Records an event.") operation takes place asynchronously and there is no guarantee that the measured latency is actually just between the two events. Any number of other different stream operations could execute in between the two measured events, thus altering the timing in a significant way.

If [cuEventRecord()](<group__CUDA__EVENT.html#group__CUDA__EVENT_1g95424d3be52c4eb95d83861b70fb89d1> "Records an event.") has not been called on either event then [CUDA_ERROR_INVALID_HANDLE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e90fd2e63260c6317ba943af0f7e4b8d21>) is returned. If [cuEventRecord()](<group__CUDA__EVENT.html#group__CUDA__EVENT_1g95424d3be52c4eb95d83861b70fb89d1> "Records an event.") has been called on both events but one or both of them has not yet been completed (that is, [cuEventQuery()](<group__CUDA__EVENT.html#group__CUDA__EVENT_1g6f0704d755066b0ee705749ae911deef> "Queries an event's status.") would return [CUDA_ERROR_NOT_READY](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9edd9cef666ce620352e619a36b6c3f34>) on at least one of the events), [CUDA_ERROR_NOT_READY](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9edd9cef666ce620352e619a36b6c3f34>) is returned. If either event was created with the [CU_EVENT_DISABLE_TIMING](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg5ae04079c671c8e659a3a27c7b23f629daa5463f64794c10b78c603d23c0bff2>) flag, then this function will return [CUDA_ERROR_INVALID_HANDLE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e90fd2e63260c6317ba943af0f7e4b8d21>).

Note:

Note that this function may also return error codes from previous, asynchronous launches.

**See also:**

[cuEventCreate](<group__CUDA__EVENT.html#group__CUDA__EVENT_1g450687e75f3ff992fe01662a43d9d3db> "Creates an event."), [cuEventRecord](<group__CUDA__EVENT.html#group__CUDA__EVENT_1g95424d3be52c4eb95d83861b70fb89d1> "Records an event."), [cuEventQuery](<group__CUDA__EVENT.html#group__CUDA__EVENT_1g6f0704d755066b0ee705749ae911deef> "Queries an event's status."), [cuEventSynchronize](<group__CUDA__EVENT.html#group__CUDA__EVENT_1g9e520d34e51af7f5375610bca4add99c> "Waits for an event to complete."), [cuEventDestroy](<group__CUDA__EVENT.html#group__CUDA__EVENT_1g593ec73a8ec5a5fc031311d3e4dca1ef> "Destroys an event."), [cudaEventElapsedTime](<../cuda-runtime-api/group__CUDART__EVENT.html#group__CUDART__EVENT_1g40159125411db92c835edb46a0989cd6>)

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuEventQuery ( [CUevent](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g6d740185cf0953636d4ae37f68d7559b>)Â hEvent )


Queries an event's status.

######  Parameters

`hEvent`
    \- Event to query

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_DEINITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9acf52f132faf29b473cdda6061f0f44a>), [CUDA_ERROR_NOT_INITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e98feb999f0af99b4a25ab26b3866f4df8>), [CUDA_ERROR_INVALID_HANDLE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e90fd2e63260c6317ba943af0f7e4b8d21>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>), [CUDA_ERROR_NOT_READY](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9edd9cef666ce620352e619a36b6c3f34>)

###### Description

Queries the status of all work currently captured by `hEvent`. See [cuEventRecord()](<group__CUDA__EVENT.html#group__CUDA__EVENT_1g95424d3be52c4eb95d83861b70fb89d1> "Records an event.") for details on what is captured by an event.

Returns [CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>) if all captured work has been completed, or [CUDA_ERROR_NOT_READY](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9edd9cef666ce620352e619a36b6c3f34>) if any captured work is incomplete.

For the purposes of Unified Memory, a return value of [CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>) is equivalent to having called [cuEventSynchronize()](<group__CUDA__EVENT.html#group__CUDA__EVENT_1g9e520d34e51af7f5375610bca4add99c> "Waits for an event to complete.").

Note:

Note that this function may also return error codes from previous, asynchronous launches.

**See also:**

[cuEventCreate](<group__CUDA__EVENT.html#group__CUDA__EVENT_1g450687e75f3ff992fe01662a43d9d3db> "Creates an event."), [cuEventRecord](<group__CUDA__EVENT.html#group__CUDA__EVENT_1g95424d3be52c4eb95d83861b70fb89d1> "Records an event."), [cuEventSynchronize](<group__CUDA__EVENT.html#group__CUDA__EVENT_1g9e520d34e51af7f5375610bca4add99c> "Waits for an event to complete."), [cuEventDestroy](<group__CUDA__EVENT.html#group__CUDA__EVENT_1g593ec73a8ec5a5fc031311d3e4dca1ef> "Destroys an event."), [cuEventElapsedTime](<group__CUDA__EVENT.html#group__CUDA__EVENT_1gdfb1178807353bbcaa9e245da497cf97> "Computes the elapsed time between two events."), [cudaEventQuery](<../cuda-runtime-api/group__CUDART__EVENT.html#group__CUDART__EVENT_1g2bf738909b4a059023537eaa29d8a5b7>)

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuEventRecord ( [CUevent](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g6d740185cf0953636d4ae37f68d7559b>)Â hEvent, [CUstream](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gb946c7f02e09efd788a204718015d88a>)Â hStream )


Records an event.

######  Parameters

`hEvent`
    \- Event to record
`hStream`
    \- Stream to record event for

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_DEINITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9acf52f132faf29b473cdda6061f0f44a>), [CUDA_ERROR_NOT_INITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e98feb999f0af99b4a25ab26b3866f4df8>), [CUDA_ERROR_INVALID_CONTEXT](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a484e9af32c1e9893ff21f0e0191a12d>), [CUDA_ERROR_INVALID_HANDLE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e90fd2e63260c6317ba943af0f7e4b8d21>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>)

###### Description

Captures in `hEvent` the contents of `hStream` at the time of this call. `hEvent` and `hStream` must be from the same context otherwise [CUDA_ERROR_INVALID_HANDLE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e90fd2e63260c6317ba943af0f7e4b8d21>) is returned. Calls such as [cuEventQuery()](<group__CUDA__EVENT.html#group__CUDA__EVENT_1g6f0704d755066b0ee705749ae911deef> "Queries an event's status.") or [cuStreamWaitEvent()](<group__CUDA__STREAM.html#group__CUDA__STREAM_1g6a898b652dfc6aa1d5c8d97062618b2f> "Make a compute stream wait on an event.") will then examine or wait for completion of the work that was captured. Uses of `hStream` after this call do not modify `hEvent`. See note on default stream behavior for what is captured in the default case.

[cuEventRecord()](<group__CUDA__EVENT.html#group__CUDA__EVENT_1g95424d3be52c4eb95d83861b70fb89d1> "Records an event.") can be called multiple times on the same event and will overwrite the previously captured state. Other APIs such as [cuStreamWaitEvent()](<group__CUDA__STREAM.html#group__CUDA__STREAM_1g6a898b652dfc6aa1d5c8d97062618b2f> "Make a compute stream wait on an event.") use the most recently captured state at the time of the API call, and are not affected by later calls to [cuEventRecord()](<group__CUDA__EVENT.html#group__CUDA__EVENT_1g95424d3be52c4eb95d83861b70fb89d1> "Records an event."). Before the first call to [cuEventRecord()](<group__CUDA__EVENT.html#group__CUDA__EVENT_1g95424d3be52c4eb95d83861b70fb89d1> "Records an event."), an event represents an empty set of work, so for example [cuEventQuery()](<group__CUDA__EVENT.html#group__CUDA__EVENT_1g6f0704d755066b0ee705749ae911deef> "Queries an event's status.") would return [CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>).

Note:

  * This function uses standard [default stream](<stream-sync-behavior.html#stream-sync-behavior__default-stream>) semantics.

  * Note that this function may also return error codes from previous, asynchronous launches.


**See also:**

[cuEventCreate](<group__CUDA__EVENT.html#group__CUDA__EVENT_1g450687e75f3ff992fe01662a43d9d3db> "Creates an event."), [cuEventQuery](<group__CUDA__EVENT.html#group__CUDA__EVENT_1g6f0704d755066b0ee705749ae911deef> "Queries an event's status."), [cuEventSynchronize](<group__CUDA__EVENT.html#group__CUDA__EVENT_1g9e520d34e51af7f5375610bca4add99c> "Waits for an event to complete."), [cuStreamWaitEvent](<group__CUDA__STREAM.html#group__CUDA__STREAM_1g6a898b652dfc6aa1d5c8d97062618b2f> "Make a compute stream wait on an event."), [cuEventDestroy](<group__CUDA__EVENT.html#group__CUDA__EVENT_1g593ec73a8ec5a5fc031311d3e4dca1ef> "Destroys an event."), [cuEventElapsedTime](<group__CUDA__EVENT.html#group__CUDA__EVENT_1gdfb1178807353bbcaa9e245da497cf97> "Computes the elapsed time between two events."), [cudaEventRecord](<../cuda-runtime-api/group__CUDART__EVENT.html#group__CUDART__EVENT_1gf4fcb74343aa689f4159791967868446>), [cuEventRecordWithFlags](<group__CUDA__EVENT.html#group__CUDA__EVENT_1ge577e0c132d9c4961f220d79f6762c4b> "Records an event.")

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuEventRecordWithFlags ( [CUevent](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g6d740185cf0953636d4ae37f68d7559b>)Â hEvent, [CUstream](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gb946c7f02e09efd788a204718015d88a>)Â hStream, unsigned int Â flags )


Records an event.

######  Parameters

`hEvent`
    \- Event to record
`hStream`
    \- Stream to record event for
`flags`
    \- See CUevent_capture_flags

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_DEINITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9acf52f132faf29b473cdda6061f0f44a>), [CUDA_ERROR_NOT_INITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e98feb999f0af99b4a25ab26b3866f4df8>), [CUDA_ERROR_INVALID_CONTEXT](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a484e9af32c1e9893ff21f0e0191a12d>), [CUDA_ERROR_INVALID_HANDLE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e90fd2e63260c6317ba943af0f7e4b8d21>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>)

###### Description

Captures in `hEvent` the contents of `hStream` at the time of this call. `hEvent` and `hStream` must be from the same context otherwise [CUDA_ERROR_INVALID_HANDLE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e90fd2e63260c6317ba943af0f7e4b8d21>) is returned. Calls such as [cuEventQuery()](<group__CUDA__EVENT.html#group__CUDA__EVENT_1g6f0704d755066b0ee705749ae911deef> "Queries an event's status.") or [cuStreamWaitEvent()](<group__CUDA__STREAM.html#group__CUDA__STREAM_1g6a898b652dfc6aa1d5c8d97062618b2f> "Make a compute stream wait on an event.") will then examine or wait for completion of the work that was captured. Uses of `hStream` after this call do not modify `hEvent`. See note on default stream behavior for what is captured in the default case.

[cuEventRecordWithFlags()](<group__CUDA__EVENT.html#group__CUDA__EVENT_1ge577e0c132d9c4961f220d79f6762c4b> "Records an event.") can be called multiple times on the same event and will overwrite the previously captured state. Other APIs such as [cuStreamWaitEvent()](<group__CUDA__STREAM.html#group__CUDA__STREAM_1g6a898b652dfc6aa1d5c8d97062618b2f> "Make a compute stream wait on an event.") use the most recently captured state at the time of the API call, and are not affected by later calls to [cuEventRecordWithFlags()](<group__CUDA__EVENT.html#group__CUDA__EVENT_1ge577e0c132d9c4961f220d79f6762c4b> "Records an event."). Before the first call to [cuEventRecordWithFlags()](<group__CUDA__EVENT.html#group__CUDA__EVENT_1ge577e0c132d9c4961f220d79f6762c4b> "Records an event."), an event represents an empty set of work, so for example [cuEventQuery()](<group__CUDA__EVENT.html#group__CUDA__EVENT_1g6f0704d755066b0ee705749ae911deef> "Queries an event's status.") would return [CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>).

flags include:

  * [CU_EVENT_RECORD_DEFAULT](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg223a74c96434bb4e1d01c8685cbdef2257b646d34f7e5a14ef353de72b7ae091>): Default event creation flag.

  * [CU_EVENT_RECORD_EXTERNAL](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg223a74c96434bb4e1d01c8685cbdef22a47a6b397953152dfed8186e84b686b2>): Event is captured in the graph as an external event node when performing stream capture. This flag is invalid outside of stream capture.


Note:

  * This function uses standard [default stream](<stream-sync-behavior.html#stream-sync-behavior__default-stream>) semantics.

  * Note that this function may also return error codes from previous, asynchronous launches.


**See also:**

[cuEventCreate](<group__CUDA__EVENT.html#group__CUDA__EVENT_1g450687e75f3ff992fe01662a43d9d3db> "Creates an event."), [cuEventQuery](<group__CUDA__EVENT.html#group__CUDA__EVENT_1g6f0704d755066b0ee705749ae911deef> "Queries an event's status."), [cuEventSynchronize](<group__CUDA__EVENT.html#group__CUDA__EVENT_1g9e520d34e51af7f5375610bca4add99c> "Waits for an event to complete."), [cuStreamWaitEvent](<group__CUDA__STREAM.html#group__CUDA__STREAM_1g6a898b652dfc6aa1d5c8d97062618b2f> "Make a compute stream wait on an event."), [cuEventDestroy](<group__CUDA__EVENT.html#group__CUDA__EVENT_1g593ec73a8ec5a5fc031311d3e4dca1ef> "Destroys an event."), [cuEventElapsedTime](<group__CUDA__EVENT.html#group__CUDA__EVENT_1gdfb1178807353bbcaa9e245da497cf97> "Computes the elapsed time between two events."), [cuEventRecord](<group__CUDA__EVENT.html#group__CUDA__EVENT_1g95424d3be52c4eb95d83861b70fb89d1> "Records an event."), [cudaEventRecord](<../cuda-runtime-api/group__CUDART__EVENT.html#group__CUDART__EVENT_1gf4fcb74343aa689f4159791967868446>)

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuEventSynchronize ( [CUevent](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g6d740185cf0953636d4ae37f68d7559b>)Â hEvent )


Waits for an event to complete.

######  Parameters

`hEvent`
    \- Event to wait for

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_DEINITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9acf52f132faf29b473cdda6061f0f44a>), [CUDA_ERROR_NOT_INITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e98feb999f0af99b4a25ab26b3866f4df8>), [CUDA_ERROR_INVALID_CONTEXT](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a484e9af32c1e9893ff21f0e0191a12d>), [CUDA_ERROR_INVALID_HANDLE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e90fd2e63260c6317ba943af0f7e4b8d21>)

###### Description

Waits until the completion of all work currently captured in `hEvent`. See [cuEventRecord()](<group__CUDA__EVENT.html#group__CUDA__EVENT_1g95424d3be52c4eb95d83861b70fb89d1> "Records an event.") for details on what is captured by an event.

Waiting for an event that was created with the [CU_EVENT_BLOCKING_SYNC](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg5ae04079c671c8e659a3a27c7b23f6296813b3b31fdb737133124f3c35044362>) flag will cause the calling CPU thread to block until the event has been completed by the device. If the [CU_EVENT_BLOCKING_SYNC](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg5ae04079c671c8e659a3a27c7b23f6296813b3b31fdb737133124f3c35044362>) flag has not been set, then the CPU thread will busy-wait until the event has been completed by the device.

Note:

Note that this function may also return error codes from previous, asynchronous launches.

**See also:**

[cuEventCreate](<group__CUDA__EVENT.html#group__CUDA__EVENT_1g450687e75f3ff992fe01662a43d9d3db> "Creates an event."), [cuEventRecord](<group__CUDA__EVENT.html#group__CUDA__EVENT_1g95424d3be52c4eb95d83861b70fb89d1> "Records an event."), [cuEventQuery](<group__CUDA__EVENT.html#group__CUDA__EVENT_1g6f0704d755066b0ee705749ae911deef> "Queries an event's status."), [cuEventDestroy](<group__CUDA__EVENT.html#group__CUDA__EVENT_1g593ec73a8ec5a5fc031311d3e4dca1ef> "Destroys an event."), [cuEventElapsedTime](<group__CUDA__EVENT.html#group__CUDA__EVENT_1gdfb1178807353bbcaa9e245da497cf97> "Computes the elapsed time between two events."), [cudaEventSynchronize](<../cuda-runtime-api/group__CUDART__EVENT.html#group__CUDART__EVENT_1g949aa42b30ae9e622f6ba0787129ff22>)

* * *


---

# External Resource Interoperability

## 6.20.Â External Resource Interoperability

This section describes the external resource interoperability functions of the low-level CUDA driver application programming interface.

### Functions

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuDestroyExternalMemory](<#group__CUDA__EXTRES__INTEROP_1g1b586dda86565617e7e0883b956c7052>) ( [CUexternalMemory](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc9500ef066876b1186f8a54afff900ba>)Â extMem )
     Destroys an external memory object.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuDestroyExternalSemaphore](<#group__CUDA__EXTRES__INTEROP_1g7f13444973542fa50b7e75bcfb2f923d>) ( [CUexternalSemaphore](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g0bc360152166a414e50a5167250552b8>)Â extSem )
     Destroys an external semaphore.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuExternalMemoryGetMappedBuffer](<#group__CUDA__EXTRES__INTEROP_1gb9fec33920400c70961b4e33d838da91>) ( [CUdeviceptr](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g183f7b0d8ad008ea2a5fd552537ace4e>)*Â devPtr, [CUexternalMemory](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc9500ef066876b1186f8a54afff900ba>)Â extMem, const [CUDA_EXTERNAL_MEMORY_BUFFER_DESC](<structCUDA__EXTERNAL__MEMORY__BUFFER__DESC__v1.html#structCUDA__EXTERNAL__MEMORY__BUFFER__DESC__v1>)*Â bufferDesc )
     Maps a buffer onto an imported memory object.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuExternalMemoryGetMappedMipmappedArray](<#group__CUDA__EXTRES__INTEROP_1g02debbfa1b997e4f0e05300a312c17cc>) ( [CUmipmappedArray](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g96db856ab3d2940fb694ce4501d9b583>)*Â mipmap, [CUexternalMemory](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc9500ef066876b1186f8a54afff900ba>)Â extMem, const [CUDA_EXTERNAL_MEMORY_MIPMAPPED_ARRAY_DESC](<structCUDA__EXTERNAL__MEMORY__MIPMAPPED__ARRAY__DESC__v1.html#structCUDA__EXTERNAL__MEMORY__MIPMAPPED__ARRAY__DESC__v1>)*Â mipmapDesc )
     Maps a CUDA mipmapped array onto an external memory object.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuImportExternalMemory](<#group__CUDA__EXTRES__INTEROP_1g52aba3a7f780157d8ba12972b2481735>) ( [CUexternalMemory](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc9500ef066876b1186f8a54afff900ba>)*Â extMem_out, const [CUDA_EXTERNAL_MEMORY_HANDLE_DESC](<structCUDA__EXTERNAL__MEMORY__HANDLE__DESC__v1.html#structCUDA__EXTERNAL__MEMORY__HANDLE__DESC__v1>)*Â memHandleDesc )
     Imports an external memory object.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuImportExternalSemaphore](<#group__CUDA__EXTRES__INTEROP_1ge593134f5f9650474af74db644c4a326>) ( [CUexternalSemaphore](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g0bc360152166a414e50a5167250552b8>)*Â extSem_out, const [CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC](<structCUDA__EXTERNAL__SEMAPHORE__HANDLE__DESC__v1.html#structCUDA__EXTERNAL__SEMAPHORE__HANDLE__DESC__v1>)*Â semHandleDesc )
     Imports an external semaphore.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuSignalExternalSemaphoresAsync](<#group__CUDA__EXTRES__INTEROP_1g86cd6c4b3f439ba786f4e65d1b8107c3>) ( const [CUexternalSemaphore](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g0bc360152166a414e50a5167250552b8>)*Â extSemArray, const [CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS](<structCUDA__EXTERNAL__SEMAPHORE__SIGNAL__PARAMS__v1.html#structCUDA__EXTERNAL__SEMAPHORE__SIGNAL__PARAMS__v1>)*Â paramsArray, unsigned int Â numExtSems, [CUstream](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gb946c7f02e09efd788a204718015d88a>)Â stream )
     Signals a set of external semaphore objects.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuWaitExternalSemaphoresAsync](<#group__CUDA__EXTRES__INTEROP_1g063f01a524818ac89bacf521c55a39f0>) ( const [CUexternalSemaphore](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g0bc360152166a414e50a5167250552b8>)*Â extSemArray, const [CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS](<structCUDA__EXTERNAL__SEMAPHORE__WAIT__PARAMS__v1.html#structCUDA__EXTERNAL__SEMAPHORE__WAIT__PARAMS__v1>)*Â paramsArray, unsigned int Â numExtSems, [CUstream](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gb946c7f02e09efd788a204718015d88a>)Â stream )
     Waits on a set of external semaphore objects.

### Functions

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuDestroyExternalMemory ( [CUexternalMemory](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc9500ef066876b1186f8a54afff900ba>)Â extMem )


Destroys an external memory object.

######  Parameters

`extMem`
    \- External memory object to be destroyed

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_NOT_INITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e98feb999f0af99b4a25ab26b3866f4df8>), [CUDA_ERROR_INVALID_HANDLE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e90fd2e63260c6317ba943af0f7e4b8d21>)

###### Description

Destroys the specified external memory object. Any existing buffers and CUDA mipmapped arrays mapped onto this object must no longer be used and must be explicitly freed using [cuMemFree](<group__CUDA__MEM.html#group__CUDA__MEM_1g89b3f154e17cc89b6eea277dbdf5c93a> "Frees device memory.") and [cuMipmappedArrayDestroy](<group__CUDA__MEM.html#group__CUDA__MEM_1ge0d7c768b6a6963c4d4bde5bbc74f0ad> "Destroys a CUDA mipmapped array.") respectively.

Note:

Note that this function may also return error codes from previous, asynchronous launches.

**See also:**

[cuImportExternalMemory](<group__CUDA__EXTRES__INTEROP.html#group__CUDA__EXTRES__INTEROP_1g52aba3a7f780157d8ba12972b2481735> "Imports an external memory object."), [cuExternalMemoryGetMappedBuffer](<group__CUDA__EXTRES__INTEROP.html#group__CUDA__EXTRES__INTEROP_1gb9fec33920400c70961b4e33d838da91> "Maps a buffer onto an imported memory object."), [cuExternalMemoryGetMappedMipmappedArray](<group__CUDA__EXTRES__INTEROP.html#group__CUDA__EXTRES__INTEROP_1g02debbfa1b997e4f0e05300a312c17cc> "Maps a CUDA mipmapped array onto an external memory object.")

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuDestroyExternalSemaphore ( [CUexternalSemaphore](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g0bc360152166a414e50a5167250552b8>)Â extSem )


Destroys an external semaphore.

######  Parameters

`extSem`
    \- External semaphore to be destroyed

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_NOT_INITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e98feb999f0af99b4a25ab26b3866f4df8>), [CUDA_ERROR_INVALID_HANDLE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e90fd2e63260c6317ba943af0f7e4b8d21>)

###### Description

Destroys an external semaphore object and releases any references to the underlying resource. Any outstanding signals or waits must have completed before the semaphore is destroyed.

Note:

Note that this function may also return error codes from previous, asynchronous launches.

**See also:**

[cuImportExternalSemaphore](<group__CUDA__EXTRES__INTEROP.html#group__CUDA__EXTRES__INTEROP_1ge593134f5f9650474af74db644c4a326> "Imports an external semaphore."), [cuSignalExternalSemaphoresAsync](<group__CUDA__EXTRES__INTEROP.html#group__CUDA__EXTRES__INTEROP_1g86cd6c4b3f439ba786f4e65d1b8107c3> "Signals a set of external semaphore objects."), [cuWaitExternalSemaphoresAsync](<group__CUDA__EXTRES__INTEROP.html#group__CUDA__EXTRES__INTEROP_1g063f01a524818ac89bacf521c55a39f0> "Waits on a set of external semaphore objects.")

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuExternalMemoryGetMappedBuffer ( [CUdeviceptr](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g183f7b0d8ad008ea2a5fd552537ace4e>)*Â devPtr, [CUexternalMemory](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc9500ef066876b1186f8a54afff900ba>)Â extMem, const [CUDA_EXTERNAL_MEMORY_BUFFER_DESC](<structCUDA__EXTERNAL__MEMORY__BUFFER__DESC__v1.html#structCUDA__EXTERNAL__MEMORY__BUFFER__DESC__v1>)*Â bufferDesc )


Maps a buffer onto an imported memory object.

######  Parameters

`devPtr`
    \- Returned device pointer to buffer
`extMem`
    \- Handle to external memory object
`bufferDesc`
    \- Buffer descriptor

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_NOT_INITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e98feb999f0af99b4a25ab26b3866f4df8>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>), [CUDA_ERROR_INVALID_HANDLE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e90fd2e63260c6317ba943af0f7e4b8d21>)

###### Description

Maps a buffer onto an imported memory object and returns a device pointer in `devPtr`.

The properties of the buffer being mapped must be described in `bufferDesc`. The CUDA_EXTERNAL_MEMORY_BUFFER_DESC structure is defined as follows:


    â        typedef struct CUDA_EXTERNAL_MEMORY_BUFFER_DESC_st {
                      unsigned long long offset;
                      unsigned long long size;
                      unsigned int flags;
                  } [CUDA_EXTERNAL_MEMORY_BUFFER_DESC](<structCUDA__EXTERNAL__MEMORY__BUFFER__DESC__v1.html#structCUDA__EXTERNAL__MEMORY__BUFFER__DESC__v1>);

where [CUDA_EXTERNAL_MEMORY_BUFFER_DESC::offset](<structCUDA__EXTERNAL__MEMORY__BUFFER__DESC__v1.html#structCUDA__EXTERNAL__MEMORY__BUFFER__DESC__v1_1734130661fb389658d29d10ed6cf41cd>) is the offset in the memory object where the buffer's base address is. [CUDA_EXTERNAL_MEMORY_BUFFER_DESC::size](<structCUDA__EXTERNAL__MEMORY__BUFFER__DESC__v1.html#structCUDA__EXTERNAL__MEMORY__BUFFER__DESC__v1_1b736c75bec5e1461f565e95500c8227f>) is the size of the buffer. [CUDA_EXTERNAL_MEMORY_BUFFER_DESC::flags](<structCUDA__EXTERNAL__MEMORY__BUFFER__DESC__v1.html#structCUDA__EXTERNAL__MEMORY__BUFFER__DESC__v1_186aad4fc1ddac67d953daddec0a5c94a>) must be zero.

The offset and size have to be suitably aligned to match the requirements of the external API. Mapping two buffers whose ranges overlap may or may not result in the same virtual address being returned for the overlapped portion. In such cases, the application must ensure that all accesses to that region from the GPU are volatile. Otherwise writes made via one address are not guaranteed to be visible via the other address, even if they're issued by the same thread. It is recommended that applications map the combined range instead of mapping separate buffers and then apply the appropriate offsets to the returned pointer to derive the individual buffers.

The returned pointer `devPtr` must be freed using [cuMemFree](<group__CUDA__MEM.html#group__CUDA__MEM_1g89b3f154e17cc89b6eea277dbdf5c93a> "Frees device memory.").

Note:

Note that this function may also return error codes from previous, asynchronous launches.

**See also:**

[cuImportExternalMemory](<group__CUDA__EXTRES__INTEROP.html#group__CUDA__EXTRES__INTEROP_1g52aba3a7f780157d8ba12972b2481735> "Imports an external memory object."), [cuDestroyExternalMemory](<group__CUDA__EXTRES__INTEROP.html#group__CUDA__EXTRES__INTEROP_1g1b586dda86565617e7e0883b956c7052> "Destroys an external memory object."), [cuExternalMemoryGetMappedMipmappedArray](<group__CUDA__EXTRES__INTEROP.html#group__CUDA__EXTRES__INTEROP_1g02debbfa1b997e4f0e05300a312c17cc> "Maps a CUDA mipmapped array onto an external memory object.")

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuExternalMemoryGetMappedMipmappedArray ( [CUmipmappedArray](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g96db856ab3d2940fb694ce4501d9b583>)*Â mipmap, [CUexternalMemory](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc9500ef066876b1186f8a54afff900ba>)Â extMem, const [CUDA_EXTERNAL_MEMORY_MIPMAPPED_ARRAY_DESC](<structCUDA__EXTERNAL__MEMORY__MIPMAPPED__ARRAY__DESC__v1.html#structCUDA__EXTERNAL__MEMORY__MIPMAPPED__ARRAY__DESC__v1>)*Â mipmapDesc )


Maps a CUDA mipmapped array onto an external memory object.

######  Parameters

`mipmap`
    \- Returned CUDA mipmapped array
`extMem`
    \- Handle to external memory object
`mipmapDesc`
    \- CUDA array descriptor

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_NOT_INITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e98feb999f0af99b4a25ab26b3866f4df8>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>), [CUDA_ERROR_INVALID_HANDLE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e90fd2e63260c6317ba943af0f7e4b8d21>)

###### Description

Maps a CUDA mipmapped array onto an external object and returns a handle to it in `mipmap`.

The properties of the CUDA mipmapped array being mapped must be described in `mipmapDesc`. The structure CUDA_EXTERNAL_MEMORY_MIPMAPPED_ARRAY_DESC is defined as follows:


    â        typedef struct CUDA_EXTERNAL_MEMORY_MIPMAPPED_ARRAY_DESC_st {
                      unsigned long long offset;
                      [CUDA_ARRAY3D_DESCRIPTOR](<structCUDA__ARRAY3D__DESCRIPTOR__v2.html#structCUDA__ARRAY3D__DESCRIPTOR__v2>) arrayDesc;
                      unsigned int numLevels;
                  } [CUDA_EXTERNAL_MEMORY_MIPMAPPED_ARRAY_DESC](<structCUDA__EXTERNAL__MEMORY__MIPMAPPED__ARRAY__DESC__v1.html#structCUDA__EXTERNAL__MEMORY__MIPMAPPED__ARRAY__DESC__v1>);

where [CUDA_EXTERNAL_MEMORY_MIPMAPPED_ARRAY_DESC::offset](<structCUDA__EXTERNAL__MEMORY__MIPMAPPED__ARRAY__DESC__v1.html#structCUDA__EXTERNAL__MEMORY__MIPMAPPED__ARRAY__DESC__v1_1c4a2c246eab269279434d8153d6e15aa>) is the offset in the memory object where the base level of the mipmap chain is. [CUDA_EXTERNAL_MEMORY_MIPMAPPED_ARRAY_DESC::arrayDesc](<structCUDA__EXTERNAL__MEMORY__MIPMAPPED__ARRAY__DESC__v1.html#structCUDA__EXTERNAL__MEMORY__MIPMAPPED__ARRAY__DESC__v1_17c3e0998380d9922a9fcddadeecd186d>) describes the format, dimensions and type of the base level of the mipmap chain. For further details on these parameters, please refer to the documentation for [cuMipmappedArrayCreate](<group__CUDA__MEM.html#group__CUDA__MEM_1ga5d2e311c7f9b0bc6d130af824a40bd3> "Creates a CUDA mipmapped array."). Note that if the mipmapped array is bound as a color target in the graphics API, then the flag [CUDA_ARRAY3D_COLOR_ATTACHMENT](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g26e6ae0e2d1dcef8205a840ebc193022>) must be specified in CUDA_EXTERNAL_MEMORY_MIPMAPPED_ARRAY_DESC::arrayDesc::Flags. [CUDA_EXTERNAL_MEMORY_MIPMAPPED_ARRAY_DESC::numLevels](<structCUDA__EXTERNAL__MEMORY__MIPMAPPED__ARRAY__DESC__v1.html#structCUDA__EXTERNAL__MEMORY__MIPMAPPED__ARRAY__DESC__v1_1938185e3178ee0fb5920ac104035b321>) specifies the total number of levels in the mipmap chain.

If `extMem` was imported from a handle of type [CU_EXTERNAL_MEMORY_HANDLE_TYPE_NVSCIBUF](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggbca0bdde9a33c47058b5c97f21e2edd8adf93206205d155aed8228f4a118d6ee>), then [CUDA_EXTERNAL_MEMORY_MIPMAPPED_ARRAY_DESC::numLevels](<structCUDA__EXTERNAL__MEMORY__MIPMAPPED__ARRAY__DESC__v1.html#structCUDA__EXTERNAL__MEMORY__MIPMAPPED__ARRAY__DESC__v1_1938185e3178ee0fb5920ac104035b321>) must be equal to 1.

Mapping `extMem` imported from a handle of type [CU_EXTERNAL_MEMORY_HANDLE_TYPE_DMABUF_FD](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggbca0bdde9a33c47058b5c97f21e2edd8eaccb8a4e89ddf36b2e432bca0e53791>), is not supported.

The returned CUDA mipmapped array must be freed using [cuMipmappedArrayDestroy](<group__CUDA__MEM.html#group__CUDA__MEM_1ge0d7c768b6a6963c4d4bde5bbc74f0ad> "Destroys a CUDA mipmapped array.").

Note:

Note that this function may also return error codes from previous, asynchronous launches.

**See also:**

[cuImportExternalMemory](<group__CUDA__EXTRES__INTEROP.html#group__CUDA__EXTRES__INTEROP_1g52aba3a7f780157d8ba12972b2481735> "Imports an external memory object."), [cuDestroyExternalMemory](<group__CUDA__EXTRES__INTEROP.html#group__CUDA__EXTRES__INTEROP_1g1b586dda86565617e7e0883b956c7052> "Destroys an external memory object."), [cuExternalMemoryGetMappedBuffer](<group__CUDA__EXTRES__INTEROP.html#group__CUDA__EXTRES__INTEROP_1gb9fec33920400c70961b4e33d838da91> "Maps a buffer onto an imported memory object.")

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuImportExternalMemory ( [CUexternalMemory](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc9500ef066876b1186f8a54afff900ba>)*Â extMem_out, const [CUDA_EXTERNAL_MEMORY_HANDLE_DESC](<structCUDA__EXTERNAL__MEMORY__HANDLE__DESC__v1.html#structCUDA__EXTERNAL__MEMORY__HANDLE__DESC__v1>)*Â memHandleDesc )


Imports an external memory object.

######  Parameters

`extMem_out`
    \- Returned handle to an external memory object
`memHandleDesc`
    \- Memory import handle descriptor

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_NOT_INITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e98feb999f0af99b4a25ab26b3866f4df8>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>), [CUDA_ERROR_INVALID_HANDLE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e90fd2e63260c6317ba943af0f7e4b8d21>), [CUDA_ERROR_OPERATING_SYSTEM](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9c849a151611f6e2ed1b3ae923f79ef3c>)

###### Description

Imports an externally allocated memory object and returns a handle to that in `extMem_out`.

The properties of the handle being imported must be described in `memHandleDesc`. The CUDA_EXTERNAL_MEMORY_HANDLE_DESC structure is defined as follows:


    â        typedef struct CUDA_EXTERNAL_MEMORY_HANDLE_DESC_st {
                      [CUexternalMemoryHandleType](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gbca0bdde9a33c47058b5c97f21e2edd8>) type;
                      union {
                          int fd;
                          struct {
                              void *handle;
                              const void *name;
                          } win32;
                          const void *nvSciBufObject;
                      } handle;
                      unsigned long long size;
                      unsigned int flags;
                  } [CUDA_EXTERNAL_MEMORY_HANDLE_DESC](<structCUDA__EXTERNAL__MEMORY__HANDLE__DESC__v1.html#structCUDA__EXTERNAL__MEMORY__HANDLE__DESC__v1>);

where [CUDA_EXTERNAL_MEMORY_HANDLE_DESC::type](<structCUDA__EXTERNAL__MEMORY__HANDLE__DESC__v1.html#structCUDA__EXTERNAL__MEMORY__HANDLE__DESC__v1_1d4e3663348d28278d066980b422ab70e>) specifies the type of handle being imported. [CUexternalMemoryHandleType](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gbca0bdde9a33c47058b5c97f21e2edd8>) is defined as:


    â        typedef enum CUexternalMemoryHandleType_enum {
                      [CU_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_FD](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggbca0bdde9a33c47058b5c97f21e2edd864efb8402f2268e489336396b2048c07>)          = 1,
                      [CU_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggbca0bdde9a33c47058b5c97f21e2edd8d76fbf1ffdee6cee58aa8a4a41f6b5fd>)       = 2,
                      [CU_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggbca0bdde9a33c47058b5c97f21e2edd8fde7150bec78dae8ee4cd6e88a7f4064>)   = 3,
                      [CU_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_HEAP](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggbca0bdde9a33c47058b5c97f21e2edd81a96f6957350ec0508b6ac4ec17f465f>)         = 4,
                      [CU_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_RESOURCE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggbca0bdde9a33c47058b5c97f21e2edd8532abdef8908d5d35a773e491ea68f5b>)     = 5,
                      [CU_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_RESOURCE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggbca0bdde9a33c47058b5c97f21e2edd89c10fcedb0f4e95a6cbf600f95be2369>)     = 6,
                      [CU_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_RESOURCE_KMT](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggbca0bdde9a33c47058b5c97f21e2edd8159b39907f15e7077609b488333cd390>) = 7,
                      [CU_EXTERNAL_MEMORY_HANDLE_TYPE_NVSCIBUF](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggbca0bdde9a33c47058b5c97f21e2edd8adf93206205d155aed8228f4a118d6ee>)           = 8,
                      [CU_EXTERNAL_MEMORY_HANDLE_TYPE_DMABUF_FD](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggbca0bdde9a33c47058b5c97f21e2edd8eaccb8a4e89ddf36b2e432bca0e53791>)          = 9
                  } [CUexternalMemoryHandleType](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gbca0bdde9a33c47058b5c97f21e2edd8>);

If [CUDA_EXTERNAL_MEMORY_HANDLE_DESC::type](<structCUDA__EXTERNAL__MEMORY__HANDLE__DESC__v1.html#structCUDA__EXTERNAL__MEMORY__HANDLE__DESC__v1_1d4e3663348d28278d066980b422ab70e>) is [CU_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_FD](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggbca0bdde9a33c47058b5c97f21e2edd864efb8402f2268e489336396b2048c07>), then CUDA_EXTERNAL_MEMORY_HANDLE_DESC::handle::fd must be a valid file descriptor referencing a memory object. Ownership of the file descriptor is transferred to the CUDA driver when the handle is imported successfully. Performing any operations on the file descriptor after it is imported results in undefined behavior.

If [CUDA_EXTERNAL_MEMORY_HANDLE_DESC::type](<structCUDA__EXTERNAL__MEMORY__HANDLE__DESC__v1.html#structCUDA__EXTERNAL__MEMORY__HANDLE__DESC__v1_1d4e3663348d28278d066980b422ab70e>) is [CU_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggbca0bdde9a33c47058b5c97f21e2edd8d76fbf1ffdee6cee58aa8a4a41f6b5fd>), then exactly one of CUDA_EXTERNAL_MEMORY_HANDLE_DESC::handle::win32::handle and CUDA_EXTERNAL_MEMORY_HANDLE_DESC::handle::win32::name must not be NULL. If CUDA_EXTERNAL_MEMORY_HANDLE_DESC::handle::win32::handle is not NULL, then it must represent a valid shared NT handle that references a memory object. Ownership of this handle is not transferred to CUDA after the import operation, so the application must release the handle using the appropriate system call. If CUDA_EXTERNAL_MEMORY_HANDLE_DESC::handle::win32::name is not NULL, then it must point to a NULL-terminated array of UTF-16 characters that refers to a memory object.

If [CUDA_EXTERNAL_MEMORY_HANDLE_DESC::type](<structCUDA__EXTERNAL__MEMORY__HANDLE__DESC__v1.html#structCUDA__EXTERNAL__MEMORY__HANDLE__DESC__v1_1d4e3663348d28278d066980b422ab70e>) is [CU_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggbca0bdde9a33c47058b5c97f21e2edd8fde7150bec78dae8ee4cd6e88a7f4064>), then CUDA_EXTERNAL_MEMORY_HANDLE_DESC::handle::win32::handle must be non-NULL and CUDA_EXTERNAL_MEMORY_HANDLE_DESC::handle::win32::name must be NULL. The handle specified must be a globally shared KMT handle. This handle does not hold a reference to the underlying object, and thus will be invalid when all references to the memory object are destroyed.

If [CUDA_EXTERNAL_MEMORY_HANDLE_DESC::type](<structCUDA__EXTERNAL__MEMORY__HANDLE__DESC__v1.html#structCUDA__EXTERNAL__MEMORY__HANDLE__DESC__v1_1d4e3663348d28278d066980b422ab70e>) is [CU_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_HEAP](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggbca0bdde9a33c47058b5c97f21e2edd81a96f6957350ec0508b6ac4ec17f465f>), then exactly one of CUDA_EXTERNAL_MEMORY_HANDLE_DESC::handle::win32::handle and CUDA_EXTERNAL_MEMORY_HANDLE_DESC::handle::win32::name must not be NULL. If CUDA_EXTERNAL_MEMORY_HANDLE_DESC::handle::win32::handle is not NULL, then it must represent a valid shared NT handle that is returned by ID3D12Device::CreateSharedHandle when referring to a ID3D12Heap object. This handle holds a reference to the underlying object. If CUDA_EXTERNAL_MEMORY_HANDLE_DESC::handle::win32::name is not NULL, then it must point to a NULL-terminated array of UTF-16 characters that refers to a ID3D12Heap object.

If [CUDA_EXTERNAL_MEMORY_HANDLE_DESC::type](<structCUDA__EXTERNAL__MEMORY__HANDLE__DESC__v1.html#structCUDA__EXTERNAL__MEMORY__HANDLE__DESC__v1_1d4e3663348d28278d066980b422ab70e>) is [CU_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_RESOURCE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggbca0bdde9a33c47058b5c97f21e2edd8532abdef8908d5d35a773e491ea68f5b>), then exactly one of CUDA_EXTERNAL_MEMORY_HANDLE_DESC::handle::win32::handle and CUDA_EXTERNAL_MEMORY_HANDLE_DESC::handle::win32::name must not be NULL. If CUDA_EXTERNAL_MEMORY_HANDLE_DESC::handle::win32::handle is not NULL, then it must represent a valid shared NT handle that is returned by ID3D12Device::CreateSharedHandle when referring to a ID3D12Resource object. This handle holds a reference to the underlying object. If CUDA_EXTERNAL_MEMORY_HANDLE_DESC::handle::win32::name is not NULL, then it must point to a NULL-terminated array of UTF-16 characters that refers to a ID3D12Resource object.

If [CUDA_EXTERNAL_MEMORY_HANDLE_DESC::type](<structCUDA__EXTERNAL__MEMORY__HANDLE__DESC__v1.html#structCUDA__EXTERNAL__MEMORY__HANDLE__DESC__v1_1d4e3663348d28278d066980b422ab70e>) is [CU_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_RESOURCE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggbca0bdde9a33c47058b5c97f21e2edd89c10fcedb0f4e95a6cbf600f95be2369>), then CUDA_EXTERNAL_MEMORY_HANDLE_DESC::handle::win32::handle must represent a valid shared NT handle that is returned by IDXGIResource1::CreateSharedHandle when referring to a ID3D11Resource object. If CUDA_EXTERNAL_MEMORY_HANDLE_DESC::handle::win32::name is not NULL, then it must point to a NULL-terminated array of UTF-16 characters that refers to a ID3D11Resource object.

If [CUDA_EXTERNAL_MEMORY_HANDLE_DESC::type](<structCUDA__EXTERNAL__MEMORY__HANDLE__DESC__v1.html#structCUDA__EXTERNAL__MEMORY__HANDLE__DESC__v1_1d4e3663348d28278d066980b422ab70e>) is [CU_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_RESOURCE_KMT](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggbca0bdde9a33c47058b5c97f21e2edd8159b39907f15e7077609b488333cd390>), then CUDA_EXTERNAL_MEMORY_HANDLE_DESC::handle::win32::handle must represent a valid shared KMT handle that is returned by IDXGIResource::GetSharedHandle when referring to a ID3D11Resource object and CUDA_EXTERNAL_MEMORY_HANDLE_DESC::handle::win32::name must be NULL.

If [CUDA_EXTERNAL_MEMORY_HANDLE_DESC::type](<structCUDA__EXTERNAL__MEMORY__HANDLE__DESC__v1.html#structCUDA__EXTERNAL__MEMORY__HANDLE__DESC__v1_1d4e3663348d28278d066980b422ab70e>) is [CU_EXTERNAL_MEMORY_HANDLE_TYPE_NVSCIBUF](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggbca0bdde9a33c47058b5c97f21e2edd8adf93206205d155aed8228f4a118d6ee>), then CUDA_EXTERNAL_MEMORY_HANDLE_DESC::handle::nvSciBufObject must be non-NULL and reference a valid NvSciBuf object. If the NvSciBuf object imported into CUDA is also mapped by other drivers, then the application must use [cuWaitExternalSemaphoresAsync](<group__CUDA__EXTRES__INTEROP.html#group__CUDA__EXTRES__INTEROP_1g063f01a524818ac89bacf521c55a39f0> "Waits on a set of external semaphore objects.") or [cuSignalExternalSemaphoresAsync](<group__CUDA__EXTRES__INTEROP.html#group__CUDA__EXTRES__INTEROP_1g86cd6c4b3f439ba786f4e65d1b8107c3> "Signals a set of external semaphore objects.") as appropriate barriers to maintain coherence between CUDA and the other drivers. See [CUDA_EXTERNAL_SEMAPHORE_SIGNAL_SKIP_NVSCIBUF_MEMSYNC](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g1a6161a80f60177235f479cd74de7e04>) and [CUDA_EXTERNAL_SEMAPHORE_WAIT_SKIP_NVSCIBUF_MEMSYNC](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gf07a1d15f2696b915c068c892e6f1a35>) for memory synchronization.

If [CUDA_EXTERNAL_MEMORY_HANDLE_DESC::type](<structCUDA__EXTERNAL__MEMORY__HANDLE__DESC__v1.html#structCUDA__EXTERNAL__MEMORY__HANDLE__DESC__v1_1d4e3663348d28278d066980b422ab70e>) is [CU_EXTERNAL_MEMORY_HANDLE_TYPE_DMABUF_FD](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggbca0bdde9a33c47058b5c97f21e2edd8eaccb8a4e89ddf36b2e432bca0e53791>), then CUDA_EXTERNAL_MEMORY_HANDLE_DESC::handle::fd must be a valid file descriptor referencing a dma_buf object and [CUDA_EXTERNAL_MEMORY_HANDLE_DESC::flags](<structCUDA__EXTERNAL__MEMORY__HANDLE__DESC__v1.html#structCUDA__EXTERNAL__MEMORY__HANDLE__DESC__v1_144d7c253f6b6f34e46b8726496e425c9>) must be zero. Importing a dma_buf object is supported only on Tegra Jetson platform starting with Thor series. Mapping an imported dma_buf object as CUDA mipmapped array using [cuExternalMemoryGetMappedMipmappedArray](<group__CUDA__EXTRES__INTEROP.html#group__CUDA__EXTRES__INTEROP_1g02debbfa1b997e4f0e05300a312c17cc> "Maps a CUDA mipmapped array onto an external memory object.") is not supported.

The size of the memory object must be specified in [CUDA_EXTERNAL_MEMORY_HANDLE_DESC::size](<structCUDA__EXTERNAL__MEMORY__HANDLE__DESC__v1.html#structCUDA__EXTERNAL__MEMORY__HANDLE__DESC__v1_136570cee9bbfa12b3f34d0d1d98029ce>).

Specifying the flag [CUDA_EXTERNAL_MEMORY_DEDICATED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g7a3c833643e392f32a52c131aa87ccac>) in [CUDA_EXTERNAL_MEMORY_HANDLE_DESC::flags](<structCUDA__EXTERNAL__MEMORY__HANDLE__DESC__v1.html#structCUDA__EXTERNAL__MEMORY__HANDLE__DESC__v1_144d7c253f6b6f34e46b8726496e425c9>) indicates that the resource is a dedicated resource. The definition of what a dedicated resource is outside the scope of this extension. This flag must be set if [CUDA_EXTERNAL_MEMORY_HANDLE_DESC::type](<structCUDA__EXTERNAL__MEMORY__HANDLE__DESC__v1.html#structCUDA__EXTERNAL__MEMORY__HANDLE__DESC__v1_1d4e3663348d28278d066980b422ab70e>) is one of the following: [CU_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_RESOURCE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggbca0bdde9a33c47058b5c97f21e2edd8532abdef8908d5d35a773e491ea68f5b>)[CU_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_RESOURCE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggbca0bdde9a33c47058b5c97f21e2edd89c10fcedb0f4e95a6cbf600f95be2369>)[CU_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_RESOURCE_KMT](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggbca0bdde9a33c47058b5c97f21e2edd8159b39907f15e7077609b488333cd390>)

Note:

  * Note that this function may also return error codes from previous, asynchronous launches.

  * If the Vulkan memory imported into CUDA is mapped on the CPU then the application must use vkInvalidateMappedMemoryRanges/vkFlushMappedMemoryRanges as well as appropriate Vulkan pipeline barriers to maintain coherence between CPU and GPU. For more information on these APIs, please refer to "Synchronization and Cache Control" chapter from Vulkan specification.


**See also:**

[cuDestroyExternalMemory](<group__CUDA__EXTRES__INTEROP.html#group__CUDA__EXTRES__INTEROP_1g1b586dda86565617e7e0883b956c7052> "Destroys an external memory object."), [cuExternalMemoryGetMappedBuffer](<group__CUDA__EXTRES__INTEROP.html#group__CUDA__EXTRES__INTEROP_1gb9fec33920400c70961b4e33d838da91> "Maps a buffer onto an imported memory object."), [cuExternalMemoryGetMappedMipmappedArray](<group__CUDA__EXTRES__INTEROP.html#group__CUDA__EXTRES__INTEROP_1g02debbfa1b997e4f0e05300a312c17cc> "Maps a CUDA mipmapped array onto an external memory object.")

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuImportExternalSemaphore ( [CUexternalSemaphore](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g0bc360152166a414e50a5167250552b8>)*Â extSem_out, const [CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC](<structCUDA__EXTERNAL__SEMAPHORE__HANDLE__DESC__v1.html#structCUDA__EXTERNAL__SEMAPHORE__HANDLE__DESC__v1>)*Â semHandleDesc )


Imports an external semaphore.

######  Parameters

`extSem_out`
    \- Returned handle to an external semaphore
`semHandleDesc`
    \- Semaphore import handle descriptor

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_NOT_INITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e98feb999f0af99b4a25ab26b3866f4df8>), [CUDA_ERROR_NOT_SUPPORTED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e954756ae7ade0dfd09faeccb513dd831b>), [CUDA_ERROR_INVALID_HANDLE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e90fd2e63260c6317ba943af0f7e4b8d21>), [CUDA_ERROR_OPERATING_SYSTEM](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9c849a151611f6e2ed1b3ae923f79ef3c>)

###### Description

Imports an externally allocated synchronization object and returns a handle to that in `extSem_out`.

The properties of the handle being imported must be described in `semHandleDesc`. The CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC is defined as follows:


    â        typedef struct CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC_st {
                      [CUexternalSemaphoreHandleType](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gfecb27c44dbd154273d24d35896a2920>) type;
                      union {
                          int fd;
                          struct {
                              void *handle;
                              const void *name;
                          } win32;
                          const void* NvSciSyncObj;
                      } handle;
                      unsigned int flags;
                  } [CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC](<structCUDA__EXTERNAL__SEMAPHORE__HANDLE__DESC__v1.html#structCUDA__EXTERNAL__SEMAPHORE__HANDLE__DESC__v1>);

where [CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC::type](<structCUDA__EXTERNAL__SEMAPHORE__HANDLE__DESC__v1.html#structCUDA__EXTERNAL__SEMAPHORE__HANDLE__DESC__v1_1cf32b96f55beec6f904b2455effed87d>) specifies the type of handle being imported. [CUexternalSemaphoreHandleType](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gfecb27c44dbd154273d24d35896a2920>) is defined as:


    â        typedef enum CUexternalSemaphoreHandleType_enum {
                      [CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_FD](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggfecb27c44dbd154273d24d35896a2920771961c5b13e123cbc9b44ef0886067d>)                = 1,
                      [CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggfecb27c44dbd154273d24d35896a2920e56d4d1a5f92a866d6d8da5249a7f068>)             = 2,
                      [CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_KMT](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggfecb27c44dbd154273d24d35896a292014138c9067a288abae77ee3b7efacf4b>)         = 3,
                      [CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D12_FENCE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggfecb27c44dbd154273d24d35896a29200f65d633a7b72b5cd5d2bb741c0edfd7>)              = 4,
                      [CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D11_FENCE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggfecb27c44dbd154273d24d35896a292068cb46b3e49fa0dc11c89376e93a833b>)              = 5,
                      [CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_NVSCISYNC](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggfecb27c44dbd154273d24d35896a2920908455daa7bbeb91a83930f977c0f1c1>)                = 6,
                      [CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D11_KEYED_MUTEX](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggfecb27c44dbd154273d24d35896a2920a93c602f3eb2b39ab95b0dfeb72f8eba>)        = 7,
                      [CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D11_KEYED_MUTEX_KMT](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggfecb27c44dbd154273d24d35896a2920c97816c259dde37432b63177377473da>)    = 8,
                      [CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_TIMELINE_SEMAPHORE_FD](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggfecb27c44dbd154273d24d35896a2920d133ab71b234267c59da61978951e020>)    = 9,
                      [CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_TIMELINE_SEMAPHORE_WIN32](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggfecb27c44dbd154273d24d35896a2920d3625359c063deedf0cef25b16fbba4b>) = 10
                  } [CUexternalSemaphoreHandleType](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gfecb27c44dbd154273d24d35896a2920>);

If [CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC::type](<structCUDA__EXTERNAL__SEMAPHORE__HANDLE__DESC__v1.html#structCUDA__EXTERNAL__SEMAPHORE__HANDLE__DESC__v1_1cf32b96f55beec6f904b2455effed87d>) is [CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_FD](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggfecb27c44dbd154273d24d35896a2920771961c5b13e123cbc9b44ef0886067d>), then CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC::handle::fd must be a valid file descriptor referencing a synchronization object. Ownership of the file descriptor is transferred to the CUDA driver when the handle is imported successfully. Performing any operations on the file descriptor after it is imported results in undefined behavior.

If [CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC::type](<structCUDA__EXTERNAL__SEMAPHORE__HANDLE__DESC__v1.html#structCUDA__EXTERNAL__SEMAPHORE__HANDLE__DESC__v1_1cf32b96f55beec6f904b2455effed87d>) is [CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggfecb27c44dbd154273d24d35896a2920e56d4d1a5f92a866d6d8da5249a7f068>), then exactly one of CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC::handle::win32::handle and CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC::handle::win32::name must not be NULL. If CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC::handle::win32::handle is not NULL, then it must represent a valid shared NT handle that references a synchronization object. Ownership of this handle is not transferred to CUDA after the import operation, so the application must release the handle using the appropriate system call. If CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC::handle::win32::name is not NULL, then it must name a valid synchronization object.

If [CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC::type](<structCUDA__EXTERNAL__SEMAPHORE__HANDLE__DESC__v1.html#structCUDA__EXTERNAL__SEMAPHORE__HANDLE__DESC__v1_1cf32b96f55beec6f904b2455effed87d>) is [CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_KMT](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggfecb27c44dbd154273d24d35896a292014138c9067a288abae77ee3b7efacf4b>), then CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC::handle::win32::handle must be non-NULL and CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC::handle::win32::name must be NULL. The handle specified must be a globally shared KMT handle. This handle does not hold a reference to the underlying object, and thus will be invalid when all references to the synchronization object are destroyed.

If [CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC::type](<structCUDA__EXTERNAL__SEMAPHORE__HANDLE__DESC__v1.html#structCUDA__EXTERNAL__SEMAPHORE__HANDLE__DESC__v1_1cf32b96f55beec6f904b2455effed87d>) is [CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D12_FENCE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggfecb27c44dbd154273d24d35896a29200f65d633a7b72b5cd5d2bb741c0edfd7>), then exactly one of CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC::handle::win32::handle and CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC::handle::win32::name must not be NULL. If CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC::handle::win32::handle is not NULL, then it must represent a valid shared NT handle that is returned by ID3D12Device::CreateSharedHandle when referring to a ID3D12Fence object. This handle holds a reference to the underlying object. If CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC::handle::win32::name is not NULL, then it must name a valid synchronization object that refers to a valid ID3D12Fence object.

If [CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC::type](<structCUDA__EXTERNAL__SEMAPHORE__HANDLE__DESC__v1.html#structCUDA__EXTERNAL__SEMAPHORE__HANDLE__DESC__v1_1cf32b96f55beec6f904b2455effed87d>) is [CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D11_FENCE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggfecb27c44dbd154273d24d35896a292068cb46b3e49fa0dc11c89376e93a833b>), then CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC::handle::win32::handle represents a valid shared NT handle that is returned by ID3D11Fence::CreateSharedHandle. If CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC::handle::win32::name is not NULL, then it must name a valid synchronization object that refers to a valid ID3D11Fence object.

If [CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC::type](<structCUDA__EXTERNAL__SEMAPHORE__HANDLE__DESC__v1.html#structCUDA__EXTERNAL__SEMAPHORE__HANDLE__DESC__v1_1cf32b96f55beec6f904b2455effed87d>) is [CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_NVSCISYNC](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggfecb27c44dbd154273d24d35896a2920908455daa7bbeb91a83930f977c0f1c1>), then CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC::handle::nvSciSyncObj represents a valid NvSciSyncObj.

[CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D11_KEYED_MUTEX](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggfecb27c44dbd154273d24d35896a2920a93c602f3eb2b39ab95b0dfeb72f8eba>), then CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC::handle::win32::handle represents a valid shared NT handle that is returned by IDXGIResource1::CreateSharedHandle when referring to a IDXGIKeyedMutex object. If CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC::handle::win32::name is not NULL, then it must name a valid synchronization object that refers to a valid IDXGIKeyedMutex object.

If [CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC::type](<structCUDA__EXTERNAL__SEMAPHORE__HANDLE__DESC__v1.html#structCUDA__EXTERNAL__SEMAPHORE__HANDLE__DESC__v1_1cf32b96f55beec6f904b2455effed87d>) is [CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D11_KEYED_MUTEX_KMT](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggfecb27c44dbd154273d24d35896a2920c97816c259dde37432b63177377473da>), then CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC::handle::win32::handle represents a valid shared KMT handle that is returned by IDXGIResource::GetSharedHandle when referring to a IDXGIKeyedMutex object and CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC::handle::win32::name must be NULL.

If [CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC::type](<structCUDA__EXTERNAL__SEMAPHORE__HANDLE__DESC__v1.html#structCUDA__EXTERNAL__SEMAPHORE__HANDLE__DESC__v1_1cf32b96f55beec6f904b2455effed87d>) is [CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_TIMELINE_SEMAPHORE_FD](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggfecb27c44dbd154273d24d35896a2920d133ab71b234267c59da61978951e020>), then CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC::handle::fd must be a valid file descriptor referencing a synchronization object. Ownership of the file descriptor is transferred to the CUDA driver when the handle is imported successfully. Performing any operations on the file descriptor after it is imported results in undefined behavior.

If [CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC::type](<structCUDA__EXTERNAL__SEMAPHORE__HANDLE__DESC__v1.html#structCUDA__EXTERNAL__SEMAPHORE__HANDLE__DESC__v1_1cf32b96f55beec6f904b2455effed87d>) is [CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_TIMELINE_SEMAPHORE_WIN32](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggfecb27c44dbd154273d24d35896a2920d3625359c063deedf0cef25b16fbba4b>), then exactly one of CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC::handle::win32::handle and CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC::handle::win32::name must not be NULL. If CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC::handle::win32::handle is not NULL, then it must represent a valid shared NT handle that references a synchronization object. Ownership of this handle is not transferred to CUDA after the import operation, so the application must release the handle using the appropriate system call. If CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC::handle::win32::name is not NULL, then it must name a valid synchronization object.

Note:

Note that this function may also return error codes from previous, asynchronous launches.

**See also:**

[cuDestroyExternalSemaphore](<group__CUDA__EXTRES__INTEROP.html#group__CUDA__EXTRES__INTEROP_1g7f13444973542fa50b7e75bcfb2f923d> "Destroys an external semaphore."), [cuSignalExternalSemaphoresAsync](<group__CUDA__EXTRES__INTEROP.html#group__CUDA__EXTRES__INTEROP_1g86cd6c4b3f439ba786f4e65d1b8107c3> "Signals a set of external semaphore objects."), [cuWaitExternalSemaphoresAsync](<group__CUDA__EXTRES__INTEROP.html#group__CUDA__EXTRES__INTEROP_1g063f01a524818ac89bacf521c55a39f0> "Waits on a set of external semaphore objects.")

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuSignalExternalSemaphoresAsync ( const [CUexternalSemaphore](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g0bc360152166a414e50a5167250552b8>)*Â extSemArray, const [CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS](<structCUDA__EXTERNAL__SEMAPHORE__SIGNAL__PARAMS__v1.html#structCUDA__EXTERNAL__SEMAPHORE__SIGNAL__PARAMS__v1>)*Â paramsArray, unsigned int Â numExtSems, [CUstream](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gb946c7f02e09efd788a204718015d88a>)Â stream )


Signals a set of external semaphore objects.

######  Parameters

`extSemArray`
    \- Set of external semaphores to be signaled
`paramsArray`
    \- Array of semaphore parameters
`numExtSems`
    \- Number of semaphores to signal
`stream`
    \- Stream to enqueue the signal operations in

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_NOT_INITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e98feb999f0af99b4a25ab26b3866f4df8>), [CUDA_ERROR_INVALID_HANDLE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e90fd2e63260c6317ba943af0f7e4b8d21>), [CUDA_ERROR_NOT_SUPPORTED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e954756ae7ade0dfd09faeccb513dd831b>)

###### Description

Enqueues a signal operation on a set of externally allocated semaphore object in the specified stream. The operations will be executed when all prior operations in the stream complete.

The exact semantics of signaling a semaphore depends on the type of the object.

If the semaphore object is any one of the following types: [CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_FD](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggfecb27c44dbd154273d24d35896a2920771961c5b13e123cbc9b44ef0886067d>), [CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggfecb27c44dbd154273d24d35896a2920e56d4d1a5f92a866d6d8da5249a7f068>), [CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_KMT](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggfecb27c44dbd154273d24d35896a292014138c9067a288abae77ee3b7efacf4b>) then signaling the semaphore will set it to the signaled state.

If the semaphore object is any one of the following types: [CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D12_FENCE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggfecb27c44dbd154273d24d35896a29200f65d633a7b72b5cd5d2bb741c0edfd7>), [CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D11_FENCE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggfecb27c44dbd154273d24d35896a292068cb46b3e49fa0dc11c89376e93a833b>), [CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_TIMELINE_SEMAPHORE_FD](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggfecb27c44dbd154273d24d35896a2920d133ab71b234267c59da61978951e020>), [CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_TIMELINE_SEMAPHORE_WIN32](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggfecb27c44dbd154273d24d35896a2920d3625359c063deedf0cef25b16fbba4b>) then the semaphore will be set to the value specified in CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS::params::fence::value.

If the semaphore object is of the type [CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_NVSCISYNC](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggfecb27c44dbd154273d24d35896a2920908455daa7bbeb91a83930f977c0f1c1>) this API sets CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS::params::nvSciSync::fence to a value that can be used by subsequent waiters of the same NvSciSync object to order operations with those currently submitted in `stream`. Such an update will overwrite previous contents of CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS::params::nvSciSync::fence. By default, signaling such an external semaphore object causes appropriate memory synchronization operations to be performed over all external memory objects that are imported as [CU_EXTERNAL_MEMORY_HANDLE_TYPE_NVSCIBUF](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggbca0bdde9a33c47058b5c97f21e2edd8adf93206205d155aed8228f4a118d6ee>). This ensures that any subsequent accesses made by other importers of the same set of NvSciBuf memory object(s) are coherent. These operations can be skipped by specifying the flag [CUDA_EXTERNAL_SEMAPHORE_SIGNAL_SKIP_NVSCIBUF_MEMSYNC](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g1a6161a80f60177235f479cd74de7e04>), which can be used as a performance optimization when data coherency is not required. But specifying this flag in scenarios where data coherency is required results in undefined behavior. Also, for semaphore object of the type [CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_NVSCISYNC](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggfecb27c44dbd154273d24d35896a2920908455daa7bbeb91a83930f977c0f1c1>), if the NvSciSyncAttrList used to create the NvSciSyncObj had not set the flags in [cuDeviceGetNvSciSyncAttributes](<group__CUDA__DEVICE.html#group__CUDA__DEVICE_1g0991e2b2b3cedee1ca77d6376e581335> "Return NvSciSync attributes that this device can support.") to CUDA_NVSCISYNC_ATTR_SIGNAL, this API will return CUDA_ERROR_NOT_SUPPORTED. NvSciSyncFence associated with semaphore object of the type [CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_NVSCISYNC](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggfecb27c44dbd154273d24d35896a2920908455daa7bbeb91a83930f977c0f1c1>) can be deterministic. For this the NvSciSyncAttrList used to create the semaphore object must have value of NvSciSyncAttrKey_RequireDeterministicFences key set to true. Deterministic fences allow users to enqueue a wait over the semaphore object even before corresponding signal is enqueued. For such a semaphore object, CUDA guarantees that each signal operation will increment the fence value by '1'. Users are expected to track count of signals enqueued on the semaphore object and insert waits accordingly. When such a semaphore object is signaled from multiple streams, due to concurrent stream execution, it is possible that the order in which the semaphore gets signaled is indeterministic. This could lead to waiters of the semaphore getting unblocked incorrectly. Users are expected to handle such situations, either by not using the same semaphore object with deterministic fence support enabled in different streams or by adding explicit dependency amongst such streams so that the semaphore is signaled in order. NvSciSyncFence associated with semaphore object of the type [CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_NVSCISYNC](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggfecb27c44dbd154273d24d35896a2920908455daa7bbeb91a83930f977c0f1c1>) can be timestamp enabled. For this the NvSciSyncAttrList used to create the object must have the value of NvSciSyncAttrKey_WaiterRequireTimestamps key set to true. Timestamps are emitted asynchronously by the GPU and CUDA saves the GPU timestamp in the corresponding NvSciSyncFence at the time of signal on GPU. Users are expected to convert GPU clocks to CPU clocks using appropriate scaling functions. Users are expected to wait for the completion of the fence before extracting timestamp using appropriate NvSciSync APIs. Users are expected to ensure that there is only one outstanding timestamp enabled fence per Cuda-NvSciSync object at any point of time, failing which leads to undefined behavior. Extracting the timestamp before the corresponding fence is signalled could lead to undefined behaviour. Timestamp extracted via appropriate NvSciSync API would be in microseconds.

If the semaphore object is any one of the following types: [CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D11_KEYED_MUTEX](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggfecb27c44dbd154273d24d35896a2920a93c602f3eb2b39ab95b0dfeb72f8eba>), [CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D11_KEYED_MUTEX_KMT](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggfecb27c44dbd154273d24d35896a2920c97816c259dde37432b63177377473da>) then the keyed mutex will be released with the key specified in CUDA_EXTERNAL_SEMAPHORE_PARAMS::params::keyedmutex::key.

Note:

Note that this function may also return error codes from previous, asynchronous launches.

**See also:**

[cuImportExternalSemaphore](<group__CUDA__EXTRES__INTEROP.html#group__CUDA__EXTRES__INTEROP_1ge593134f5f9650474af74db644c4a326> "Imports an external semaphore."), [cuDestroyExternalSemaphore](<group__CUDA__EXTRES__INTEROP.html#group__CUDA__EXTRES__INTEROP_1g7f13444973542fa50b7e75bcfb2f923d> "Destroys an external semaphore."), [cuWaitExternalSemaphoresAsync](<group__CUDA__EXTRES__INTEROP.html#group__CUDA__EXTRES__INTEROP_1g063f01a524818ac89bacf521c55a39f0> "Waits on a set of external semaphore objects.")

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuWaitExternalSemaphoresAsync ( const [CUexternalSemaphore](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g0bc360152166a414e50a5167250552b8>)*Â extSemArray, const [CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS](<structCUDA__EXTERNAL__SEMAPHORE__WAIT__PARAMS__v1.html#structCUDA__EXTERNAL__SEMAPHORE__WAIT__PARAMS__v1>)*Â paramsArray, unsigned int Â numExtSems, [CUstream](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gb946c7f02e09efd788a204718015d88a>)Â stream )


Waits on a set of external semaphore objects.

######  Parameters

`extSemArray`
    \- External semaphores to be waited on
`paramsArray`
    \- Array of semaphore parameters
`numExtSems`
    \- Number of semaphores to wait on
`stream`
    \- Stream to enqueue the wait operations in

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_NOT_INITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e98feb999f0af99b4a25ab26b3866f4df8>), [CUDA_ERROR_INVALID_HANDLE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e90fd2e63260c6317ba943af0f7e4b8d21>), [CUDA_ERROR_NOT_SUPPORTED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e954756ae7ade0dfd09faeccb513dd831b>), [CUDA_ERROR_TIMEOUT](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e92cd1f40fc3a327d2bc6e9ff650d1af11>)

###### Description

Enqueues a wait operation on a set of externally allocated semaphore object in the specified stream. The operations will be executed when all prior operations in the stream complete.

The exact semantics of waiting on a semaphore depends on the type of the object.

If the semaphore object is any one of the following types: [CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_FD](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggfecb27c44dbd154273d24d35896a2920771961c5b13e123cbc9b44ef0886067d>), [CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggfecb27c44dbd154273d24d35896a2920e56d4d1a5f92a866d6d8da5249a7f068>), [CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_KMT](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggfecb27c44dbd154273d24d35896a292014138c9067a288abae77ee3b7efacf4b>) then waiting on the semaphore will wait until the semaphore reaches the signaled state. The semaphore will then be reset to the unsignaled state. Therefore for every signal operation, there can only be one wait operation.

If the semaphore object is any one of the following types: [CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D12_FENCE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggfecb27c44dbd154273d24d35896a29200f65d633a7b72b5cd5d2bb741c0edfd7>), [CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D11_FENCE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggfecb27c44dbd154273d24d35896a292068cb46b3e49fa0dc11c89376e93a833b>), [CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_TIMELINE_SEMAPHORE_FD](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggfecb27c44dbd154273d24d35896a2920d133ab71b234267c59da61978951e020>), [CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_TIMELINE_SEMAPHORE_WIN32](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggfecb27c44dbd154273d24d35896a2920d3625359c063deedf0cef25b16fbba4b>) then waiting on the semaphore will wait until the value of the semaphore is greater than or equal to CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS::params::fence::value.

If the semaphore object is of the type [CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_NVSCISYNC](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggfecb27c44dbd154273d24d35896a2920908455daa7bbeb91a83930f977c0f1c1>) then, waiting on the semaphore will wait until the CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS::params::nvSciSync::fence is signaled by the signaler of the NvSciSyncObj that was associated with this semaphore object. By default, waiting on such an external semaphore object causes appropriate memory synchronization operations to be performed over all external memory objects that are imported as [CU_EXTERNAL_MEMORY_HANDLE_TYPE_NVSCIBUF](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggbca0bdde9a33c47058b5c97f21e2edd8adf93206205d155aed8228f4a118d6ee>). This ensures that any subsequent accesses made by other importers of the same set of NvSciBuf memory object(s) are coherent. These operations can be skipped by specifying the flag [CUDA_EXTERNAL_SEMAPHORE_WAIT_SKIP_NVSCIBUF_MEMSYNC](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gf07a1d15f2696b915c068c892e6f1a35>), which can be used as a performance optimization when data coherency is not required. But specifying this flag in scenarios where data coherency is required results in undefined behavior. Also, for semaphore object of the type [CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_NVSCISYNC](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggfecb27c44dbd154273d24d35896a2920908455daa7bbeb91a83930f977c0f1c1>), if the NvSciSyncAttrList used to create the NvSciSyncObj had not set the flags in [cuDeviceGetNvSciSyncAttributes](<group__CUDA__DEVICE.html#group__CUDA__DEVICE_1g0991e2b2b3cedee1ca77d6376e581335> "Return NvSciSync attributes that this device can support.") to CUDA_NVSCISYNC_ATTR_WAIT, this API will return CUDA_ERROR_NOT_SUPPORTED.

If the semaphore object is any one of the following types: [CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D11_KEYED_MUTEX](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggfecb27c44dbd154273d24d35896a2920a93c602f3eb2b39ab95b0dfeb72f8eba>), [CU_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D11_KEYED_MUTEX_KMT](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggfecb27c44dbd154273d24d35896a2920c97816c259dde37432b63177377473da>) then the keyed mutex will be acquired when it is released with the key specified in CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS::params::keyedmutex::key or until the timeout specified by CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS::params::keyedmutex::timeoutMs has lapsed. The timeout interval can either be a finite value specified in milliseconds or an infinite value. In case an infinite value is specified the timeout never elapses. The windows INFINITE macro must be used to specify infinite timeout.

Note:

Note that this function may also return error codes from previous, asynchronous launches.

**See also:**

[cuImportExternalSemaphore](<group__CUDA__EXTRES__INTEROP.html#group__CUDA__EXTRES__INTEROP_1ge593134f5f9650474af74db644c4a326> "Imports an external semaphore."), [cuDestroyExternalSemaphore](<group__CUDA__EXTRES__INTEROP.html#group__CUDA__EXTRES__INTEROP_1g7f13444973542fa50b7e75bcfb2f923d> "Destroys an external semaphore."), [cuSignalExternalSemaphoresAsync](<group__CUDA__EXTRES__INTEROP.html#group__CUDA__EXTRES__INTEROP_1g86cd6c4b3f439ba786f4e65d1b8107c3> "Signals a set of external semaphore objects.")

* * *


---

# Stream Memory Operations

Failed to fetch documentation.


---

# Execution Control

## 6.22.Â Execution Control

This section describes the execution control functions of the low-level CUDA driver application programming interface.

### Functions

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuFuncGetAttribute](<#group__CUDA__EXEC_1g5e92a1b0d8d1b82cb00dcfb2de15961b>) ( int*Â pi, [CUfunction_attribute](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g9d955dde0904a9b43ca4d875ac1551bc>)Â attrib, [CUfunction](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gba6128b948022f495706d93bc2cea9c8>)Â hfunc )
     Returns information about a function.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuFuncGetModule](<#group__CUDA__EXEC_1g58f0fd1db9dadd3870440662622a27ef>) ( [CUmodule](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g9e4ef4dcfba4662b2299acb8d049a1ef>)*Â hmod, [CUfunction](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gba6128b948022f495706d93bc2cea9c8>)Â hfunc )
     Returns a module handle.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuFuncGetName](<#group__CUDA__EXEC_1gf60c6c51203cab164c07d6ddcc2b2e26>) ( const char**Â name, [CUfunction](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gba6128b948022f495706d93bc2cea9c8>)Â hfunc )
     Returns the function name for a CUfunction handle.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuFuncGetParamInfo](<#group__CUDA__EXEC_1g6874b82bcf2803902085645e46e0ca0e>) ( [CUfunction](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gba6128b948022f495706d93bc2cea9c8>)Â func, size_tÂ paramIndex, size_t*Â paramOffset, size_t*Â paramSize )
     Returns the offset and size of a kernel parameter in the device-side parameter layout.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuFuncIsLoaded](<#group__CUDA__EXEC_1gfc6fed4bbe6c35e0445a49396774aa96>) ( CUfunctionLoadingState*Â state, [CUfunction](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gba6128b948022f495706d93bc2cea9c8>)Â function )
     Returns if the function is loaded.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuFuncLoad](<#group__CUDA__EXEC_1g3b67024e8875bfd155534785708093ab>) ( [CUfunction](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gba6128b948022f495706d93bc2cea9c8>)Â function )
     Loads a function.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuFuncSetAttribute](<#group__CUDA__EXEC_1g0e37dce0173bc883aa1e5b14dd747f26>) ( [CUfunction](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gba6128b948022f495706d93bc2cea9c8>)Â hfunc, [CUfunction_attribute](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g9d955dde0904a9b43ca4d875ac1551bc>)Â attrib, int Â value )
     Sets information about a function.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuFuncSetCacheConfig](<#group__CUDA__EXEC_1g40f8c11e81def95dc0072a375f965681>) ( [CUfunction](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gba6128b948022f495706d93bc2cea9c8>)Â hfunc, [CUfunc_cache](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g3b9bbcf42528b889e9dbe9cfa2aea3ec>)Â config )
     Sets the preferred cache configuration for a device function.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuLaunchCooperativeKernel](<#group__CUDA__EXEC_1g06d753134145c4584c0c62525c1894cb>) ( [CUfunction](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gba6128b948022f495706d93bc2cea9c8>)Â f, unsigned int Â gridDimX, unsigned int Â gridDimY, unsigned int Â gridDimZ, unsigned int Â blockDimX, unsigned int Â blockDimY, unsigned int Â blockDimZ, unsigned int Â sharedMemBytes, [CUstream](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gb946c7f02e09efd788a204718015d88a>)Â hStream, void**Â kernelParams )
     Launches a CUDA function CUfunction or a CUDA kernel CUkernel where thread blocks can cooperate and synchronize as they execute.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuLaunchCooperativeKernelMultiDevice](<#group__CUDA__EXEC_1g1d34025bc4f8fcec82fbcfc18d07a6e2>) ( [CUDA_LAUNCH_PARAMS](<structCUDA__LAUNCH__PARAMS__v1.html#structCUDA__LAUNCH__PARAMS__v1>)*Â launchParamsList, unsigned int Â numDevices, unsigned int Â flags )
     Launches CUDA functions on multiple devices where thread blocks can cooperate and synchronize as they execute.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuLaunchHostFunc](<#group__CUDA__EXEC_1gab95a78143bae7f21eebb978f91e7f3f>) ( [CUstream](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gb946c7f02e09efd788a204718015d88a>)Â hStream, [CUhostFn](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g262cd3570ff5d396db4e3dabede3c355>)Â fn, void*Â userData )
     Enqueues a host function call in a stream.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuLaunchKernel](<#group__CUDA__EXEC_1gb8f3dc3031b40da29d5f9a7139e52e15>) ( [CUfunction](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gba6128b948022f495706d93bc2cea9c8>)Â f, unsigned int Â gridDimX, unsigned int Â gridDimY, unsigned int Â gridDimZ, unsigned int Â blockDimX, unsigned int Â blockDimY, unsigned int Â blockDimZ, unsigned int Â sharedMemBytes, [CUstream](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gb946c7f02e09efd788a204718015d88a>)Â hStream, void**Â kernelParams, void**Â extra )
     Launches a CUDA function CUfunction or a CUDA kernel CUkernel.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuLaunchKernelEx](<#group__CUDA__EXEC_1gb9c891eb6bb8f4089758e64c9c976db9>) ( const [CUlaunchConfig](<structCUlaunchConfig.html#structCUlaunchConfig>)*Â config, [CUfunction](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gba6128b948022f495706d93bc2cea9c8>)Â f, void**Â kernelParams, void**Â extra )
     Launches a CUDA function CUfunction or a CUDA kernel CUkernel with launch-time configuration.

### Functions

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuFuncGetAttribute ( int*Â pi, [CUfunction_attribute](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g9d955dde0904a9b43ca4d875ac1551bc>)Â attrib, [CUfunction](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gba6128b948022f495706d93bc2cea9c8>)Â hfunc )


Returns information about a function.

######  Parameters

`pi`
    \- Returned attribute value
`attrib`
    \- Attribute requested
`hfunc`
    \- Function to query attribute of

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_DEINITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9acf52f132faf29b473cdda6061f0f44a>), [CUDA_ERROR_NOT_INITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e98feb999f0af99b4a25ab26b3866f4df8>), [CUDA_ERROR_INVALID_CONTEXT](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a484e9af32c1e9893ff21f0e0191a12d>), [CUDA_ERROR_INVALID_HANDLE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e90fd2e63260c6317ba943af0f7e4b8d21>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>), [CUDA_ERROR_FUNCTION_NOT_LOADED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9356546a00d65f2f6bf9fc65311edabdf>)

###### Description

Returns in `*pi` the integer value of the attribute `attrib` on the kernel given by `hfunc`. The supported attributes are:

  * [CU_FUNC_ATTRIBUTE_MAX_THREADS_PER_BLOCK](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg9d955dde0904a9b43ca4d875ac1551bca244b9a52d7426e6684acebf4c9e24b8>): The maximum number of threads per block, beyond which a launch of the function would fail. This number depends on both the function and the device on which the function is currently loaded.

  * [CU_FUNC_ATTRIBUTE_SHARED_SIZE_BYTES](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg9d955dde0904a9b43ca4d875ac1551bc15651a634781263c9d4ee6070a3991f4>): The size in bytes of statically-allocated shared memory per block required by this function. This does not include dynamically-allocated shared memory requested by the user at runtime.

  * [CU_FUNC_ATTRIBUTE_CONST_SIZE_BYTES](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg9d955dde0904a9b43ca4d875ac1551bc4a255dc4e2b8542e84c9431c1953a952>): The size in bytes of user-allocated constant memory required by this function.

  * [CU_FUNC_ATTRIBUTE_LOCAL_SIZE_BYTES](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg9d955dde0904a9b43ca4d875ac1551bc0318e60c17eb22c70ffb59f610c504dd>): The size in bytes of local memory used by each thread of this function.

  * [CU_FUNC_ATTRIBUTE_NUM_REGS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg9d955dde0904a9b43ca4d875ac1551bc217730c04b1edbc80bb1772c1d6a7752>): The number of registers used by each thread of this function.

  * [CU_FUNC_ATTRIBUTE_PTX_VERSION](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg9d955dde0904a9b43ca4d875ac1551bccbd28200668ad2de39035446a89bf930>): The PTX virtual architecture version for which the function was compiled. This value is the major PTX version * 10 + the minor PTX version, so a PTX version 1.3 function would return the value 13. Note that this may return the undefined value of 0 for cubins compiled prior to CUDA 3.0.

  * [CU_FUNC_ATTRIBUTE_BINARY_VERSION](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg9d955dde0904a9b43ca4d875ac1551bcc4f70f5d16889d0b75c3bf7a303eb437>): The binary architecture version for which the function was compiled. This value is the major binary version * 10 + the minor binary version, so a binary version 1.3 function would return the value 13. Note that this will return a value of 10 for legacy cubins that do not have a properly-encoded binary architecture version.

  * CU_FUNC_CACHE_MODE_CA: The attribute to indicate whether the function has been compiled with user specified option "-Xptxas \--dlcm=ca" set .

  * [CU_FUNC_ATTRIBUTE_MAX_DYNAMIC_SHARED_SIZE_BYTES](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg9d955dde0904a9b43ca4d875ac1551bc75b33d145e83462ef7292575015be03e>): The maximum size in bytes of dynamically-allocated shared memory.

  * [CU_FUNC_ATTRIBUTE_PREFERRED_SHARED_MEMORY_CARVEOUT](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg9d955dde0904a9b43ca4d875ac1551bcc75f6fd470b848653f026b8c82c10ae3>): Preferred shared memory-L1 cache split ratio in percent of total shared memory.

  * [CU_FUNC_ATTRIBUTE_CLUSTER_SIZE_MUST_BE_SET](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg9d955dde0904a9b43ca4d875ac1551bc8bd0417b504a8006cc6f57c023b54c2b>): If this attribute is set, the kernel must launch with a valid cluster size specified.

  * [CU_FUNC_ATTRIBUTE_REQUIRED_CLUSTER_WIDTH](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg9d955dde0904a9b43ca4d875ac1551bc1c83b56a254f78ddd5bf75ccfd15f0cb>): The required cluster width in blocks.

  * [CU_FUNC_ATTRIBUTE_REQUIRED_CLUSTER_HEIGHT](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg9d955dde0904a9b43ca4d875ac1551bc0c3f2eb7eaea02e3c85a4bedd02be331>): The required cluster height in blocks.

  * [CU_FUNC_ATTRIBUTE_REQUIRED_CLUSTER_DEPTH](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg9d955dde0904a9b43ca4d875ac1551bc4ab3672ad6476ad4bfa973e3083cdb32>): The required cluster depth in blocks.

  * [CU_FUNC_ATTRIBUTE_NON_PORTABLE_CLUSTER_SIZE_ALLOWED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg9d955dde0904a9b43ca4d875ac1551bce5ea0cdab1af87e68ac45e19e4c52c5d>): Indicates whether the function can be launched with non-portable cluster size. 1 is allowed, 0 is disallowed. A non-portable cluster size may only function on the specific SKUs the program is tested on. The launch might fail if the program is run on a different hardware platform. CUDA API provides cudaOccupancyMaxActiveClusters to assist with checking whether the desired size can be launched on the current device. A portable cluster size is guaranteed to be functional on all compute capabilities higher than the target compute capability. The portable cluster size for sm_90 is 8 blocks per cluster. This value may increase for future compute capabilities. The specific hardware unit may support higher cluster sizes thatâs not guaranteed to be portable.

  * [CU_FUNC_ATTRIBUTE_CLUSTER_SCHEDULING_POLICY_PREFERENCE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg9d955dde0904a9b43ca4d875ac1551bcad30df41ca0cac5046c58a75d91326a6>): The block scheduling policy of a function. The value type is CUclusterSchedulingPolicy.


With a few execeptions, function attributes may also be queried on unloaded function handles returned from [cuModuleEnumerateFunctions](<group__CUDA__MODULE.html#group__CUDA__MODULE_1g6bdb22a7d9cacf7df5bda2a18082ec50> "Returns the function handles within a module."). [CUDA_ERROR_FUNCTION_NOT_LOADED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9356546a00d65f2f6bf9fc65311edabdf>) is returned if the attribute requires a fully loaded function but the function is not loaded. The loading state of a function may be queried using cuFuncIsloaded. [cuFuncLoad](<group__CUDA__EXEC.html#group__CUDA__EXEC_1g3b67024e8875bfd155534785708093ab> "Loads a function.") may be called to explicitly load a function before querying the following attributes that require the function to be loaded:

  * [CU_FUNC_ATTRIBUTE_MAX_THREADS_PER_BLOCK](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg9d955dde0904a9b43ca4d875ac1551bca244b9a52d7426e6684acebf4c9e24b8>)

  * [CU_FUNC_ATTRIBUTE_CONST_SIZE_BYTES](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg9d955dde0904a9b43ca4d875ac1551bc4a255dc4e2b8542e84c9431c1953a952>)

  * [CU_FUNC_ATTRIBUTE_MAX_DYNAMIC_SHARED_SIZE_BYTES](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg9d955dde0904a9b43ca4d875ac1551bc75b33d145e83462ef7292575015be03e>)


Note:

Note that this function may also return error codes from previous, asynchronous launches.

**See also:**

[cuCtxGetCacheConfig](<group__CUDA__CTX.html#group__CUDA__CTX_1g40b6b141698f76744dea6e39b9a25360> "Returns the preferred cache configuration for the current context."), [cuCtxSetCacheConfig](<group__CUDA__CTX.html#group__CUDA__CTX_1g54699acf7e2ef27279d013ca2095f4a3> "Sets the preferred cache configuration for the current context."), [cuFuncSetCacheConfig](<group__CUDA__EXEC.html#group__CUDA__EXEC_1g40f8c11e81def95dc0072a375f965681> "Sets the preferred cache configuration for a device function."), [cuLaunchKernel](<group__CUDA__EXEC.html#group__CUDA__EXEC_1gb8f3dc3031b40da29d5f9a7139e52e15> "Launches a CUDA function CUfunction or a CUDA kernel CUkernel."), [cudaFuncGetAttributes](<../cuda-runtime-api/group__CUDART__HIGHLEVEL.html#group__CUDART__HIGHLEVEL_1g0e78e02c6d12ebddd4577ac6ebadf494>), [cudaFuncSetAttribute](<../cuda-runtime-api/group__CUDART__HIGHLEVEL.html#group__CUDART__HIGHLEVEL_1g61085e9f04656b92573af16072bbc78d>), [cuFuncIsLoaded](<group__CUDA__EXEC.html#group__CUDA__EXEC_1gfc6fed4bbe6c35e0445a49396774aa96> "Returns if the function is loaded."), [cuFuncLoad](<group__CUDA__EXEC.html#group__CUDA__EXEC_1g3b67024e8875bfd155534785708093ab> "Loads a function."), [cuKernelGetAttribute](<group__CUDA__LIBRARY.html#group__CUDA__LIBRARY_1gd98317cb151b99fbd95767418122071f> "Returns information about a kernel.")

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuFuncGetModule ( [CUmodule](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g9e4ef4dcfba4662b2299acb8d049a1ef>)*Â hmod, [CUfunction](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gba6128b948022f495706d93bc2cea9c8>)Â hfunc )


Returns a module handle.

######  Parameters

`hmod`
    \- Returned module handle
`hfunc`
    \- Function to retrieve module for

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_DEINITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9acf52f132faf29b473cdda6061f0f44a>), [CUDA_ERROR_NOT_INITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e98feb999f0af99b4a25ab26b3866f4df8>), [CUDA_ERROR_INVALID_CONTEXT](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a484e9af32c1e9893ff21f0e0191a12d>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>), [CUDA_ERROR_NOT_FOUND](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9af1cadbeb21d3a78115ca211ba44c053>)

###### Description

Returns in `*hmod` the handle of the module that function `hfunc` is located in. The lifetime of the module corresponds to the lifetime of the context it was loaded in or until the module is explicitly unloaded.

The CUDA runtime manages its own modules loaded into the primary context. If the handle returned by this API refers to a module loaded by the CUDA runtime, calling [cuModuleUnload()](<group__CUDA__MODULE.html#group__CUDA__MODULE_1g8ea3d716524369de3763104ced4ea57b> "Unloads a module.") on that module will result in undefined behavior.

Note:

Note that this function may also return error codes from previous, asynchronous launches.

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuFuncGetName ( const char**Â name, [CUfunction](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gba6128b948022f495706d93bc2cea9c8>)Â hfunc )


Returns the function name for a CUfunction handle.

######  Parameters

`name`
    \- The returned name of the function
`hfunc`
    \- The function handle to retrieve the name for

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>),

###### Description

Returns in `**name` the function name associated with the function handle `hfunc` . The function name is returned as a null-terminated string. The returned name is only valid when the function handle is valid. If the module is unloaded or reloaded, one must call the API again to get the updated name. This API may return a mangled name if the function is not declared as having C linkage. If either `**name` or `hfunc` is NULL, [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>) is returned.

Note:

Note that this function may also return error codes from previous, asynchronous launches.

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuFuncGetParamInfo ( [CUfunction](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gba6128b948022f495706d93bc2cea9c8>)Â func, size_tÂ paramIndex, size_t*Â paramOffset, size_t*Â paramSize )


Returns the offset and size of a kernel parameter in the device-side parameter layout.

######  Parameters

`func`
    \- The function to query
`paramIndex`
    \- The parameter index to query
`paramOffset`
    \- Returns the offset into the device-side parameter layout at which the parameter resides
`paramSize`
    \- Optionally returns the size of the parameter in the device-side parameter layout

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>),

###### Description

Queries the kernel parameter at `paramIndex` into `func's` list of parameters, and returns in `paramOffset` and `paramSize` the offset and size, respectively, where the parameter will reside in the device-side parameter layout. This information can be used to update kernel node parameters from the device via [cudaGraphKernelNodeSetParam()](<../cuda-runtime-api/group__CUDART__GRAPH.html#group__CUDART__GRAPH_1g0c2bd161eff1e47531eedce282e66d21>) and [cudaGraphKernelNodeUpdatesApply()](<../cuda-runtime-api/group__CUDART__GRAPH.html#group__CUDART__GRAPH_1g2d558cf37c9616365c67447e61ac0d6a>). `paramIndex` must be less than the number of parameters that `func` takes. `paramSize` can be set to NULL if only the parameter offset is desired.

Note:

Note that this function may also return error codes from previous, asynchronous launches.

**See also:**

[cuKernelGetParamInfo](<group__CUDA__LIBRARY.html#group__CUDA__LIBRARY_1ga61653c9f13f713527e189fb0c2fe235> "Returns the offset and size of a kernel parameter in the device-side parameter layout.")

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuFuncIsLoaded ( CUfunctionLoadingState*Â state, [CUfunction](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gba6128b948022f495706d93bc2cea9c8>)Â function )


Returns if the function is loaded.

######  Parameters

`state`
    \- returned loading state
`function`
    \- the function to check

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_INVALID_HANDLE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e90fd2e63260c6317ba943af0f7e4b8d21>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>)

###### Description

Returns in `state` the loading state of `function`.

**See also:**

[cuFuncLoad](<group__CUDA__EXEC.html#group__CUDA__EXEC_1g3b67024e8875bfd155534785708093ab> "Loads a function."), [cuModuleEnumerateFunctions](<group__CUDA__MODULE.html#group__CUDA__MODULE_1g6bdb22a7d9cacf7df5bda2a18082ec50> "Returns the function handles within a module.")

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuFuncLoad ( [CUfunction](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gba6128b948022f495706d93bc2cea9c8>)Â function )


Loads a function.

######  Parameters

`function`
    \- the function to load

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_INVALID_HANDLE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e90fd2e63260c6317ba943af0f7e4b8d21>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>)

###### Description

Finalizes function loading for `function`. Calling this API with a fully loaded function has no effect.

**See also:**

[cuModuleEnumerateFunctions](<group__CUDA__MODULE.html#group__CUDA__MODULE_1g6bdb22a7d9cacf7df5bda2a18082ec50> "Returns the function handles within a module."), [cuFuncIsLoaded](<group__CUDA__EXEC.html#group__CUDA__EXEC_1gfc6fed4bbe6c35e0445a49396774aa96> "Returns if the function is loaded.")

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuFuncSetAttribute ( [CUfunction](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gba6128b948022f495706d93bc2cea9c8>)Â hfunc, [CUfunction_attribute](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g9d955dde0904a9b43ca4d875ac1551bc>)Â attrib, int Â value )


Sets information about a function.

######  Parameters

`hfunc`
    \- Function to query attribute of
`attrib`
    \- Attribute requested
`value`
    \- The value to set

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_DEINITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9acf52f132faf29b473cdda6061f0f44a>), [CUDA_ERROR_NOT_INITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e98feb999f0af99b4a25ab26b3866f4df8>), [CUDA_ERROR_INVALID_CONTEXT](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a484e9af32c1e9893ff21f0e0191a12d>), [CUDA_ERROR_INVALID_HANDLE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e90fd2e63260c6317ba943af0f7e4b8d21>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>)

###### Description

This call sets the value of a specified attribute `attrib` on the kernel given by `hfunc` to an integer value specified by `val` This function returns CUDA_SUCCESS if the new value of the attribute could be successfully set. If the set fails, this call will return an error. Not all attributes can have values set. Attempting to set a value on a read-only attribute will result in an error (CUDA_ERROR_INVALID_VALUE)

Supported attributes for the cuFuncSetAttribute call are:

  * [CU_FUNC_ATTRIBUTE_MAX_DYNAMIC_SHARED_SIZE_BYTES](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg9d955dde0904a9b43ca4d875ac1551bc75b33d145e83462ef7292575015be03e>): This maximum size in bytes of dynamically-allocated shared memory. The value should contain the requested maximum size of dynamically-allocated shared memory. The sum of this value and the function attribute [CU_FUNC_ATTRIBUTE_SHARED_SIZE_BYTES](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg9d955dde0904a9b43ca4d875ac1551bc15651a634781263c9d4ee6070a3991f4>) cannot exceed the device attribute [CU_DEVICE_ATTRIBUTE_MAX_SHARED_MEMORY_PER_BLOCK_OPTIN](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gge12b8a782bebe21b1ac0091bf9f4e2a3e788564c0a95b866dc624fbc1b49dab3>). The maximal size of requestable dynamic shared memory may differ by GPU architecture.

  * [CU_FUNC_ATTRIBUTE_PREFERRED_SHARED_MEMORY_CARVEOUT](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg9d955dde0904a9b43ca4d875ac1551bcc75f6fd470b848653f026b8c82c10ae3>): On devices where the L1 cache and shared memory use the same hardware resources, this sets the shared memory carveout preference, in percent of the total shared memory. See [CU_DEVICE_ATTRIBUTE_MAX_SHARED_MEMORY_PER_MULTIPROCESSOR](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gge12b8a782bebe21b1ac0091bf9f4e2a306a33c18889f6fc907412451c95154ed>) This is only a hint, and the driver can choose a different ratio if required to execute the function.

  * [CU_FUNC_ATTRIBUTE_REQUIRED_CLUSTER_WIDTH](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg9d955dde0904a9b43ca4d875ac1551bc1c83b56a254f78ddd5bf75ccfd15f0cb>): The required cluster width in blocks. The width, height, and depth values must either all be 0 or all be positive. The validity of the cluster dimensions is checked at launch time. If the value is set during compile time, it cannot be set at runtime. Setting it at runtime will return CUDA_ERROR_NOT_PERMITTED.

  * [CU_FUNC_ATTRIBUTE_REQUIRED_CLUSTER_HEIGHT](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg9d955dde0904a9b43ca4d875ac1551bc0c3f2eb7eaea02e3c85a4bedd02be331>): The required cluster height in blocks. The width, height, and depth values must either all be 0 or all be positive. The validity of the cluster dimensions is checked at launch time. If the value is set during compile time, it cannot be set at runtime. Setting it at runtime will return CUDA_ERROR_NOT_PERMITTED.

  * [CU_FUNC_ATTRIBUTE_REQUIRED_CLUSTER_DEPTH](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg9d955dde0904a9b43ca4d875ac1551bc4ab3672ad6476ad4bfa973e3083cdb32>): The required cluster depth in blocks. The width, height, and depth values must either all be 0 or all be positive. The validity of the cluster dimensions is checked at launch time. If the value is set during compile time, it cannot be set at runtime. Setting it at runtime will return CUDA_ERROR_NOT_PERMITTED.

  * [CU_FUNC_ATTRIBUTE_NON_PORTABLE_CLUSTER_SIZE_ALLOWED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg9d955dde0904a9b43ca4d875ac1551bce5ea0cdab1af87e68ac45e19e4c52c5d>): Indicates whether the function can be launched with non-portable cluster size. 1 is allowed, 0 is disallowed.

  * [CU_FUNC_ATTRIBUTE_CLUSTER_SCHEDULING_POLICY_PREFERENCE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg9d955dde0904a9b43ca4d875ac1551bcad30df41ca0cac5046c58a75d91326a6>): The block scheduling policy of a function. The value type is CUclusterSchedulingPolicy.


Note:

Note that this function may also return error codes from previous, asynchronous launches.

**See also:**

[cuCtxGetCacheConfig](<group__CUDA__CTX.html#group__CUDA__CTX_1g40b6b141698f76744dea6e39b9a25360> "Returns the preferred cache configuration for the current context."), [cuCtxSetCacheConfig](<group__CUDA__CTX.html#group__CUDA__CTX_1g54699acf7e2ef27279d013ca2095f4a3> "Sets the preferred cache configuration for the current context."), [cuFuncSetCacheConfig](<group__CUDA__EXEC.html#group__CUDA__EXEC_1g40f8c11e81def95dc0072a375f965681> "Sets the preferred cache configuration for a device function."), [cuLaunchKernel](<group__CUDA__EXEC.html#group__CUDA__EXEC_1gb8f3dc3031b40da29d5f9a7139e52e15> "Launches a CUDA function CUfunction or a CUDA kernel CUkernel."), [cudaFuncGetAttributes](<../cuda-runtime-api/group__CUDART__HIGHLEVEL.html#group__CUDART__HIGHLEVEL_1g0e78e02c6d12ebddd4577ac6ebadf494>), [cudaFuncSetAttribute](<../cuda-runtime-api/group__CUDART__HIGHLEVEL.html#group__CUDART__HIGHLEVEL_1g61085e9f04656b92573af16072bbc78d>), [cuKernelSetAttribute](<group__CUDA__LIBRARY.html#group__CUDA__LIBRARY_1g1093ade718915249de3b14320d567067> "Sets information about a kernel.")

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuFuncSetCacheConfig ( [CUfunction](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gba6128b948022f495706d93bc2cea9c8>)Â hfunc, [CUfunc_cache](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g3b9bbcf42528b889e9dbe9cfa2aea3ec>)Â config )


Sets the preferred cache configuration for a device function.

######  Parameters

`hfunc`
    \- Kernel to configure cache for
`config`
    \- Requested cache configuration

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>), [CUDA_ERROR_DEINITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9acf52f132faf29b473cdda6061f0f44a>), [CUDA_ERROR_NOT_INITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e98feb999f0af99b4a25ab26b3866f4df8>), [CUDA_ERROR_INVALID_CONTEXT](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a484e9af32c1e9893ff21f0e0191a12d>)

###### Description

On devices where the L1 cache and shared memory use the same hardware resources, this sets through `config` the preferred cache configuration for the device function `hfunc`. This is only a preference. The driver will use the requested configuration if possible, but it is free to choose a different configuration if required to execute `hfunc`. Any context-wide preference set via [cuCtxSetCacheConfig()](<group__CUDA__CTX.html#group__CUDA__CTX_1g54699acf7e2ef27279d013ca2095f4a3> "Sets the preferred cache configuration for the current context.") will be overridden by this per-function setting unless the per-function setting is [CU_FUNC_CACHE_PREFER_NONE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg3b9bbcf42528b889e9dbe9cfa2aea3ec47d2f367dc3965c27ff748688229dc22>). In that case, the current context-wide setting will be used.

This setting does nothing on devices where the size of the L1 cache and shared memory are fixed.

Launching a kernel with a different preference than the most recent preference setting may insert a device-side synchronization point.

The supported cache configurations are:

  * [CU_FUNC_CACHE_PREFER_NONE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg3b9bbcf42528b889e9dbe9cfa2aea3ec47d2f367dc3965c27ff748688229dc22>): no preference for shared memory or L1 (default)

  * [CU_FUNC_CACHE_PREFER_SHARED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg3b9bbcf42528b889e9dbe9cfa2aea3ec712f43defb051d7985317bce426cccc8>): prefer larger shared memory and smaller L1 cache

  * [CU_FUNC_CACHE_PREFER_L1](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg3b9bbcf42528b889e9dbe9cfa2aea3ecb1e6c4e889e1a70ed5283172be08f6a5>): prefer larger L1 cache and smaller shared memory

  * [CU_FUNC_CACHE_PREFER_EQUAL](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg3b9bbcf42528b889e9dbe9cfa2aea3ec4434321280821d844a15b02e4d6c80a9>): prefer equal sized L1 cache and shared memory


Note:

Note that this function may also return error codes from previous, asynchronous launches.

**See also:**

[cuCtxGetCacheConfig](<group__CUDA__CTX.html#group__CUDA__CTX_1g40b6b141698f76744dea6e39b9a25360> "Returns the preferred cache configuration for the current context."), [cuCtxSetCacheConfig](<group__CUDA__CTX.html#group__CUDA__CTX_1g54699acf7e2ef27279d013ca2095f4a3> "Sets the preferred cache configuration for the current context."), [cuFuncGetAttribute](<group__CUDA__EXEC.html#group__CUDA__EXEC_1g5e92a1b0d8d1b82cb00dcfb2de15961b> "Returns information about a function."), [cuLaunchKernel](<group__CUDA__EXEC.html#group__CUDA__EXEC_1gb8f3dc3031b40da29d5f9a7139e52e15> "Launches a CUDA function CUfunction or a CUDA kernel CUkernel."), [cudaFuncSetCacheConfig](<../cuda-runtime-api/group__CUDART__HIGHLEVEL.html#group__CUDART__HIGHLEVEL_1g7d9cc996fe45b6260ebb086caff1c685>), [cuKernelSetCacheConfig](<group__CUDA__LIBRARY.html#group__CUDA__LIBRARY_1g8490476e5d3573c7ede78f29bd8cde51> "Sets the preferred cache configuration for a device kernel.")

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuLaunchCooperativeKernel ( [CUfunction](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gba6128b948022f495706d93bc2cea9c8>)Â f, unsigned int Â gridDimX, unsigned int Â gridDimY, unsigned int Â gridDimZ, unsigned int Â blockDimX, unsigned int Â blockDimY, unsigned int Â blockDimZ, unsigned int Â sharedMemBytes, [CUstream](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gb946c7f02e09efd788a204718015d88a>)Â hStream, void**Â kernelParams )


Launches a CUDA function CUfunction or a CUDA kernel CUkernel where thread blocks can cooperate and synchronize as they execute.

######  Parameters

`f`
    \- Function [CUfunction](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gba6128b948022f495706d93bc2cea9c8>) or Kernel [CUkernel](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g612028921e5736db673e4307589989ed>) to launch
`gridDimX`
    \- Width of grid in blocks
`gridDimY`
    \- Height of grid in blocks
`gridDimZ`
    \- Depth of grid in blocks
`blockDimX`
    \- X dimension of each thread block
`blockDimY`
    \- Y dimension of each thread block
`blockDimZ`
    \- Z dimension of each thread block
`sharedMemBytes`
    \- Dynamic shared-memory size per thread block in bytes
`hStream`
    \- Stream identifier
`kernelParams`
    \- Array of pointers to kernel parameters

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_DEINITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9acf52f132faf29b473cdda6061f0f44a>), [CUDA_ERROR_NOT_INITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e98feb999f0af99b4a25ab26b3866f4df8>), [CUDA_ERROR_INVALID_CONTEXT](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a484e9af32c1e9893ff21f0e0191a12d>), [CUDA_ERROR_INVALID_HANDLE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e90fd2e63260c6317ba943af0f7e4b8d21>), [CUDA_ERROR_INVALID_IMAGE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e90b7bd1dd2fb3491c588ce569c02d1a2f>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>), [CUDA_ERROR_LAUNCH_FAILED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e94f270bc1011b152febc8154b2b1e1b8d>), [CUDA_ERROR_LAUNCH_OUT_OF_RESOURCES](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9b5da09cc5697599a56a71a04184ffdaa>), [CUDA_ERROR_LAUNCH_TIMEOUT](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e965460d83f63575af9805ca59f8f19d74>), [CUDA_ERROR_LAUNCH_INCOMPATIBLE_TEXTURING](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e99e36a98a3a2c5123d422b9a1b69dd5f6>), [CUDA_ERROR_COOPERATIVE_LAUNCH_TOO_LARGE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9d26f67e0acc1563f87ddb94c638478cd>), [CUDA_ERROR_SHARED_OBJECT_INIT_FAILED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9d8a149ebc98aa90f6417e531fa645043>), [CUDA_ERROR_NOT_FOUND](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9af1cadbeb21d3a78115ca211ba44c053>)

###### Description

Invokes the function [CUfunction](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gba6128b948022f495706d93bc2cea9c8>) or the kernel [CUkernel](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g612028921e5736db673e4307589989ed>)`f` on a `gridDimX` x `gridDimY` x `gridDimZ` grid of blocks. Each block contains `blockDimX` x `blockDimY` x `blockDimZ` threads.

`sharedMemBytes` sets the amount of dynamic shared memory that will be available to each thread block.

The device on which this kernel is invoked must have a non-zero value for the device attribute [CU_DEVICE_ATTRIBUTE_COOPERATIVE_LAUNCH](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gge12b8a782bebe21b1ac0091bf9f4e2a3e9d3b7631f9112048c541cdb08c8a4e6>).

The total number of blocks launched cannot exceed the maximum number of blocks per multiprocessor as returned by [cuOccupancyMaxActiveBlocksPerMultiprocessor](<group__CUDA__OCCUPANCY.html#group__CUDA__OCCUPANCY_1gcc6e1094d05cba2cee17fe33ddd04a98> "Returns occupancy of a function.") (or [cuOccupancyMaxActiveBlocksPerMultiprocessorWithFlags](<group__CUDA__OCCUPANCY.html#group__CUDA__OCCUPANCY_1g8f1da4d4983e5c3025447665423ae2c2> "Returns occupancy of a function.")) times the number of multiprocessors as specified by the device attribute [CU_DEVICE_ATTRIBUTE_MULTIPROCESSOR_COUNT](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gge12b8a782bebe21b1ac0091bf9f4e2a3b92d0a38a94a3f61d4c53e00114afcaa>).

The kernel cannot make use of CUDA dynamic parallelism.

Kernel parameters must be specified via `kernelParams`. If `f` has N parameters, then `kernelParams` needs to be an array of N pointers. Each of `kernelParams`[0] through `kernelParams`[N-1] must point to a region of memory from which the actual kernel parameter will be copied. The number of kernel parameters and their offsets and sizes do not need to be specified as that information is retrieved directly from the kernel's image.

Calling [cuLaunchCooperativeKernel()](<group__CUDA__EXEC.html#group__CUDA__EXEC_1g06d753134145c4584c0c62525c1894cb> "Launches a CUDA function CUfunction or a CUDA kernel CUkernel where thread blocks can cooperate and synchronize as they execute.") sets persistent function state that is the same as function state set through [cuLaunchKernel](<group__CUDA__EXEC.html#group__CUDA__EXEC_1gb8f3dc3031b40da29d5f9a7139e52e15> "Launches a CUDA function CUfunction or a CUDA kernel CUkernel.") API

When the kernel `f` is launched via [cuLaunchCooperativeKernel()](<group__CUDA__EXEC.html#group__CUDA__EXEC_1g06d753134145c4584c0c62525c1894cb> "Launches a CUDA function CUfunction or a CUDA kernel CUkernel where thread blocks can cooperate and synchronize as they execute."), the previous block shape, shared size and parameter info associated with `f` is overwritten.

Note that to use [cuLaunchCooperativeKernel()](<group__CUDA__EXEC.html#group__CUDA__EXEC_1g06d753134145c4584c0c62525c1894cb> "Launches a CUDA function CUfunction or a CUDA kernel CUkernel where thread blocks can cooperate and synchronize as they execute."), the kernel `f` must either have been compiled with toolchain version 3.2 or later so that it will contain kernel parameter information, or have no kernel parameters. If either of these conditions is not met, then [cuLaunchCooperativeKernel()](<group__CUDA__EXEC.html#group__CUDA__EXEC_1g06d753134145c4584c0c62525c1894cb> "Launches a CUDA function CUfunction or a CUDA kernel CUkernel where thread blocks can cooperate and synchronize as they execute.") will return [CUDA_ERROR_INVALID_IMAGE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e90b7bd1dd2fb3491c588ce569c02d1a2f>).

Note that the API can also be used to launch context-less kernel [CUkernel](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g612028921e5736db673e4307589989ed>) by querying the handle using [cuLibraryGetKernel()](<group__CUDA__LIBRARY.html#group__CUDA__LIBRARY_1g15336d865f5abd63e3dc6004d5bc037a> "Returns a kernel handle.") and then passing it to the API by casting to [CUfunction](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gba6128b948022f495706d93bc2cea9c8>). Here, the context to launch the kernel on will either be taken from the specified stream `hStream` or the current context in case of NULL stream.

Note:

  * This function uses standard [default stream](<stream-sync-behavior.html#stream-sync-behavior__default-stream>) semantics.

  * Note that this function may also return error codes from previous, asynchronous launches.


**See also:**

[cuCtxGetCacheConfig](<group__CUDA__CTX.html#group__CUDA__CTX_1g40b6b141698f76744dea6e39b9a25360> "Returns the preferred cache configuration for the current context."), [cuCtxSetCacheConfig](<group__CUDA__CTX.html#group__CUDA__CTX_1g54699acf7e2ef27279d013ca2095f4a3> "Sets the preferred cache configuration for the current context."), [cuFuncSetCacheConfig](<group__CUDA__EXEC.html#group__CUDA__EXEC_1g40f8c11e81def95dc0072a375f965681> "Sets the preferred cache configuration for a device function."), [cuFuncGetAttribute](<group__CUDA__EXEC.html#group__CUDA__EXEC_1g5e92a1b0d8d1b82cb00dcfb2de15961b> "Returns information about a function."), [cuLaunchCooperativeKernelMultiDevice](<group__CUDA__EXEC.html#group__CUDA__EXEC_1g1d34025bc4f8fcec82fbcfc18d07a6e2> "Launches CUDA functions on multiple devices where thread blocks can cooperate and synchronize as they execute."), [cudaLaunchCooperativeKernel](<../cuda-runtime-api/group__CUDART__HIGHLEVEL.html#group__CUDART__HIGHLEVEL_1g7c4cb6c44a6c4608da36c44374499b31>), [cuLibraryGetKernel](<group__CUDA__LIBRARY.html#group__CUDA__LIBRARY_1g15336d865f5abd63e3dc6004d5bc037a> "Returns a kernel handle."), [cuKernelSetCacheConfig](<group__CUDA__LIBRARY.html#group__CUDA__LIBRARY_1g8490476e5d3573c7ede78f29bd8cde51> "Sets the preferred cache configuration for a device kernel."), [cuKernelGetAttribute](<group__CUDA__LIBRARY.html#group__CUDA__LIBRARY_1gd98317cb151b99fbd95767418122071f> "Returns information about a kernel."), [cuKernelSetAttribute](<group__CUDA__LIBRARY.html#group__CUDA__LIBRARY_1g1093ade718915249de3b14320d567067> "Sets information about a kernel.")

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuLaunchCooperativeKernelMultiDevice ( [CUDA_LAUNCH_PARAMS](<structCUDA__LAUNCH__PARAMS__v1.html#structCUDA__LAUNCH__PARAMS__v1>)*Â launchParamsList, unsigned int Â numDevices, unsigned int Â flags )


Launches CUDA functions on multiple devices where thread blocks can cooperate and synchronize as they execute.

######  Parameters

`launchParamsList`
    \- List of launch parameters, one per device
`numDevices`
    \- Size of the `launchParamsList` array
`flags`
    \- Flags to control launch behavior

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_DEINITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9acf52f132faf29b473cdda6061f0f44a>), [CUDA_ERROR_NOT_INITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e98feb999f0af99b4a25ab26b3866f4df8>), [CUDA_ERROR_INVALID_CONTEXT](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a484e9af32c1e9893ff21f0e0191a12d>), [CUDA_ERROR_INVALID_HANDLE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e90fd2e63260c6317ba943af0f7e4b8d21>), [CUDA_ERROR_INVALID_IMAGE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e90b7bd1dd2fb3491c588ce569c02d1a2f>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>), [CUDA_ERROR_LAUNCH_FAILED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e94f270bc1011b152febc8154b2b1e1b8d>), [CUDA_ERROR_LAUNCH_OUT_OF_RESOURCES](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9b5da09cc5697599a56a71a04184ffdaa>), [CUDA_ERROR_LAUNCH_TIMEOUT](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e965460d83f63575af9805ca59f8f19d74>), [CUDA_ERROR_LAUNCH_INCOMPATIBLE_TEXTURING](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e99e36a98a3a2c5123d422b9a1b69dd5f6>), [CUDA_ERROR_COOPERATIVE_LAUNCH_TOO_LARGE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9d26f67e0acc1563f87ddb94c638478cd>), [CUDA_ERROR_SHARED_OBJECT_INIT_FAILED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9d8a149ebc98aa90f6417e531fa645043>)

###### [Deprecated](<deprecated.html#deprecated__deprecated_1_deprecated000010>)

This function is deprecated as of CUDA 11.3.

###### Description

Invokes kernels as specified in the `launchParamsList` array where each element of the array specifies all the parameters required to perform a single kernel launch. These kernels can cooperate and synchronize as they execute. The size of the array is specified by `numDevices`.

No two kernels can be launched on the same device. All the devices targeted by this multi-device launch must be identical. All devices must have a non-zero value for the device attribute [CU_DEVICE_ATTRIBUTE_COOPERATIVE_MULTI_DEVICE_LAUNCH](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gge12b8a782bebe21b1ac0091bf9f4e2a31d10266c0f67ba1fe57b23c9d311f0a3>).

All kernels launched must be identical with respect to the compiled code. Note that any __device__, __constant__ or __managed__ variables present in the module that owns the kernel launched on each device, are independently instantiated on every device. It is the application's responsibility to ensure these variables are initialized and used appropriately.

The size of the grids as specified in blocks, the size of the blocks themselves and the amount of shared memory used by each thread block must also match across all launched kernels.

The streams used to launch these kernels must have been created via either [cuStreamCreate](<group__CUDA__STREAM.html#group__CUDA__STREAM_1ga581f0c5833e21ded8b5a56594e243f4> "Create a stream.") or [cuStreamCreateWithPriority](<group__CUDA__STREAM.html#group__CUDA__STREAM_1g95c1a8c7c3dacb13091692dd9c7f7471> "Create a stream with the given priority."). The NULL stream or [CU_STREAM_LEGACY](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ga53e8210837f039dd6434a3a4c3324aa>) or [CU_STREAM_PER_THREAD](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g02e40b82600f62c42ed29abb150f857c>) cannot be used.

The total number of blocks launched per kernel cannot exceed the maximum number of blocks per multiprocessor as returned by [cuOccupancyMaxActiveBlocksPerMultiprocessor](<group__CUDA__OCCUPANCY.html#group__CUDA__OCCUPANCY_1gcc6e1094d05cba2cee17fe33ddd04a98> "Returns occupancy of a function.") (or [cuOccupancyMaxActiveBlocksPerMultiprocessorWithFlags](<group__CUDA__OCCUPANCY.html#group__CUDA__OCCUPANCY_1g8f1da4d4983e5c3025447665423ae2c2> "Returns occupancy of a function.")) times the number of multiprocessors as specified by the device attribute [CU_DEVICE_ATTRIBUTE_MULTIPROCESSOR_COUNT](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gge12b8a782bebe21b1ac0091bf9f4e2a3b92d0a38a94a3f61d4c53e00114afcaa>). Since the total number of blocks launched per device has to match across all devices, the maximum number of blocks that can be launched per device will be limited by the device with the least number of multiprocessors.

The kernels cannot make use of CUDA dynamic parallelism.

The CUDA_LAUNCH_PARAMS structure is defined as:


    â        typedef struct CUDA_LAUNCH_PARAMS_st
                  {
                      [CUfunction](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gba6128b948022f495706d93bc2cea9c8>) function;
                      unsigned int gridDimX;
                      unsigned int gridDimY;
                      unsigned int gridDimZ;
                      unsigned int blockDimX;
                      unsigned int blockDimY;
                      unsigned int blockDimZ;
                      unsigned int sharedMemBytes;
                      [CUstream](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gb946c7f02e09efd788a204718015d88a>) hStream;
                      void **kernelParams;
                  } [CUDA_LAUNCH_PARAMS](<structCUDA__LAUNCH__PARAMS__v1.html#structCUDA__LAUNCH__PARAMS__v1>);

where:

  * [CUDA_LAUNCH_PARAMS::function](<structCUDA__LAUNCH__PARAMS__v1.html#structCUDA__LAUNCH__PARAMS__v1_1ad25005328ba7debf0f5bd2d39a5363c>) specifies the kernel to be launched. All functions must be identical with respect to the compiled code. Note that you can also specify context-less kernel [CUkernel](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g612028921e5736db673e4307589989ed>) by querying the handle using [cuLibraryGetKernel()](<group__CUDA__LIBRARY.html#group__CUDA__LIBRARY_1g15336d865f5abd63e3dc6004d5bc037a> "Returns a kernel handle.") and then casting to [CUfunction](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gba6128b948022f495706d93bc2cea9c8>). In this case, the context to launch the kernel on be taken from the specified stream [CUDA_LAUNCH_PARAMS::hStream](<structCUDA__LAUNCH__PARAMS__v1.html#structCUDA__LAUNCH__PARAMS__v1_1d7b7a742ef397fe918c18bf1f5e63576>).

  * [CUDA_LAUNCH_PARAMS::gridDimX](<structCUDA__LAUNCH__PARAMS__v1.html#structCUDA__LAUNCH__PARAMS__v1_14328c3a1123bed3c08894d66ae9f0e8f>) is the width of the grid in blocks. This must match across all kernels launched.

  * [CUDA_LAUNCH_PARAMS::gridDimY](<structCUDA__LAUNCH__PARAMS__v1.html#structCUDA__LAUNCH__PARAMS__v1_175e5d98e55ad9c877acf3511f9e4c6bc>) is the height of the grid in blocks. This must match across all kernels launched.

  * [CUDA_LAUNCH_PARAMS::gridDimZ](<structCUDA__LAUNCH__PARAMS__v1.html#structCUDA__LAUNCH__PARAMS__v1_16e34c343c3dc355e93f3c47d5c3e3fbe>) is the depth of the grid in blocks. This must match across all kernels launched.

  * [CUDA_LAUNCH_PARAMS::blockDimX](<structCUDA__LAUNCH__PARAMS__v1.html#structCUDA__LAUNCH__PARAMS__v1_1a31d64be7210f4f21404e89ed3c8bc09>) is the X dimension of each thread block. This must match across all kernels launched.

  * [CUDA_LAUNCH_PARAMS::blockDimX](<structCUDA__LAUNCH__PARAMS__v1.html#structCUDA__LAUNCH__PARAMS__v1_1a31d64be7210f4f21404e89ed3c8bc09>) is the Y dimension of each thread block. This must match across all kernels launched.

  * [CUDA_LAUNCH_PARAMS::blockDimZ](<structCUDA__LAUNCH__PARAMS__v1.html#structCUDA__LAUNCH__PARAMS__v1_1e35cc15ae81f10e20fc4c91dbc7356ea>) is the Z dimension of each thread block. This must match across all kernels launched.

  * [CUDA_LAUNCH_PARAMS::sharedMemBytes](<structCUDA__LAUNCH__PARAMS__v1.html#structCUDA__LAUNCH__PARAMS__v1_113811a872234e77c9903dd977f7c7ac3>) is the dynamic shared-memory size per thread block in bytes. This must match across all kernels launched.

  * [CUDA_LAUNCH_PARAMS::hStream](<structCUDA__LAUNCH__PARAMS__v1.html#structCUDA__LAUNCH__PARAMS__v1_1d7b7a742ef397fe918c18bf1f5e63576>) is the handle to the stream to perform the launch in. This cannot be the NULL stream or [CU_STREAM_LEGACY](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ga53e8210837f039dd6434a3a4c3324aa>) or [CU_STREAM_PER_THREAD](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g02e40b82600f62c42ed29abb150f857c>). The CUDA context associated with this stream must match that associated with [CUDA_LAUNCH_PARAMS::function](<structCUDA__LAUNCH__PARAMS__v1.html#structCUDA__LAUNCH__PARAMS__v1_1ad25005328ba7debf0f5bd2d39a5363c>).

  * [CUDA_LAUNCH_PARAMS::kernelParams](<structCUDA__LAUNCH__PARAMS__v1.html#structCUDA__LAUNCH__PARAMS__v1_16788671fda12351d95398142aa4c3bcd>) is an array of pointers to kernel parameters. If [CUDA_LAUNCH_PARAMS::function](<structCUDA__LAUNCH__PARAMS__v1.html#structCUDA__LAUNCH__PARAMS__v1_1ad25005328ba7debf0f5bd2d39a5363c>) has N parameters, then [CUDA_LAUNCH_PARAMS::kernelParams](<structCUDA__LAUNCH__PARAMS__v1.html#structCUDA__LAUNCH__PARAMS__v1_16788671fda12351d95398142aa4c3bcd>) needs to be an array of N pointers. Each of [CUDA_LAUNCH_PARAMS::kernelParams](<structCUDA__LAUNCH__PARAMS__v1.html#structCUDA__LAUNCH__PARAMS__v1_16788671fda12351d95398142aa4c3bcd>)[0] through [CUDA_LAUNCH_PARAMS::kernelParams](<structCUDA__LAUNCH__PARAMS__v1.html#structCUDA__LAUNCH__PARAMS__v1_16788671fda12351d95398142aa4c3bcd>)[N-1] must point to a region of memory from which the actual kernel parameter will be copied. The number of kernel parameters and their offsets and sizes do not need to be specified as that information is retrieved directly from the kernel's image.


By default, the kernel won't begin execution on any GPU until all prior work in all the specified streams has completed. This behavior can be overridden by specifying the flag [CUDA_COOPERATIVE_LAUNCH_MULTI_DEVICE_NO_PRE_LAUNCH_SYNC](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g14fbb447864d154bdd6d82a7af51c5ab>). When this flag is specified, each kernel will only wait for prior work in the stream corresponding to that GPU to complete before it begins execution.

Similarly, by default, any subsequent work pushed in any of the specified streams will not begin execution until the kernels on all GPUs have completed. This behavior can be overridden by specifying the flag [CUDA_COOPERATIVE_LAUNCH_MULTI_DEVICE_NO_POST_LAUNCH_SYNC](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gb46080444b8784713763d4d0dc4e1c90>). When this flag is specified, any subsequent work pushed in any of the specified streams will only wait for the kernel launched on the GPU corresponding to that stream to complete before it begins execution.

Calling [cuLaunchCooperativeKernelMultiDevice()](<group__CUDA__EXEC.html#group__CUDA__EXEC_1g1d34025bc4f8fcec82fbcfc18d07a6e2> "Launches CUDA functions on multiple devices where thread blocks can cooperate and synchronize as they execute.") sets persistent function state that is the same as function state set through [cuLaunchKernel](<group__CUDA__EXEC.html#group__CUDA__EXEC_1gb8f3dc3031b40da29d5f9a7139e52e15> "Launches a CUDA function CUfunction or a CUDA kernel CUkernel.") API when called individually for each element in `launchParamsList`.

When kernels are launched via [cuLaunchCooperativeKernelMultiDevice()](<group__CUDA__EXEC.html#group__CUDA__EXEC_1g1d34025bc4f8fcec82fbcfc18d07a6e2> "Launches CUDA functions on multiple devices where thread blocks can cooperate and synchronize as they execute."), the previous block shape, shared size and parameter info associated with each [CUDA_LAUNCH_PARAMS::function](<structCUDA__LAUNCH__PARAMS__v1.html#structCUDA__LAUNCH__PARAMS__v1_1ad25005328ba7debf0f5bd2d39a5363c>) in `launchParamsList` is overwritten.

Note that to use [cuLaunchCooperativeKernelMultiDevice()](<group__CUDA__EXEC.html#group__CUDA__EXEC_1g1d34025bc4f8fcec82fbcfc18d07a6e2> "Launches CUDA functions on multiple devices where thread blocks can cooperate and synchronize as they execute."), the kernels must either have been compiled with toolchain version 3.2 or later so that it will contain kernel parameter information, or have no kernel parameters. If either of these conditions is not met, then [cuLaunchCooperativeKernelMultiDevice()](<group__CUDA__EXEC.html#group__CUDA__EXEC_1g1d34025bc4f8fcec82fbcfc18d07a6e2> "Launches CUDA functions on multiple devices where thread blocks can cooperate and synchronize as they execute.") will return [CUDA_ERROR_INVALID_IMAGE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e90b7bd1dd2fb3491c588ce569c02d1a2f>).

Note:

  * This function uses standard [default stream](<stream-sync-behavior.html#stream-sync-behavior__default-stream>) semantics.

  * Note that this function may also return error codes from previous, asynchronous launches.


**See also:**

[cuCtxGetCacheConfig](<group__CUDA__CTX.html#group__CUDA__CTX_1g40b6b141698f76744dea6e39b9a25360> "Returns the preferred cache configuration for the current context."), [cuCtxSetCacheConfig](<group__CUDA__CTX.html#group__CUDA__CTX_1g54699acf7e2ef27279d013ca2095f4a3> "Sets the preferred cache configuration for the current context."), [cuFuncSetCacheConfig](<group__CUDA__EXEC.html#group__CUDA__EXEC_1g40f8c11e81def95dc0072a375f965681> "Sets the preferred cache configuration for a device function."), [cuFuncGetAttribute](<group__CUDA__EXEC.html#group__CUDA__EXEC_1g5e92a1b0d8d1b82cb00dcfb2de15961b> "Returns information about a function."), [cuLaunchCooperativeKernel](<group__CUDA__EXEC.html#group__CUDA__EXEC_1g06d753134145c4584c0c62525c1894cb> "Launches a CUDA function CUfunction or a CUDA kernel CUkernel where thread blocks can cooperate and synchronize as they execute."), cudaLaunchCooperativeKernelMultiDevice

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuLaunchHostFunc ( [CUstream](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gb946c7f02e09efd788a204718015d88a>)Â hStream, [CUhostFn](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g262cd3570ff5d396db4e3dabede3c355>)Â fn, void*Â userData )


Enqueues a host function call in a stream.

######  Parameters

`hStream`
    \- Stream to enqueue function call in
`fn`
    \- The function to call once preceding stream operations are complete
`userData`
    \- User-specified data to be passed to the function

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_DEINITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9acf52f132faf29b473cdda6061f0f44a>), [CUDA_ERROR_NOT_INITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e98feb999f0af99b4a25ab26b3866f4df8>), [CUDA_ERROR_INVALID_CONTEXT](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a484e9af32c1e9893ff21f0e0191a12d>), [CUDA_ERROR_INVALID_HANDLE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e90fd2e63260c6317ba943af0f7e4b8d21>), [CUDA_ERROR_NOT_SUPPORTED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e954756ae7ade0dfd09faeccb513dd831b>)

###### Description

Enqueues a host function to run in a stream. The function will be called after currently enqueued work and will block work added after it.

The host function must not make any CUDA API calls. Attempting to use a CUDA API may result in [CUDA_ERROR_NOT_PERMITTED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9e23d0197c490ec332a43e55b167968a3>), but this is not required. The host function must not perform any synchronization that may depend on outstanding CUDA work not mandated to run earlier. Host functions without a mandated order (such as in independent streams) execute in undefined order and may be serialized.

For the purposes of Unified Memory, execution makes a number of guarantees:

  * The stream is considered idle for the duration of the function's execution. Thus, for example, the function may always use memory attached to the stream it was enqueued in.

  * The start of execution of the function has the same effect as synchronizing an event recorded in the same stream immediately prior to the function. It thus synchronizes streams which have been "joined" prior to the function.

  * Adding device work to any stream does not have the effect of making the stream active until all preceding host functions and stream callbacks have executed. Thus, for example, a function might use global attached memory even if work has been added to another stream, if the work has been ordered behind the function call with an event.

  * Completion of the function does not cause a stream to become active except as described above. The stream will remain idle if no device work follows the function, and will remain idle across consecutive host functions or stream callbacks without device work in between. Thus, for example, stream synchronization can be done by signaling from a host function at the end of the stream.


Note that, in contrast to [cuStreamAddCallback](<group__CUDA__STREAM.html#group__CUDA__STREAM_1g613d97a277d7640f4cb1c03bd51c2483> "Add a callback to a compute stream."), the function will not be called in the event of an error in the CUDA context.

Note:

  * This function uses standard [default stream](<stream-sync-behavior.html#stream-sync-behavior__default-stream>) semantics.

  * Note that this function may also return error codes from previous, asynchronous launches.


**See also:**

[cuStreamCreate](<group__CUDA__STREAM.html#group__CUDA__STREAM_1ga581f0c5833e21ded8b5a56594e243f4> "Create a stream."), [cuStreamQuery](<group__CUDA__STREAM.html#group__CUDA__STREAM_1g1b0d24bbe97fa68e4bc511fb6adfeb0b> "Determine status of a compute stream."), [cuStreamSynchronize](<group__CUDA__STREAM.html#group__CUDA__STREAM_1g15e49dd91ec15991eb7c0a741beb7dad> "Wait until a stream's tasks are completed."), [cuStreamWaitEvent](<group__CUDA__STREAM.html#group__CUDA__STREAM_1g6a898b652dfc6aa1d5c8d97062618b2f> "Make a compute stream wait on an event."), [cuStreamDestroy](<group__CUDA__STREAM.html#group__CUDA__STREAM_1g244c8833de4596bcd31a06cdf21ee758> "Destroys a stream."), [cuMemAllocManaged](<group__CUDA__MEM.html#group__CUDA__MEM_1gb347ded34dc326af404aa02af5388a32> "Allocates memory that will be automatically managed by the Unified Memory system."), [cuStreamAttachMemAsync](<group__CUDA__STREAM.html#group__CUDA__STREAM_1g6e468d680e263e7eba02a56643c50533> "Attach memory to a stream asynchronously."), [cuStreamAddCallback](<group__CUDA__STREAM.html#group__CUDA__STREAM_1g613d97a277d7640f4cb1c03bd51c2483> "Add a callback to a compute stream.")

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuLaunchKernel ( [CUfunction](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gba6128b948022f495706d93bc2cea9c8>)Â f, unsigned int Â gridDimX, unsigned int Â gridDimY, unsigned int Â gridDimZ, unsigned int Â blockDimX, unsigned int Â blockDimY, unsigned int Â blockDimZ, unsigned int Â sharedMemBytes, [CUstream](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gb946c7f02e09efd788a204718015d88a>)Â hStream, void**Â kernelParams, void**Â extra )


Launches a CUDA function CUfunction or a CUDA kernel CUkernel.

######  Parameters

`f`
    \- Function [CUfunction](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gba6128b948022f495706d93bc2cea9c8>) or Kernel [CUkernel](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g612028921e5736db673e4307589989ed>) to launch
`gridDimX`
    \- Width of grid in blocks
`gridDimY`
    \- Height of grid in blocks
`gridDimZ`
    \- Depth of grid in blocks
`blockDimX`
    \- X dimension of each thread block
`blockDimY`
    \- Y dimension of each thread block
`blockDimZ`
    \- Z dimension of each thread block
`sharedMemBytes`
    \- Dynamic shared-memory size per thread block in bytes
`hStream`
    \- Stream identifier
`kernelParams`
    \- Array of pointers to kernel parameters
`extra`
    \- Extra options

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_DEINITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9acf52f132faf29b473cdda6061f0f44a>), [CUDA_ERROR_NOT_INITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e98feb999f0af99b4a25ab26b3866f4df8>), [CUDA_ERROR_INVALID_CONTEXT](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a484e9af32c1e9893ff21f0e0191a12d>), [CUDA_ERROR_INVALID_HANDLE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e90fd2e63260c6317ba943af0f7e4b8d21>), [CUDA_ERROR_INVALID_IMAGE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e90b7bd1dd2fb3491c588ce569c02d1a2f>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>), [CUDA_ERROR_LAUNCH_FAILED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e94f270bc1011b152febc8154b2b1e1b8d>), [CUDA_ERROR_LAUNCH_OUT_OF_RESOURCES](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9b5da09cc5697599a56a71a04184ffdaa>), [CUDA_ERROR_LAUNCH_TIMEOUT](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e965460d83f63575af9805ca59f8f19d74>), [CUDA_ERROR_LAUNCH_INCOMPATIBLE_TEXTURING](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e99e36a98a3a2c5123d422b9a1b69dd5f6>), [CUDA_ERROR_SHARED_OBJECT_INIT_FAILED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9d8a149ebc98aa90f6417e531fa645043>), [CUDA_ERROR_NOT_FOUND](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9af1cadbeb21d3a78115ca211ba44c053>)

###### Description

Invokes the function [CUfunction](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gba6128b948022f495706d93bc2cea9c8>) or the kernel [CUkernel](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g612028921e5736db673e4307589989ed>)`f` on a `gridDimX` x `gridDimY` x `gridDimZ` grid of blocks. Each block contains `blockDimX` x `blockDimY` x `blockDimZ` threads.

`sharedMemBytes` sets the amount of dynamic shared memory that will be available to each thread block.

Kernel parameters to `f` can be specified in one of two ways:

1) Kernel parameters can be specified via `kernelParams`. If `f` has N parameters, then `kernelParams` needs to be an array of N pointers. Each of `kernelParams`[0] through `kernelParams`[N-1] must point to a region of memory from which the actual kernel parameter will be copied. The number of kernel parameters and their offsets and sizes do not need to be specified as that information is retrieved directly from the kernel's image.

2) Kernel parameters can also be packaged by the application into a single buffer that is passed in via the `extra` parameter. This places the burden on the application of knowing each kernel parameter's size and alignment/padding within the buffer. Here is an example of using the `extra` parameter in this manner:


    â    size_t argBufferSize;
              char argBuffer[256];

              // populate argBuffer and argBufferSize

              void *config[] = {
                  [CU_LAUNCH_PARAM_BUFFER_POINTER](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g36d10d0b40c51372877578a2cffd6acd>), argBuffer,
                  [CU_LAUNCH_PARAM_BUFFER_SIZE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gf339c057cd94562ead93a192e11c17e9>),    &argBufferSize,
                  [CU_LAUNCH_PARAM_END](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gd5c11cff5adfa5a69d66829399653532>)
              };
              status = [cuLaunchKernel](<group__CUDA__EXEC.html#group__CUDA__EXEC_1gb8f3dc3031b40da29d5f9a7139e52e15> "Launches a CUDA function CUfunction or a CUDA kernel CUkernel.")(f, gx, gy, gz, bx, by, bz, sh, s, NULL, config);

The `extra` parameter exists to allow [cuLaunchKernel](<group__CUDA__EXEC.html#group__CUDA__EXEC_1gb8f3dc3031b40da29d5f9a7139e52e15> "Launches a CUDA function CUfunction or a CUDA kernel CUkernel.") to take additional less commonly used arguments. `extra` specifies a list of names of extra settings and their corresponding values. Each extra setting name is immediately followed by the corresponding value. The list must be terminated with either NULL or [CU_LAUNCH_PARAM_END](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gd5c11cff5adfa5a69d66829399653532>).

  * [CU_LAUNCH_PARAM_END](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gd5c11cff5adfa5a69d66829399653532>), which indicates the end of the `extra` array;

  * [CU_LAUNCH_PARAM_BUFFER_POINTER](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g36d10d0b40c51372877578a2cffd6acd>), which specifies that the next value in `extra` will be a pointer to a buffer containing all the kernel parameters for launching kernel `f`;

  * [CU_LAUNCH_PARAM_BUFFER_SIZE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gf339c057cd94562ead93a192e11c17e9>), which specifies that the next value in `extra` will be a pointer to a size_t containing the size of the buffer specified with [CU_LAUNCH_PARAM_BUFFER_POINTER](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g36d10d0b40c51372877578a2cffd6acd>);


The error [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>) will be returned if kernel parameters are specified with both `kernelParams` and `extra` (i.e. both `kernelParams` and `extra` are non-NULL).

Calling [cuLaunchKernel()](<group__CUDA__EXEC.html#group__CUDA__EXEC_1gb8f3dc3031b40da29d5f9a7139e52e15> "Launches a CUDA function CUfunction or a CUDA kernel CUkernel.") invalidates the persistent function state set through the following deprecated APIs: [cuFuncSetBlockShape()](<group__CUDA__EXEC__DEPRECATED.html#group__CUDA__EXEC__DEPRECATED_1gd98ab7e00740f68145972deb6ddab271> "Sets the block-dimensions for the function."), [cuFuncSetSharedSize()](<group__CUDA__EXEC__DEPRECATED.html#group__CUDA__EXEC__DEPRECATED_1g9b5a3f121142f7b42aea48366c72bf8b> "Sets the dynamic shared-memory size for the function."), [cuParamSetSize()](<group__CUDA__EXEC__DEPRECATED.html#group__CUDA__EXEC__DEPRECATED_1gf6896c37762d695f5d161ee56cf86e62> "Sets the parameter size for the function."), [cuParamSeti()](<group__CUDA__EXEC__DEPRECATED.html#group__CUDA__EXEC__DEPRECATED_1g07f1264a68f97f582353b0f5dd9ebd5c> "Adds an integer parameter to the function's argument list."), [cuParamSetf()](<group__CUDA__EXEC__DEPRECATED.html#group__CUDA__EXEC__DEPRECATED_1gd5e7679999e3792203d477abad2958c5> "Adds a floating-point parameter to the function's argument list."), [cuParamSetv()](<group__CUDA__EXEC__DEPRECATED.html#group__CUDA__EXEC__DEPRECATED_1g24e5ceee66d1a84609b74e77672638b6> "Adds arbitrary data to the function's argument list.").

Note that to use [cuLaunchKernel()](<group__CUDA__EXEC.html#group__CUDA__EXEC_1gb8f3dc3031b40da29d5f9a7139e52e15> "Launches a CUDA function CUfunction or a CUDA kernel CUkernel."), the kernel `f` must either have been compiled with toolchain version 3.2 or later so that it will contain kernel parameter information, or have no kernel parameters. If either of these conditions is not met, then [cuLaunchKernel()](<group__CUDA__EXEC.html#group__CUDA__EXEC_1gb8f3dc3031b40da29d5f9a7139e52e15> "Launches a CUDA function CUfunction or a CUDA kernel CUkernel.") will return [CUDA_ERROR_INVALID_IMAGE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e90b7bd1dd2fb3491c588ce569c02d1a2f>).

Note that the API can also be used to launch context-less kernel [CUkernel](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g612028921e5736db673e4307589989ed>) by querying the handle using [cuLibraryGetKernel()](<group__CUDA__LIBRARY.html#group__CUDA__LIBRARY_1g15336d865f5abd63e3dc6004d5bc037a> "Returns a kernel handle.") and then passing it to the API by casting to [CUfunction](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gba6128b948022f495706d93bc2cea9c8>). Here, the context to launch the kernel on will either be taken from the specified stream `hStream` or the current context in case of NULL stream.

Note:

  * This function uses standard [default stream](<stream-sync-behavior.html#stream-sync-behavior__default-stream>) semantics.

  * Note that this function may also return error codes from previous, asynchronous launches.


**See also:**

[cuCtxGetCacheConfig](<group__CUDA__CTX.html#group__CUDA__CTX_1g40b6b141698f76744dea6e39b9a25360> "Returns the preferred cache configuration for the current context."), [cuCtxSetCacheConfig](<group__CUDA__CTX.html#group__CUDA__CTX_1g54699acf7e2ef27279d013ca2095f4a3> "Sets the preferred cache configuration for the current context."), [cuFuncSetCacheConfig](<group__CUDA__EXEC.html#group__CUDA__EXEC_1g40f8c11e81def95dc0072a375f965681> "Sets the preferred cache configuration for a device function."), [cuFuncGetAttribute](<group__CUDA__EXEC.html#group__CUDA__EXEC_1g5e92a1b0d8d1b82cb00dcfb2de15961b> "Returns information about a function."), [cudaLaunchKernel](<../cuda-runtime-api/group__CUDART__HIGHLEVEL.html#group__CUDART__HIGHLEVEL_1g2c91bfe5e072fcd28de6606dd43cd64b>), [cuLibraryGetKernel](<group__CUDA__LIBRARY.html#group__CUDA__LIBRARY_1g15336d865f5abd63e3dc6004d5bc037a> "Returns a kernel handle."), [cuKernelSetCacheConfig](<group__CUDA__LIBRARY.html#group__CUDA__LIBRARY_1g8490476e5d3573c7ede78f29bd8cde51> "Sets the preferred cache configuration for a device kernel."), [cuKernelGetAttribute](<group__CUDA__LIBRARY.html#group__CUDA__LIBRARY_1gd98317cb151b99fbd95767418122071f> "Returns information about a kernel."), [cuKernelSetAttribute](<group__CUDA__LIBRARY.html#group__CUDA__LIBRARY_1g1093ade718915249de3b14320d567067> "Sets information about a kernel.")

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuLaunchKernelEx ( const [CUlaunchConfig](<structCUlaunchConfig.html#structCUlaunchConfig>)*Â config, [CUfunction](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gba6128b948022f495706d93bc2cea9c8>)Â f, void**Â kernelParams, void**Â extra )


Launches a CUDA function CUfunction or a CUDA kernel CUkernel with launch-time configuration.

######  Parameters

`config`
    \- Config to launch
`f`
    \- Function [CUfunction](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gba6128b948022f495706d93bc2cea9c8>) or Kernel [CUkernel](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g612028921e5736db673e4307589989ed>) to launch
`kernelParams`
    \- Array of pointers to kernel parameters
`extra`
    \- Extra options

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_DEINITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9acf52f132faf29b473cdda6061f0f44a>), [CUDA_ERROR_NOT_INITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e98feb999f0af99b4a25ab26b3866f4df8>), [CUDA_ERROR_INVALID_CONTEXT](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a484e9af32c1e9893ff21f0e0191a12d>), [CUDA_ERROR_INVALID_HANDLE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e90fd2e63260c6317ba943af0f7e4b8d21>), [CUDA_ERROR_INVALID_IMAGE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e90b7bd1dd2fb3491c588ce569c02d1a2f>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>), [CUDA_ERROR_LAUNCH_FAILED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e94f270bc1011b152febc8154b2b1e1b8d>), [CUDA_ERROR_LAUNCH_OUT_OF_RESOURCES](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9b5da09cc5697599a56a71a04184ffdaa>), [CUDA_ERROR_LAUNCH_TIMEOUT](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e965460d83f63575af9805ca59f8f19d74>), [CUDA_ERROR_LAUNCH_INCOMPATIBLE_TEXTURING](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e99e36a98a3a2c5123d422b9a1b69dd5f6>), [CUDA_ERROR_COOPERATIVE_LAUNCH_TOO_LARGE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9d26f67e0acc1563f87ddb94c638478cd>), [CUDA_ERROR_SHARED_OBJECT_INIT_FAILED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9d8a149ebc98aa90f6417e531fa645043>), [CUDA_ERROR_NOT_FOUND](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9af1cadbeb21d3a78115ca211ba44c053>)

###### Description

Invokes the function [CUfunction](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gba6128b948022f495706d93bc2cea9c8>) or the kernel [CUkernel](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g612028921e5736db673e4307589989ed>)`f` with the specified launch-time configuration `config`.

The [CUlaunchConfig](<structCUlaunchConfig.html#structCUlaunchConfig>) structure is defined as:


    â       typedef struct CUlaunchConfig_st {
               unsigned int gridDimX;
               unsigned int gridDimY;
               unsigned int gridDimZ;
               unsigned int blockDimX;
               unsigned int blockDimY;
               unsigned int blockDimZ;
               unsigned int sharedMemBytes;
               [CUstream](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gb946c7f02e09efd788a204718015d88a>) hStream;
               [CUlaunchAttribute](<structCUlaunchAttribute.html#structCUlaunchAttribute>) *attrs;
               unsigned int numAttrs;
           } [CUlaunchConfig](<structCUlaunchConfig.html#structCUlaunchConfig>);

where:

  * [CUlaunchConfig::gridDimX](<structCUlaunchConfig.html#structCUlaunchConfig_1689d9cc16fd423b080ec828b5bc9d885>) is the width of the grid in blocks.

  * [CUlaunchConfig::gridDimY](<structCUlaunchConfig.html#structCUlaunchConfig_18c2c6a003a635f55703d3e00873c1a04>) is the height of the grid in blocks.

  * [CUlaunchConfig::gridDimZ](<structCUlaunchConfig.html#structCUlaunchConfig_12ee1e4c17d2976638d5c1def7aab2173>) is the depth of the grid in blocks.

  * [CUlaunchConfig::blockDimX](<structCUlaunchConfig.html#structCUlaunchConfig_1c6348b2aec5d4cbe883351f0a4ca2404>) is the X dimension of each thread block.

  * [CUlaunchConfig::blockDimX](<structCUlaunchConfig.html#structCUlaunchConfig_1c6348b2aec5d4cbe883351f0a4ca2404>) is the Y dimension of each thread block.

  * [CUlaunchConfig::blockDimZ](<structCUlaunchConfig.html#structCUlaunchConfig_114969c04364799742f22a4eb97501f75>) is the Z dimension of each thread block.

  * [CUlaunchConfig::sharedMemBytes](<structCUlaunchConfig.html#structCUlaunchConfig_139281cdd7b80edb790b0fa85b2bca38f>) is the dynamic shared-memory size per thread block in bytes.

  * [CUlaunchConfig::hStream](<structCUlaunchConfig.html#structCUlaunchConfig_18bbdd01ea0d4d380fad9e8be14fb928b>) is the handle to the stream to perform the launch in. The CUDA context associated with this stream must match that associated with function f.

  * [CUlaunchConfig::attrs](<structCUlaunchConfig.html#structCUlaunchConfig_189bd86e2a9d67c421d5ad9650e57f375>) is an array of [CUlaunchConfig::numAttrs](<structCUlaunchConfig.html#structCUlaunchConfig_1c64a4dd37ff79255de128a5868658e06>) continguous [CUlaunchAttribute](<structCUlaunchAttribute.html#structCUlaunchAttribute>) elements. The value of this pointer is not considered if [CUlaunchConfig::numAttrs](<structCUlaunchConfig.html#structCUlaunchConfig_1c64a4dd37ff79255de128a5868658e06>) is zero. However, in that case, it is recommended to set the pointer to NULL.

  * [CUlaunchConfig::numAttrs](<structCUlaunchConfig.html#structCUlaunchConfig_1c64a4dd37ff79255de128a5868658e06>) is the number of attributes populating the first [CUlaunchConfig::numAttrs](<structCUlaunchConfig.html#structCUlaunchConfig_1c64a4dd37ff79255de128a5868658e06>) positions of the [CUlaunchConfig::attrs](<structCUlaunchConfig.html#structCUlaunchConfig_189bd86e2a9d67c421d5ad9650e57f375>) array.


Launch-time configuration is specified by adding entries to [CUlaunchConfig::attrs](<structCUlaunchConfig.html#structCUlaunchConfig_189bd86e2a9d67c421d5ad9650e57f375>). Each entry is an attribute ID and a corresponding attribute value.

The [CUlaunchAttribute](<structCUlaunchAttribute.html#structCUlaunchAttribute>) structure is defined as:


    â       typedef struct CUlaunchAttribute_st {
               [CUlaunchAttributeID](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g6f6565b334be6bb3134868e10bbdd331>) id;
               [CUlaunchAttributeValue](<unionCUlaunchAttributeValue.html#unionCUlaunchAttributeValue>) value;
           } [CUlaunchAttribute](<structCUlaunchAttribute.html#structCUlaunchAttribute>);

where:

  * [CUlaunchAttribute::id](<structCUlaunchAttribute.html#structCUlaunchAttribute_132aed095f6c0ffe51ea05d61ee83a5df>) is a unique enum identifying the attribute.

  * [CUlaunchAttribute::value](<structCUlaunchAttribute.html#structCUlaunchAttribute_1924768cf94d6cf1d94691d30e491fc55>) is a union that hold the attribute value.


An example of using the `config` parameter:


    â       [CUlaunchAttribute](<structCUlaunchAttribute.html#structCUlaunchAttribute>) coopAttr = {.id = [CU_LAUNCH_ATTRIBUTE_COOPERATIVE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg6f6565b334be6bb3134868e10bbdd331a2a65a417546d2d54837c1516ceaec4d>),
                                         .value = 1};
           [CUlaunchConfig](<structCUlaunchConfig.html#structCUlaunchConfig>) config = {... // set block and grid dimensions
                                  .attrs = &coopAttr,
                                  .numAttrs = 1};

           [cuLaunchKernelEx](<group__CUDA__EXEC.html#group__CUDA__EXEC_1gb9c891eb6bb8f4089758e64c9c976db9> "Launches a CUDA function CUfunction or a CUDA kernel CUkernel with launch-time configuration.")(&config, kernel, NULL, NULL);

The [CUlaunchAttributeID](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g6f6565b334be6bb3134868e10bbdd331>) enum is defined as:


    â       typedef enum CUlaunchAttributeID_enum {
               [CU_LAUNCH_ATTRIBUTE_IGNORE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg6f6565b334be6bb3134868e10bbdd3313df820dd1fa823081b1923ff294b95b6>) = 0,
               [CU_LAUNCH_ATTRIBUTE_ACCESS_POLICY_WINDOW](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg6f6565b334be6bb3134868e10bbdd3313761deda73b2f2b9da73406c7c4e9553>)   = 1,
               [CU_LAUNCH_ATTRIBUTE_COOPERATIVE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg6f6565b334be6bb3134868e10bbdd331a2a65a417546d2d54837c1516ceaec4d>)            = 2,
               [CU_LAUNCH_ATTRIBUTE_SYNCHRONIZATION_POLICY](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg6f6565b334be6bb3134868e10bbdd331455ddb66a56b148882e3c6f23cd57cf3>) = 3,
               [CU_LAUNCH_ATTRIBUTE_CLUSTER_DIMENSION](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg6f6565b334be6bb3134868e10bbdd331f1a227eb6283f2a292cf5a38cdceb638>)                    = 4,
               [CU_LAUNCH_ATTRIBUTE_CLUSTER_SCHEDULING_POLICY_PREFERENCE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg6f6565b334be6bb3134868e10bbdd331ebd12c41bbb15196ea07644d90b9f55d>) = 5,
               [CU_LAUNCH_ATTRIBUTE_PROGRAMMATIC_STREAM_SERIALIZATION](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg6f6565b334be6bb3134868e10bbdd33116b07ee1531b349fae46df8623a9fd24>)    = 6,
               [CU_LAUNCH_ATTRIBUTE_PROGRAMMATIC_EVENT](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg6f6565b334be6bb3134868e10bbdd3311667102e857f5d37bb4f460c530dfb13>)                   = 7,
               [CU_LAUNCH_ATTRIBUTE_PRIORITY](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg6f6565b334be6bb3134868e10bbdd33176a390a5743b2f72d392a429d413f64f>)               = 8,
               [CU_LAUNCH_ATTRIBUTE_MEM_SYNC_DOMAIN_MAP](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg6f6565b334be6bb3134868e10bbdd331b05f66cedd0038b77034a8c62127a09d>)    = 9,
               [CU_LAUNCH_ATTRIBUTE_MEM_SYNC_DOMAIN](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg6f6565b334be6bb3134868e10bbdd331b57049dbe6c473013088dbc3cbc41139>)        = 10,
               [CU_LAUNCH_ATTRIBUTE_PREFERRED_CLUSTER_DIMENSION](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg6f6565b334be6bb3134868e10bbdd331e0237963b795260b6d24842cdde29f3b>) = 11,
               [CU_LAUNCH_ATTRIBUTE_LAUNCH_COMPLETION_EVENT](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg6f6565b334be6bb3134868e10bbdd33121248c3419121151076d819052270513>) = 12,
               [CU_LAUNCH_ATTRIBUTE_DEVICE_UPDATABLE_KERNEL_NODE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg6f6565b334be6bb3134868e10bbdd331e46e24e30991b52ec5b267e40e093a4b>) = 13,
           } [CUlaunchAttributeID](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g6f6565b334be6bb3134868e10bbdd331>);

and the corresponding [CUlaunchAttributeValue](<unionCUlaunchAttributeValue.html#unionCUlaunchAttributeValue>) union as :


    â       typedef union CUlaunchAttributeValue_union {
               [CUaccessPolicyWindow](<structCUaccessPolicyWindow__v1.html#structCUaccessPolicyWindow__v1>) accessPolicyWindow;
               int cooperative;
               CUsynchronizationPolicy syncPolicy;
               struct {
                   unsigned int x;
                   unsigned int y;
                   unsigned int z;
               } clusterDim;
               [CUclusterSchedulingPolicy](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g2d60fcf51c7e8a70bd27687f19543192>) clusterSchedulingPolicyPreference;
               int programmaticStreamSerializationAllowed;
               struct {
                   [CUevent](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g6d740185cf0953636d4ae37f68d7559b>) event;
                   int flags;
                   int triggerAtBlockStart;
               } programmaticEvent;
               int priority;
               [CUlaunchMemSyncDomainMap](<structCUlaunchMemSyncDomainMap.html#structCUlaunchMemSyncDomainMap>) memSyncDomainMap;
               [CUlaunchMemSyncDomain](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g471f645fa24df354626fe8107358e05f>) memSyncDomain;
               struct {
                   unsigned int x;
                   unsigned int y;
                   unsigned int z;
               } preferredClusterDim;
               struct {
                   [CUevent](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g6d740185cf0953636d4ae37f68d7559b>) event;
                   int flags;
               } launchCompletionEvent;
               struct {
                   int deviceUpdatable;
                   [CUgraphDeviceNode](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g90c635c072ada74bb594cdc06b155b4a>) devNode;
               } deviceUpdatableKernelNode;
           } [CUlaunchAttributeValue](<unionCUlaunchAttributeValue.html#unionCUlaunchAttributeValue>);

Setting [CU_LAUNCH_ATTRIBUTE_COOPERATIVE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg6f6565b334be6bb3134868e10bbdd331a2a65a417546d2d54837c1516ceaec4d>) to a non-zero value causes the kernel launch to be a cooperative launch, with exactly the same usage and semantics of [cuLaunchCooperativeKernel](<group__CUDA__EXEC.html#group__CUDA__EXEC_1g06d753134145c4584c0c62525c1894cb> "Launches a CUDA function CUfunction or a CUDA kernel CUkernel where thread blocks can cooperate and synchronize as they execute.").

Setting [CU_LAUNCH_ATTRIBUTE_PROGRAMMATIC_STREAM_SERIALIZATION](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg6f6565b334be6bb3134868e10bbdd33116b07ee1531b349fae46df8623a9fd24>) to a non-zero values causes the kernel to use programmatic means to resolve its stream dependency -- enabling the CUDA runtime to opportunistically allow the grid's execution to overlap with the previous kernel in the stream, if that kernel requests the overlap.

[CU_LAUNCH_ATTRIBUTE_PROGRAMMATIC_EVENT](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg6f6565b334be6bb3134868e10bbdd3311667102e857f5d37bb4f460c530dfb13>) records an event along with the kernel launch. Event recorded through this launch attribute is guaranteed to only trigger after all block in the associated kernel trigger the event. A block can trigger the event through PTX launchdep.release or CUDA builtin function [cudaTriggerProgrammaticLaunchCompletion()](<../cuda-runtime-api/group__CUDART__EXECUTION.html#group__CUDART__EXECUTION_1ge194af462d927583bed3acf60d450218>). A trigger can also be inserted at the beginning of each block's execution if triggerAtBlockStart is set to non-0. Note that dependents (including the CPU thread calling [cuEventSynchronize()](<group__CUDA__EVENT.html#group__CUDA__EVENT_1g9e520d34e51af7f5375610bca4add99c> "Waits for an event to complete.")) are not guaranteed to observe the release precisely when it is released. For example, [cuEventSynchronize()](<group__CUDA__EVENT.html#group__CUDA__EVENT_1g9e520d34e51af7f5375610bca4add99c> "Waits for an event to complete.") may only observe the event trigger long after the associated kernel has completed. This recording type is primarily meant for establishing programmatic dependency between device tasks. The event supplied must not be an interprocess or interop event. The event must disable timing (i.e. created with [CU_EVENT_DISABLE_TIMING](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg5ae04079c671c8e659a3a27c7b23f629daa5463f64794c10b78c603d23c0bff2>) flag set).

[CU_LAUNCH_ATTRIBUTE_LAUNCH_COMPLETION_EVENT](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg6f6565b334be6bb3134868e10bbdd33121248c3419121151076d819052270513>) records an event along with the kernel launch. Nominally, the event is triggered once all blocks of the kernel have begun execution. Currently this is a best effort. If a kernel B has a launch completion dependency on a kernel A, B may wait until A is complete. Alternatively, blocks of B may begin before all blocks of A have begun, for example:

  * If B can claim execution resources unavailable to A, for example if they run on different GPUs.

  * If B is a higher priority than A.


Exercise caution if such an ordering inversion could lead to deadlock. The event supplied must not be an interprocess or interop event. The event must disable timing (i.e. must be created with the [CU_EVENT_DISABLE_TIMING](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg5ae04079c671c8e659a3a27c7b23f629daa5463f64794c10b78c603d23c0bff2>) flag set).

Setting [CU_LAUNCH_ATTRIBUTE_DEVICE_UPDATABLE_KERNEL_NODE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg6f6565b334be6bb3134868e10bbdd331e46e24e30991b52ec5b267e40e093a4b>) to 1 on a captured launch causes the resulting kernel node to be device-updatable. This attribute is specific to graphs, and passing it to a launch in a non-capturing stream results in an error. Passing a value other than 0 or 1 is not allowed.

On success, a handle will be returned via CUlaunchAttributeValue::deviceUpdatableKernelNode::devNode which can be passed to the various device-side update functions to update the node's kernel parameters from within another kernel. For more information on the types of device updates that can be made, as well as the relevant limitations thereof, see [cudaGraphKernelNodeUpdatesApply](<../cuda-runtime-api/group__CUDART__GRAPH.html#group__CUDART__GRAPH_1g2d558cf37c9616365c67447e61ac0d6a>).

Kernel nodes which are device-updatable have additional restrictions compared to regular kernel nodes. Firstly, device-updatable nodes cannot be removed from their graph via [cuGraphDestroyNode](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1g00ed16434d983d8f0011683eacaf19b9> "Remove a node from the graph."). Additionally, once opted-in to this functionality, a node cannot opt out, and any attempt to set the attribute to 0 will result in an error. Graphs containing one or more device-updatable node also do not allow multiple instantiation.

[CU_LAUNCH_ATTRIBUTE_PREFERRED_CLUSTER_DIMENSION](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg6f6565b334be6bb3134868e10bbdd331e0237963b795260b6d24842cdde29f3b>) allows the kernel launch to specify a preferred substitute cluster dimension. Blocks may be grouped according to either the dimensions specified with this attribute (grouped into a "preferred substitute cluster"), or the one specified with [CU_LAUNCH_ATTRIBUTE_CLUSTER_DIMENSION](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg6f6565b334be6bb3134868e10bbdd331f1a227eb6283f2a292cf5a38cdceb638>) attribute (grouped into a "regular cluster"). The cluster dimensions of a "preferred substitute cluster" shall be an integer multiple greater than zero of the regular cluster dimensions. The device will attempt - on a best-effort basis - to group thread blocks into preferred clusters over grouping them into regular clusters. When it deems necessary (primarily when the device temporarily runs out of physical resources to launch the larger preferred clusters), the device may switch to launch the regular clusters instead to attempt to utilize as much of the physical device resources as possible.

Each type of cluster will have its enumeration / coordinate setup as if the grid consists solely of its type of cluster. For example, if the preferred substitute cluster dimensions double the regular cluster dimensions, there might be simultaneously a regular cluster indexed at (1,0,0), and a preferred cluster indexed at (1,0,0). In this example, the preferred substitute cluster (1,0,0) replaces regular clusters (2,0,0) and (3,0,0) and groups their blocks.

This attribute will only take effect when a regular cluster dimension has been specified. The preferred substitute The preferred substitute cluster dimension must be an integer multiple greater than zero of the regular cluster dimension and must divide the grid. It must also be no more than `maxBlocksPerCluster`, if it is set in the kernel's `__launch_bounds__`. Otherwise it must be less than the maximum value the driver can support. Otherwise, setting this attribute to a value physically unable to fit on any particular device is permitted.

The effect of other attributes is consistent with their effect when set via persistent APIs.

See [cuStreamSetAttribute](<group__CUDA__STREAM.html#group__CUDA__STREAM_1ga2c5fc0292861a42f264af6ca48be8c0> "Sets stream attribute.") for

  * [CU_LAUNCH_ATTRIBUTE_ACCESS_POLICY_WINDOW](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg6f6565b334be6bb3134868e10bbdd3313761deda73b2f2b9da73406c7c4e9553>)

  * [CU_LAUNCH_ATTRIBUTE_SYNCHRONIZATION_POLICY](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg6f6565b334be6bb3134868e10bbdd331455ddb66a56b148882e3c6f23cd57cf3>)


See [cuFuncSetAttribute](<group__CUDA__EXEC.html#group__CUDA__EXEC_1g0e37dce0173bc883aa1e5b14dd747f26> "Sets information about a function.") for

  * [CU_LAUNCH_ATTRIBUTE_CLUSTER_DIMENSION](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg6f6565b334be6bb3134868e10bbdd331f1a227eb6283f2a292cf5a38cdceb638>)

  * [CU_LAUNCH_ATTRIBUTE_CLUSTER_SCHEDULING_POLICY_PREFERENCE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg6f6565b334be6bb3134868e10bbdd331ebd12c41bbb15196ea07644d90b9f55d>)


Kernel parameters to `f` can be specified in the same ways that they can be using [cuLaunchKernel](<group__CUDA__EXEC.html#group__CUDA__EXEC_1gb8f3dc3031b40da29d5f9a7139e52e15> "Launches a CUDA function CUfunction or a CUDA kernel CUkernel.").

Note that the API can also be used to launch context-less kernel [CUkernel](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g612028921e5736db673e4307589989ed>) by querying the handle using [cuLibraryGetKernel()](<group__CUDA__LIBRARY.html#group__CUDA__LIBRARY_1g15336d865f5abd63e3dc6004d5bc037a> "Returns a kernel handle.") and then passing it to the API by casting to [CUfunction](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gba6128b948022f495706d93bc2cea9c8>). Here, the context to launch the kernel on will either be taken from the specified stream [CUlaunchConfig::hStream](<structCUlaunchConfig.html#structCUlaunchConfig_18bbdd01ea0d4d380fad9e8be14fb928b>) or the current context in case of NULL stream.

Note:

  * This function uses standard [default stream](<stream-sync-behavior.html#stream-sync-behavior__default-stream>) semantics.

  * Note that this function may also return error codes from previous, asynchronous launches.


**See also:**

[cuCtxGetCacheConfig](<group__CUDA__CTX.html#group__CUDA__CTX_1g40b6b141698f76744dea6e39b9a25360> "Returns the preferred cache configuration for the current context."), [cuCtxSetCacheConfig](<group__CUDA__CTX.html#group__CUDA__CTX_1g54699acf7e2ef27279d013ca2095f4a3> "Sets the preferred cache configuration for the current context."), [cuFuncSetCacheConfig](<group__CUDA__EXEC.html#group__CUDA__EXEC_1g40f8c11e81def95dc0072a375f965681> "Sets the preferred cache configuration for a device function."), [cuFuncGetAttribute](<group__CUDA__EXEC.html#group__CUDA__EXEC_1g5e92a1b0d8d1b82cb00dcfb2de15961b> "Returns information about a function."), [cudaLaunchKernel](<../cuda-runtime-api/group__CUDART__HIGHLEVEL.html#group__CUDART__HIGHLEVEL_1g2c91bfe5e072fcd28de6606dd43cd64b>), [cudaLaunchKernelEx](<../cuda-runtime-api/group__CUDART__HIGHLEVEL.html#group__CUDART__HIGHLEVEL_1g98d60efe48c3400a1c17a1edb698e530>), [cuLibraryGetKernel](<group__CUDA__LIBRARY.html#group__CUDA__LIBRARY_1g15336d865f5abd63e3dc6004d5bc037a> "Returns a kernel handle."), [cuKernelSetCacheConfig](<group__CUDA__LIBRARY.html#group__CUDA__LIBRARY_1g8490476e5d3573c7ede78f29bd8cde51> "Sets the preferred cache configuration for a device kernel."), [cuKernelGetAttribute](<group__CUDA__LIBRARY.html#group__CUDA__LIBRARY_1gd98317cb151b99fbd95767418122071f> "Returns information about a kernel."), [cuKernelSetAttribute](<group__CUDA__LIBRARY.html#group__CUDA__LIBRARY_1g1093ade718915249de3b14320d567067> "Sets information about a kernel.")

* * *


---

# Execution Control (Deprecated)

## 6.23.Â Execution Control [DEPRECATED]

This section describes the deprecated execution control functions of the low-level CUDA driver application programming interface.

### Functions

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuFuncSetBlockShape](<#group__CUDA__EXEC__DEPRECATED_1gd98ab7e00740f68145972deb6ddab271>) ( [CUfunction](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gba6128b948022f495706d93bc2cea9c8>)Â hfunc, int Â x, int Â y, int Â z )
     Sets the block-dimensions for the function.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuFuncSetSharedMemConfig](<#group__CUDA__EXEC__DEPRECATED_1g3fe2417a78a7b5554a694c40355b54ce>) ( [CUfunction](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gba6128b948022f495706d93bc2cea9c8>)Â hfunc, [CUsharedconfig](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g92d66e95f602cb9fdaf0682c260c241b>)Â config )
     Sets the shared memory configuration for a device function.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuFuncSetSharedSize](<#group__CUDA__EXEC__DEPRECATED_1g9b5a3f121142f7b42aea48366c72bf8b>) ( [CUfunction](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gba6128b948022f495706d93bc2cea9c8>)Â hfunc, unsigned int Â bytes )
     Sets the dynamic shared-memory size for the function.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuLaunch](<#group__CUDA__EXEC__DEPRECATED_1gea7bd80835bcce59c73247120766f6ff>) ( [CUfunction](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gba6128b948022f495706d93bc2cea9c8>)Â f )
     Launches a CUDA function.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuLaunchGrid](<#group__CUDA__EXEC__DEPRECATED_1g0676b0afb5d5c63aa46801788e3d8ca5>) ( [CUfunction](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gba6128b948022f495706d93bc2cea9c8>)Â f, int Â grid_width, int Â grid_height )
     Launches a CUDA function.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuLaunchGridAsync](<#group__CUDA__EXEC__DEPRECATED_1gb0292382e6b0d059263acd2574aaf00b>) ( [CUfunction](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gba6128b948022f495706d93bc2cea9c8>)Â f, int Â grid_width, int Â grid_height, [CUstream](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gb946c7f02e09efd788a204718015d88a>)Â hStream )
     Launches a CUDA function.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuParamSetSize](<#group__CUDA__EXEC__DEPRECATED_1gf6896c37762d695f5d161ee56cf86e62>) ( [CUfunction](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gba6128b948022f495706d93bc2cea9c8>)Â hfunc, unsigned int Â numbytes )
     Sets the parameter size for the function.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuParamSetTexRef](<#group__CUDA__EXEC__DEPRECATED_1g10fad4a11f4f6d0422f4929ff348fce5>) ( [CUfunction](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gba6128b948022f495706d93bc2cea9c8>)Â hfunc, int Â texunit, [CUtexref](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gec1e8eb9dc48ad748765d1fcc020d6b5>)Â hTexRef )
     Adds a texture-reference to the function's argument list.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuParamSetf](<#group__CUDA__EXEC__DEPRECATED_1gd5e7679999e3792203d477abad2958c5>) ( [CUfunction](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gba6128b948022f495706d93bc2cea9c8>)Â hfunc, int Â offset, float Â value )
     Adds a floating-point parameter to the function's argument list.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuParamSeti](<#group__CUDA__EXEC__DEPRECATED_1g07f1264a68f97f582353b0f5dd9ebd5c>) ( [CUfunction](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gba6128b948022f495706d93bc2cea9c8>)Â hfunc, int Â offset, unsigned int Â value )
     Adds an integer parameter to the function's argument list.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuParamSetv](<#group__CUDA__EXEC__DEPRECATED_1g24e5ceee66d1a84609b74e77672638b6>) ( [CUfunction](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gba6128b948022f495706d93bc2cea9c8>)Â hfunc, int Â offset, void*Â ptr, unsigned int Â numbytes )
     Adds arbitrary data to the function's argument list.

### Functions

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuFuncSetBlockShape ( [CUfunction](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gba6128b948022f495706d93bc2cea9c8>)Â hfunc, int Â x, int Â y, int Â z )


Sets the block-dimensions for the function.

######  Parameters

`hfunc`
    \- Kernel to specify dimensions of
`x`
    \- X dimension
`y`
    \- Y dimension
`z`
    \- Z dimension

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_DEINITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9acf52f132faf29b473cdda6061f0f44a>), [CUDA_ERROR_NOT_INITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e98feb999f0af99b4a25ab26b3866f4df8>), [CUDA_ERROR_INVALID_CONTEXT](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a484e9af32c1e9893ff21f0e0191a12d>), [CUDA_ERROR_INVALID_HANDLE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e90fd2e63260c6317ba943af0f7e4b8d21>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>)

###### [Deprecated](<deprecated.html#deprecated__deprecated_1_deprecated000011>)

###### Description

Specifies the `x`, `y`, and `z` dimensions of the thread blocks that are created when the kernel given by `hfunc` is launched.

Note:

Note that this function may also return error codes from previous, asynchronous launches.

**See also:**

[cuFuncSetSharedSize](<group__CUDA__EXEC__DEPRECATED.html#group__CUDA__EXEC__DEPRECATED_1g9b5a3f121142f7b42aea48366c72bf8b> "Sets the dynamic shared-memory size for the function."), [cuFuncSetCacheConfig](<group__CUDA__EXEC.html#group__CUDA__EXEC_1g40f8c11e81def95dc0072a375f965681> "Sets the preferred cache configuration for a device function."), [cuFuncGetAttribute](<group__CUDA__EXEC.html#group__CUDA__EXEC_1g5e92a1b0d8d1b82cb00dcfb2de15961b> "Returns information about a function."), [cuParamSetSize](<group__CUDA__EXEC__DEPRECATED.html#group__CUDA__EXEC__DEPRECATED_1gf6896c37762d695f5d161ee56cf86e62> "Sets the parameter size for the function."), [cuParamSeti](<group__CUDA__EXEC__DEPRECATED.html#group__CUDA__EXEC__DEPRECATED_1g07f1264a68f97f582353b0f5dd9ebd5c> "Adds an integer parameter to the function's argument list."), [cuParamSetf](<group__CUDA__EXEC__DEPRECATED.html#group__CUDA__EXEC__DEPRECATED_1gd5e7679999e3792203d477abad2958c5> "Adds a floating-point parameter to the function's argument list."), [cuParamSetv](<group__CUDA__EXEC__DEPRECATED.html#group__CUDA__EXEC__DEPRECATED_1g24e5ceee66d1a84609b74e77672638b6> "Adds arbitrary data to the function's argument list."), [cuLaunch](<group__CUDA__EXEC__DEPRECATED.html#group__CUDA__EXEC__DEPRECATED_1gea7bd80835bcce59c73247120766f6ff> "Launches a CUDA function."), [cuLaunchGrid](<group__CUDA__EXEC__DEPRECATED.html#group__CUDA__EXEC__DEPRECATED_1g0676b0afb5d5c63aa46801788e3d8ca5> "Launches a CUDA function."), [cuLaunchGridAsync](<group__CUDA__EXEC__DEPRECATED.html#group__CUDA__EXEC__DEPRECATED_1gb0292382e6b0d059263acd2574aaf00b> "Launches a CUDA function."), [cuLaunchKernel](<group__CUDA__EXEC.html#group__CUDA__EXEC_1gb8f3dc3031b40da29d5f9a7139e52e15> "Launches a CUDA function CUfunction or a CUDA kernel CUkernel.")

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuFuncSetSharedMemConfig ( [CUfunction](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gba6128b948022f495706d93bc2cea9c8>)Â hfunc, [CUsharedconfig](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g92d66e95f602cb9fdaf0682c260c241b>)Â config )


Sets the shared memory configuration for a device function.

######  Parameters

`hfunc`
    \- kernel to be given a shared memory config
`config`
    \- requested shared memory configuration

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>), [CUDA_ERROR_DEINITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9acf52f132faf29b473cdda6061f0f44a>), [CUDA_ERROR_NOT_INITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e98feb999f0af99b4a25ab26b3866f4df8>), [CUDA_ERROR_INVALID_CONTEXT](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a484e9af32c1e9893ff21f0e0191a12d>)

###### [Deprecated](<deprecated.html#deprecated__deprecated_1_deprecated000021>)

###### Description

On devices with configurable shared memory banks, this function will force all subsequent launches of the specified device function to have the given shared memory bank size configuration. On any given launch of the function, the shared memory configuration of the device will be temporarily changed if needed to suit the function's preferred configuration. Changes in shared memory configuration between subsequent launches of functions, may introduce a device side synchronization point.

Any per-function setting of shared memory bank size set via [cuFuncSetSharedMemConfig](<group__CUDA__EXEC__DEPRECATED.html#group__CUDA__EXEC__DEPRECATED_1g3fe2417a78a7b5554a694c40355b54ce> "Sets the shared memory configuration for a device function.") will override the context wide setting set with [cuCtxSetSharedMemConfig](<group__CUDA__CTX__DEPRECATED.html#group__CUDA__CTX__DEPRECATED_1gb1fef6f9fd5c252245214f85ae01ec23> "Sets the shared memory configuration for the current context.").

Changing the shared memory bank size will not increase shared memory usage or affect occupancy of kernels, but may have major effects on performance. Larger bank sizes will allow for greater potential bandwidth to shared memory, but will change what kinds of accesses to shared memory will result in bank conflicts.

This function will do nothing on devices with fixed shared memory bank size.

The supported bank configurations are:

  * [CU_SHARED_MEM_CONFIG_DEFAULT_BANK_SIZE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg92d66e95f602cb9fdaf0682c260c241bd65d166d885bd3f41bf1ced4ab8e044e>): use the context's shared memory configuration when launching this function.

  * [CU_SHARED_MEM_CONFIG_FOUR_BYTE_BANK_SIZE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg92d66e95f602cb9fdaf0682c260c241b18d5d945c971d5d288d2693cbaa4d7dc>): set shared memory bank width to be natively four bytes when launching this function.

  * [CU_SHARED_MEM_CONFIG_EIGHT_BYTE_BANK_SIZE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg92d66e95f602cb9fdaf0682c260c241b081c400b814b9832b8a934ad2934985c>): set shared memory bank width to be natively eight bytes when launching this function.


Note:

Note that this function may also return error codes from previous, asynchronous launches.

**See also:**

[cuCtxGetCacheConfig](<group__CUDA__CTX.html#group__CUDA__CTX_1g40b6b141698f76744dea6e39b9a25360> "Returns the preferred cache configuration for the current context."), [cuCtxSetCacheConfig](<group__CUDA__CTX.html#group__CUDA__CTX_1g54699acf7e2ef27279d013ca2095f4a3> "Sets the preferred cache configuration for the current context."), [cuCtxGetSharedMemConfig](<group__CUDA__CTX__DEPRECATED.html#group__CUDA__CTX__DEPRECATED_1gfac1414497a1a2a40bba474c6b5bf194> "Returns the current shared memory configuration for the current context."), [cuCtxSetSharedMemConfig](<group__CUDA__CTX__DEPRECATED.html#group__CUDA__CTX__DEPRECATED_1gb1fef6f9fd5c252245214f85ae01ec23> "Sets the shared memory configuration for the current context."), [cuFuncGetAttribute](<group__CUDA__EXEC.html#group__CUDA__EXEC_1g5e92a1b0d8d1b82cb00dcfb2de15961b> "Returns information about a function."), [cuLaunchKernel](<group__CUDA__EXEC.html#group__CUDA__EXEC_1gb8f3dc3031b40da29d5f9a7139e52e15> "Launches a CUDA function CUfunction or a CUDA kernel CUkernel."), [cudaFuncSetSharedMemConfig](<../cuda-runtime-api/group__CUDART__EXECUTION__DEPRECATED.html#group__CUDART__EXECUTION__DEPRECATED_1gbd189716def6fdb5f819dae77452d30b>)

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuFuncSetSharedSize ( [CUfunction](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gba6128b948022f495706d93bc2cea9c8>)Â hfunc, unsigned int Â bytes )


Sets the dynamic shared-memory size for the function.

######  Parameters

`hfunc`
    \- Kernel to specify dynamic shared-memory size for
`bytes`
    \- Dynamic shared-memory size per thread in bytes

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_DEINITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9acf52f132faf29b473cdda6061f0f44a>), [CUDA_ERROR_NOT_INITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e98feb999f0af99b4a25ab26b3866f4df8>), [CUDA_ERROR_INVALID_CONTEXT](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a484e9af32c1e9893ff21f0e0191a12d>), [CUDA_ERROR_INVALID_HANDLE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e90fd2e63260c6317ba943af0f7e4b8d21>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>)

###### [Deprecated](<deprecated.html#deprecated__deprecated_1_deprecated000012>)

###### Description

Sets through `bytes` the amount of dynamic shared memory that will be available to each thread block when the kernel given by `hfunc` is launched.

Note:

Note that this function may also return error codes from previous, asynchronous launches.

**See also:**

[cuFuncSetBlockShape](<group__CUDA__EXEC__DEPRECATED.html#group__CUDA__EXEC__DEPRECATED_1gd98ab7e00740f68145972deb6ddab271> "Sets the block-dimensions for the function."), [cuFuncSetCacheConfig](<group__CUDA__EXEC.html#group__CUDA__EXEC_1g40f8c11e81def95dc0072a375f965681> "Sets the preferred cache configuration for a device function."), [cuFuncGetAttribute](<group__CUDA__EXEC.html#group__CUDA__EXEC_1g5e92a1b0d8d1b82cb00dcfb2de15961b> "Returns information about a function."), [cuParamSetSize](<group__CUDA__EXEC__DEPRECATED.html#group__CUDA__EXEC__DEPRECATED_1gf6896c37762d695f5d161ee56cf86e62> "Sets the parameter size for the function."), [cuParamSeti](<group__CUDA__EXEC__DEPRECATED.html#group__CUDA__EXEC__DEPRECATED_1g07f1264a68f97f582353b0f5dd9ebd5c> "Adds an integer parameter to the function's argument list."), [cuParamSetf](<group__CUDA__EXEC__DEPRECATED.html#group__CUDA__EXEC__DEPRECATED_1gd5e7679999e3792203d477abad2958c5> "Adds a floating-point parameter to the function's argument list."), [cuParamSetv](<group__CUDA__EXEC__DEPRECATED.html#group__CUDA__EXEC__DEPRECATED_1g24e5ceee66d1a84609b74e77672638b6> "Adds arbitrary data to the function's argument list."), [cuLaunch](<group__CUDA__EXEC__DEPRECATED.html#group__CUDA__EXEC__DEPRECATED_1gea7bd80835bcce59c73247120766f6ff> "Launches a CUDA function."), [cuLaunchGrid](<group__CUDA__EXEC__DEPRECATED.html#group__CUDA__EXEC__DEPRECATED_1g0676b0afb5d5c63aa46801788e3d8ca5> "Launches a CUDA function."), [cuLaunchGridAsync](<group__CUDA__EXEC__DEPRECATED.html#group__CUDA__EXEC__DEPRECATED_1gb0292382e6b0d059263acd2574aaf00b> "Launches a CUDA function."), [cuLaunchKernel](<group__CUDA__EXEC.html#group__CUDA__EXEC_1gb8f3dc3031b40da29d5f9a7139e52e15> "Launches a CUDA function CUfunction or a CUDA kernel CUkernel.")

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuLaunch ( [CUfunction](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gba6128b948022f495706d93bc2cea9c8>)Â f )


Launches a CUDA function.

######  Parameters

`f`
    \- Kernel to launch

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_DEINITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9acf52f132faf29b473cdda6061f0f44a>), [CUDA_ERROR_NOT_INITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e98feb999f0af99b4a25ab26b3866f4df8>), [CUDA_ERROR_INVALID_CONTEXT](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a484e9af32c1e9893ff21f0e0191a12d>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>), [CUDA_ERROR_LAUNCH_FAILED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e94f270bc1011b152febc8154b2b1e1b8d>), [CUDA_ERROR_LAUNCH_OUT_OF_RESOURCES](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9b5da09cc5697599a56a71a04184ffdaa>), [CUDA_ERROR_LAUNCH_TIMEOUT](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e965460d83f63575af9805ca59f8f19d74>), [CUDA_ERROR_LAUNCH_INCOMPATIBLE_TEXTURING](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e99e36a98a3a2c5123d422b9a1b69dd5f6>), [CUDA_ERROR_SHARED_OBJECT_INIT_FAILED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9d8a149ebc98aa90f6417e531fa645043>)

###### [Deprecated](<deprecated.html#deprecated__deprecated_1_deprecated000017>)

###### Description

Invokes the kernel `f` on a 1 x 1 x 1 grid of blocks. The block contains the number of threads specified by a previous call to [cuFuncSetBlockShape()](<group__CUDA__EXEC__DEPRECATED.html#group__CUDA__EXEC__DEPRECATED_1gd98ab7e00740f68145972deb6ddab271> "Sets the block-dimensions for the function.").

The block shape, dynamic shared memory size, and parameter information must be set using [cuFuncSetBlockShape()](<group__CUDA__EXEC__DEPRECATED.html#group__CUDA__EXEC__DEPRECATED_1gd98ab7e00740f68145972deb6ddab271> "Sets the block-dimensions for the function."), [cuFuncSetSharedSize()](<group__CUDA__EXEC__DEPRECATED.html#group__CUDA__EXEC__DEPRECATED_1g9b5a3f121142f7b42aea48366c72bf8b> "Sets the dynamic shared-memory size for the function."), [cuParamSetSize()](<group__CUDA__EXEC__DEPRECATED.html#group__CUDA__EXEC__DEPRECATED_1gf6896c37762d695f5d161ee56cf86e62> "Sets the parameter size for the function."), [cuParamSeti()](<group__CUDA__EXEC__DEPRECATED.html#group__CUDA__EXEC__DEPRECATED_1g07f1264a68f97f582353b0f5dd9ebd5c> "Adds an integer parameter to the function's argument list."), [cuParamSetf()](<group__CUDA__EXEC__DEPRECATED.html#group__CUDA__EXEC__DEPRECATED_1gd5e7679999e3792203d477abad2958c5> "Adds a floating-point parameter to the function's argument list."), and [cuParamSetv()](<group__CUDA__EXEC__DEPRECATED.html#group__CUDA__EXEC__DEPRECATED_1g24e5ceee66d1a84609b74e77672638b6> "Adds arbitrary data to the function's argument list.") prior to calling this function.

Launching a function via [cuLaunchKernel()](<group__CUDA__EXEC.html#group__CUDA__EXEC_1gb8f3dc3031b40da29d5f9a7139e52e15> "Launches a CUDA function CUfunction or a CUDA kernel CUkernel.") invalidates the function's block shape, dynamic shared memory size, and parameter information. After launching via cuLaunchKernel, this state must be re-initialized prior to calling this function. Failure to do so results in undefined behavior.

Note:

Note that this function may also return error codes from previous, asynchronous launches.

**See also:**

[cuFuncSetBlockShape](<group__CUDA__EXEC__DEPRECATED.html#group__CUDA__EXEC__DEPRECATED_1gd98ab7e00740f68145972deb6ddab271> "Sets the block-dimensions for the function."), [cuFuncSetSharedSize](<group__CUDA__EXEC__DEPRECATED.html#group__CUDA__EXEC__DEPRECATED_1g9b5a3f121142f7b42aea48366c72bf8b> "Sets the dynamic shared-memory size for the function."), [cuFuncGetAttribute](<group__CUDA__EXEC.html#group__CUDA__EXEC_1g5e92a1b0d8d1b82cb00dcfb2de15961b> "Returns information about a function."), [cuParamSetSize](<group__CUDA__EXEC__DEPRECATED.html#group__CUDA__EXEC__DEPRECATED_1gf6896c37762d695f5d161ee56cf86e62> "Sets the parameter size for the function."), [cuParamSetf](<group__CUDA__EXEC__DEPRECATED.html#group__CUDA__EXEC__DEPRECATED_1gd5e7679999e3792203d477abad2958c5> "Adds a floating-point parameter to the function's argument list."), [cuParamSeti](<group__CUDA__EXEC__DEPRECATED.html#group__CUDA__EXEC__DEPRECATED_1g07f1264a68f97f582353b0f5dd9ebd5c> "Adds an integer parameter to the function's argument list."), [cuParamSetv](<group__CUDA__EXEC__DEPRECATED.html#group__CUDA__EXEC__DEPRECATED_1g24e5ceee66d1a84609b74e77672638b6> "Adds arbitrary data to the function's argument list."), [cuLaunchGrid](<group__CUDA__EXEC__DEPRECATED.html#group__CUDA__EXEC__DEPRECATED_1g0676b0afb5d5c63aa46801788e3d8ca5> "Launches a CUDA function."), [cuLaunchGridAsync](<group__CUDA__EXEC__DEPRECATED.html#group__CUDA__EXEC__DEPRECATED_1gb0292382e6b0d059263acd2574aaf00b> "Launches a CUDA function."), [cuLaunchKernel](<group__CUDA__EXEC.html#group__CUDA__EXEC_1gb8f3dc3031b40da29d5f9a7139e52e15> "Launches a CUDA function CUfunction or a CUDA kernel CUkernel.")

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuLaunchGrid ( [CUfunction](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gba6128b948022f495706d93bc2cea9c8>)Â f, int Â grid_width, int Â grid_height )


Launches a CUDA function.

######  Parameters

`f`
    \- Kernel to launch
`grid_width`
    \- Width of grid in blocks
`grid_height`
    \- Height of grid in blocks

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_DEINITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9acf52f132faf29b473cdda6061f0f44a>), [CUDA_ERROR_NOT_INITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e98feb999f0af99b4a25ab26b3866f4df8>), [CUDA_ERROR_INVALID_CONTEXT](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a484e9af32c1e9893ff21f0e0191a12d>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>), [CUDA_ERROR_LAUNCH_FAILED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e94f270bc1011b152febc8154b2b1e1b8d>), [CUDA_ERROR_LAUNCH_OUT_OF_RESOURCES](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9b5da09cc5697599a56a71a04184ffdaa>), [CUDA_ERROR_LAUNCH_TIMEOUT](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e965460d83f63575af9805ca59f8f19d74>), [CUDA_ERROR_LAUNCH_INCOMPATIBLE_TEXTURING](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e99e36a98a3a2c5123d422b9a1b69dd5f6>), [CUDA_ERROR_SHARED_OBJECT_INIT_FAILED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9d8a149ebc98aa90f6417e531fa645043>)

###### [Deprecated](<deprecated.html#deprecated__deprecated_1_deprecated000018>)

###### Description

Invokes the kernel `f` on a `grid_width` x `grid_height` grid of blocks. Each block contains the number of threads specified by a previous call to [cuFuncSetBlockShape()](<group__CUDA__EXEC__DEPRECATED.html#group__CUDA__EXEC__DEPRECATED_1gd98ab7e00740f68145972deb6ddab271> "Sets the block-dimensions for the function.").

The block shape, dynamic shared memory size, and parameter information must be set using [cuFuncSetBlockShape()](<group__CUDA__EXEC__DEPRECATED.html#group__CUDA__EXEC__DEPRECATED_1gd98ab7e00740f68145972deb6ddab271> "Sets the block-dimensions for the function."), [cuFuncSetSharedSize()](<group__CUDA__EXEC__DEPRECATED.html#group__CUDA__EXEC__DEPRECATED_1g9b5a3f121142f7b42aea48366c72bf8b> "Sets the dynamic shared-memory size for the function."), [cuParamSetSize()](<group__CUDA__EXEC__DEPRECATED.html#group__CUDA__EXEC__DEPRECATED_1gf6896c37762d695f5d161ee56cf86e62> "Sets the parameter size for the function."), [cuParamSeti()](<group__CUDA__EXEC__DEPRECATED.html#group__CUDA__EXEC__DEPRECATED_1g07f1264a68f97f582353b0f5dd9ebd5c> "Adds an integer parameter to the function's argument list."), [cuParamSetf()](<group__CUDA__EXEC__DEPRECATED.html#group__CUDA__EXEC__DEPRECATED_1gd5e7679999e3792203d477abad2958c5> "Adds a floating-point parameter to the function's argument list."), and [cuParamSetv()](<group__CUDA__EXEC__DEPRECATED.html#group__CUDA__EXEC__DEPRECATED_1g24e5ceee66d1a84609b74e77672638b6> "Adds arbitrary data to the function's argument list.") prior to calling this function.

Launching a function via [cuLaunchKernel()](<group__CUDA__EXEC.html#group__CUDA__EXEC_1gb8f3dc3031b40da29d5f9a7139e52e15> "Launches a CUDA function CUfunction or a CUDA kernel CUkernel.") invalidates the function's block shape, dynamic shared memory size, and parameter information. After launching via cuLaunchKernel, this state must be re-initialized prior to calling this function. Failure to do so results in undefined behavior.

Note:

Note that this function may also return error codes from previous, asynchronous launches.

**See also:**

[cuFuncSetBlockShape](<group__CUDA__EXEC__DEPRECATED.html#group__CUDA__EXEC__DEPRECATED_1gd98ab7e00740f68145972deb6ddab271> "Sets the block-dimensions for the function."), [cuFuncSetSharedSize](<group__CUDA__EXEC__DEPRECATED.html#group__CUDA__EXEC__DEPRECATED_1g9b5a3f121142f7b42aea48366c72bf8b> "Sets the dynamic shared-memory size for the function."), [cuFuncGetAttribute](<group__CUDA__EXEC.html#group__CUDA__EXEC_1g5e92a1b0d8d1b82cb00dcfb2de15961b> "Returns information about a function."), [cuParamSetSize](<group__CUDA__EXEC__DEPRECATED.html#group__CUDA__EXEC__DEPRECATED_1gf6896c37762d695f5d161ee56cf86e62> "Sets the parameter size for the function."), [cuParamSetf](<group__CUDA__EXEC__DEPRECATED.html#group__CUDA__EXEC__DEPRECATED_1gd5e7679999e3792203d477abad2958c5> "Adds a floating-point parameter to the function's argument list."), [cuParamSeti](<group__CUDA__EXEC__DEPRECATED.html#group__CUDA__EXEC__DEPRECATED_1g07f1264a68f97f582353b0f5dd9ebd5c> "Adds an integer parameter to the function's argument list."), [cuParamSetv](<group__CUDA__EXEC__DEPRECATED.html#group__CUDA__EXEC__DEPRECATED_1g24e5ceee66d1a84609b74e77672638b6> "Adds arbitrary data to the function's argument list."), [cuLaunch](<group__CUDA__EXEC__DEPRECATED.html#group__CUDA__EXEC__DEPRECATED_1gea7bd80835bcce59c73247120766f6ff> "Launches a CUDA function."), [cuLaunchGridAsync](<group__CUDA__EXEC__DEPRECATED.html#group__CUDA__EXEC__DEPRECATED_1gb0292382e6b0d059263acd2574aaf00b> "Launches a CUDA function."), [cuLaunchKernel](<group__CUDA__EXEC.html#group__CUDA__EXEC_1gb8f3dc3031b40da29d5f9a7139e52e15> "Launches a CUDA function CUfunction or a CUDA kernel CUkernel.")

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuLaunchGridAsync ( [CUfunction](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gba6128b948022f495706d93bc2cea9c8>)Â f, int Â grid_width, int Â grid_height, [CUstream](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gb946c7f02e09efd788a204718015d88a>)Â hStream )


Launches a CUDA function.

######  Parameters

`f`
    \- Kernel to launch
`grid_width`
    \- Width of grid in blocks
`grid_height`
    \- Height of grid in blocks
`hStream`
    \- Stream identifier

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_DEINITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9acf52f132faf29b473cdda6061f0f44a>), [CUDA_ERROR_NOT_INITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e98feb999f0af99b4a25ab26b3866f4df8>), [CUDA_ERROR_INVALID_CONTEXT](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a484e9af32c1e9893ff21f0e0191a12d>), [CUDA_ERROR_INVALID_HANDLE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e90fd2e63260c6317ba943af0f7e4b8d21>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>), [CUDA_ERROR_LAUNCH_FAILED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e94f270bc1011b152febc8154b2b1e1b8d>), [CUDA_ERROR_LAUNCH_OUT_OF_RESOURCES](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9b5da09cc5697599a56a71a04184ffdaa>), [CUDA_ERROR_LAUNCH_TIMEOUT](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e965460d83f63575af9805ca59f8f19d74>), [CUDA_ERROR_LAUNCH_INCOMPATIBLE_TEXTURING](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e99e36a98a3a2c5123d422b9a1b69dd5f6>), [CUDA_ERROR_SHARED_OBJECT_INIT_FAILED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9d8a149ebc98aa90f6417e531fa645043>)

###### [Deprecated](<deprecated.html#deprecated__deprecated_1_deprecated000019>)

###### Description

Invokes the kernel `f` on a `grid_width` x `grid_height` grid of blocks. Each block contains the number of threads specified by a previous call to [cuFuncSetBlockShape()](<group__CUDA__EXEC__DEPRECATED.html#group__CUDA__EXEC__DEPRECATED_1gd98ab7e00740f68145972deb6ddab271> "Sets the block-dimensions for the function.").

The block shape, dynamic shared memory size, and parameter information must be set using [cuFuncSetBlockShape()](<group__CUDA__EXEC__DEPRECATED.html#group__CUDA__EXEC__DEPRECATED_1gd98ab7e00740f68145972deb6ddab271> "Sets the block-dimensions for the function."), [cuFuncSetSharedSize()](<group__CUDA__EXEC__DEPRECATED.html#group__CUDA__EXEC__DEPRECATED_1g9b5a3f121142f7b42aea48366c72bf8b> "Sets the dynamic shared-memory size for the function."), [cuParamSetSize()](<group__CUDA__EXEC__DEPRECATED.html#group__CUDA__EXEC__DEPRECATED_1gf6896c37762d695f5d161ee56cf86e62> "Sets the parameter size for the function."), [cuParamSeti()](<group__CUDA__EXEC__DEPRECATED.html#group__CUDA__EXEC__DEPRECATED_1g07f1264a68f97f582353b0f5dd9ebd5c> "Adds an integer parameter to the function's argument list."), [cuParamSetf()](<group__CUDA__EXEC__DEPRECATED.html#group__CUDA__EXEC__DEPRECATED_1gd5e7679999e3792203d477abad2958c5> "Adds a floating-point parameter to the function's argument list."), and [cuParamSetv()](<group__CUDA__EXEC__DEPRECATED.html#group__CUDA__EXEC__DEPRECATED_1g24e5ceee66d1a84609b74e77672638b6> "Adds arbitrary data to the function's argument list.") prior to calling this function.

Launching a function via [cuLaunchKernel()](<group__CUDA__EXEC.html#group__CUDA__EXEC_1gb8f3dc3031b40da29d5f9a7139e52e15> "Launches a CUDA function CUfunction or a CUDA kernel CUkernel.") invalidates the function's block shape, dynamic shared memory size, and parameter information. After launching via cuLaunchKernel, this state must be re-initialized prior to calling this function. Failure to do so results in undefined behavior.

Note:

  * In certain cases where cubins are created with no ABI (i.e., using `ptxas``--abi-compile``no`), this function may serialize kernel launches. The CUDA driver retains asynchronous behavior by growing the per-thread stack as needed per launch and not shrinking it afterwards.

  * This function uses standard [default stream](<stream-sync-behavior.html#stream-sync-behavior__default-stream>) semantics.

  * Note that this function may also return error codes from previous, asynchronous launches.


**See also:**

[cuFuncSetBlockShape](<group__CUDA__EXEC__DEPRECATED.html#group__CUDA__EXEC__DEPRECATED_1gd98ab7e00740f68145972deb6ddab271> "Sets the block-dimensions for the function."), [cuFuncSetSharedSize](<group__CUDA__EXEC__DEPRECATED.html#group__CUDA__EXEC__DEPRECATED_1g9b5a3f121142f7b42aea48366c72bf8b> "Sets the dynamic shared-memory size for the function."), [cuFuncGetAttribute](<group__CUDA__EXEC.html#group__CUDA__EXEC_1g5e92a1b0d8d1b82cb00dcfb2de15961b> "Returns information about a function."), [cuParamSetSize](<group__CUDA__EXEC__DEPRECATED.html#group__CUDA__EXEC__DEPRECATED_1gf6896c37762d695f5d161ee56cf86e62> "Sets the parameter size for the function."), [cuParamSetf](<group__CUDA__EXEC__DEPRECATED.html#group__CUDA__EXEC__DEPRECATED_1gd5e7679999e3792203d477abad2958c5> "Adds a floating-point parameter to the function's argument list."), [cuParamSeti](<group__CUDA__EXEC__DEPRECATED.html#group__CUDA__EXEC__DEPRECATED_1g07f1264a68f97f582353b0f5dd9ebd5c> "Adds an integer parameter to the function's argument list."), [cuParamSetv](<group__CUDA__EXEC__DEPRECATED.html#group__CUDA__EXEC__DEPRECATED_1g24e5ceee66d1a84609b74e77672638b6> "Adds arbitrary data to the function's argument list."), [cuLaunch](<group__CUDA__EXEC__DEPRECATED.html#group__CUDA__EXEC__DEPRECATED_1gea7bd80835bcce59c73247120766f6ff> "Launches a CUDA function."), [cuLaunchGrid](<group__CUDA__EXEC__DEPRECATED.html#group__CUDA__EXEC__DEPRECATED_1g0676b0afb5d5c63aa46801788e3d8ca5> "Launches a CUDA function."), [cuLaunchKernel](<group__CUDA__EXEC.html#group__CUDA__EXEC_1gb8f3dc3031b40da29d5f9a7139e52e15> "Launches a CUDA function CUfunction or a CUDA kernel CUkernel.")

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuParamSetSize ( [CUfunction](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gba6128b948022f495706d93bc2cea9c8>)Â hfunc, unsigned int Â numbytes )


Sets the parameter size for the function.

######  Parameters

`hfunc`
    \- Kernel to set parameter size for
`numbytes`
    \- Size of parameter list in bytes

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_DEINITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9acf52f132faf29b473cdda6061f0f44a>), [CUDA_ERROR_NOT_INITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e98feb999f0af99b4a25ab26b3866f4df8>), [CUDA_ERROR_INVALID_CONTEXT](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a484e9af32c1e9893ff21f0e0191a12d>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>)

###### [Deprecated](<deprecated.html#deprecated__deprecated_1_deprecated000013>)

###### Description

Sets through `numbytes` the total size in bytes needed by the function parameters of the kernel corresponding to `hfunc`.

Note:

Note that this function may also return error codes from previous, asynchronous launches.

**See also:**

[cuFuncSetBlockShape](<group__CUDA__EXEC__DEPRECATED.html#group__CUDA__EXEC__DEPRECATED_1gd98ab7e00740f68145972deb6ddab271> "Sets the block-dimensions for the function."), [cuFuncSetSharedSize](<group__CUDA__EXEC__DEPRECATED.html#group__CUDA__EXEC__DEPRECATED_1g9b5a3f121142f7b42aea48366c72bf8b> "Sets the dynamic shared-memory size for the function."), [cuFuncGetAttribute](<group__CUDA__EXEC.html#group__CUDA__EXEC_1g5e92a1b0d8d1b82cb00dcfb2de15961b> "Returns information about a function."), [cuParamSetf](<group__CUDA__EXEC__DEPRECATED.html#group__CUDA__EXEC__DEPRECATED_1gd5e7679999e3792203d477abad2958c5> "Adds a floating-point parameter to the function's argument list."), [cuParamSeti](<group__CUDA__EXEC__DEPRECATED.html#group__CUDA__EXEC__DEPRECATED_1g07f1264a68f97f582353b0f5dd9ebd5c> "Adds an integer parameter to the function's argument list."), [cuParamSetv](<group__CUDA__EXEC__DEPRECATED.html#group__CUDA__EXEC__DEPRECATED_1g24e5ceee66d1a84609b74e77672638b6> "Adds arbitrary data to the function's argument list."), [cuLaunch](<group__CUDA__EXEC__DEPRECATED.html#group__CUDA__EXEC__DEPRECATED_1gea7bd80835bcce59c73247120766f6ff> "Launches a CUDA function."), [cuLaunchGrid](<group__CUDA__EXEC__DEPRECATED.html#group__CUDA__EXEC__DEPRECATED_1g0676b0afb5d5c63aa46801788e3d8ca5> "Launches a CUDA function."), [cuLaunchGridAsync](<group__CUDA__EXEC__DEPRECATED.html#group__CUDA__EXEC__DEPRECATED_1gb0292382e6b0d059263acd2574aaf00b> "Launches a CUDA function."), [cuLaunchKernel](<group__CUDA__EXEC.html#group__CUDA__EXEC_1gb8f3dc3031b40da29d5f9a7139e52e15> "Launches a CUDA function CUfunction or a CUDA kernel CUkernel.")

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuParamSetTexRef ( [CUfunction](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gba6128b948022f495706d93bc2cea9c8>)Â hfunc, int Â texunit, [CUtexref](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gec1e8eb9dc48ad748765d1fcc020d6b5>)Â hTexRef )


Adds a texture-reference to the function's argument list.

######  Parameters

`hfunc`
    \- Kernel to add texture-reference to
`texunit`
    \- Texture unit (must be [CU_PARAM_TR_DEFAULT](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g3e9be6955a6a5c311ad5ea2debdd6613>))
`hTexRef`
    \- Texture-reference to add to argument list

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_DEINITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9acf52f132faf29b473cdda6061f0f44a>), [CUDA_ERROR_NOT_INITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e98feb999f0af99b4a25ab26b3866f4df8>), [CUDA_ERROR_INVALID_CONTEXT](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a484e9af32c1e9893ff21f0e0191a12d>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>)

###### [Deprecated](<deprecated.html#deprecated__deprecated_1_deprecated000020>)

###### Description

Makes the CUDA array or linear memory bound to the texture reference `hTexRef` available to a device program as a texture. In this version of CUDA, the texture-reference must be obtained via [cuModuleGetTexRef()](<group__CUDA__MODULE__DEPRECATED.html#group__CUDA__MODULE__DEPRECATED_1g9965d238143354d573ef5789057be561> "Returns a handle to a texture reference.") and the `texunit` parameter must be set to [CU_PARAM_TR_DEFAULT](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g3e9be6955a6a5c311ad5ea2debdd6613>).

Note:

Note that this function may also return error codes from previous, asynchronous launches.

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuParamSetf ( [CUfunction](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gba6128b948022f495706d93bc2cea9c8>)Â hfunc, int Â offset, float Â value )


Adds a floating-point parameter to the function's argument list.

######  Parameters

`hfunc`
    \- Kernel to add parameter to
`offset`
    \- Offset to add parameter to argument list
`value`
    \- Value of parameter

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_DEINITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9acf52f132faf29b473cdda6061f0f44a>), [CUDA_ERROR_NOT_INITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e98feb999f0af99b4a25ab26b3866f4df8>), [CUDA_ERROR_INVALID_CONTEXT](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a484e9af32c1e9893ff21f0e0191a12d>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>)

###### [Deprecated](<deprecated.html#deprecated__deprecated_1_deprecated000015>)

###### Description

Sets a floating-point parameter that will be specified the next time the kernel corresponding to `hfunc` will be invoked. `offset` is a byte offset.

Note:

Note that this function may also return error codes from previous, asynchronous launches.

**See also:**

[cuFuncSetBlockShape](<group__CUDA__EXEC__DEPRECATED.html#group__CUDA__EXEC__DEPRECATED_1gd98ab7e00740f68145972deb6ddab271> "Sets the block-dimensions for the function."), [cuFuncSetSharedSize](<group__CUDA__EXEC__DEPRECATED.html#group__CUDA__EXEC__DEPRECATED_1g9b5a3f121142f7b42aea48366c72bf8b> "Sets the dynamic shared-memory size for the function."), [cuFuncGetAttribute](<group__CUDA__EXEC.html#group__CUDA__EXEC_1g5e92a1b0d8d1b82cb00dcfb2de15961b> "Returns information about a function."), [cuParamSetSize](<group__CUDA__EXEC__DEPRECATED.html#group__CUDA__EXEC__DEPRECATED_1gf6896c37762d695f5d161ee56cf86e62> "Sets the parameter size for the function."), [cuParamSeti](<group__CUDA__EXEC__DEPRECATED.html#group__CUDA__EXEC__DEPRECATED_1g07f1264a68f97f582353b0f5dd9ebd5c> "Adds an integer parameter to the function's argument list."), [cuParamSetv](<group__CUDA__EXEC__DEPRECATED.html#group__CUDA__EXEC__DEPRECATED_1g24e5ceee66d1a84609b74e77672638b6> "Adds arbitrary data to the function's argument list."), [cuLaunch](<group__CUDA__EXEC__DEPRECATED.html#group__CUDA__EXEC__DEPRECATED_1gea7bd80835bcce59c73247120766f6ff> "Launches a CUDA function."), [cuLaunchGrid](<group__CUDA__EXEC__DEPRECATED.html#group__CUDA__EXEC__DEPRECATED_1g0676b0afb5d5c63aa46801788e3d8ca5> "Launches a CUDA function."), [cuLaunchGridAsync](<group__CUDA__EXEC__DEPRECATED.html#group__CUDA__EXEC__DEPRECATED_1gb0292382e6b0d059263acd2574aaf00b> "Launches a CUDA function."), [cuLaunchKernel](<group__CUDA__EXEC.html#group__CUDA__EXEC_1gb8f3dc3031b40da29d5f9a7139e52e15> "Launches a CUDA function CUfunction or a CUDA kernel CUkernel.")

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuParamSeti ( [CUfunction](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gba6128b948022f495706d93bc2cea9c8>)Â hfunc, int Â offset, unsigned int Â value )


Adds an integer parameter to the function's argument list.

######  Parameters

`hfunc`
    \- Kernel to add parameter to
`offset`
    \- Offset to add parameter to argument list
`value`
    \- Value of parameter

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_DEINITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9acf52f132faf29b473cdda6061f0f44a>), [CUDA_ERROR_NOT_INITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e98feb999f0af99b4a25ab26b3866f4df8>), [CUDA_ERROR_INVALID_CONTEXT](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a484e9af32c1e9893ff21f0e0191a12d>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>)

###### [Deprecated](<deprecated.html#deprecated__deprecated_1_deprecated000014>)

###### Description

Sets an integer parameter that will be specified the next time the kernel corresponding to `hfunc` will be invoked. `offset` is a byte offset.

Note:

Note that this function may also return error codes from previous, asynchronous launches.

**See also:**

[cuFuncSetBlockShape](<group__CUDA__EXEC__DEPRECATED.html#group__CUDA__EXEC__DEPRECATED_1gd98ab7e00740f68145972deb6ddab271> "Sets the block-dimensions for the function."), [cuFuncSetSharedSize](<group__CUDA__EXEC__DEPRECATED.html#group__CUDA__EXEC__DEPRECATED_1g9b5a3f121142f7b42aea48366c72bf8b> "Sets the dynamic shared-memory size for the function."), [cuFuncGetAttribute](<group__CUDA__EXEC.html#group__CUDA__EXEC_1g5e92a1b0d8d1b82cb00dcfb2de15961b> "Returns information about a function."), [cuParamSetSize](<group__CUDA__EXEC__DEPRECATED.html#group__CUDA__EXEC__DEPRECATED_1gf6896c37762d695f5d161ee56cf86e62> "Sets the parameter size for the function."), [cuParamSetf](<group__CUDA__EXEC__DEPRECATED.html#group__CUDA__EXEC__DEPRECATED_1gd5e7679999e3792203d477abad2958c5> "Adds a floating-point parameter to the function's argument list."), [cuParamSetv](<group__CUDA__EXEC__DEPRECATED.html#group__CUDA__EXEC__DEPRECATED_1g24e5ceee66d1a84609b74e77672638b6> "Adds arbitrary data to the function's argument list."), [cuLaunch](<group__CUDA__EXEC__DEPRECATED.html#group__CUDA__EXEC__DEPRECATED_1gea7bd80835bcce59c73247120766f6ff> "Launches a CUDA function."), [cuLaunchGrid](<group__CUDA__EXEC__DEPRECATED.html#group__CUDA__EXEC__DEPRECATED_1g0676b0afb5d5c63aa46801788e3d8ca5> "Launches a CUDA function."), [cuLaunchGridAsync](<group__CUDA__EXEC__DEPRECATED.html#group__CUDA__EXEC__DEPRECATED_1gb0292382e6b0d059263acd2574aaf00b> "Launches a CUDA function."), [cuLaunchKernel](<group__CUDA__EXEC.html#group__CUDA__EXEC_1gb8f3dc3031b40da29d5f9a7139e52e15> "Launches a CUDA function CUfunction or a CUDA kernel CUkernel.")

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuParamSetv ( [CUfunction](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gba6128b948022f495706d93bc2cea9c8>)Â hfunc, int Â offset, void*Â ptr, unsigned int Â numbytes )


Adds arbitrary data to the function's argument list.

######  Parameters

`hfunc`
    \- Kernel to add data to
`offset`
    \- Offset to add data to argument list
`ptr`
    \- Pointer to arbitrary data
`numbytes`
    \- Size of data to copy in bytes

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_DEINITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9acf52f132faf29b473cdda6061f0f44a>), [CUDA_ERROR_NOT_INITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e98feb999f0af99b4a25ab26b3866f4df8>), [CUDA_ERROR_INVALID_CONTEXT](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a484e9af32c1e9893ff21f0e0191a12d>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>)

###### [Deprecated](<deprecated.html#deprecated__deprecated_1_deprecated000016>)

###### Description

Copies an arbitrary amount of data (specified in `numbytes`) from `ptr` into the parameter space of the kernel corresponding to `hfunc`. `offset` is a byte offset.

Note:

Note that this function may also return error codes from previous, asynchronous launches.

**See also:**

[cuFuncSetBlockShape](<group__CUDA__EXEC__DEPRECATED.html#group__CUDA__EXEC__DEPRECATED_1gd98ab7e00740f68145972deb6ddab271> "Sets the block-dimensions for the function."), [cuFuncSetSharedSize](<group__CUDA__EXEC__DEPRECATED.html#group__CUDA__EXEC__DEPRECATED_1g9b5a3f121142f7b42aea48366c72bf8b> "Sets the dynamic shared-memory size for the function."), [cuFuncGetAttribute](<group__CUDA__EXEC.html#group__CUDA__EXEC_1g5e92a1b0d8d1b82cb00dcfb2de15961b> "Returns information about a function."), [cuParamSetSize](<group__CUDA__EXEC__DEPRECATED.html#group__CUDA__EXEC__DEPRECATED_1gf6896c37762d695f5d161ee56cf86e62> "Sets the parameter size for the function."), [cuParamSetf](<group__CUDA__EXEC__DEPRECATED.html#group__CUDA__EXEC__DEPRECATED_1gd5e7679999e3792203d477abad2958c5> "Adds a floating-point parameter to the function's argument list."), [cuParamSeti](<group__CUDA__EXEC__DEPRECATED.html#group__CUDA__EXEC__DEPRECATED_1g07f1264a68f97f582353b0f5dd9ebd5c> "Adds an integer parameter to the function's argument list."), [cuLaunch](<group__CUDA__EXEC__DEPRECATED.html#group__CUDA__EXEC__DEPRECATED_1gea7bd80835bcce59c73247120766f6ff> "Launches a CUDA function."), [cuLaunchGrid](<group__CUDA__EXEC__DEPRECATED.html#group__CUDA__EXEC__DEPRECATED_1g0676b0afb5d5c63aa46801788e3d8ca5> "Launches a CUDA function."), [cuLaunchGridAsync](<group__CUDA__EXEC__DEPRECATED.html#group__CUDA__EXEC__DEPRECATED_1gb0292382e6b0d059263acd2574aaf00b> "Launches a CUDA function."), [cuLaunchKernel](<group__CUDA__EXEC.html#group__CUDA__EXEC_1gb8f3dc3031b40da29d5f9a7139e52e15> "Launches a CUDA function CUfunction or a CUDA kernel CUkernel.")

* * *


---

# Graph Management

## 6.24.Â Graph Management

This section describes the graph management functions of the low-level CUDA driver application programming interface.

### Functions

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuDeviceGetGraphMemAttribute](<#group__CUDA__GRAPH_1g359903c2447ac22b4e1a0dce26adfef5>) ( [CUdevice](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g41ca2a24a242b36ef2ca77330b5fb72a>)Â device, [CUgraphMem_attribute](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g5f76366f87bbdf761007768fe30a57db>)Â attr, void*Â value )
     Query asynchronous allocation attributes related to graphs.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuDeviceGraphMemTrim](<#group__CUDA__GRAPH_1g57c87f4ba6af41825627cdd4e5a8c52b>) ( [CUdevice](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g41ca2a24a242b36ef2ca77330b5fb72a>)Â device )
     Free unused memory that was cached on the specified device for use with graphs back to the OS.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuDeviceSetGraphMemAttribute](<#group__CUDA__GRAPH_1g064bd5c6a773b83d145c281ebf5dbe34>) ( [CUdevice](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g41ca2a24a242b36ef2ca77330b5fb72a>)Â device, [CUgraphMem_attribute](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g5f76366f87bbdf761007768fe30a57db>)Â attr, void*Â value )
     Set asynchronous allocation attributes related to graphs.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuGraphAddBatchMemOpNode](<#group__CUDA__GRAPH_1g5acb6914dbd18cb1ae15ea9437a73c96>) ( [CUgraphNode](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc72514a94dacc85ed0617f979211079c>)*Â phGraphNode, [CUgraph](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g69f555c38df5b3fa1ed25efef794739a>)Â hGraph, const [CUgraphNode](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc72514a94dacc85ed0617f979211079c>)*Â dependencies, size_tÂ numDependencies, const [CUDA_BATCH_MEM_OP_NODE_PARAMS](<structCUDA__BATCH__MEM__OP__NODE__PARAMS__v1.html#structCUDA__BATCH__MEM__OP__NODE__PARAMS__v1>)*Â nodeParams )
     Creates a batch memory operation node and adds it to a graph.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuGraphAddChildGraphNode](<#group__CUDA__GRAPH_1gde52afbcf91a8c79d4d7efbe0e3b6844>) ( [CUgraphNode](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc72514a94dacc85ed0617f979211079c>)*Â phGraphNode, [CUgraph](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g69f555c38df5b3fa1ed25efef794739a>)Â hGraph, const [CUgraphNode](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc72514a94dacc85ed0617f979211079c>)*Â dependencies, size_tÂ numDependencies, [CUgraph](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g69f555c38df5b3fa1ed25efef794739a>)Â childGraph )
     Creates a child graph node and adds it to a graph.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuGraphAddDependencies](<#group__CUDA__GRAPH_1g5dad91f0be4e0fde6092f15797427e2d>) ( [CUgraph](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g69f555c38df5b3fa1ed25efef794739a>)Â hGraph, const [CUgraphNode](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc72514a94dacc85ed0617f979211079c>)*Â from, const [CUgraphNode](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc72514a94dacc85ed0617f979211079c>)*Â to, const [CUgraphEdgeData](<structCUgraphEdgeData.html#structCUgraphEdgeData>)*Â edgeData, size_tÂ numDependencies )
     Adds dependency edges to a graph.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuGraphAddEmptyNode](<#group__CUDA__GRAPH_1g14b625984430cb2d574c63f29c9b9223>) ( [CUgraphNode](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc72514a94dacc85ed0617f979211079c>)*Â phGraphNode, [CUgraph](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g69f555c38df5b3fa1ed25efef794739a>)Â hGraph, const [CUgraphNode](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc72514a94dacc85ed0617f979211079c>)*Â dependencies, size_tÂ numDependencies )
     Creates an empty node and adds it to a graph.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuGraphAddEventRecordNode](<#group__CUDA__GRAPH_1ga7f6dcb109f4b7470ce6b067d39974a4>) ( [CUgraphNode](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc72514a94dacc85ed0617f979211079c>)*Â phGraphNode, [CUgraph](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g69f555c38df5b3fa1ed25efef794739a>)Â hGraph, const [CUgraphNode](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc72514a94dacc85ed0617f979211079c>)*Â dependencies, size_tÂ numDependencies, [CUevent](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g6d740185cf0953636d4ae37f68d7559b>)Â event )
     Creates an event record node and adds it to a graph.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuGraphAddEventWaitNode](<#group__CUDA__GRAPH_1g7306f3bcbec3406d80e110cd13405c5e>) ( [CUgraphNode](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc72514a94dacc85ed0617f979211079c>)*Â phGraphNode, [CUgraph](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g69f555c38df5b3fa1ed25efef794739a>)Â hGraph, const [CUgraphNode](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc72514a94dacc85ed0617f979211079c>)*Â dependencies, size_tÂ numDependencies, [CUevent](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g6d740185cf0953636d4ae37f68d7559b>)Â event )
     Creates an event wait node and adds it to a graph.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuGraphAddExternalSemaphoresSignalNode](<#group__CUDA__GRAPH_1g6410d5401de205568457fba5e1862ad3>) ( [CUgraphNode](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc72514a94dacc85ed0617f979211079c>)*Â phGraphNode, [CUgraph](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g69f555c38df5b3fa1ed25efef794739a>)Â hGraph, const [CUgraphNode](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc72514a94dacc85ed0617f979211079c>)*Â dependencies, size_tÂ numDependencies, const [CUDA_EXT_SEM_SIGNAL_NODE_PARAMS](<structCUDA__EXT__SEM__SIGNAL__NODE__PARAMS__v1.html#structCUDA__EXT__SEM__SIGNAL__NODE__PARAMS__v1>)*Â nodeParams )
     Creates an external semaphore signal node and adds it to a graph.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuGraphAddExternalSemaphoresWaitNode](<#group__CUDA__GRAPH_1g49131c65fcef0b60b3939e008f7b467e>) ( [CUgraphNode](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc72514a94dacc85ed0617f979211079c>)*Â phGraphNode, [CUgraph](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g69f555c38df5b3fa1ed25efef794739a>)Â hGraph, const [CUgraphNode](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc72514a94dacc85ed0617f979211079c>)*Â dependencies, size_tÂ numDependencies, const [CUDA_EXT_SEM_WAIT_NODE_PARAMS](<structCUDA__EXT__SEM__WAIT__NODE__PARAMS__v1.html#structCUDA__EXT__SEM__WAIT__NODE__PARAMS__v1>)*Â nodeParams )
     Creates an external semaphore wait node and adds it to a graph.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuGraphAddHostNode](<#group__CUDA__GRAPH_1g0809d65e85a3c052296373954a05b1d6>) ( [CUgraphNode](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc72514a94dacc85ed0617f979211079c>)*Â phGraphNode, [CUgraph](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g69f555c38df5b3fa1ed25efef794739a>)Â hGraph, const [CUgraphNode](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc72514a94dacc85ed0617f979211079c>)*Â dependencies, size_tÂ numDependencies, const [CUDA_HOST_NODE_PARAMS](<structCUDA__HOST__NODE__PARAMS__v1.html#structCUDA__HOST__NODE__PARAMS__v1>)*Â nodeParams )
     Creates a host execution node and adds it to a graph.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuGraphAddKernelNode](<#group__CUDA__GRAPH_1g50d871e3bd06c1b835e52f2966ef366b>) ( [CUgraphNode](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc72514a94dacc85ed0617f979211079c>)*Â phGraphNode, [CUgraph](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g69f555c38df5b3fa1ed25efef794739a>)Â hGraph, const [CUgraphNode](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc72514a94dacc85ed0617f979211079c>)*Â dependencies, size_tÂ numDependencies, const [CUDA_KERNEL_NODE_PARAMS](<structCUDA__KERNEL__NODE__PARAMS__v2.html#structCUDA__KERNEL__NODE__PARAMS__v2>)*Â nodeParams )
     Creates a kernel execution node and adds it to a graph.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuGraphAddMemAllocNode](<#group__CUDA__GRAPH_1g73a351cb71b2945a0bcb913a93f69ec9>) ( [CUgraphNode](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc72514a94dacc85ed0617f979211079c>)*Â phGraphNode, [CUgraph](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g69f555c38df5b3fa1ed25efef794739a>)Â hGraph, const [CUgraphNode](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc72514a94dacc85ed0617f979211079c>)*Â dependencies, size_tÂ numDependencies, [CUDA_MEM_ALLOC_NODE_PARAMS](<structCUDA__MEM__ALLOC__NODE__PARAMS__v1.html#structCUDA__MEM__ALLOC__NODE__PARAMS__v1>)*Â nodeParams )
     Creates an allocation node and adds it to a graph.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuGraphAddMemFreeNode](<#group__CUDA__GRAPH_1geb7cdce5d9be2d28d9428e74eb00fa53>) ( [CUgraphNode](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc72514a94dacc85ed0617f979211079c>)*Â phGraphNode, [CUgraph](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g69f555c38df5b3fa1ed25efef794739a>)Â hGraph, const [CUgraphNode](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc72514a94dacc85ed0617f979211079c>)*Â dependencies, size_tÂ numDependencies, [CUdeviceptr](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g183f7b0d8ad008ea2a5fd552537ace4e>)Â dptr )
     Creates a memory free node and adds it to a graph.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuGraphAddMemcpyNode](<#group__CUDA__GRAPH_1g674da6ab54a677f13e0e0e8206ff5073>) ( [CUgraphNode](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc72514a94dacc85ed0617f979211079c>)*Â phGraphNode, [CUgraph](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g69f555c38df5b3fa1ed25efef794739a>)Â hGraph, const [CUgraphNode](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc72514a94dacc85ed0617f979211079c>)*Â dependencies, size_tÂ numDependencies, const [CUDA_MEMCPY3D](<structCUDA__MEMCPY3D__v2.html#structCUDA__MEMCPY3D__v2>)*Â copyParams, [CUcontext](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gf9f5bd81658f866613785b3a0bb7d7d9>)Â ctx )
     Creates a memcpy node and adds it to a graph.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuGraphAddMemsetNode](<#group__CUDA__GRAPH_1g89dc8fc3743392777c0daa2c4aca40d3>) ( [CUgraphNode](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc72514a94dacc85ed0617f979211079c>)*Â phGraphNode, [CUgraph](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g69f555c38df5b3fa1ed25efef794739a>)Â hGraph, const [CUgraphNode](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc72514a94dacc85ed0617f979211079c>)*Â dependencies, size_tÂ numDependencies, const [CUDA_MEMSET_NODE_PARAMS](<structCUDA__MEMSET__NODE__PARAMS__v1.html#structCUDA__MEMSET__NODE__PARAMS__v1>)*Â memsetParams, [CUcontext](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gf9f5bd81658f866613785b3a0bb7d7d9>)Â ctx )
     Creates a memset node and adds it to a graph.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuGraphAddNode](<#group__CUDA__GRAPH_1ge01208e62f72a53367a2af903bf17d23>) ( [CUgraphNode](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc72514a94dacc85ed0617f979211079c>)*Â phGraphNode, [CUgraph](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g69f555c38df5b3fa1ed25efef794739a>)Â hGraph, const [CUgraphNode](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc72514a94dacc85ed0617f979211079c>)*Â dependencies, const [CUgraphEdgeData](<structCUgraphEdgeData.html#structCUgraphEdgeData>)*Â dependencyData, size_tÂ numDependencies, [CUgraphNodeParams](<structCUgraphNodeParams.html#structCUgraphNodeParams>)*Â nodeParams )
     Adds a node of arbitrary type to a graph.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuGraphBatchMemOpNodeGetParams](<#group__CUDA__GRAPH_1g1d8039468b71285c61bc03ab3c302a28>) ( [CUgraphNode](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc72514a94dacc85ed0617f979211079c>)Â hNode, [CUDA_BATCH_MEM_OP_NODE_PARAMS](<structCUDA__BATCH__MEM__OP__NODE__PARAMS__v1.html#structCUDA__BATCH__MEM__OP__NODE__PARAMS__v1>)*Â nodeParams_out )
     Returns a batch mem op node's parameters.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuGraphBatchMemOpNodeSetParams](<#group__CUDA__GRAPH_1g625ca946b58df3d17221ff7db5cd7800>) ( [CUgraphNode](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc72514a94dacc85ed0617f979211079c>)Â hNode, const [CUDA_BATCH_MEM_OP_NODE_PARAMS](<structCUDA__BATCH__MEM__OP__NODE__PARAMS__v1.html#structCUDA__BATCH__MEM__OP__NODE__PARAMS__v1>)*Â nodeParams )
     Sets a batch mem op node's parameters.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuGraphChildGraphNodeGetGraph](<#group__CUDA__GRAPH_1gbe9fc9267316b3778ef0db507917b4fd>) ( [CUgraphNode](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc72514a94dacc85ed0617f979211079c>)Â hNode, [CUgraph](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g69f555c38df5b3fa1ed25efef794739a>)*Â phGraph )
     Gets a handle to the embedded graph of a child graph node.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuGraphClone](<#group__CUDA__GRAPH_1g3603974654e463f2231c71d9b9d1517e>) ( [CUgraph](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g69f555c38df5b3fa1ed25efef794739a>)*Â phGraphClone, [CUgraph](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g69f555c38df5b3fa1ed25efef794739a>)Â originalGraph )
     Clones a graph.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuGraphConditionalHandleCreate](<#group__CUDA__GRAPH_1gece6f3b9e85d0edb8484d625fe567376>) ( [CUgraphConditionalHandle](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gf5f0f00dad6aa27aff480400b77f93ee>)*Â pHandle_out, [CUgraph](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g69f555c38df5b3fa1ed25efef794739a>)Â hGraph, [CUcontext](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gf9f5bd81658f866613785b3a0bb7d7d9>)Â ctx, unsigned int Â defaultLaunchValue, unsigned int Â flags )
     Create a conditional handle.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuGraphCreate](<#group__CUDA__GRAPH_1gd885f719186010727b75c3315f865fdf>) ( [CUgraph](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g69f555c38df5b3fa1ed25efef794739a>)*Â phGraph, unsigned int Â flags )
     Creates a graph.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuGraphDebugDotPrint](<#group__CUDA__GRAPH_1g0fb0c4d319477a0a98da005fcb0dacc4>) ( [CUgraph](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g69f555c38df5b3fa1ed25efef794739a>)Â hGraph, const char*Â path, unsigned int Â flags )
     Write a DOT file describing graph structure.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuGraphDestroy](<#group__CUDA__GRAPH_1g718cfd9681f078693d4be2426fd689c8>) ( [CUgraph](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g69f555c38df5b3fa1ed25efef794739a>)Â hGraph )
     Destroys a graph.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuGraphDestroyNode](<#group__CUDA__GRAPH_1g00ed16434d983d8f0011683eacaf19b9>) ( [CUgraphNode](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc72514a94dacc85ed0617f979211079c>)Â hNode )
     Remove a node from the graph.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuGraphEventRecordNodeGetEvent](<#group__CUDA__GRAPH_1gb3608efc284aa2bbe5db61826d6e2259>) ( [CUgraphNode](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc72514a94dacc85ed0617f979211079c>)Â hNode, [CUevent](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g6d740185cf0953636d4ae37f68d7559b>)*Â event_out )
     Returns the event associated with an event record node.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuGraphEventRecordNodeSetEvent](<#group__CUDA__GRAPH_1g8ad8006aa7865865bf4d8c475cb21d87>) ( [CUgraphNode](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc72514a94dacc85ed0617f979211079c>)Â hNode, [CUevent](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g6d740185cf0953636d4ae37f68d7559b>)Â event )
     Sets an event record node's event.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuGraphEventWaitNodeGetEvent](<#group__CUDA__GRAPH_1g90b9d60f3f5f4156d1351a96ce92846e>) ( [CUgraphNode](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc72514a94dacc85ed0617f979211079c>)Â hNode, [CUevent](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g6d740185cf0953636d4ae37f68d7559b>)*Â event_out )
     Returns the event associated with an event wait node.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuGraphEventWaitNodeSetEvent](<#group__CUDA__GRAPH_1g2d6730d63efd399d3000952c54134930>) ( [CUgraphNode](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc72514a94dacc85ed0617f979211079c>)Â hNode, [CUevent](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g6d740185cf0953636d4ae37f68d7559b>)Â event )
     Sets an event wait node's event.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuGraphExecBatchMemOpNodeSetParams](<#group__CUDA__GRAPH_1g23f51bb4e4c029bb32fac0146e38c076>) ( [CUgraphExec](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gf0abeceeaa9f0a39592fe36a538ea1f0>)Â hGraphExec, [CUgraphNode](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc72514a94dacc85ed0617f979211079c>)Â hNode, const [CUDA_BATCH_MEM_OP_NODE_PARAMS](<structCUDA__BATCH__MEM__OP__NODE__PARAMS__v1.html#structCUDA__BATCH__MEM__OP__NODE__PARAMS__v1>)*Â nodeParams )
     Sets the parameters for a batch mem op node in the given graphExec.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuGraphExecChildGraphNodeSetParams](<#group__CUDA__GRAPH_1g8f2d9893f6b899f992db1a2942ec03ff>) ( [CUgraphExec](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gf0abeceeaa9f0a39592fe36a538ea1f0>)Â hGraphExec, [CUgraphNode](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc72514a94dacc85ed0617f979211079c>)Â hNode, [CUgraph](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g69f555c38df5b3fa1ed25efef794739a>)Â childGraph )
     Updates node parameters in the child graph node in the given graphExec.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuGraphExecDestroy](<#group__CUDA__GRAPH_1ga32ad4944cc5d408158207c978bc43a7>) ( [CUgraphExec](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gf0abeceeaa9f0a39592fe36a538ea1f0>)Â hGraphExec )
     Destroys an executable graph.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuGraphExecEventRecordNodeSetEvent](<#group__CUDA__GRAPH_1g62fea841fdc169c3ef18e9199f28a6a7>) ( [CUgraphExec](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gf0abeceeaa9f0a39592fe36a538ea1f0>)Â hGraphExec, [CUgraphNode](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc72514a94dacc85ed0617f979211079c>)Â hNode, [CUevent](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g6d740185cf0953636d4ae37f68d7559b>)Â event )
     Sets the event for an event record node in the given graphExec.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuGraphExecEventWaitNodeSetEvent](<#group__CUDA__GRAPH_1gfea9619d6ff228401613febae793f996>) ( [CUgraphExec](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gf0abeceeaa9f0a39592fe36a538ea1f0>)Â hGraphExec, [CUgraphNode](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc72514a94dacc85ed0617f979211079c>)Â hNode, [CUevent](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g6d740185cf0953636d4ae37f68d7559b>)Â event )
     Sets the event for an event wait node in the given graphExec.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuGraphExecExternalSemaphoresSignalNodeSetParams](<#group__CUDA__GRAPH_1g96aedf2977d0dce275fa3b3cf3700ade>) ( [CUgraphExec](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gf0abeceeaa9f0a39592fe36a538ea1f0>)Â hGraphExec, [CUgraphNode](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc72514a94dacc85ed0617f979211079c>)Â hNode, const [CUDA_EXT_SEM_SIGNAL_NODE_PARAMS](<structCUDA__EXT__SEM__SIGNAL__NODE__PARAMS__v1.html#structCUDA__EXT__SEM__SIGNAL__NODE__PARAMS__v1>)*Â nodeParams )
     Sets the parameters for an external semaphore signal node in the given graphExec.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuGraphExecExternalSemaphoresWaitNodeSetParams](<#group__CUDA__GRAPH_1g98a93c41b057cc1b48c0498811f65ad3>) ( [CUgraphExec](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gf0abeceeaa9f0a39592fe36a538ea1f0>)Â hGraphExec, [CUgraphNode](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc72514a94dacc85ed0617f979211079c>)Â hNode, const [CUDA_EXT_SEM_WAIT_NODE_PARAMS](<structCUDA__EXT__SEM__WAIT__NODE__PARAMS__v1.html#structCUDA__EXT__SEM__WAIT__NODE__PARAMS__v1>)*Â nodeParams )
     Sets the parameters for an external semaphore wait node in the given graphExec.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuGraphExecGetFlags](<#group__CUDA__GRAPH_1g5004de43ce63398a1a7d7a57edf17d9a>) ( [CUgraphExec](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gf0abeceeaa9f0a39592fe36a538ea1f0>)Â hGraphExec, cuuint64_t*Â flags )
     Query the instantiation flags of an executable graph.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuGraphExecGetId](<#group__CUDA__GRAPH_1g7a561a95ac508d0a99bccbf89aa01509>) ( [CUgraphExec](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gf0abeceeaa9f0a39592fe36a538ea1f0>)Â hGraphExec, unsigned int*Â graphId )
     Returns the id of a given graph exec.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuGraphExecHostNodeSetParams](<#group__CUDA__GRAPH_1ga549b946cedb73dc2596314b2d52f8d8>) ( [CUgraphExec](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gf0abeceeaa9f0a39592fe36a538ea1f0>)Â hGraphExec, [CUgraphNode](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc72514a94dacc85ed0617f979211079c>)Â hNode, const [CUDA_HOST_NODE_PARAMS](<structCUDA__HOST__NODE__PARAMS__v1.html#structCUDA__HOST__NODE__PARAMS__v1>)*Â nodeParams )
     Sets the parameters for a host node in the given graphExec.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuGraphExecKernelNodeSetParams](<#group__CUDA__GRAPH_1gd84243569e4c3d6356b9f2eea20ed48c>) ( [CUgraphExec](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gf0abeceeaa9f0a39592fe36a538ea1f0>)Â hGraphExec, [CUgraphNode](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc72514a94dacc85ed0617f979211079c>)Â hNode, const [CUDA_KERNEL_NODE_PARAMS](<structCUDA__KERNEL__NODE__PARAMS__v2.html#structCUDA__KERNEL__NODE__PARAMS__v2>)*Â nodeParams )
     Sets the parameters for a kernel node in the given graphExec.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuGraphExecMemcpyNodeSetParams](<#group__CUDA__GRAPH_1g26186d58858ab32ccc7425b53786cce5>) ( [CUgraphExec](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gf0abeceeaa9f0a39592fe36a538ea1f0>)Â hGraphExec, [CUgraphNode](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc72514a94dacc85ed0617f979211079c>)Â hNode, const [CUDA_MEMCPY3D](<structCUDA__MEMCPY3D__v2.html#structCUDA__MEMCPY3D__v2>)*Â copyParams, [CUcontext](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gf9f5bd81658f866613785b3a0bb7d7d9>)Â ctx )
     Sets the parameters for a memcpy node in the given graphExec.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuGraphExecMemsetNodeSetParams](<#group__CUDA__GRAPH_1g5df5be09a0b7b3513e740ebbbcd59739>) ( [CUgraphExec](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gf0abeceeaa9f0a39592fe36a538ea1f0>)Â hGraphExec, [CUgraphNode](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc72514a94dacc85ed0617f979211079c>)Â hNode, const [CUDA_MEMSET_NODE_PARAMS](<structCUDA__MEMSET__NODE__PARAMS__v1.html#structCUDA__MEMSET__NODE__PARAMS__v1>)*Â memsetParams, [CUcontext](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gf9f5bd81658f866613785b3a0bb7d7d9>)Â ctx )
     Sets the parameters for a memset node in the given graphExec.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuGraphExecNodeSetParams](<#group__CUDA__GRAPH_1gb318c5b61ada0e333bb12d1d33dae48b>) ( [CUgraphExec](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gf0abeceeaa9f0a39592fe36a538ea1f0>)Â hGraphExec, [CUgraphNode](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc72514a94dacc85ed0617f979211079c>)Â hNode, [CUgraphNodeParams](<structCUgraphNodeParams.html#structCUgraphNodeParams>)*Â nodeParams )
     Update's a graph node's parameters in an instantiated graph.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuGraphExecUpdate](<#group__CUDA__GRAPH_1g96efefc56df46927da7297f122adfb9f>) ( [CUgraphExec](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gf0abeceeaa9f0a39592fe36a538ea1f0>)Â hGraphExec, [CUgraph](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g69f555c38df5b3fa1ed25efef794739a>)Â hGraph, [CUgraphExecUpdateResultInfo](<structCUgraphExecUpdateResultInfo__v1.html#structCUgraphExecUpdateResultInfo__v1>)*Â resultInfo )
     Check whether an executable graph can be updated with a graph and perform the update if possible.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuGraphExternalSemaphoresSignalNodeGetParams](<#group__CUDA__GRAPH_1ga9f9b30ce6eb9f45d691190b20f34126>) ( [CUgraphNode](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc72514a94dacc85ed0617f979211079c>)Â hNode, [CUDA_EXT_SEM_SIGNAL_NODE_PARAMS](<structCUDA__EXT__SEM__SIGNAL__NODE__PARAMS__v1.html#structCUDA__EXT__SEM__SIGNAL__NODE__PARAMS__v1>)*Â params_out )
     Returns an external semaphore signal node's parameters.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuGraphExternalSemaphoresSignalNodeSetParams](<#group__CUDA__GRAPH_1g7a344ed4c6a5fcaad7bc7c53b04c6099>) ( [CUgraphNode](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc72514a94dacc85ed0617f979211079c>)Â hNode, const [CUDA_EXT_SEM_SIGNAL_NODE_PARAMS](<structCUDA__EXT__SEM__SIGNAL__NODE__PARAMS__v1.html#structCUDA__EXT__SEM__SIGNAL__NODE__PARAMS__v1>)*Â nodeParams )
     Sets an external semaphore signal node's parameters.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuGraphExternalSemaphoresWaitNodeGetParams](<#group__CUDA__GRAPH_1g1430da6d26a58818a4712d135cf37a54>) ( [CUgraphNode](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc72514a94dacc85ed0617f979211079c>)Â hNode, [CUDA_EXT_SEM_WAIT_NODE_PARAMS](<structCUDA__EXT__SEM__WAIT__NODE__PARAMS__v1.html#structCUDA__EXT__SEM__WAIT__NODE__PARAMS__v1>)*Â params_out )
     Returns an external semaphore wait node's parameters.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuGraphExternalSemaphoresWaitNodeSetParams](<#group__CUDA__GRAPH_1ge8b93792930a21ec352d6efd2c21c8c0>) ( [CUgraphNode](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc72514a94dacc85ed0617f979211079c>)Â hNode, const [CUDA_EXT_SEM_WAIT_NODE_PARAMS](<structCUDA__EXT__SEM__WAIT__NODE__PARAMS__v1.html#structCUDA__EXT__SEM__WAIT__NODE__PARAMS__v1>)*Â nodeParams )
     Sets an external semaphore wait node's parameters.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuGraphGetEdges](<#group__CUDA__GRAPH_1g4e3183ca455aae2e832edd4034094082>) ( [CUgraph](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g69f555c38df5b3fa1ed25efef794739a>)Â hGraph, [CUgraphNode](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc72514a94dacc85ed0617f979211079c>)*Â from, [CUgraphNode](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc72514a94dacc85ed0617f979211079c>)*Â to, [CUgraphEdgeData](<structCUgraphEdgeData.html#structCUgraphEdgeData>)*Â edgeData, size_t*Â numEdges )
     Returns a graph's dependency edges.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuGraphGetId](<#group__CUDA__GRAPH_1g0f05ae29d14198ff57d722156d60aa41>) ( [CUgraph](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g69f555c38df5b3fa1ed25efef794739a>)Â hGraph, unsigned int*Â graphId )
     Returns the id of a given graph.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuGraphGetNodes](<#group__CUDA__GRAPH_1gfa35a8e2d2fc32f48dbd67ba27cf27e5>) ( [CUgraph](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g69f555c38df5b3fa1ed25efef794739a>)Â hGraph, [CUgraphNode](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc72514a94dacc85ed0617f979211079c>)*Â nodes, size_t*Â numNodes )
     Returns a graph's nodes.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuGraphGetRootNodes](<#group__CUDA__GRAPH_1gf8517646bd8b39ab6359f8e7f0edffbd>) ( [CUgraph](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g69f555c38df5b3fa1ed25efef794739a>)Â hGraph, [CUgraphNode](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc72514a94dacc85ed0617f979211079c>)*Â rootNodes, size_t*Â numRootNodes )
     Returns a graph's root nodes.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuGraphHostNodeGetParams](<#group__CUDA__GRAPH_1g2e3ea6000089fd5523c197ab5e73d5a2>) ( [CUgraphNode](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc72514a94dacc85ed0617f979211079c>)Â hNode, [CUDA_HOST_NODE_PARAMS](<structCUDA__HOST__NODE__PARAMS__v1.html#structCUDA__HOST__NODE__PARAMS__v1>)*Â nodeParams )
     Returns a host node's parameters.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuGraphHostNodeSetParams](<#group__CUDA__GRAPH_1gae021ae8f19ee51044339db9c24dd266>) ( [CUgraphNode](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc72514a94dacc85ed0617f979211079c>)Â hNode, const [CUDA_HOST_NODE_PARAMS](<structCUDA__HOST__NODE__PARAMS__v1.html#structCUDA__HOST__NODE__PARAMS__v1>)*Â nodeParams )
     Sets a host node's parameters.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuGraphInstantiate](<#group__CUDA__GRAPH_1gb53b435e178cccfa37ac87285d2c3fa1>) ( [CUgraphExec](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gf0abeceeaa9f0a39592fe36a538ea1f0>)*Â phGraphExec, [CUgraph](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g69f555c38df5b3fa1ed25efef794739a>)Â hGraph, unsigned long longÂ flags )
     Creates an executable graph from a graph.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuGraphInstantiateWithParams](<#group__CUDA__GRAPH_1g8d9541e4df43ee8440e794634a0d1af8>) ( [CUgraphExec](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gf0abeceeaa9f0a39592fe36a538ea1f0>)*Â phGraphExec, [CUgraph](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g69f555c38df5b3fa1ed25efef794739a>)Â hGraph, [CUDA_GRAPH_INSTANTIATE_PARAMS](<structCUDA__GRAPH__INSTANTIATE__PARAMS.html#structCUDA__GRAPH__INSTANTIATE__PARAMS>)*Â instantiateParams )
     Creates an executable graph from a graph.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuGraphKernelNodeCopyAttributes](<#group__CUDA__GRAPH_1ga5f4e6786704bf710b61a26146c51c9e>) ( [CUgraphNode](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc72514a94dacc85ed0617f979211079c>)Â dst, [CUgraphNode](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc72514a94dacc85ed0617f979211079c>)Â src )
     Copies attributes from source node to destination node.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuGraphKernelNodeGetAttribute](<#group__CUDA__GRAPH_1g9827e34c800e2f2cb4d9a6f4e186f796>) ( [CUgraphNode](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc72514a94dacc85ed0617f979211079c>)Â hNode, [CUkernelNodeAttrID](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g6f6565b334be6bb3134868e10bbdd331>)Â attr, [CUkernelNodeAttrValue](<unionCUlaunchAttributeValue.html#unionCUlaunchAttributeValue>)*Â value_out )
     Queries node attribute.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuGraphKernelNodeGetParams](<#group__CUDA__GRAPH_1gb8df3f99e8dd5e4f4a5a0f19a5518252>) ( [CUgraphNode](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc72514a94dacc85ed0617f979211079c>)Â hNode, [CUDA_KERNEL_NODE_PARAMS](<structCUDA__KERNEL__NODE__PARAMS__v2.html#structCUDA__KERNEL__NODE__PARAMS__v2>)*Â nodeParams )
     Returns a kernel node's parameters.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuGraphKernelNodeSetAttribute](<#group__CUDA__GRAPH_1gd888774df6c1d0774bee49ec9442eefc>) ( [CUgraphNode](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc72514a94dacc85ed0617f979211079c>)Â hNode, [CUkernelNodeAttrID](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g6f6565b334be6bb3134868e10bbdd331>)Â attr, const [CUkernelNodeAttrValue](<unionCUlaunchAttributeValue.html#unionCUlaunchAttributeValue>)*Â value )
     Sets node attribute.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuGraphKernelNodeSetParams](<#group__CUDA__GRAPH_1ga268bf2fd520f5aa3a3d700005df6703>) ( [CUgraphNode](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc72514a94dacc85ed0617f979211079c>)Â hNode, const [CUDA_KERNEL_NODE_PARAMS](<structCUDA__KERNEL__NODE__PARAMS__v2.html#structCUDA__KERNEL__NODE__PARAMS__v2>)*Â nodeParams )
     Sets a kernel node's parameters.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuGraphLaunch](<#group__CUDA__GRAPH_1g6b2dceb3901e71a390d2bd8b0491e471>) ( [CUgraphExec](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gf0abeceeaa9f0a39592fe36a538ea1f0>)Â hGraphExec, [CUstream](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gb946c7f02e09efd788a204718015d88a>)Â hStream )
     Launches an executable graph in a stream.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuGraphMemAllocNodeGetParams](<#group__CUDA__GRAPH_1gee2c7d66d3d96b1470c1d1a769f250a2>) ( [CUgraphNode](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc72514a94dacc85ed0617f979211079c>)Â hNode, [CUDA_MEM_ALLOC_NODE_PARAMS](<structCUDA__MEM__ALLOC__NODE__PARAMS__v1.html#structCUDA__MEM__ALLOC__NODE__PARAMS__v1>)*Â params_out )
     Returns a memory alloc node's parameters.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuGraphMemFreeNodeGetParams](<#group__CUDA__GRAPH_1gd24d9fe5769222a2367e3f571fb2f28b>) ( [CUgraphNode](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc72514a94dacc85ed0617f979211079c>)Â hNode, [CUdeviceptr](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g183f7b0d8ad008ea2a5fd552537ace4e>)*Â dptr_out )
     Returns a memory free node's parameters.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuGraphMemcpyNodeGetParams](<#group__CUDA__GRAPH_1g572889131dbc31720eff94b130f4005b>) ( [CUgraphNode](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc72514a94dacc85ed0617f979211079c>)Â hNode, [CUDA_MEMCPY3D](<structCUDA__MEMCPY3D__v2.html#structCUDA__MEMCPY3D__v2>)*Â nodeParams )
     Returns a memcpy node's parameters.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuGraphMemcpyNodeSetParams](<#group__CUDA__GRAPH_1ga278a7ec0700c86abb0b2cfdf4d3dc1d>) ( [CUgraphNode](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc72514a94dacc85ed0617f979211079c>)Â hNode, const [CUDA_MEMCPY3D](<structCUDA__MEMCPY3D__v2.html#structCUDA__MEMCPY3D__v2>)*Â nodeParams )
     Sets a memcpy node's parameters.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuGraphMemsetNodeGetParams](<#group__CUDA__GRAPH_1g18830edcfd982f952820a0d7f91b894a>) ( [CUgraphNode](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc72514a94dacc85ed0617f979211079c>)Â hNode, [CUDA_MEMSET_NODE_PARAMS](<structCUDA__MEMSET__NODE__PARAMS__v1.html#structCUDA__MEMSET__NODE__PARAMS__v1>)*Â nodeParams )
     Returns a memset node's parameters.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuGraphMemsetNodeSetParams](<#group__CUDA__GRAPH_1gc27f3fd83a6e33c74519066fbaa0de67>) ( [CUgraphNode](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc72514a94dacc85ed0617f979211079c>)Â hNode, const [CUDA_MEMSET_NODE_PARAMS](<structCUDA__MEMSET__NODE__PARAMS__v1.html#structCUDA__MEMSET__NODE__PARAMS__v1>)*Â nodeParams )
     Sets a memset node's parameters.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuGraphNodeFindInClone](<#group__CUDA__GRAPH_1gf21f6c968e346f028737c1118bfd41c2>) ( [CUgraphNode](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc72514a94dacc85ed0617f979211079c>)*Â phNode, [CUgraphNode](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc72514a94dacc85ed0617f979211079c>)Â hOriginalNode, [CUgraph](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g69f555c38df5b3fa1ed25efef794739a>)Â hClonedGraph )
     Finds a cloned version of a node.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuGraphNodeGetContainingGraph](<#group__CUDA__GRAPH_1gbbfe267adf728f1c53aa9d99ba101b92>) ( [CUgraphNode](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc72514a94dacc85ed0617f979211079c>)Â hNode, [CUgraph](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g69f555c38df5b3fa1ed25efef794739a>)*Â phGraph )
     Returns the graph that contains a given graph node.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuGraphNodeGetDependencies](<#group__CUDA__GRAPH_1gd3fc7f62e46f621f59de2173e08fccc9>) ( [CUgraphNode](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc72514a94dacc85ed0617f979211079c>)Â hNode, [CUgraphNode](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc72514a94dacc85ed0617f979211079c>)*Â dependencies, [CUgraphEdgeData](<structCUgraphEdgeData.html#structCUgraphEdgeData>)*Â edgeData, size_t*Â numDependencies )
     Returns a node's dependencies.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuGraphNodeGetDependentNodes](<#group__CUDA__GRAPH_1g61e907fa6896b5393246d1588c794450>) ( [CUgraphNode](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc72514a94dacc85ed0617f979211079c>)Â hNode, [CUgraphNode](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc72514a94dacc85ed0617f979211079c>)*Â dependentNodes, [CUgraphEdgeData](<structCUgraphEdgeData.html#structCUgraphEdgeData>)*Â edgeData, size_t*Â numDependentNodes )
     Returns a node's dependent nodes.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuGraphNodeGetEnabled](<#group__CUDA__GRAPH_1g428f51dceec6f6211bb9c1d710925a3d>) ( [CUgraphExec](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gf0abeceeaa9f0a39592fe36a538ea1f0>)Â hGraphExec, [CUgraphNode](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc72514a94dacc85ed0617f979211079c>)Â hNode, unsigned int*Â isEnabled )
     Query whether a node in the given graphExec is enabled.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuGraphNodeGetLocalId](<#group__CUDA__GRAPH_1g18fd5107a28aaae1e396efcb0edaa70d>) ( [CUgraphNode](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc72514a94dacc85ed0617f979211079c>)Â hNode, unsigned int*Â nodeId )
     Returns the local node id of a given graph node.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuGraphNodeGetToolsId](<#group__CUDA__GRAPH_1g10d4cf58921a26acce90ed1a03fcd4c1>) ( [CUgraphNode](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc72514a94dacc85ed0617f979211079c>)Â hNode, unsigned long long*Â toolsNodeId )
     Returns an id used by tools to identify a given node.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuGraphNodeGetType](<#group__CUDA__GRAPH_1gdb1776d97aa1c9d5144774b29e4b8c3e>) ( [CUgraphNode](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc72514a94dacc85ed0617f979211079c>)Â hNode, [CUgraphNodeType](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g0731a28f826922120d783d8444e154dc>)*Â type )
     Returns a node's type.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuGraphNodeSetEnabled](<#group__CUDA__GRAPH_1g371b20eb0c0658731e38db7e68f12c78>) ( [CUgraphExec](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gf0abeceeaa9f0a39592fe36a538ea1f0>)Â hGraphExec, [CUgraphNode](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc72514a94dacc85ed0617f979211079c>)Â hNode, unsigned int Â isEnabled )
     Enables or disables the specified node in the given graphExec.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuGraphNodeSetParams](<#group__CUDA__GRAPH_1gbf18157f40ea2d160cb0b9e4e2b16139>) ( [CUgraphNode](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc72514a94dacc85ed0617f979211079c>)Â hNode, [CUgraphNodeParams](<structCUgraphNodeParams.html#structCUgraphNodeParams>)*Â nodeParams )
     Update's a graph node's parameters.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuGraphReleaseUserObject](<#group__CUDA__GRAPH_1g232c84cc31e13e4201a421e28561eebf>) ( [CUgraph](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g69f555c38df5b3fa1ed25efef794739a>)Â graph, [CUuserObject](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g2578b65c87dc98d336f99edca913e92b>)Â object, unsigned int Â count )
     Release a user object reference from a graph.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuGraphRemoveDependencies](<#group__CUDA__GRAPH_1g25048b696f56b4d6131f068074176301>) ( [CUgraph](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g69f555c38df5b3fa1ed25efef794739a>)Â hGraph, const [CUgraphNode](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc72514a94dacc85ed0617f979211079c>)*Â from, const [CUgraphNode](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc72514a94dacc85ed0617f979211079c>)*Â to, const [CUgraphEdgeData](<structCUgraphEdgeData.html#structCUgraphEdgeData>)*Â edgeData, size_tÂ numDependencies )
     Removes dependency edges from a graph.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuGraphRetainUserObject](<#group__CUDA__GRAPH_1gaffd130c928e56740a2a5aaeb6125c8a>) ( [CUgraph](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g69f555c38df5b3fa1ed25efef794739a>)Â graph, [CUuserObject](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g2578b65c87dc98d336f99edca913e92b>)Â object, unsigned int Â count, unsigned int Â flags )
     Retain a reference to a user object from a graph.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuGraphUpload](<#group__CUDA__GRAPH_1ga7eb9849e6e4604864a482b38f25be48>) ( [CUgraphExec](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gf0abeceeaa9f0a39592fe36a538ea1f0>)Â hGraphExec, [CUstream](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gb946c7f02e09efd788a204718015d88a>)Â hStream )
     Uploads an executable graph in a stream.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuUserObjectCreate](<#group__CUDA__GRAPH_1g58f04e0ac0ad23d2f15ea6e9f6c8a999>) ( [CUuserObject](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g2578b65c87dc98d336f99edca913e92b>)*Â object_out, void*Â ptr, [CUhostFn](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g262cd3570ff5d396db4e3dabede3c355>)Â destroy, unsigned int Â initialRefcount, unsigned int Â flags )
     Create a user object.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuUserObjectRelease](<#group__CUDA__GRAPH_1ga2c16918341b8d020c9246e75658cc80>) ( [CUuserObject](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g2578b65c87dc98d336f99edca913e92b>)Â object, unsigned int Â count )
     Release a reference to a user object.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuUserObjectRetain](<#group__CUDA__GRAPH_1ge022bcecdeca2d14cc8f28afc6a2eaf6>) ( [CUuserObject](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g2578b65c87dc98d336f99edca913e92b>)Â object, unsigned int Â count )
     Retain a reference to a user object.

### Functions

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuDeviceGetGraphMemAttribute ( [CUdevice](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g41ca2a24a242b36ef2ca77330b5fb72a>)Â device, [CUgraphMem_attribute](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g5f76366f87bbdf761007768fe30a57db>)Â attr, void*Â value )


Query asynchronous allocation attributes related to graphs.

######  Parameters

`device`
    \- Specifies the scope of the query
`attr`
    \- attribute to get
`value`
    \- retrieved value

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_INVALID_DEVICE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e96f047e7215788ca96c81af92a04bfb6c>)

###### Description

Valid attributes are:

  * [CU_GRAPH_MEM_ATTR_USED_MEM_CURRENT](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg5f76366f87bbdf761007768fe30a57dbd64476ce9c5839854a7a82cee4b882af>): Amount of memory, in bytes, currently associated with graphs

  * [CU_GRAPH_MEM_ATTR_USED_MEM_HIGH](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg5f76366f87bbdf761007768fe30a57db21e8caa067ac3b5264197b4d445575ce>): High watermark of memory, in bytes, associated with graphs since the last time it was reset. High watermark can only be reset to zero.

  * [CU_GRAPH_MEM_ATTR_RESERVED_MEM_CURRENT](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg5f76366f87bbdf761007768fe30a57db365a64945f1af3af1b3e50aca699cf55>): Amount of memory, in bytes, currently allocated for use by the CUDA graphs asynchronous allocator.

  * [CU_GRAPH_MEM_ATTR_RESERVED_MEM_HIGH](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg5f76366f87bbdf761007768fe30a57dbef25946b479b24908620814513f6acd4>): High watermark of memory, in bytes, currently allocated for use by the CUDA graphs asynchronous allocator.


**See also:**

[cuDeviceSetGraphMemAttribute](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1g064bd5c6a773b83d145c281ebf5dbe34> "Set asynchronous allocation attributes related to graphs."), [cuGraphAddMemAllocNode](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1g73a351cb71b2945a0bcb913a93f69ec9> "Creates an allocation node and adds it to a graph."), [cuGraphAddMemFreeNode](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1geb7cdce5d9be2d28d9428e74eb00fa53> "Creates a memory free node and adds it to a graph.")

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuDeviceGraphMemTrim ( [CUdevice](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g41ca2a24a242b36ef2ca77330b5fb72a>)Â device )


Free unused memory that was cached on the specified device for use with graphs back to the OS.

######  Parameters

`device`
    \- The device for which cached memory should be freed.

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_INVALID_DEVICE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e96f047e7215788ca96c81af92a04bfb6c>)

###### Description

Blocks which are not in use by a graph that is either currently executing or scheduled to execute are freed back to the operating system.

**See also:**

[cuGraphAddMemAllocNode](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1g73a351cb71b2945a0bcb913a93f69ec9> "Creates an allocation node and adds it to a graph."), [cuGraphAddMemFreeNode](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1geb7cdce5d9be2d28d9428e74eb00fa53> "Creates a memory free node and adds it to a graph."), [cuDeviceSetGraphMemAttribute](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1g064bd5c6a773b83d145c281ebf5dbe34> "Set asynchronous allocation attributes related to graphs."), [cuDeviceGetGraphMemAttribute](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1g359903c2447ac22b4e1a0dce26adfef5> "Query asynchronous allocation attributes related to graphs.")

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuDeviceSetGraphMemAttribute ( [CUdevice](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g41ca2a24a242b36ef2ca77330b5fb72a>)Â device, [CUgraphMem_attribute](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g5f76366f87bbdf761007768fe30a57db>)Â attr, void*Â value )


Set asynchronous allocation attributes related to graphs.

######  Parameters

`device`
    \- Specifies the scope of the query
`attr`
    \- attribute to get
`value`
    \- pointer to value to set

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_INVALID_DEVICE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e96f047e7215788ca96c81af92a04bfb6c>)

###### Description

Valid attributes are:

  * [CU_GRAPH_MEM_ATTR_USED_MEM_HIGH](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg5f76366f87bbdf761007768fe30a57db21e8caa067ac3b5264197b4d445575ce>): High watermark of memory, in bytes, associated with graphs since the last time it was reset. High watermark can only be reset to zero.

  * [CU_GRAPH_MEM_ATTR_RESERVED_MEM_HIGH](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg5f76366f87bbdf761007768fe30a57dbef25946b479b24908620814513f6acd4>): High watermark of memory, in bytes, currently allocated for use by the CUDA graphs asynchronous allocator.


**See also:**

[cuDeviceGetGraphMemAttribute](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1g359903c2447ac22b4e1a0dce26adfef5> "Query asynchronous allocation attributes related to graphs."), [cuGraphAddMemAllocNode](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1g73a351cb71b2945a0bcb913a93f69ec9> "Creates an allocation node and adds it to a graph."), [cuGraphAddMemFreeNode](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1geb7cdce5d9be2d28d9428e74eb00fa53> "Creates a memory free node and adds it to a graph.")

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuGraphAddBatchMemOpNode ( [CUgraphNode](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc72514a94dacc85ed0617f979211079c>)*Â phGraphNode, [CUgraph](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g69f555c38df5b3fa1ed25efef794739a>)Â hGraph, const [CUgraphNode](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc72514a94dacc85ed0617f979211079c>)*Â dependencies, size_tÂ numDependencies, const [CUDA_BATCH_MEM_OP_NODE_PARAMS](<structCUDA__BATCH__MEM__OP__NODE__PARAMS__v1.html#structCUDA__BATCH__MEM__OP__NODE__PARAMS__v1>)*Â nodeParams )


Creates a batch memory operation node and adds it to a graph.

######  Parameters

`phGraphNode`
    \- Returns newly created node
`hGraph`
    \- Graph to which to add the node
`dependencies`
    \- Dependencies of the node
`numDependencies`
    \- Number of dependencies
`nodeParams`
    \- Parameters for the node

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_DEINITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9acf52f132faf29b473cdda6061f0f44a>), [CUDA_ERROR_NOT_INITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e98feb999f0af99b4a25ab26b3866f4df8>), [CUDA_ERROR_NOT_SUPPORTED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e954756ae7ade0dfd09faeccb513dd831b>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>)

###### Description

Creates a new batch memory operation node and adds it to `hGraph` with `numDependencies` dependencies specified via `dependencies` and arguments specified in `nodeParams`. It is possible for `numDependencies` to be 0, in which case the node will be placed at the root of the graph. `dependencies` may not have any duplicate entries. A handle to the new node will be returned in `phGraphNode`.

When the node is added, the paramArray inside `nodeParams` is copied and therefore it can be freed after the call returns.

Note:

Warning: Improper use of this API may deadlock the application. Synchronization ordering established through this API is not visible to CUDA. CUDA tasks that are (even indirectly) ordered by this API should also have that order expressed with CUDA-visible dependencies such as events. This ensures that the scheduler does not serialize them in an improper order.

Note:

  * Graph objects are not threadsafe. [More here](<graphs-thread-safety.html#graphs-thread-safety>).

  * Note that this function may also return error codes from previous, asynchronous launches.


**See also:**

[cuGraphAddNode](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1ge01208e62f72a53367a2af903bf17d23> "Adds a node of arbitrary type to a graph."), [cuStreamBatchMemOp](<group__CUDA__MEMOP.html#group__CUDA__MEMOP_1g764c442de9b671f9dec856e8ae531ed1> "Batch operations to synchronize the stream via memory operations."), [cuStreamWaitValue32](<group__CUDA__MEMOP.html#group__CUDA__MEMOP_1g629856339de7bc6606047385addbb398> "Wait on a memory location."), [cuStreamWriteValue32](<group__CUDA__MEMOP.html#group__CUDA__MEMOP_1g091455366d56dc2f1f69726aafa369b0> "Write a value to memory."), [cuStreamWaitValue64](<group__CUDA__MEMOP.html#group__CUDA__MEMOP_1g6910c1258c5f15aa5d699f0fd60d6933> "Wait on a memory location."), [cuStreamWriteValue64](<group__CUDA__MEMOP.html#group__CUDA__MEMOP_1gc8af1e8b96d7561840affd5217dd6830> "Write a value to memory."), [cuGraphBatchMemOpNodeGetParams](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1g1d8039468b71285c61bc03ab3c302a28> "Returns a batch mem op node's parameters."), [cuGraphBatchMemOpNodeSetParams](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1g625ca946b58df3d17221ff7db5cd7800> "Sets a batch mem op node's parameters."), [cuGraphCreate](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1gd885f719186010727b75c3315f865fdf> "Creates a graph."), [cuGraphDestroyNode](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1g00ed16434d983d8f0011683eacaf19b9> "Remove a node from the graph."), [cuGraphAddChildGraphNode](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1gde52afbcf91a8c79d4d7efbe0e3b6844> "Creates a child graph node and adds it to a graph."), [cuGraphAddEmptyNode](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1g14b625984430cb2d574c63f29c9b9223> "Creates an empty node and adds it to a graph."), [cuGraphAddKernelNode](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1g50d871e3bd06c1b835e52f2966ef366b> "Creates a kernel execution node and adds it to a graph."), [cuGraphAddMemcpyNode](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1g674da6ab54a677f13e0e0e8206ff5073> "Creates a memcpy node and adds it to a graph."), [cuGraphAddMemsetNode](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1g89dc8fc3743392777c0daa2c4aca40d3> "Creates a memset node and adds it to a graph.")

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuGraphAddChildGraphNode ( [CUgraphNode](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc72514a94dacc85ed0617f979211079c>)*Â phGraphNode, [CUgraph](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g69f555c38df5b3fa1ed25efef794739a>)Â hGraph, const [CUgraphNode](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc72514a94dacc85ed0617f979211079c>)*Â dependencies, size_tÂ numDependencies, [CUgraph](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g69f555c38df5b3fa1ed25efef794739a>)Â childGraph )


Creates a child graph node and adds it to a graph.

######  Parameters

`phGraphNode`
    \- Returns newly created node
`hGraph`
    \- Graph to which to add the node
`dependencies`
    \- Dependencies of the node
`numDependencies`
    \- Number of dependencies
`childGraph`
    \- The graph to clone into this node

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_DEINITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9acf52f132faf29b473cdda6061f0f44a>), [CUDA_ERROR_NOT_INITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e98feb999f0af99b4a25ab26b3866f4df8>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>),

###### Description

Creates a new node which executes an embedded graph, and adds it to `hGraph` with `numDependencies` dependencies specified via `dependencies`. It is possible for `numDependencies` to be 0, in which case the node will be placed at the root of the graph. `dependencies` may not have any duplicate entries. A handle to the new node will be returned in `phGraphNode`.

If `childGraph` contains allocation nodes, free nodes, or conditional nodes, this call will return an error.

The node executes an embedded child graph. The child graph is cloned in this call.

Note:

  * Graph objects are not threadsafe. [More here](<graphs-thread-safety.html#graphs-thread-safety>).

  * Note that this function may also return error codes from previous, asynchronous launches.


**See also:**

[cuGraphAddNode](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1ge01208e62f72a53367a2af903bf17d23> "Adds a node of arbitrary type to a graph."), [cuGraphChildGraphNodeGetGraph](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1gbe9fc9267316b3778ef0db507917b4fd> "Gets a handle to the embedded graph of a child graph node."), [cuGraphCreate](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1gd885f719186010727b75c3315f865fdf> "Creates a graph."), [cuGraphDestroyNode](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1g00ed16434d983d8f0011683eacaf19b9> "Remove a node from the graph."), [cuGraphAddEmptyNode](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1g14b625984430cb2d574c63f29c9b9223> "Creates an empty node and adds it to a graph."), [cuGraphAddKernelNode](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1g50d871e3bd06c1b835e52f2966ef366b> "Creates a kernel execution node and adds it to a graph."), [cuGraphAddHostNode](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1g0809d65e85a3c052296373954a05b1d6> "Creates a host execution node and adds it to a graph."), [cuGraphAddMemcpyNode](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1g674da6ab54a677f13e0e0e8206ff5073> "Creates a memcpy node and adds it to a graph."), [cuGraphAddMemsetNode](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1g89dc8fc3743392777c0daa2c4aca40d3> "Creates a memset node and adds it to a graph."), [cuGraphClone](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1g3603974654e463f2231c71d9b9d1517e> "Clones a graph.")

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuGraphAddDependencies ( [CUgraph](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g69f555c38df5b3fa1ed25efef794739a>)Â hGraph, const [CUgraphNode](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc72514a94dacc85ed0617f979211079c>)*Â from, const [CUgraphNode](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc72514a94dacc85ed0617f979211079c>)*Â to, const [CUgraphEdgeData](<structCUgraphEdgeData.html#structCUgraphEdgeData>)*Â edgeData, size_tÂ numDependencies )


Adds dependency edges to a graph.

######  Parameters

`hGraph`
    \- Graph to which dependencies are added
`from`
    \- Array of nodes that provide the dependencies
`to`
    \- Array of dependent nodes
`edgeData`
    \- Optional array of edge data. If NULL, default (zeroed) edge data is assumed.
`numDependencies`
    \- Number of dependencies to be added

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>)

###### Description

The number of dependencies to be added is defined by `numDependencies` Elements in `from` and `to` at corresponding indices define a dependency. Each node in `from` and `to` must belong to `hGraph`.

If `numDependencies` is 0, elements in `from` and `to` will be ignored. Specifying an existing dependency will return an error.

Note:

  * Graph objects are not threadsafe. [More here](<graphs-thread-safety.html#graphs-thread-safety>).

  * Note that this function may also return error codes from previous, asynchronous launches.


**See also:**

[cuGraphRemoveDependencies](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1g25048b696f56b4d6131f068074176301> "Removes dependency edges from a graph."), [cuGraphGetEdges](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1g4e3183ca455aae2e832edd4034094082> "Returns a graph's dependency edges."), [cuGraphNodeGetDependencies](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1gd3fc7f62e46f621f59de2173e08fccc9> "Returns a node's dependencies."), [cuGraphNodeGetDependentNodes](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1g61e907fa6896b5393246d1588c794450> "Returns a node's dependent nodes.")

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuGraphAddEmptyNode ( [CUgraphNode](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc72514a94dacc85ed0617f979211079c>)*Â phGraphNode, [CUgraph](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g69f555c38df5b3fa1ed25efef794739a>)Â hGraph, const [CUgraphNode](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc72514a94dacc85ed0617f979211079c>)*Â dependencies, size_tÂ numDependencies )


Creates an empty node and adds it to a graph.

######  Parameters

`phGraphNode`
    \- Returns newly created node
`hGraph`
    \- Graph to which to add the node
`dependencies`
    \- Dependencies of the node
`numDependencies`
    \- Number of dependencies

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_DEINITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9acf52f132faf29b473cdda6061f0f44a>), [CUDA_ERROR_NOT_INITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e98feb999f0af99b4a25ab26b3866f4df8>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>),

###### Description

Creates a new node which performs no operation, and adds it to `hGraph` with `numDependencies` dependencies specified via `dependencies`. It is possible for `numDependencies` to be 0, in which case the node will be placed at the root of the graph. `dependencies` may not have any duplicate entries. A handle to the new node will be returned in `phGraphNode`.

An empty node performs no operation during execution, but can be used for transitive ordering. For example, a phased execution graph with 2 groups of n nodes with a barrier between them can be represented using an empty node and 2*n dependency edges, rather than no empty node and n^2 dependency edges.

Note:

  * Graph objects are not threadsafe. [More here](<graphs-thread-safety.html#graphs-thread-safety>).

  * Note that this function may also return error codes from previous, asynchronous launches.


**See also:**

[cuGraphAddNode](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1ge01208e62f72a53367a2af903bf17d23> "Adds a node of arbitrary type to a graph."), [cuGraphCreate](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1gd885f719186010727b75c3315f865fdf> "Creates a graph."), [cuGraphDestroyNode](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1g00ed16434d983d8f0011683eacaf19b9> "Remove a node from the graph."), [cuGraphAddChildGraphNode](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1gde52afbcf91a8c79d4d7efbe0e3b6844> "Creates a child graph node and adds it to a graph."), [cuGraphAddKernelNode](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1g50d871e3bd06c1b835e52f2966ef366b> "Creates a kernel execution node and adds it to a graph."), [cuGraphAddHostNode](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1g0809d65e85a3c052296373954a05b1d6> "Creates a host execution node and adds it to a graph."), [cuGraphAddMemcpyNode](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1g674da6ab54a677f13e0e0e8206ff5073> "Creates a memcpy node and adds it to a graph."), [cuGraphAddMemsetNode](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1g89dc8fc3743392777c0daa2c4aca40d3> "Creates a memset node and adds it to a graph.")

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuGraphAddEventRecordNode ( [CUgraphNode](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc72514a94dacc85ed0617f979211079c>)*Â phGraphNode, [CUgraph](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g69f555c38df5b3fa1ed25efef794739a>)Â hGraph, const [CUgraphNode](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc72514a94dacc85ed0617f979211079c>)*Â dependencies, size_tÂ numDependencies, [CUevent](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g6d740185cf0953636d4ae37f68d7559b>)Â event )


Creates an event record node and adds it to a graph.

######  Parameters

`phGraphNode`
    \- Returns newly created node
`hGraph`
    \- Graph to which to add the node
`dependencies`
    \- Dependencies of the node
`numDependencies`
    \- Number of dependencies
`event`
    \- Event for the node

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_DEINITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9acf52f132faf29b473cdda6061f0f44a>), [CUDA_ERROR_NOT_INITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e98feb999f0af99b4a25ab26b3866f4df8>), [CUDA_ERROR_NOT_SUPPORTED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e954756ae7ade0dfd09faeccb513dd831b>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>)

###### Description

Creates a new event record node and adds it to `hGraph` with `numDependencies` dependencies specified via `dependencies` and event specified in `event`. It is possible for `numDependencies` to be 0, in which case the node will be placed at the root of the graph. `dependencies` may not have any duplicate entries. A handle to the new node will be returned in `phGraphNode`.

Each launch of the graph will record `event` to capture execution of the node's dependencies.

Note:

  * Graph objects are not threadsafe. [More here](<graphs-thread-safety.html#graphs-thread-safety>).

  * Note that this function may also return error codes from previous, asynchronous launches.


**See also:**

[cuGraphAddNode](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1ge01208e62f72a53367a2af903bf17d23> "Adds a node of arbitrary type to a graph."), [cuGraphAddEventWaitNode](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1g7306f3bcbec3406d80e110cd13405c5e> "Creates an event wait node and adds it to a graph."), [cuEventRecordWithFlags](<group__CUDA__EVENT.html#group__CUDA__EVENT_1ge577e0c132d9c4961f220d79f6762c4b> "Records an event."), [cuStreamWaitEvent](<group__CUDA__STREAM.html#group__CUDA__STREAM_1g6a898b652dfc6aa1d5c8d97062618b2f> "Make a compute stream wait on an event."), [cuGraphCreate](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1gd885f719186010727b75c3315f865fdf> "Creates a graph."), [cuGraphDestroyNode](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1g00ed16434d983d8f0011683eacaf19b9> "Remove a node from the graph."), [cuGraphAddChildGraphNode](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1gde52afbcf91a8c79d4d7efbe0e3b6844> "Creates a child graph node and adds it to a graph."), [cuGraphAddEmptyNode](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1g14b625984430cb2d574c63f29c9b9223> "Creates an empty node and adds it to a graph."), [cuGraphAddKernelNode](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1g50d871e3bd06c1b835e52f2966ef366b> "Creates a kernel execution node and adds it to a graph."), [cuGraphAddMemcpyNode](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1g674da6ab54a677f13e0e0e8206ff5073> "Creates a memcpy node and adds it to a graph."), [cuGraphAddMemsetNode](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1g89dc8fc3743392777c0daa2c4aca40d3> "Creates a memset node and adds it to a graph.")

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuGraphAddEventWaitNode ( [CUgraphNode](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc72514a94dacc85ed0617f979211079c>)*Â phGraphNode, [CUgraph](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g69f555c38df5b3fa1ed25efef794739a>)Â hGraph, const [CUgraphNode](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc72514a94dacc85ed0617f979211079c>)*Â dependencies, size_tÂ numDependencies, [CUevent](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g6d740185cf0953636d4ae37f68d7559b>)Â event )


Creates an event wait node and adds it to a graph.

######  Parameters

`phGraphNode`
    \- Returns newly created node
`hGraph`
    \- Graph to which to add the node
`dependencies`
    \- Dependencies of the node
`numDependencies`
    \- Number of dependencies
`event`
    \- Event for the node

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_DEINITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9acf52f132faf29b473cdda6061f0f44a>), [CUDA_ERROR_NOT_INITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e98feb999f0af99b4a25ab26b3866f4df8>), [CUDA_ERROR_NOT_SUPPORTED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e954756ae7ade0dfd09faeccb513dd831b>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>)

###### Description

Creates a new event wait node and adds it to `hGraph` with `numDependencies` dependencies specified via `dependencies` and event specified in `event`. It is possible for `numDependencies` to be 0, in which case the node will be placed at the root of the graph. `dependencies` may not have any duplicate entries. A handle to the new node will be returned in `phGraphNode`.

The graph node will wait for all work captured in `event`. See [cuEventRecord()](<group__CUDA__EVENT.html#group__CUDA__EVENT_1g95424d3be52c4eb95d83861b70fb89d1> "Records an event.") for details on what is captured by an event. `event` may be from a different context or device than the launch stream.

Note:

  * Graph objects are not threadsafe. [More here](<graphs-thread-safety.html#graphs-thread-safety>).

  * Note that this function may also return error codes from previous, asynchronous launches.


**See also:**

[cuGraphAddNode](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1ge01208e62f72a53367a2af903bf17d23> "Adds a node of arbitrary type to a graph."), [cuGraphAddEventRecordNode](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1ga7f6dcb109f4b7470ce6b067d39974a4> "Creates an event record node and adds it to a graph."), [cuEventRecordWithFlags](<group__CUDA__EVENT.html#group__CUDA__EVENT_1ge577e0c132d9c4961f220d79f6762c4b> "Records an event."), [cuStreamWaitEvent](<group__CUDA__STREAM.html#group__CUDA__STREAM_1g6a898b652dfc6aa1d5c8d97062618b2f> "Make a compute stream wait on an event."), [cuGraphCreate](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1gd885f719186010727b75c3315f865fdf> "Creates a graph."), [cuGraphDestroyNode](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1g00ed16434d983d8f0011683eacaf19b9> "Remove a node from the graph."), [cuGraphAddChildGraphNode](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1gde52afbcf91a8c79d4d7efbe0e3b6844> "Creates a child graph node and adds it to a graph."), [cuGraphAddEmptyNode](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1g14b625984430cb2d574c63f29c9b9223> "Creates an empty node and adds it to a graph."), [cuGraphAddKernelNode](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1g50d871e3bd06c1b835e52f2966ef366b> "Creates a kernel execution node and adds it to a graph."), [cuGraphAddMemcpyNode](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1g674da6ab54a677f13e0e0e8206ff5073> "Creates a memcpy node and adds it to a graph."), [cuGraphAddMemsetNode](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1g89dc8fc3743392777c0daa2c4aca40d3> "Creates a memset node and adds it to a graph.")

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuGraphAddExternalSemaphoresSignalNode ( [CUgraphNode](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc72514a94dacc85ed0617f979211079c>)*Â phGraphNode, [CUgraph](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g69f555c38df5b3fa1ed25efef794739a>)Â hGraph, const [CUgraphNode](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc72514a94dacc85ed0617f979211079c>)*Â dependencies, size_tÂ numDependencies, const [CUDA_EXT_SEM_SIGNAL_NODE_PARAMS](<structCUDA__EXT__SEM__SIGNAL__NODE__PARAMS__v1.html#structCUDA__EXT__SEM__SIGNAL__NODE__PARAMS__v1>)*Â nodeParams )


Creates an external semaphore signal node and adds it to a graph.

######  Parameters

`phGraphNode`
    \- Returns newly created node
`hGraph`
    \- Graph to which to add the node
`dependencies`
    \- Dependencies of the node
`numDependencies`
    \- Number of dependencies
`nodeParams`
    \- Parameters for the node

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_DEINITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9acf52f132faf29b473cdda6061f0f44a>), [CUDA_ERROR_NOT_INITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e98feb999f0af99b4a25ab26b3866f4df8>), [CUDA_ERROR_NOT_SUPPORTED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e954756ae7ade0dfd09faeccb513dd831b>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>)

###### Description

Creates a new external semaphore signal node and adds it to `hGraph` with `numDependencies` dependencies specified via `dependencies` and arguments specified in `nodeParams`. It is possible for `numDependencies` to be 0, in which case the node will be placed at the root of the graph. `dependencies` may not have any duplicate entries. A handle to the new node will be returned in `phGraphNode`.

Performs a signal operation on a set of externally allocated semaphore objects when the node is launched. The operation(s) will occur after all of the node's dependencies have completed.

Note:

  * Graph objects are not threadsafe. [More here](<graphs-thread-safety.html#graphs-thread-safety>).

  * Note that this function may also return error codes from previous, asynchronous launches.


**See also:**

[cuGraphAddNode](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1ge01208e62f72a53367a2af903bf17d23> "Adds a node of arbitrary type to a graph."), [cuGraphExternalSemaphoresSignalNodeGetParams](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1ga9f9b30ce6eb9f45d691190b20f34126> "Returns an external semaphore signal node's parameters."), [cuGraphExternalSemaphoresSignalNodeSetParams](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1g7a344ed4c6a5fcaad7bc7c53b04c6099> "Sets an external semaphore signal node's parameters."), [cuGraphExecExternalSemaphoresSignalNodeSetParams](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1g96aedf2977d0dce275fa3b3cf3700ade> "Sets the parameters for an external semaphore signal node in the given graphExec."), [cuGraphAddExternalSemaphoresWaitNode](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1g49131c65fcef0b60b3939e008f7b467e> "Creates an external semaphore wait node and adds it to a graph."), [cuImportExternalSemaphore](<group__CUDA__EXTRES__INTEROP.html#group__CUDA__EXTRES__INTEROP_1ge593134f5f9650474af74db644c4a326> "Imports an external semaphore."), [cuSignalExternalSemaphoresAsync](<group__CUDA__EXTRES__INTEROP.html#group__CUDA__EXTRES__INTEROP_1g86cd6c4b3f439ba786f4e65d1b8107c3> "Signals a set of external semaphore objects."), [cuWaitExternalSemaphoresAsync](<group__CUDA__EXTRES__INTEROP.html#group__CUDA__EXTRES__INTEROP_1g063f01a524818ac89bacf521c55a39f0> "Waits on a set of external semaphore objects."), [cuGraphCreate](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1gd885f719186010727b75c3315f865fdf> "Creates a graph."), [cuGraphDestroyNode](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1g00ed16434d983d8f0011683eacaf19b9> "Remove a node from the graph."), [cuGraphAddEventRecordNode](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1ga7f6dcb109f4b7470ce6b067d39974a4> "Creates an event record node and adds it to a graph."), [cuGraphAddEventWaitNode](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1g7306f3bcbec3406d80e110cd13405c5e> "Creates an event wait node and adds it to a graph."), [cuGraphAddChildGraphNode](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1gde52afbcf91a8c79d4d7efbe0e3b6844> "Creates a child graph node and adds it to a graph."), [cuGraphAddEmptyNode](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1g14b625984430cb2d574c63f29c9b9223> "Creates an empty node and adds it to a graph."), [cuGraphAddKernelNode](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1g50d871e3bd06c1b835e52f2966ef366b> "Creates a kernel execution node and adds it to a graph."), [cuGraphAddMemcpyNode](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1g674da6ab54a677f13e0e0e8206ff5073> "Creates a memcpy node and adds it to a graph."), [cuGraphAddMemsetNode](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1g89dc8fc3743392777c0daa2c4aca40d3> "Creates a memset node and adds it to a graph.")

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuGraphAddExternalSemaphoresWaitNode ( [CUgraphNode](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc72514a94dacc85ed0617f979211079c>)*Â phGraphNode, [CUgraph](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g69f555c38df5b3fa1ed25efef794739a>)Â hGraph, const [CUgraphNode](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc72514a94dacc85ed0617f979211079c>)*Â dependencies, size_tÂ numDependencies, const [CUDA_EXT_SEM_WAIT_NODE_PARAMS](<structCUDA__EXT__SEM__WAIT__NODE__PARAMS__v1.html#structCUDA__EXT__SEM__WAIT__NODE__PARAMS__v1>)*Â nodeParams )


Creates an external semaphore wait node and adds it to a graph.

######  Parameters

`phGraphNode`
    \- Returns newly created node
`hGraph`
    \- Graph to which to add the node
`dependencies`
    \- Dependencies of the node
`numDependencies`
    \- Number of dependencies
`nodeParams`
    \- Parameters for the node

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_DEINITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9acf52f132faf29b473cdda6061f0f44a>), [CUDA_ERROR_NOT_INITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e98feb999f0af99b4a25ab26b3866f4df8>), [CUDA_ERROR_NOT_SUPPORTED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e954756ae7ade0dfd09faeccb513dd831b>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>)

###### Description

Creates a new external semaphore wait node and adds it to `hGraph` with `numDependencies` dependencies specified via `dependencies` and arguments specified in `nodeParams`. It is possible for `numDependencies` to be 0, in which case the node will be placed at the root of the graph. `dependencies` may not have any duplicate entries. A handle to the new node will be returned in `phGraphNode`.

Performs a wait operation on a set of externally allocated semaphore objects when the node is launched. The node's dependencies will not be launched until the wait operation has completed.

Note:

  * Graph objects are not threadsafe. [More here](<graphs-thread-safety.html#graphs-thread-safety>).

  * Note that this function may also return error codes from previous, asynchronous launches.


**See also:**

[cuGraphAddNode](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1ge01208e62f72a53367a2af903bf17d23> "Adds a node of arbitrary type to a graph."), [cuGraphExternalSemaphoresWaitNodeGetParams](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1g1430da6d26a58818a4712d135cf37a54> "Returns an external semaphore wait node's parameters."), [cuGraphExternalSemaphoresWaitNodeSetParams](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1ge8b93792930a21ec352d6efd2c21c8c0> "Sets an external semaphore wait node's parameters."), [cuGraphExecExternalSemaphoresWaitNodeSetParams](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1g98a93c41b057cc1b48c0498811f65ad3> "Sets the parameters for an external semaphore wait node in the given graphExec."), [cuGraphAddExternalSemaphoresSignalNode](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1g6410d5401de205568457fba5e1862ad3> "Creates an external semaphore signal node and adds it to a graph."), [cuImportExternalSemaphore](<group__CUDA__EXTRES__INTEROP.html#group__CUDA__EXTRES__INTEROP_1ge593134f5f9650474af74db644c4a326> "Imports an external semaphore."), [cuSignalExternalSemaphoresAsync](<group__CUDA__EXTRES__INTEROP.html#group__CUDA__EXTRES__INTEROP_1g86cd6c4b3f439ba786f4e65d1b8107c3> "Signals a set of external semaphore objects."), [cuWaitExternalSemaphoresAsync](<group__CUDA__EXTRES__INTEROP.html#group__CUDA__EXTRES__INTEROP_1g063f01a524818ac89bacf521c55a39f0> "Waits on a set of external semaphore objects."), [cuGraphCreate](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1gd885f719186010727b75c3315f865fdf> "Creates a graph."), [cuGraphDestroyNode](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1g00ed16434d983d8f0011683eacaf19b9> "Remove a node from the graph."), [cuGraphAddEventRecordNode](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1ga7f6dcb109f4b7470ce6b067d39974a4> "Creates an event record node and adds it to a graph."), [cuGraphAddEventWaitNode](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1g7306f3bcbec3406d80e110cd13405c5e> "Creates an event wait node and adds it to a graph."), [cuGraphAddChildGraphNode](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1gde52afbcf91a8c79d4d7efbe0e3b6844> "Creates a child graph node and adds it to a graph."), [cuGraphAddEmptyNode](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1g14b625984430cb2d574c63f29c9b9223> "Creates an empty node and adds it to a graph."), [cuGraphAddKernelNode](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1g50d871e3bd06c1b835e52f2966ef366b> "Creates a kernel execution node and adds it to a graph."), [cuGraphAddMemcpyNode](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1g674da6ab54a677f13e0e0e8206ff5073> "Creates a memcpy node and adds it to a graph."), [cuGraphAddMemsetNode](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1g89dc8fc3743392777c0daa2c4aca40d3> "Creates a memset node and adds it to a graph.")

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuGraphAddHostNode ( [CUgraphNode](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc72514a94dacc85ed0617f979211079c>)*Â phGraphNode, [CUgraph](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g69f555c38df5b3fa1ed25efef794739a>)Â hGraph, const [CUgraphNode](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc72514a94dacc85ed0617f979211079c>)*Â dependencies, size_tÂ numDependencies, const [CUDA_HOST_NODE_PARAMS](<structCUDA__HOST__NODE__PARAMS__v1.html#structCUDA__HOST__NODE__PARAMS__v1>)*Â nodeParams )


Creates a host execution node and adds it to a graph.

######  Parameters

`phGraphNode`
    \- Returns newly created node
`hGraph`
    \- Graph to which to add the node
`dependencies`
    \- Dependencies of the node
`numDependencies`
    \- Number of dependencies
`nodeParams`
    \- Parameters for the host node

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_DEINITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9acf52f132faf29b473cdda6061f0f44a>), [CUDA_ERROR_NOT_INITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e98feb999f0af99b4a25ab26b3866f4df8>), [CUDA_ERROR_NOT_SUPPORTED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e954756ae7ade0dfd09faeccb513dd831b>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>)

###### Description

Creates a new CPU execution node and adds it to `hGraph` with `numDependencies` dependencies specified via `dependencies` and arguments specified in `nodeParams`. It is possible for `numDependencies` to be 0, in which case the node will be placed at the root of the graph. `dependencies` may not have any duplicate entries. A handle to the new node will be returned in `phGraphNode`.

When the graph is launched, the node will invoke the specified CPU function. Host nodes are not supported under MPS with pre-Volta GPUs.

Note:

  * Graph objects are not threadsafe. [More here](<graphs-thread-safety.html#graphs-thread-safety>).

  * Note that this function may also return error codes from previous, asynchronous launches.


**See also:**

[cuGraphAddNode](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1ge01208e62f72a53367a2af903bf17d23> "Adds a node of arbitrary type to a graph."), [cuLaunchHostFunc](<group__CUDA__EXEC.html#group__CUDA__EXEC_1gab95a78143bae7f21eebb978f91e7f3f> "Enqueues a host function call in a stream."), [cuGraphHostNodeGetParams](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1g2e3ea6000089fd5523c197ab5e73d5a2> "Returns a host node's parameters."), [cuGraphHostNodeSetParams](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1gae021ae8f19ee51044339db9c24dd266> "Sets a host node's parameters."), [cuGraphCreate](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1gd885f719186010727b75c3315f865fdf> "Creates a graph."), [cuGraphDestroyNode](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1g00ed16434d983d8f0011683eacaf19b9> "Remove a node from the graph."), [cuGraphAddChildGraphNode](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1gde52afbcf91a8c79d4d7efbe0e3b6844> "Creates a child graph node and adds it to a graph."), [cuGraphAddEmptyNode](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1g14b625984430cb2d574c63f29c9b9223> "Creates an empty node and adds it to a graph."), [cuGraphAddKernelNode](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1g50d871e3bd06c1b835e52f2966ef366b> "Creates a kernel execution node and adds it to a graph."), [cuGraphAddMemcpyNode](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1g674da6ab54a677f13e0e0e8206ff5073> "Creates a memcpy node and adds it to a graph."), [cuGraphAddMemsetNode](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1g89dc8fc3743392777c0daa2c4aca40d3> "Creates a memset node and adds it to a graph.")

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuGraphAddKernelNode ( [CUgraphNode](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc72514a94dacc85ed0617f979211079c>)*Â phGraphNode, [CUgraph](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g69f555c38df5b3fa1ed25efef794739a>)Â hGraph, const [CUgraphNode](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc72514a94dacc85ed0617f979211079c>)*Â dependencies, size_tÂ numDependencies, const [CUDA_KERNEL_NODE_PARAMS](<structCUDA__KERNEL__NODE__PARAMS__v2.html#structCUDA__KERNEL__NODE__PARAMS__v2>)*Â nodeParams )


Creates a kernel execution node and adds it to a graph.

######  Parameters

`phGraphNode`
    \- Returns newly created node
`hGraph`
    \- Graph to which to add the node
`dependencies`
    \- Dependencies of the node
`numDependencies`
    \- Number of dependencies
`nodeParams`
    \- Parameters for the GPU execution node

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_DEINITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9acf52f132faf29b473cdda6061f0f44a>), [CUDA_ERROR_NOT_INITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e98feb999f0af99b4a25ab26b3866f4df8>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>)

###### Description

Creates a new kernel execution node and adds it to `hGraph` with `numDependencies` dependencies specified via `dependencies` and arguments specified in `nodeParams`. It is possible for `numDependencies` to be 0, in which case the node will be placed at the root of the graph. `dependencies` may not have any duplicate entries. A handle to the new node will be returned in `phGraphNode`.

The CUDA_KERNEL_NODE_PARAMS structure is defined as:


    â  typedef struct CUDA_KERNEL_NODE_PARAMS_st {
                [CUfunction](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gba6128b948022f495706d93bc2cea9c8>) func;
                unsigned int gridDimX;
                unsigned int gridDimY;
                unsigned int gridDimZ;
                unsigned int blockDimX;
                unsigned int blockDimY;
                unsigned int blockDimZ;
                unsigned int sharedMemBytes;
                void **kernelParams;
                void **extra;
                [CUkernel](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g612028921e5736db673e4307589989ed>) kern;
                [CUcontext](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gf9f5bd81658f866613785b3a0bb7d7d9>) ctx;
            } [CUDA_KERNEL_NODE_PARAMS](<structCUDA__KERNEL__NODE__PARAMS__v2.html#structCUDA__KERNEL__NODE__PARAMS__v2>);

When the graph is launched, the node will invoke kernel `func` on a (`gridDimX` x `gridDimY` x `gridDimZ`) grid of blocks. Each block contains (`blockDimX` x `blockDimY` x `blockDimZ`) threads.

`sharedMemBytes` sets the amount of dynamic shared memory that will be available to each thread block.

Kernel parameters to `func` can be specified in one of two ways:

1) Kernel parameters can be specified via `kernelParams`. If the kernel has N parameters, then `kernelParams` needs to be an array of N pointers. Each pointer, from `kernelParams`[0] to `kernelParams`[N-1], points to the region of memory from which the actual parameter will be copied. The number of kernel parameters and their offsets and sizes do not need to be specified as that information is retrieved directly from the kernel's image.

2) Kernel parameters for non-cooperative kernels can also be packaged by the application into a single buffer that is passed in via `extra`. This places the burden on the application of knowing each kernel parameter's size and alignment/padding within the buffer. The `extra` parameter exists to allow this function to take additional less commonly used arguments. `extra` specifies a list of names of extra settings and their corresponding values. Each extra setting name is immediately followed by the corresponding value. The list must be terminated with either NULL or CU_LAUNCH_PARAM_END.

  * [CU_LAUNCH_PARAM_END](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gd5c11cff5adfa5a69d66829399653532>), which indicates the end of the `extra` array;

  * [CU_LAUNCH_PARAM_BUFFER_POINTER](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g36d10d0b40c51372877578a2cffd6acd>), which specifies that the next value in `extra` will be a pointer to a buffer containing all the kernel parameters for launching kernel `func`;

  * [CU_LAUNCH_PARAM_BUFFER_SIZE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gf339c057cd94562ead93a192e11c17e9>), which specifies that the next value in `extra` will be a pointer to a size_t containing the size of the buffer specified with [CU_LAUNCH_PARAM_BUFFER_POINTER](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g36d10d0b40c51372877578a2cffd6acd>);


The error [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>) will be returned if kernel parameters are specified with both `kernelParams` and `extra` (i.e. both `kernelParams` and `extra` are non-NULL). [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>) will be returned if `extra` is used for a cooperative kernel.

The `kernelParams` or `extra` array, as well as the argument values it points to, are copied during this call.

Note:

Kernels launched using graphs must not use texture and surface references. Reading or writing through any texture or surface reference is undefined behavior. This restriction does not apply to texture and surface objects.

Note:

  * Graph objects are not threadsafe. [More here](<graphs-thread-safety.html#graphs-thread-safety>).

  * Note that this function may also return error codes from previous, asynchronous launches.


**See also:**

[cuGraphAddNode](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1ge01208e62f72a53367a2af903bf17d23> "Adds a node of arbitrary type to a graph."), [cuLaunchKernel](<group__CUDA__EXEC.html#group__CUDA__EXEC_1gb8f3dc3031b40da29d5f9a7139e52e15> "Launches a CUDA function CUfunction or a CUDA kernel CUkernel."), [cuLaunchCooperativeKernel](<group__CUDA__EXEC.html#group__CUDA__EXEC_1g06d753134145c4584c0c62525c1894cb> "Launches a CUDA function CUfunction or a CUDA kernel CUkernel where thread blocks can cooperate and synchronize as they execute."), [cuGraphKernelNodeGetParams](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1gb8df3f99e8dd5e4f4a5a0f19a5518252> "Returns a kernel node's parameters."), [cuGraphKernelNodeSetParams](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1ga268bf2fd520f5aa3a3d700005df6703> "Sets a kernel node's parameters."), [cuGraphCreate](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1gd885f719186010727b75c3315f865fdf> "Creates a graph."), [cuGraphDestroyNode](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1g00ed16434d983d8f0011683eacaf19b9> "Remove a node from the graph."), [cuGraphAddChildGraphNode](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1gde52afbcf91a8c79d4d7efbe0e3b6844> "Creates a child graph node and adds it to a graph."), [cuGraphAddEmptyNode](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1g14b625984430cb2d574c63f29c9b9223> "Creates an empty node and adds it to a graph."), [cuGraphAddHostNode](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1g0809d65e85a3c052296373954a05b1d6> "Creates a host execution node and adds it to a graph."), [cuGraphAddMemcpyNode](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1g674da6ab54a677f13e0e0e8206ff5073> "Creates a memcpy node and adds it to a graph."), [cuGraphAddMemsetNode](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1g89dc8fc3743392777c0daa2c4aca40d3> "Creates a memset node and adds it to a graph.")

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuGraphAddMemAllocNode ( [CUgraphNode](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc72514a94dacc85ed0617f979211079c>)*Â phGraphNode, [CUgraph](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g69f555c38df5b3fa1ed25efef794739a>)Â hGraph, const [CUgraphNode](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc72514a94dacc85ed0617f979211079c>)*Â dependencies, size_tÂ numDependencies, [CUDA_MEM_ALLOC_NODE_PARAMS](<structCUDA__MEM__ALLOC__NODE__PARAMS__v1.html#structCUDA__MEM__ALLOC__NODE__PARAMS__v1>)*Â nodeParams )


Creates an allocation node and adds it to a graph.

######  Parameters

`phGraphNode`
    \- Returns newly created node
`hGraph`
    \- Graph to which to add the node
`dependencies`
    \- Dependencies of the node
`numDependencies`
    \- Number of dependencies
`nodeParams`
    \- Parameters for the node

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_DEINITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9acf52f132faf29b473cdda6061f0f44a>), [CUDA_ERROR_NOT_INITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e98feb999f0af99b4a25ab26b3866f4df8>), [CUDA_ERROR_NOT_SUPPORTED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e954756ae7ade0dfd09faeccb513dd831b>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>)

###### Description

Creates a new allocation node and adds it to `hGraph` with `numDependencies` dependencies specified via `dependencies` and arguments specified in `nodeParams`. It is possible for `numDependencies` to be 0, in which case the node will be placed at the root of the graph. `dependencies` may not have any duplicate entries. A handle to the new node will be returned in `phGraphNode`.

When [cuGraphAddMemAllocNode](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1g73a351cb71b2945a0bcb913a93f69ec9> "Creates an allocation node and adds it to a graph.") creates an allocation node, it returns the address of the allocation in `nodeParams.dptr`. The allocation's address remains fixed across instantiations and launches.

If the allocation is freed in the same graph, by creating a free node using [cuGraphAddMemFreeNode](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1geb7cdce5d9be2d28d9428e74eb00fa53> "Creates a memory free node and adds it to a graph."), the allocation can be accessed by nodes ordered after the allocation node but before the free node. These allocations cannot be freed outside the owning graph, and they can only be freed once in the owning graph.

If the allocation is not freed in the same graph, then it can be accessed not only by nodes in the graph which are ordered after the allocation node, but also by stream operations ordered after the graph's execution but before the allocation is freed.

Allocations which are not freed in the same graph can be freed by:

  * passing the allocation to [cuMemFreeAsync](<group__CUDA__MALLOC__ASYNC.html#group__CUDA__MALLOC__ASYNC_1g41acf4131f672a2a75cd93d3241f10cf> "Frees memory with stream ordered semantics.") or [cuMemFree](<group__CUDA__MEM.html#group__CUDA__MEM_1g89b3f154e17cc89b6eea277dbdf5c93a> "Frees device memory.");

  * launching a graph with a free node for that allocation; or

  * specifying [CUDA_GRAPH_INSTANTIATE_FLAG_AUTO_FREE_ON_LAUNCH](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg070bf5517d3a7915667c256eefce49561684f715bf05e39afd69aa508299a479>) during instantiation, which makes each launch behave as though it called [cuMemFreeAsync](<group__CUDA__MALLOC__ASYNC.html#group__CUDA__MALLOC__ASYNC_1g41acf4131f672a2a75cd93d3241f10cf> "Frees memory with stream ordered semantics.") for every unfreed allocation.


It is not possible to free an allocation in both the owning graph and another graph. If the allocation is freed in the same graph, a free node cannot be added to another graph. If the allocation is freed in another graph, a free node can no longer be added to the owning graph.

The following restrictions apply to graphs which contain allocation and/or memory free nodes:

  * Nodes and edges of the graph cannot be deleted.

  * The graph can only be used in a child node if the ownership is moved to the parent.

  * Only one instantiation of the graph may exist at any point in time.

  * The graph cannot be cloned.


Note:

  * Graph objects are not threadsafe. [More here](<graphs-thread-safety.html#graphs-thread-safety>).

  * Note that this function may also return error codes from previous, asynchronous launches.


**See also:**

[cuGraphAddNode](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1ge01208e62f72a53367a2af903bf17d23> "Adds a node of arbitrary type to a graph."), [cuGraphAddMemFreeNode](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1geb7cdce5d9be2d28d9428e74eb00fa53> "Creates a memory free node and adds it to a graph."), [cuGraphMemAllocNodeGetParams](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1gee2c7d66d3d96b1470c1d1a769f250a2> "Returns a memory alloc node's parameters."), [cuDeviceGraphMemTrim](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1g57c87f4ba6af41825627cdd4e5a8c52b> "Free unused memory that was cached on the specified device for use with graphs back to the OS."), [cuDeviceGetGraphMemAttribute](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1g359903c2447ac22b4e1a0dce26adfef5> "Query asynchronous allocation attributes related to graphs."), [cuDeviceSetGraphMemAttribute](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1g064bd5c6a773b83d145c281ebf5dbe34> "Set asynchronous allocation attributes related to graphs."), [cuMemAllocAsync](<group__CUDA__MALLOC__ASYNC.html#group__CUDA__MALLOC__ASYNC_1g13413273e84a641bce1929eae9e6501f> "Allocates memory with stream ordered semantics."), [cuMemFreeAsync](<group__CUDA__MALLOC__ASYNC.html#group__CUDA__MALLOC__ASYNC_1g41acf4131f672a2a75cd93d3241f10cf> "Frees memory with stream ordered semantics."), [cuGraphCreate](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1gd885f719186010727b75c3315f865fdf> "Creates a graph."), [cuGraphDestroyNode](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1g00ed16434d983d8f0011683eacaf19b9> "Remove a node from the graph."), [cuGraphAddChildGraphNode](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1gde52afbcf91a8c79d4d7efbe0e3b6844> "Creates a child graph node and adds it to a graph."), [cuGraphAddEmptyNode](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1g14b625984430cb2d574c63f29c9b9223> "Creates an empty node and adds it to a graph."), [cuGraphAddEventRecordNode](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1ga7f6dcb109f4b7470ce6b067d39974a4> "Creates an event record node and adds it to a graph."), [cuGraphAddEventWaitNode](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1g7306f3bcbec3406d80e110cd13405c5e> "Creates an event wait node and adds it to a graph."), [cuGraphAddExternalSemaphoresSignalNode](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1g6410d5401de205568457fba5e1862ad3> "Creates an external semaphore signal node and adds it to a graph."), [cuGraphAddExternalSemaphoresWaitNode](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1g49131c65fcef0b60b3939e008f7b467e> "Creates an external semaphore wait node and adds it to a graph."), [cuGraphAddKernelNode](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1g50d871e3bd06c1b835e52f2966ef366b> "Creates a kernel execution node and adds it to a graph."), [cuGraphAddMemcpyNode](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1g674da6ab54a677f13e0e0e8206ff5073> "Creates a memcpy node and adds it to a graph."), [cuGraphAddMemsetNode](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1g89dc8fc3743392777c0daa2c4aca40d3> "Creates a memset node and adds it to a graph.")

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuGraphAddMemFreeNode ( [CUgraphNode](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc72514a94dacc85ed0617f979211079c>)*Â phGraphNode, [CUgraph](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g69f555c38df5b3fa1ed25efef794739a>)Â hGraph, const [CUgraphNode](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc72514a94dacc85ed0617f979211079c>)*Â dependencies, size_tÂ numDependencies, [CUdeviceptr](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g183f7b0d8ad008ea2a5fd552537ace4e>)Â dptr )


Creates a memory free node and adds it to a graph.

######  Parameters

`phGraphNode`
    \- Returns newly created node
`hGraph`
    \- Graph to which to add the node
`dependencies`
    \- Dependencies of the node
`numDependencies`
    \- Number of dependencies
`dptr`
    \- Address of memory to free

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_DEINITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9acf52f132faf29b473cdda6061f0f44a>), [CUDA_ERROR_NOT_INITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e98feb999f0af99b4a25ab26b3866f4df8>), [CUDA_ERROR_NOT_SUPPORTED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e954756ae7ade0dfd09faeccb513dd831b>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>)

###### Description

Creates a new memory free node and adds it to `hGraph` with `numDependencies` dependencies specified via `dependencies` and arguments specified in `nodeParams`. It is possible for `numDependencies` to be 0, in which case the node will be placed at the root of the graph. `dependencies` may not have any duplicate entries. A handle to the new node will be returned in `phGraphNode`.

[cuGraphAddMemFreeNode](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1geb7cdce5d9be2d28d9428e74eb00fa53> "Creates a memory free node and adds it to a graph.") will return [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>) if the user attempts to free:

  * an allocation twice in the same graph.

  * an address that was not returned by an allocation node.

  * an invalid address.


The following restrictions apply to graphs which contain allocation and/or memory free nodes:

  * Nodes and edges of the graph cannot be deleted.

  * The graph can only be used in a child node if the ownership is moved to the parent.

  * Only one instantiation of the graph may exist at any point in time.

  * The graph cannot be cloned.


Note:

  * Graph objects are not threadsafe. [More here](<graphs-thread-safety.html#graphs-thread-safety>).

  * Note that this function may also return error codes from previous, asynchronous launches.


**See also:**

[cuGraphAddNode](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1ge01208e62f72a53367a2af903bf17d23> "Adds a node of arbitrary type to a graph."), [cuGraphAddMemAllocNode](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1g73a351cb71b2945a0bcb913a93f69ec9> "Creates an allocation node and adds it to a graph."), [cuGraphMemFreeNodeGetParams](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1gd24d9fe5769222a2367e3f571fb2f28b> "Returns a memory free node's parameters."), [cuDeviceGraphMemTrim](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1g57c87f4ba6af41825627cdd4e5a8c52b> "Free unused memory that was cached on the specified device for use with graphs back to the OS."), [cuDeviceGetGraphMemAttribute](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1g359903c2447ac22b4e1a0dce26adfef5> "Query asynchronous allocation attributes related to graphs."), [cuDeviceSetGraphMemAttribute](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1g064bd5c6a773b83d145c281ebf5dbe34> "Set asynchronous allocation attributes related to graphs."), [cuMemAllocAsync](<group__CUDA__MALLOC__ASYNC.html#group__CUDA__MALLOC__ASYNC_1g13413273e84a641bce1929eae9e6501f> "Allocates memory with stream ordered semantics."), [cuMemFreeAsync](<group__CUDA__MALLOC__ASYNC.html#group__CUDA__MALLOC__ASYNC_1g41acf4131f672a2a75cd93d3241f10cf> "Frees memory with stream ordered semantics."), [cuGraphCreate](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1gd885f719186010727b75c3315f865fdf> "Creates a graph."), [cuGraphDestroyNode](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1g00ed16434d983d8f0011683eacaf19b9> "Remove a node from the graph."), [cuGraphAddChildGraphNode](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1gde52afbcf91a8c79d4d7efbe0e3b6844> "Creates a child graph node and adds it to a graph."), [cuGraphAddEmptyNode](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1g14b625984430cb2d574c63f29c9b9223> "Creates an empty node and adds it to a graph."), [cuGraphAddEventRecordNode](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1ga7f6dcb109f4b7470ce6b067d39974a4> "Creates an event record node and adds it to a graph."), [cuGraphAddEventWaitNode](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1g7306f3bcbec3406d80e110cd13405c5e> "Creates an event wait node and adds it to a graph."), [cuGraphAddExternalSemaphoresSignalNode](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1g6410d5401de205568457fba5e1862ad3> "Creates an external semaphore signal node and adds it to a graph."), [cuGraphAddExternalSemaphoresWaitNode](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1g49131c65fcef0b60b3939e008f7b467e> "Creates an external semaphore wait node and adds it to a graph."), [cuGraphAddKernelNode](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1g50d871e3bd06c1b835e52f2966ef366b> "Creates a kernel execution node and adds it to a graph."), [cuGraphAddMemcpyNode](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1g674da6ab54a677f13e0e0e8206ff5073> "Creates a memcpy node and adds it to a graph."), [cuGraphAddMemsetNode](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1g89dc8fc3743392777c0daa2c4aca40d3> "Creates a memset node and adds it to a graph.")

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuGraphAddMemcpyNode ( [CUgraphNode](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc72514a94dacc85ed0617f979211079c>)*Â phGraphNode, [CUgraph](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g69f555c38df5b3fa1ed25efef794739a>)Â hGraph, const [CUgraphNode](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc72514a94dacc85ed0617f979211079c>)*Â dependencies, size_tÂ numDependencies, const [CUDA_MEMCPY3D](<structCUDA__MEMCPY3D__v2.html#structCUDA__MEMCPY3D__v2>)*Â copyParams, [CUcontext](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gf9f5bd81658f866613785b3a0bb7d7d9>)Â ctx )


Creates a memcpy node and adds it to a graph.

######  Parameters

`phGraphNode`
    \- Returns newly created node
`hGraph`
    \- Graph to which to add the node
`dependencies`
    \- Dependencies of the node
`numDependencies`
    \- Number of dependencies
`copyParams`
    \- Parameters for the memory copy
`ctx`
    \- Context on which to run the node

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_DEINITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9acf52f132faf29b473cdda6061f0f44a>), [CUDA_ERROR_NOT_INITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e98feb999f0af99b4a25ab26b3866f4df8>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>)

###### Description

Creates a new memcpy node and adds it to `hGraph` with `numDependencies` dependencies specified via `dependencies`. It is possible for `numDependencies` to be 0, in which case the node will be placed at the root of the graph. `dependencies` may not have any duplicate entries. A handle to the new node will be returned in `phGraphNode`.

When the graph is launched, the node will perform the memcpy described by `copyParams`. See [cuMemcpy3D()](<group__CUDA__MEM.html#group__CUDA__MEM_1g4b5238975579f002c0199a3800ca44df> "Copies memory for 3D arrays.") for a description of the structure and its restrictions.

Memcpy nodes have some additional restrictions with regards to managed memory, if the system contains at least one device which has a zero value for the device attribute [CU_DEVICE_ATTRIBUTE_CONCURRENT_MANAGED_ACCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gge12b8a782bebe21b1ac0091bf9f4e2a333110e44c9cb6ead02f03ff6f6fd495e>). If one or more of the operands refer to managed memory, then using the memory type [CU_MEMORYTYPE_UNIFIED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg8a114cc994ad2e865c44ef3838eaec727a47ca2de6db5cf82084ad80ce66aa71>) is disallowed for those operand(s). The managed memory will be treated as residing on either the host or the device, depending on which memory type is specified.

Note:

  * Graph objects are not threadsafe. [More here](<graphs-thread-safety.html#graphs-thread-safety>).

  * Note that this function may also return error codes from previous, asynchronous launches.


**See also:**

[cuGraphAddNode](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1ge01208e62f72a53367a2af903bf17d23> "Adds a node of arbitrary type to a graph."), [cuMemcpy3D](<group__CUDA__MEM.html#group__CUDA__MEM_1g4b5238975579f002c0199a3800ca44df> "Copies memory for 3D arrays."), [cuGraphMemcpyNodeGetParams](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1g572889131dbc31720eff94b130f4005b> "Returns a memcpy node's parameters."), [cuGraphMemcpyNodeSetParams](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1ga278a7ec0700c86abb0b2cfdf4d3dc1d> "Sets a memcpy node's parameters."), [cuGraphCreate](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1gd885f719186010727b75c3315f865fdf> "Creates a graph."), [cuGraphDestroyNode](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1g00ed16434d983d8f0011683eacaf19b9> "Remove a node from the graph."), [cuGraphAddChildGraphNode](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1gde52afbcf91a8c79d4d7efbe0e3b6844> "Creates a child graph node and adds it to a graph."), [cuGraphAddEmptyNode](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1g14b625984430cb2d574c63f29c9b9223> "Creates an empty node and adds it to a graph."), [cuGraphAddKernelNode](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1g50d871e3bd06c1b835e52f2966ef366b> "Creates a kernel execution node and adds it to a graph."), [cuGraphAddHostNode](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1g0809d65e85a3c052296373954a05b1d6> "Creates a host execution node and adds it to a graph."), [cuGraphAddMemsetNode](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1g89dc8fc3743392777c0daa2c4aca40d3> "Creates a memset node and adds it to a graph.")

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuGraphAddMemsetNode ( [CUgraphNode](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc72514a94dacc85ed0617f979211079c>)*Â phGraphNode, [CUgraph](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g69f555c38df5b3fa1ed25efef794739a>)Â hGraph, const [CUgraphNode](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc72514a94dacc85ed0617f979211079c>)*Â dependencies, size_tÂ numDependencies, const [CUDA_MEMSET_NODE_PARAMS](<structCUDA__MEMSET__NODE__PARAMS__v1.html#structCUDA__MEMSET__NODE__PARAMS__v1>)*Â memsetParams, [CUcontext](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gf9f5bd81658f866613785b3a0bb7d7d9>)Â ctx )


Creates a memset node and adds it to a graph.

######  Parameters

`phGraphNode`
    \- Returns newly created node
`hGraph`
    \- Graph to which to add the node
`dependencies`
    \- Dependencies of the node
`numDependencies`
    \- Number of dependencies
`memsetParams`
    \- Parameters for the memory set
`ctx`
    \- Context on which to run the node

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_DEINITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9acf52f132faf29b473cdda6061f0f44a>), [CUDA_ERROR_NOT_INITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e98feb999f0af99b4a25ab26b3866f4df8>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>), [CUDA_ERROR_INVALID_CONTEXT](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a484e9af32c1e9893ff21f0e0191a12d>)

###### Description

Creates a new memset node and adds it to `hGraph` with `numDependencies` dependencies specified via `dependencies`. It is possible for `numDependencies` to be 0, in which case the node will be placed at the root of the graph. `dependencies` may not have any duplicate entries. A handle to the new node will be returned in `phGraphNode`.

The element size must be 1, 2, or 4 bytes. When the graph is launched, the node will perform the memset described by `memsetParams`.

Note:

  * Graph objects are not threadsafe. [More here](<graphs-thread-safety.html#graphs-thread-safety>).

  * Note that this function may also return error codes from previous, asynchronous launches.


**See also:**

[cuGraphAddNode](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1ge01208e62f72a53367a2af903bf17d23> "Adds a node of arbitrary type to a graph."), [cuMemsetD2D32](<group__CUDA__MEM.html#group__CUDA__MEM_1g74b359b2d026bfeb7c795b5038d07523> "Initializes device memory."), [cuGraphMemsetNodeGetParams](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1g18830edcfd982f952820a0d7f91b894a> "Returns a memset node's parameters."), [cuGraphMemsetNodeSetParams](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1gc27f3fd83a6e33c74519066fbaa0de67> "Sets a memset node's parameters."), [cuGraphCreate](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1gd885f719186010727b75c3315f865fdf> "Creates a graph."), [cuGraphDestroyNode](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1g00ed16434d983d8f0011683eacaf19b9> "Remove a node from the graph."), [cuGraphAddChildGraphNode](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1gde52afbcf91a8c79d4d7efbe0e3b6844> "Creates a child graph node and adds it to a graph."), [cuGraphAddEmptyNode](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1g14b625984430cb2d574c63f29c9b9223> "Creates an empty node and adds it to a graph."), [cuGraphAddKernelNode](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1g50d871e3bd06c1b835e52f2966ef366b> "Creates a kernel execution node and adds it to a graph."), [cuGraphAddHostNode](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1g0809d65e85a3c052296373954a05b1d6> "Creates a host execution node and adds it to a graph."), [cuGraphAddMemcpyNode](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1g674da6ab54a677f13e0e0e8206ff5073> "Creates a memcpy node and adds it to a graph.")

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuGraphAddNode ( [CUgraphNode](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc72514a94dacc85ed0617f979211079c>)*Â phGraphNode, [CUgraph](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g69f555c38df5b3fa1ed25efef794739a>)Â hGraph, const [CUgraphNode](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc72514a94dacc85ed0617f979211079c>)*Â dependencies, const [CUgraphEdgeData](<structCUgraphEdgeData.html#structCUgraphEdgeData>)*Â dependencyData, size_tÂ numDependencies, [CUgraphNodeParams](<structCUgraphNodeParams.html#structCUgraphNodeParams>)*Â nodeParams )


Adds a node of arbitrary type to a graph.

######  Parameters

`phGraphNode`
    \- Returns newly created node
`hGraph`
    \- Graph to which to add the node
`dependencies`
    \- Dependencies of the node
`dependencyData`
    \- Optional edge data for the dependencies. If NULL, the data is assumed to be default (zeroed) for all dependencies.
`numDependencies`
    \- Number of dependencies
`nodeParams`
    \- Specification of the node

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>), [CUDA_ERROR_INVALID_CONTEXT](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a484e9af32c1e9893ff21f0e0191a12d>), [CUDA_ERROR_NOT_SUPPORTED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e954756ae7ade0dfd09faeccb513dd831b>)

###### Description

Creates a new node in `hGraph` described by `nodeParams` with `numDependencies` dependencies specified via `dependencies`. `numDependencies` may be 0. `dependencies` may be null if `numDependencies` is 0. `dependencies` may not have any duplicate entries.

`nodeParams` is a tagged union. The node type should be specified in the `type` field, and type-specific parameters in the corresponding union member. All unused bytes - that is, `reserved0` and all bytes past the utilized union member - must be set to zero. It is recommended to use brace initialization or memset to ensure all bytes are initialized.

Note that for some node types, `nodeParams` may contain "out parameters" which are modified during the call, such as `nodeParams->alloc.dptr`.

A handle to the new node will be returned in `phGraphNode`.

Note:

  * Graph objects are not threadsafe. [More here](<graphs-thread-safety.html#graphs-thread-safety>).

  * Note that this function may also return error codes from previous, asynchronous launches.


**See also:**

[cuGraphCreate](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1gd885f719186010727b75c3315f865fdf> "Creates a graph."), [cuGraphNodeSetParams](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1gbf18157f40ea2d160cb0b9e4e2b16139> "Update's a graph node's parameters."), [cuGraphExecNodeSetParams](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1gb318c5b61ada0e333bb12d1d33dae48b> "Update's a graph node's parameters in an instantiated graph.")

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuGraphBatchMemOpNodeGetParams ( [CUgraphNode](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc72514a94dacc85ed0617f979211079c>)Â hNode, [CUDA_BATCH_MEM_OP_NODE_PARAMS](<structCUDA__BATCH__MEM__OP__NODE__PARAMS__v1.html#structCUDA__BATCH__MEM__OP__NODE__PARAMS__v1>)*Â nodeParams_out )


Returns a batch mem op node's parameters.

######  Parameters

`hNode`
    \- Node to get the parameters for
`nodeParams_out`
    \- Pointer to return the parameters

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_DEINITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9acf52f132faf29b473cdda6061f0f44a>), [CUDA_ERROR_NOT_INITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e98feb999f0af99b4a25ab26b3866f4df8>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>)

###### Description

Returns the parameters of batch mem op node `hNode` in `nodeParams_out`. The `paramArray` returned in `nodeParams_out` is owned by the node. This memory remains valid until the node is destroyed or its parameters are modified, and should not be modified directly. Use [cuGraphBatchMemOpNodeSetParams](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1g625ca946b58df3d17221ff7db5cd7800> "Sets a batch mem op node's parameters.") to update the parameters of this node.

Note:

  * Graph objects are not threadsafe. [More here](<graphs-thread-safety.html#graphs-thread-safety>).

  * Note that this function may also return error codes from previous, asynchronous launches.


**See also:**

[cuStreamBatchMemOp](<group__CUDA__MEMOP.html#group__CUDA__MEMOP_1g764c442de9b671f9dec856e8ae531ed1> "Batch operations to synchronize the stream via memory operations."), [cuGraphAddBatchMemOpNode](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1g5acb6914dbd18cb1ae15ea9437a73c96> "Creates a batch memory operation node and adds it to a graph."), [cuGraphBatchMemOpNodeSetParams](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1g625ca946b58df3d17221ff7db5cd7800> "Sets a batch mem op node's parameters.")

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuGraphBatchMemOpNodeSetParams ( [CUgraphNode](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc72514a94dacc85ed0617f979211079c>)Â hNode, const [CUDA_BATCH_MEM_OP_NODE_PARAMS](<structCUDA__BATCH__MEM__OP__NODE__PARAMS__v1.html#structCUDA__BATCH__MEM__OP__NODE__PARAMS__v1>)*Â nodeParams )


Sets a batch mem op node's parameters.

######  Parameters

`hNode`
    \- Node to set the parameters for
`nodeParams`
    \- Parameters to copy

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>), [CUDA_ERROR_INVALID_HANDLE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e90fd2e63260c6317ba943af0f7e4b8d21>), [CUDA_ERROR_OUT_OF_MEMORY](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9264c50688ed110e8476b591befe60c02>)

###### Description

Sets the parameters of batch mem op node `hNode` to `nodeParams`.

The paramArray inside `nodeParams` is copied and therefore it can be freed after the call returns.

Note:

  * Graph objects are not threadsafe. [More here](<graphs-thread-safety.html#graphs-thread-safety>).

  * Note that this function may also return error codes from previous, asynchronous launches.


**See also:**

[cuGraphNodeSetParams](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1gbf18157f40ea2d160cb0b9e4e2b16139> "Update's a graph node's parameters."), [cuStreamBatchMemOp](<group__CUDA__MEMOP.html#group__CUDA__MEMOP_1g764c442de9b671f9dec856e8ae531ed1> "Batch operations to synchronize the stream via memory operations."), [cuGraphAddBatchMemOpNode](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1g5acb6914dbd18cb1ae15ea9437a73c96> "Creates a batch memory operation node and adds it to a graph."), [cuGraphBatchMemOpNodeGetParams](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1g1d8039468b71285c61bc03ab3c302a28> "Returns a batch mem op node's parameters.")

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuGraphChildGraphNodeGetGraph ( [CUgraphNode](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc72514a94dacc85ed0617f979211079c>)Â hNode, [CUgraph](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g69f555c38df5b3fa1ed25efef794739a>)*Â phGraph )


Gets a handle to the embedded graph of a child graph node.

######  Parameters

`hNode`
    \- Node to get the embedded graph for
`phGraph`
    \- Location to store a handle to the graph

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_DEINITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9acf52f132faf29b473cdda6061f0f44a>), [CUDA_ERROR_NOT_INITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e98feb999f0af99b4a25ab26b3866f4df8>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>),

###### Description

Gets a handle to the embedded graph in a child graph node. This call does not clone the graph. Changes to the graph will be reflected in the node, and the node retains ownership of the graph.

Allocation and free nodes cannot be added to the returned graph. Attempting to do so will return an error.

Note:

  * Graph objects are not threadsafe. [More here](<graphs-thread-safety.html#graphs-thread-safety>).

  * Note that this function may also return error codes from previous, asynchronous launches.


**See also:**

[cuGraphAddChildGraphNode](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1gde52afbcf91a8c79d4d7efbe0e3b6844> "Creates a child graph node and adds it to a graph."), [cuGraphNodeFindInClone](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1gf21f6c968e346f028737c1118bfd41c2> "Finds a cloned version of a node.")

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuGraphClone ( [CUgraph](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g69f555c38df5b3fa1ed25efef794739a>)*Â phGraphClone, [CUgraph](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g69f555c38df5b3fa1ed25efef794739a>)Â originalGraph )


Clones a graph.

######  Parameters

`phGraphClone`
    \- Returns newly created cloned graph
`originalGraph`
    \- Graph to clone

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>), [CUDA_ERROR_OUT_OF_MEMORY](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9264c50688ed110e8476b591befe60c02>)

###### Description

This function creates a copy of `originalGraph` and returns it in `phGraphClone`. All parameters are copied into the cloned graph. The original graph may be modified after this call without affecting the clone.

Child graph nodes in the original graph are recursively copied into the clone.

Note:

: Cloning is not supported for graphs which contain memory allocation nodes, memory free nodes, or conditional nodes.

Note:

  * Graph objects are not threadsafe. [More here](<graphs-thread-safety.html#graphs-thread-safety>).

  * Note that this function may also return error codes from previous, asynchronous launches.


**See also:**

[cuGraphCreate](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1gd885f719186010727b75c3315f865fdf> "Creates a graph."), [cuGraphNodeFindInClone](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1gf21f6c968e346f028737c1118bfd41c2> "Finds a cloned version of a node.")

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuGraphConditionalHandleCreate ( [CUgraphConditionalHandle](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gf5f0f00dad6aa27aff480400b77f93ee>)*Â pHandle_out, [CUgraph](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g69f555c38df5b3fa1ed25efef794739a>)Â hGraph, [CUcontext](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gf9f5bd81658f866613785b3a0bb7d7d9>)Â ctx, unsigned int Â defaultLaunchValue, unsigned int Â flags )


Create a conditional handle.

######  Parameters

`pHandle_out`
    \- Pointer used to return the handle to the caller.
`hGraph`
    \- Graph which will contain the conditional node using this handle.
`ctx`
    \- Context for the handle and associated conditional node.
`defaultLaunchValue`
    \- Optional initial value for the conditional variable. Applied at the beginning of each graph execution if CU_GRAPH_COND_ASSIGN_DEFAULT is set in `flags`.
`flags`
    \- Currently must be CU_GRAPH_COND_ASSIGN_DEFAULT or 0.

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>), [CUDA_ERROR_NOT_SUPPORTED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e954756ae7ade0dfd09faeccb513dd831b>)

###### Description

Creates a conditional handle associated with `hGraph`.

The conditional handle must be associated with a conditional node in this graph or one of its children.

Handles not associated with a conditional node may cause graph instantiation to fail.

Handles can only be set from the context with which they are associated.

Note:

  * Graph objects are not threadsafe. [More here](<graphs-thread-safety.html#graphs-thread-safety>).

  * Note that this function may also return error codes from previous, asynchronous launches.


**See also:**

[cuGraphAddNode](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1ge01208e62f72a53367a2af903bf17d23> "Adds a node of arbitrary type to a graph.")

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuGraphCreate ( [CUgraph](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g69f555c38df5b3fa1ed25efef794739a>)*Â phGraph, unsigned int Â flags )


Creates a graph.

######  Parameters

`phGraph`
    \- Returns newly created graph
`flags`
    \- Graph creation flags, must be 0

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_DEINITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9acf52f132faf29b473cdda6061f0f44a>), [CUDA_ERROR_NOT_INITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e98feb999f0af99b4a25ab26b3866f4df8>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>), [CUDA_ERROR_OUT_OF_MEMORY](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9264c50688ed110e8476b591befe60c02>)

###### Description

Creates an empty graph, which is returned via `phGraph`.

Note:

  * Graph objects are not threadsafe. [More here](<graphs-thread-safety.html#graphs-thread-safety>).

  * Note that this function may also return error codes from previous, asynchronous launches.


**See also:**

[cuGraphAddChildGraphNode](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1gde52afbcf91a8c79d4d7efbe0e3b6844> "Creates a child graph node and adds it to a graph."), [cuGraphAddEmptyNode](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1g14b625984430cb2d574c63f29c9b9223> "Creates an empty node and adds it to a graph."), [cuGraphAddKernelNode](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1g50d871e3bd06c1b835e52f2966ef366b> "Creates a kernel execution node and adds it to a graph."), [cuGraphAddHostNode](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1g0809d65e85a3c052296373954a05b1d6> "Creates a host execution node and adds it to a graph."), [cuGraphAddMemcpyNode](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1g674da6ab54a677f13e0e0e8206ff5073> "Creates a memcpy node and adds it to a graph."), [cuGraphAddMemsetNode](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1g89dc8fc3743392777c0daa2c4aca40d3> "Creates a memset node and adds it to a graph."), [cuGraphInstantiate](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1gb53b435e178cccfa37ac87285d2c3fa1> "Creates an executable graph from a graph."), [cuGraphDestroy](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1g718cfd9681f078693d4be2426fd689c8> "Destroys a graph."), [cuGraphGetNodes](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1gfa35a8e2d2fc32f48dbd67ba27cf27e5> "Returns a graph's nodes."), [cuGraphGetRootNodes](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1gf8517646bd8b39ab6359f8e7f0edffbd> "Returns a graph's root nodes."), [cuGraphGetEdges](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1g4e3183ca455aae2e832edd4034094082> "Returns a graph's dependency edges."), [cuGraphClone](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1g3603974654e463f2231c71d9b9d1517e> "Clones a graph.")

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuGraphDebugDotPrint ( [CUgraph](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g69f555c38df5b3fa1ed25efef794739a>)Â hGraph, const char*Â path, unsigned int Â flags )


Write a DOT file describing graph structure.

######  Parameters

`hGraph`
    \- The graph to create a DOT file from
`path`
    \- The path to write the DOT file to
`flags`
    \- Flags from CUgraphDebugDot_flags for specifying which additional node information to write

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>), [CUDA_ERROR_OPERATING_SYSTEM](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9c849a151611f6e2ed1b3ae923f79ef3c>)

###### Description

Using the provided `hGraph`, write to `path` a DOT formatted description of the graph. By default this includes the graph topology, node types, node id, kernel names and memcpy direction. `flags` can be specified to write more detailed information about each node type such as parameter values, kernel attributes, node and function handles.

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuGraphDestroy ( [CUgraph](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g69f555c38df5b3fa1ed25efef794739a>)Â hGraph )


Destroys a graph.

######  Parameters

`hGraph`
    \- Graph to destroy

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_DEINITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9acf52f132faf29b473cdda6061f0f44a>), [CUDA_ERROR_NOT_INITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e98feb999f0af99b4a25ab26b3866f4df8>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>)

###### Description

Destroys the graph specified by `hGraph`, as well as all of its nodes.

Note:

  * Graph objects are not threadsafe. [More here](<graphs-thread-safety.html#graphs-thread-safety>).

  * Note that this function may also return error codes from previous, asynchronous launches.


**See also:**

[cuGraphCreate](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1gd885f719186010727b75c3315f865fdf> "Creates a graph.")

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuGraphDestroyNode ( [CUgraphNode](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc72514a94dacc85ed0617f979211079c>)Â hNode )


Remove a node from the graph.

######  Parameters

`hNode`
    \- Node to remove

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>)

###### Description

Removes `hNode` from its graph. This operation also severs any dependencies of other nodes on `hNode` and vice versa.

Nodes which belong to a graph which contains allocation or free nodes cannot be destroyed. Any attempt to do so will return an error.

Note:

  * Graph objects are not threadsafe. [More here](<graphs-thread-safety.html#graphs-thread-safety>).

  * Note that this function may also return error codes from previous, asynchronous launches.


**See also:**

[cuGraphAddChildGraphNode](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1gde52afbcf91a8c79d4d7efbe0e3b6844> "Creates a child graph node and adds it to a graph."), [cuGraphAddEmptyNode](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1g14b625984430cb2d574c63f29c9b9223> "Creates an empty node and adds it to a graph."), [cuGraphAddKernelNode](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1g50d871e3bd06c1b835e52f2966ef366b> "Creates a kernel execution node and adds it to a graph."), [cuGraphAddHostNode](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1g0809d65e85a3c052296373954a05b1d6> "Creates a host execution node and adds it to a graph."), [cuGraphAddMemcpyNode](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1g674da6ab54a677f13e0e0e8206ff5073> "Creates a memcpy node and adds it to a graph."), [cuGraphAddMemsetNode](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1g89dc8fc3743392777c0daa2c4aca40d3> "Creates a memset node and adds it to a graph.")

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuGraphEventRecordNodeGetEvent ( [CUgraphNode](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc72514a94dacc85ed0617f979211079c>)Â hNode, [CUevent](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g6d740185cf0953636d4ae37f68d7559b>)*Â event_out )


Returns the event associated with an event record node.

######  Parameters

`hNode`
    \- Node to get the event for
`event_out`
    \- Pointer to return the event

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_DEINITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9acf52f132faf29b473cdda6061f0f44a>), [CUDA_ERROR_NOT_INITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e98feb999f0af99b4a25ab26b3866f4df8>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>)

###### Description

Returns the event of event record node `hNode` in `event_out`.

Note:

  * Graph objects are not threadsafe. [More here](<graphs-thread-safety.html#graphs-thread-safety>).

  * Note that this function may also return error codes from previous, asynchronous launches.


**See also:**

[cuGraphAddEventRecordNode](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1ga7f6dcb109f4b7470ce6b067d39974a4> "Creates an event record node and adds it to a graph."), [cuGraphEventRecordNodeSetEvent](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1g8ad8006aa7865865bf4d8c475cb21d87> "Sets an event record node's event."), [cuGraphEventWaitNodeGetEvent](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1g90b9d60f3f5f4156d1351a96ce92846e> "Returns the event associated with an event wait node."), [cuEventRecordWithFlags](<group__CUDA__EVENT.html#group__CUDA__EVENT_1ge577e0c132d9c4961f220d79f6762c4b> "Records an event."), [cuStreamWaitEvent](<group__CUDA__STREAM.html#group__CUDA__STREAM_1g6a898b652dfc6aa1d5c8d97062618b2f> "Make a compute stream wait on an event.")

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuGraphEventRecordNodeSetEvent ( [CUgraphNode](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc72514a94dacc85ed0617f979211079c>)Â hNode, [CUevent](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g6d740185cf0953636d4ae37f68d7559b>)Â event )


Sets an event record node's event.

######  Parameters

`hNode`
    \- Node to set the event for
`event`
    \- Event to use

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>), [CUDA_ERROR_INVALID_HANDLE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e90fd2e63260c6317ba943af0f7e4b8d21>), [CUDA_ERROR_OUT_OF_MEMORY](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9264c50688ed110e8476b591befe60c02>)

###### Description

Sets the event of event record node `hNode` to `event`.

Note:

  * Graph objects are not threadsafe. [More here](<graphs-thread-safety.html#graphs-thread-safety>).

  * Note that this function may also return error codes from previous, asynchronous launches.


**See also:**

[cuGraphNodeSetParams](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1gbf18157f40ea2d160cb0b9e4e2b16139> "Update's a graph node's parameters."), [cuGraphAddEventRecordNode](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1ga7f6dcb109f4b7470ce6b067d39974a4> "Creates an event record node and adds it to a graph."), [cuGraphEventRecordNodeGetEvent](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1gb3608efc284aa2bbe5db61826d6e2259> "Returns the event associated with an event record node."), [cuGraphEventWaitNodeSetEvent](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1g2d6730d63efd399d3000952c54134930> "Sets an event wait node's event."), [cuEventRecordWithFlags](<group__CUDA__EVENT.html#group__CUDA__EVENT_1ge577e0c132d9c4961f220d79f6762c4b> "Records an event."), [cuStreamWaitEvent](<group__CUDA__STREAM.html#group__CUDA__STREAM_1g6a898b652dfc6aa1d5c8d97062618b2f> "Make a compute stream wait on an event.")

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuGraphEventWaitNodeGetEvent ( [CUgraphNode](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc72514a94dacc85ed0617f979211079c>)Â hNode, [CUevent](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g6d740185cf0953636d4ae37f68d7559b>)*Â event_out )


Returns the event associated with an event wait node.

######  Parameters

`hNode`
    \- Node to get the event for
`event_out`
    \- Pointer to return the event

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_DEINITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9acf52f132faf29b473cdda6061f0f44a>), [CUDA_ERROR_NOT_INITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e98feb999f0af99b4a25ab26b3866f4df8>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>)

###### Description

Returns the event of event wait node `hNode` in `event_out`.

Note:

  * Graph objects are not threadsafe. [More here](<graphs-thread-safety.html#graphs-thread-safety>).

  * Note that this function may also return error codes from previous, asynchronous launches.


**See also:**

[cuGraphAddEventWaitNode](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1g7306f3bcbec3406d80e110cd13405c5e> "Creates an event wait node and adds it to a graph."), [cuGraphEventWaitNodeSetEvent](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1g2d6730d63efd399d3000952c54134930> "Sets an event wait node's event."), [cuGraphEventRecordNodeGetEvent](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1gb3608efc284aa2bbe5db61826d6e2259> "Returns the event associated with an event record node."), [cuEventRecordWithFlags](<group__CUDA__EVENT.html#group__CUDA__EVENT_1ge577e0c132d9c4961f220d79f6762c4b> "Records an event."), [cuStreamWaitEvent](<group__CUDA__STREAM.html#group__CUDA__STREAM_1g6a898b652dfc6aa1d5c8d97062618b2f> "Make a compute stream wait on an event.")

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuGraphEventWaitNodeSetEvent ( [CUgraphNode](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc72514a94dacc85ed0617f979211079c>)Â hNode, [CUevent](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g6d740185cf0953636d4ae37f68d7559b>)Â event )


Sets an event wait node's event.

######  Parameters

`hNode`
    \- Node to set the event for
`event`
    \- Event to use

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>), [CUDA_ERROR_INVALID_HANDLE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e90fd2e63260c6317ba943af0f7e4b8d21>), [CUDA_ERROR_OUT_OF_MEMORY](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9264c50688ed110e8476b591befe60c02>)

###### Description

Sets the event of event wait node `hNode` to `event`.

Note:

  * Graph objects are not threadsafe. [More here](<graphs-thread-safety.html#graphs-thread-safety>).

  * Note that this function may also return error codes from previous, asynchronous launches.


**See also:**

[cuGraphNodeSetParams](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1gbf18157f40ea2d160cb0b9e4e2b16139> "Update's a graph node's parameters."), [cuGraphAddEventWaitNode](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1g7306f3bcbec3406d80e110cd13405c5e> "Creates an event wait node and adds it to a graph."), [cuGraphEventWaitNodeGetEvent](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1g90b9d60f3f5f4156d1351a96ce92846e> "Returns the event associated with an event wait node."), [cuGraphEventRecordNodeSetEvent](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1g8ad8006aa7865865bf4d8c475cb21d87> "Sets an event record node's event."), [cuEventRecordWithFlags](<group__CUDA__EVENT.html#group__CUDA__EVENT_1ge577e0c132d9c4961f220d79f6762c4b> "Records an event."), [cuStreamWaitEvent](<group__CUDA__STREAM.html#group__CUDA__STREAM_1g6a898b652dfc6aa1d5c8d97062618b2f> "Make a compute stream wait on an event.")

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuGraphExecBatchMemOpNodeSetParams ( [CUgraphExec](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gf0abeceeaa9f0a39592fe36a538ea1f0>)Â hGraphExec, [CUgraphNode](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc72514a94dacc85ed0617f979211079c>)Â hNode, const [CUDA_BATCH_MEM_OP_NODE_PARAMS](<structCUDA__BATCH__MEM__OP__NODE__PARAMS__v1.html#structCUDA__BATCH__MEM__OP__NODE__PARAMS__v1>)*Â nodeParams )


Sets the parameters for a batch mem op node in the given graphExec.

######  Parameters

`hGraphExec`
    \- The executable graph in which to set the specified node
`hNode`
    \- Batch mem op node from the graph from which graphExec was instantiated
`nodeParams`
    \- Updated Parameters to set

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>),

###### Description

Sets the parameters of a batch mem op node in an executable graph `hGraphExec`. The node is identified by the corresponding node `hNode` in the non-executable graph, from which the executable graph was instantiated.

The following fields on operations may be modified on an executable graph:

op.waitValue.address op.waitValue.value[64] op.waitValue.flags bits corresponding to wait type (i.e. CU_STREAM_WAIT_VALUE_FLUSH bit cannot be modified) op.writeValue.address op.writeValue.value[64]

Other fields, such as the context, count or type of operations, and other types of operations such as membars, may not be modified.

`hNode` must not have been removed from the original graph.

The modifications only affect future launches of `hGraphExec`. Already enqueued or running launches of `hGraphExec` are not affected by this call. `hNode` is also not modified by this call.

The paramArray inside `nodeParams` is copied and therefore it can be freed after the call returns.

Note:

  * Graph objects are not threadsafe. [More here](<graphs-thread-safety.html#graphs-thread-safety>).

  * Note that this function may also return error codes from previous, asynchronous launches.


**See also:**

[cuGraphExecNodeSetParams](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1gb318c5b61ada0e333bb12d1d33dae48b> "Update's a graph node's parameters in an instantiated graph."), [cuStreamBatchMemOp](<group__CUDA__MEMOP.html#group__CUDA__MEMOP_1g764c442de9b671f9dec856e8ae531ed1> "Batch operations to synchronize the stream via memory operations."), [cuGraphAddBatchMemOpNode](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1g5acb6914dbd18cb1ae15ea9437a73c96> "Creates a batch memory operation node and adds it to a graph."), [cuGraphBatchMemOpNodeGetParams](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1g1d8039468b71285c61bc03ab3c302a28> "Returns a batch mem op node's parameters."), [cuGraphBatchMemOpNodeSetParams](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1g625ca946b58df3d17221ff7db5cd7800> "Sets a batch mem op node's parameters."), [cuGraphInstantiate](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1gb53b435e178cccfa37ac87285d2c3fa1> "Creates an executable graph from a graph.")

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuGraphExecChildGraphNodeSetParams ( [CUgraphExec](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gf0abeceeaa9f0a39592fe36a538ea1f0>)Â hGraphExec, [CUgraphNode](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc72514a94dacc85ed0617f979211079c>)Â hNode, [CUgraph](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g69f555c38df5b3fa1ed25efef794739a>)Â childGraph )


Updates node parameters in the child graph node in the given graphExec.

######  Parameters

`hGraphExec`
    \- The executable graph in which to set the specified node
`hNode`
    \- Host node from the graph which was used to instantiate graphExec
`childGraph`
    \- The graph supplying the updated parameters

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>),

###### Description

Updates the work represented by `hNode` in `hGraphExec` as though the nodes contained in `hNode's` graph had the parameters contained in `childGraph's` nodes at instantiation. `hNode` must remain in the graph which was used to instantiate `hGraphExec`. Changed edges to and from `hNode` are ignored.

The modifications only affect future launches of `hGraphExec`. Already enqueued or running launches of `hGraphExec` are not affected by this call. `hNode` is also not modified by this call.

The topology of `childGraph`, as well as the node insertion order, must match that of the graph contained in `hNode`. See [cuGraphExecUpdate()](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1g96efefc56df46927da7297f122adfb9f> "Check whether an executable graph can be updated with a graph and perform the update if possible.") for a list of restrictions on what can be updated in an instantiated graph. The update is recursive, so child graph nodes contained within the top level child graph will also be updated.

Note:

  * Graph objects are not threadsafe. [More here](<graphs-thread-safety.html#graphs-thread-safety>).

  * Note that this function may also return error codes from previous, asynchronous launches.


**See also:**

[cuGraphExecNodeSetParams](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1gb318c5b61ada0e333bb12d1d33dae48b> "Update's a graph node's parameters in an instantiated graph."), [cuGraphAddChildGraphNode](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1gde52afbcf91a8c79d4d7efbe0e3b6844> "Creates a child graph node and adds it to a graph."), [cuGraphChildGraphNodeGetGraph](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1gbe9fc9267316b3778ef0db507917b4fd> "Gets a handle to the embedded graph of a child graph node."), [cuGraphExecKernelNodeSetParams](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1gd84243569e4c3d6356b9f2eea20ed48c> "Sets the parameters for a kernel node in the given graphExec."), [cuGraphExecMemcpyNodeSetParams](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1g26186d58858ab32ccc7425b53786cce5> "Sets the parameters for a memcpy node in the given graphExec."), [cuGraphExecMemsetNodeSetParams](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1g5df5be09a0b7b3513e740ebbbcd59739> "Sets the parameters for a memset node in the given graphExec."), [cuGraphExecHostNodeSetParams](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1ga549b946cedb73dc2596314b2d52f8d8> "Sets the parameters for a host node in the given graphExec."), [cuGraphExecEventRecordNodeSetEvent](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1g62fea841fdc169c3ef18e9199f28a6a7> "Sets the event for an event record node in the given graphExec."), [cuGraphExecEventWaitNodeSetEvent](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1gfea9619d6ff228401613febae793f996> "Sets the event for an event wait node in the given graphExec."), [cuGraphExecExternalSemaphoresSignalNodeSetParams](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1g96aedf2977d0dce275fa3b3cf3700ade> "Sets the parameters for an external semaphore signal node in the given graphExec."), [cuGraphExecExternalSemaphoresWaitNodeSetParams](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1g98a93c41b057cc1b48c0498811f65ad3> "Sets the parameters for an external semaphore wait node in the given graphExec."), [cuGraphExecUpdate](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1g96efefc56df46927da7297f122adfb9f> "Check whether an executable graph can be updated with a graph and perform the update if possible."), [cuGraphInstantiate](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1gb53b435e178cccfa37ac87285d2c3fa1> "Creates an executable graph from a graph.")

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuGraphExecDestroy ( [CUgraphExec](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gf0abeceeaa9f0a39592fe36a538ea1f0>)Â hGraphExec )


Destroys an executable graph.

######  Parameters

`hGraphExec`
    \- Executable graph to destroy

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_DEINITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9acf52f132faf29b473cdda6061f0f44a>), [CUDA_ERROR_NOT_INITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e98feb999f0af99b4a25ab26b3866f4df8>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>)

###### Description

Destroys the executable graph specified by `hGraphExec`, as well as all of its executable nodes. If the executable graph is in-flight, it will not be terminated, but rather freed asynchronously on completion.

Note:

  * Graph objects are not threadsafe. [More here](<graphs-thread-safety.html#graphs-thread-safety>).

  * Note that this function may also return error codes from previous, asynchronous launches.


**See also:**

[cuGraphInstantiate](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1gb53b435e178cccfa37ac87285d2c3fa1> "Creates an executable graph from a graph."), [cuGraphUpload](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1ga7eb9849e6e4604864a482b38f25be48> "Uploads an executable graph in a stream."), [cuGraphLaunch](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1g6b2dceb3901e71a390d2bd8b0491e471> "Launches an executable graph in a stream.")

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuGraphExecEventRecordNodeSetEvent ( [CUgraphExec](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gf0abeceeaa9f0a39592fe36a538ea1f0>)Â hGraphExec, [CUgraphNode](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc72514a94dacc85ed0617f979211079c>)Â hNode, [CUevent](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g6d740185cf0953636d4ae37f68d7559b>)Â event )


Sets the event for an event record node in the given graphExec.

######  Parameters

`hGraphExec`
    \- The executable graph in which to set the specified node
`hNode`
    \- event record node from the graph from which graphExec was instantiated
`event`
    \- Updated event to use

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>),

###### Description

Sets the event of an event record node in an executable graph `hGraphExec`. The node is identified by the corresponding node `hNode` in the non-executable graph, from which the executable graph was instantiated.

The modifications only affect future launches of `hGraphExec`. Already enqueued or running launches of `hGraphExec` are not affected by this call. `hNode` is also not modified by this call.

Note:

  * Graph objects are not threadsafe. [More here](<graphs-thread-safety.html#graphs-thread-safety>).

  * Note that this function may also return error codes from previous, asynchronous launches.


**See also:**

[cuGraphExecNodeSetParams](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1gb318c5b61ada0e333bb12d1d33dae48b> "Update's a graph node's parameters in an instantiated graph."), [cuGraphAddEventRecordNode](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1ga7f6dcb109f4b7470ce6b067d39974a4> "Creates an event record node and adds it to a graph."), [cuGraphEventRecordNodeGetEvent](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1gb3608efc284aa2bbe5db61826d6e2259> "Returns the event associated with an event record node."), [cuGraphEventWaitNodeSetEvent](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1g2d6730d63efd399d3000952c54134930> "Sets an event wait node's event."), [cuEventRecordWithFlags](<group__CUDA__EVENT.html#group__CUDA__EVENT_1ge577e0c132d9c4961f220d79f6762c4b> "Records an event."), [cuStreamWaitEvent](<group__CUDA__STREAM.html#group__CUDA__STREAM_1g6a898b652dfc6aa1d5c8d97062618b2f> "Make a compute stream wait on an event."), [cuGraphExecKernelNodeSetParams](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1gd84243569e4c3d6356b9f2eea20ed48c> "Sets the parameters for a kernel node in the given graphExec."), [cuGraphExecMemcpyNodeSetParams](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1g26186d58858ab32ccc7425b53786cce5> "Sets the parameters for a memcpy node in the given graphExec."), [cuGraphExecMemsetNodeSetParams](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1g5df5be09a0b7b3513e740ebbbcd59739> "Sets the parameters for a memset node in the given graphExec."), [cuGraphExecHostNodeSetParams](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1ga549b946cedb73dc2596314b2d52f8d8> "Sets the parameters for a host node in the given graphExec."), [cuGraphExecChildGraphNodeSetParams](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1g8f2d9893f6b899f992db1a2942ec03ff> "Updates node parameters in the child graph node in the given graphExec."), [cuGraphExecEventWaitNodeSetEvent](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1gfea9619d6ff228401613febae793f996> "Sets the event for an event wait node in the given graphExec."), [cuGraphExecExternalSemaphoresSignalNodeSetParams](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1g96aedf2977d0dce275fa3b3cf3700ade> "Sets the parameters for an external semaphore signal node in the given graphExec."), [cuGraphExecExternalSemaphoresWaitNodeSetParams](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1g98a93c41b057cc1b48c0498811f65ad3> "Sets the parameters for an external semaphore wait node in the given graphExec."), [cuGraphExecUpdate](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1g96efefc56df46927da7297f122adfb9f> "Check whether an executable graph can be updated with a graph and perform the update if possible."), [cuGraphInstantiate](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1gb53b435e178cccfa37ac87285d2c3fa1> "Creates an executable graph from a graph.")

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuGraphExecEventWaitNodeSetEvent ( [CUgraphExec](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gf0abeceeaa9f0a39592fe36a538ea1f0>)Â hGraphExec, [CUgraphNode](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc72514a94dacc85ed0617f979211079c>)Â hNode, [CUevent](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g6d740185cf0953636d4ae37f68d7559b>)Â event )


Sets the event for an event wait node in the given graphExec.

######  Parameters

`hGraphExec`
    \- The executable graph in which to set the specified node
`hNode`
    \- event wait node from the graph from which graphExec was instantiated
`event`
    \- Updated event to use

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>),

###### Description

Sets the event of an event wait node in an executable graph `hGraphExec`. The node is identified by the corresponding node `hNode` in the non-executable graph, from which the executable graph was instantiated.

The modifications only affect future launches of `hGraphExec`. Already enqueued or running launches of `hGraphExec` are not affected by this call. `hNode` is also not modified by this call.

Note:

  * Graph objects are not threadsafe. [More here](<graphs-thread-safety.html#graphs-thread-safety>).

  * Note that this function may also return error codes from previous, asynchronous launches.


**See also:**

[cuGraphExecNodeSetParams](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1gb318c5b61ada0e333bb12d1d33dae48b> "Update's a graph node's parameters in an instantiated graph."), [cuGraphAddEventWaitNode](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1g7306f3bcbec3406d80e110cd13405c5e> "Creates an event wait node and adds it to a graph."), [cuGraphEventWaitNodeGetEvent](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1g90b9d60f3f5f4156d1351a96ce92846e> "Returns the event associated with an event wait node."), [cuGraphEventRecordNodeSetEvent](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1g8ad8006aa7865865bf4d8c475cb21d87> "Sets an event record node's event."), [cuEventRecordWithFlags](<group__CUDA__EVENT.html#group__CUDA__EVENT_1ge577e0c132d9c4961f220d79f6762c4b> "Records an event."), [cuStreamWaitEvent](<group__CUDA__STREAM.html#group__CUDA__STREAM_1g6a898b652dfc6aa1d5c8d97062618b2f> "Make a compute stream wait on an event."), [cuGraphExecKernelNodeSetParams](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1gd84243569e4c3d6356b9f2eea20ed48c> "Sets the parameters for a kernel node in the given graphExec."), [cuGraphExecMemcpyNodeSetParams](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1g26186d58858ab32ccc7425b53786cce5> "Sets the parameters for a memcpy node in the given graphExec."), [cuGraphExecMemsetNodeSetParams](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1g5df5be09a0b7b3513e740ebbbcd59739> "Sets the parameters for a memset node in the given graphExec."), [cuGraphExecHostNodeSetParams](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1ga549b946cedb73dc2596314b2d52f8d8> "Sets the parameters for a host node in the given graphExec."), [cuGraphExecChildGraphNodeSetParams](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1g8f2d9893f6b899f992db1a2942ec03ff> "Updates node parameters in the child graph node in the given graphExec."), [cuGraphExecEventRecordNodeSetEvent](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1g62fea841fdc169c3ef18e9199f28a6a7> "Sets the event for an event record node in the given graphExec."), [cuGraphExecExternalSemaphoresSignalNodeSetParams](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1g96aedf2977d0dce275fa3b3cf3700ade> "Sets the parameters for an external semaphore signal node in the given graphExec."), [cuGraphExecExternalSemaphoresWaitNodeSetParams](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1g98a93c41b057cc1b48c0498811f65ad3> "Sets the parameters for an external semaphore wait node in the given graphExec."), [cuGraphExecUpdate](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1g96efefc56df46927da7297f122adfb9f> "Check whether an executable graph can be updated with a graph and perform the update if possible."), [cuGraphInstantiate](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1gb53b435e178cccfa37ac87285d2c3fa1> "Creates an executable graph from a graph.")

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuGraphExecExternalSemaphoresSignalNodeSetParams ( [CUgraphExec](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gf0abeceeaa9f0a39592fe36a538ea1f0>)Â hGraphExec, [CUgraphNode](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc72514a94dacc85ed0617f979211079c>)Â hNode, const [CUDA_EXT_SEM_SIGNAL_NODE_PARAMS](<structCUDA__EXT__SEM__SIGNAL__NODE__PARAMS__v1.html#structCUDA__EXT__SEM__SIGNAL__NODE__PARAMS__v1>)*Â nodeParams )


Sets the parameters for an external semaphore signal node in the given graphExec.

######  Parameters

`hGraphExec`
    \- The executable graph in which to set the specified node
`hNode`
    \- semaphore signal node from the graph from which graphExec was instantiated
`nodeParams`
    \- Updated Parameters to set

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>),

###### Description

Sets the parameters of an external semaphore signal node in an executable graph `hGraphExec`. The node is identified by the corresponding node `hNode` in the non-executable graph, from which the executable graph was instantiated.

`hNode` must not have been removed from the original graph.

The modifications only affect future launches of `hGraphExec`. Already enqueued or running launches of `hGraphExec` are not affected by this call. `hNode` is also not modified by this call.

Changing `nodeParams->numExtSems` is not supported.

Note:

  * Graph objects are not threadsafe. [More here](<graphs-thread-safety.html#graphs-thread-safety>).

  * Note that this function may also return error codes from previous, asynchronous launches.


**See also:**

[cuGraphExecNodeSetParams](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1gb318c5b61ada0e333bb12d1d33dae48b> "Update's a graph node's parameters in an instantiated graph."), [cuGraphAddExternalSemaphoresSignalNode](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1g6410d5401de205568457fba5e1862ad3> "Creates an external semaphore signal node and adds it to a graph."), [cuImportExternalSemaphore](<group__CUDA__EXTRES__INTEROP.html#group__CUDA__EXTRES__INTEROP_1ge593134f5f9650474af74db644c4a326> "Imports an external semaphore."), [cuSignalExternalSemaphoresAsync](<group__CUDA__EXTRES__INTEROP.html#group__CUDA__EXTRES__INTEROP_1g86cd6c4b3f439ba786f4e65d1b8107c3> "Signals a set of external semaphore objects."), [cuWaitExternalSemaphoresAsync](<group__CUDA__EXTRES__INTEROP.html#group__CUDA__EXTRES__INTEROP_1g063f01a524818ac89bacf521c55a39f0> "Waits on a set of external semaphore objects."), [cuGraphExecKernelNodeSetParams](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1gd84243569e4c3d6356b9f2eea20ed48c> "Sets the parameters for a kernel node in the given graphExec."), [cuGraphExecMemcpyNodeSetParams](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1g26186d58858ab32ccc7425b53786cce5> "Sets the parameters for a memcpy node in the given graphExec."), [cuGraphExecMemsetNodeSetParams](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1g5df5be09a0b7b3513e740ebbbcd59739> "Sets the parameters for a memset node in the given graphExec."), [cuGraphExecHostNodeSetParams](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1ga549b946cedb73dc2596314b2d52f8d8> "Sets the parameters for a host node in the given graphExec."), [cuGraphExecChildGraphNodeSetParams](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1g8f2d9893f6b899f992db1a2942ec03ff> "Updates node parameters in the child graph node in the given graphExec."), [cuGraphExecEventRecordNodeSetEvent](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1g62fea841fdc169c3ef18e9199f28a6a7> "Sets the event for an event record node in the given graphExec."), [cuGraphExecEventWaitNodeSetEvent](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1gfea9619d6ff228401613febae793f996> "Sets the event for an event wait node in the given graphExec."), [cuGraphExecExternalSemaphoresWaitNodeSetParams](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1g98a93c41b057cc1b48c0498811f65ad3> "Sets the parameters for an external semaphore wait node in the given graphExec."), [cuGraphExecUpdate](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1g96efefc56df46927da7297f122adfb9f> "Check whether an executable graph can be updated with a graph and perform the update if possible."), [cuGraphInstantiate](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1gb53b435e178cccfa37ac87285d2c3fa1> "Creates an executable graph from a graph.")

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuGraphExecExternalSemaphoresWaitNodeSetParams ( [CUgraphExec](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gf0abeceeaa9f0a39592fe36a538ea1f0>)Â hGraphExec, [CUgraphNode](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc72514a94dacc85ed0617f979211079c>)Â hNode, const [CUDA_EXT_SEM_WAIT_NODE_PARAMS](<structCUDA__EXT__SEM__WAIT__NODE__PARAMS__v1.html#structCUDA__EXT__SEM__WAIT__NODE__PARAMS__v1>)*Â nodeParams )


Sets the parameters for an external semaphore wait node in the given graphExec.

######  Parameters

`hGraphExec`
    \- The executable graph in which to set the specified node
`hNode`
    \- semaphore wait node from the graph from which graphExec was instantiated
`nodeParams`
    \- Updated Parameters to set

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>),

###### Description

Sets the parameters of an external semaphore wait node in an executable graph `hGraphExec`. The node is identified by the corresponding node `hNode` in the non-executable graph, from which the executable graph was instantiated.

`hNode` must not have been removed from the original graph.

The modifications only affect future launches of `hGraphExec`. Already enqueued or running launches of `hGraphExec` are not affected by this call. `hNode` is also not modified by this call.

Changing `nodeParams->numExtSems` is not supported.

Note:

  * Graph objects are not threadsafe. [More here](<graphs-thread-safety.html#graphs-thread-safety>).

  * Note that this function may also return error codes from previous, asynchronous launches.


**See also:**

[cuGraphExecNodeSetParams](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1gb318c5b61ada0e333bb12d1d33dae48b> "Update's a graph node's parameters in an instantiated graph."), [cuGraphAddExternalSemaphoresWaitNode](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1g49131c65fcef0b60b3939e008f7b467e> "Creates an external semaphore wait node and adds it to a graph."), [cuImportExternalSemaphore](<group__CUDA__EXTRES__INTEROP.html#group__CUDA__EXTRES__INTEROP_1ge593134f5f9650474af74db644c4a326> "Imports an external semaphore."), [cuSignalExternalSemaphoresAsync](<group__CUDA__EXTRES__INTEROP.html#group__CUDA__EXTRES__INTEROP_1g86cd6c4b3f439ba786f4e65d1b8107c3> "Signals a set of external semaphore objects."), [cuWaitExternalSemaphoresAsync](<group__CUDA__EXTRES__INTEROP.html#group__CUDA__EXTRES__INTEROP_1g063f01a524818ac89bacf521c55a39f0> "Waits on a set of external semaphore objects."), [cuGraphExecKernelNodeSetParams](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1gd84243569e4c3d6356b9f2eea20ed48c> "Sets the parameters for a kernel node in the given graphExec."), [cuGraphExecMemcpyNodeSetParams](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1g26186d58858ab32ccc7425b53786cce5> "Sets the parameters for a memcpy node in the given graphExec."), [cuGraphExecMemsetNodeSetParams](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1g5df5be09a0b7b3513e740ebbbcd59739> "Sets the parameters for a memset node in the given graphExec."), [cuGraphExecHostNodeSetParams](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1ga549b946cedb73dc2596314b2d52f8d8> "Sets the parameters for a host node in the given graphExec."), [cuGraphExecChildGraphNodeSetParams](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1g8f2d9893f6b899f992db1a2942ec03ff> "Updates node parameters in the child graph node in the given graphExec."), [cuGraphExecEventRecordNodeSetEvent](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1g62fea841fdc169c3ef18e9199f28a6a7> "Sets the event for an event record node in the given graphExec."), [cuGraphExecEventWaitNodeSetEvent](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1gfea9619d6ff228401613febae793f996> "Sets the event for an event wait node in the given graphExec."), [cuGraphExecExternalSemaphoresSignalNodeSetParams](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1g96aedf2977d0dce275fa3b3cf3700ade> "Sets the parameters for an external semaphore signal node in the given graphExec."), [cuGraphExecUpdate](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1g96efefc56df46927da7297f122adfb9f> "Check whether an executable graph can be updated with a graph and perform the update if possible."), [cuGraphInstantiate](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1gb53b435e178cccfa37ac87285d2c3fa1> "Creates an executable graph from a graph.")

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuGraphExecGetFlags ( [CUgraphExec](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gf0abeceeaa9f0a39592fe36a538ea1f0>)Â hGraphExec, cuuint64_t*Â flags )


Query the instantiation flags of an executable graph.

######  Parameters

`hGraphExec`
    \- The executable graph to query
`flags`
    \- Returns the instantiation flags

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>),

###### Description

Returns the flags that were passed to instantiation for the given executable graph. [CUDA_GRAPH_INSTANTIATE_FLAG_UPLOAD](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg070bf5517d3a7915667c256eefce49569557f13a16fe73b147fb4c9018e92925>) will not be returned by this API as it does not affect the resulting executable graph.

Note:

  * Graph objects are not threadsafe. [More here](<graphs-thread-safety.html#graphs-thread-safety>).

  * Note that this function may also return error codes from previous, asynchronous launches.


**See also:**

[cuGraphInstantiate](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1gb53b435e178cccfa37ac87285d2c3fa1> "Creates an executable graph from a graph."), [cuGraphInstantiateWithParams](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1g8d9541e4df43ee8440e794634a0d1af8> "Creates an executable graph from a graph.")

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuGraphExecGetId ( [CUgraphExec](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gf0abeceeaa9f0a39592fe36a538ea1f0>)Â hGraphExec, unsigned int*Â graphId )


Returns the id of a given graph exec.

######  Parameters

`hGraphExec`
    \- Graph to query
`graphId`


###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>)[CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>)

###### Description

Returns the id of `hGraphExec` in `*graphId`. The value in `*graphId` will match that referenced by [cuGraphDebugDotPrint](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1g0fb0c4d319477a0a98da005fcb0dacc4> "Write a DOT file describing graph structure.").

**See also:**

[cuGraphGetNodes](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1gfa35a8e2d2fc32f48dbd67ba27cf27e5> "Returns a graph's nodes."), [cuGraphDebugDotPrint](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1g0fb0c4d319477a0a98da005fcb0dacc4> "Write a DOT file describing graph structure.")[cuGraphNodeGetContainingGraph](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1gbbfe267adf728f1c53aa9d99ba101b92> "Returns the graph that contains a given graph node.")[cuGraphNodeGetLocalId](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1g18fd5107a28aaae1e396efcb0edaa70d> "Returns the local node id of a given graph node.")[cuGraphNodeGetToolsId](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1g10d4cf58921a26acce90ed1a03fcd4c1> "Returns an id used by tools to identify a given node.")[cuGraphGetId](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1g0f05ae29d14198ff57d722156d60aa41> "Returns the id of a given graph.")

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuGraphExecHostNodeSetParams ( [CUgraphExec](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gf0abeceeaa9f0a39592fe36a538ea1f0>)Â hGraphExec, [CUgraphNode](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc72514a94dacc85ed0617f979211079c>)Â hNode, const [CUDA_HOST_NODE_PARAMS](<structCUDA__HOST__NODE__PARAMS__v1.html#structCUDA__HOST__NODE__PARAMS__v1>)*Â nodeParams )


Sets the parameters for a host node in the given graphExec.

######  Parameters

`hGraphExec`
    \- The executable graph in which to set the specified node
`hNode`
    \- Host node from the graph which was used to instantiate graphExec
`nodeParams`
    \- The updated parameters to set

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>),

###### Description

Updates the work represented by `hNode` in `hGraphExec` as though `hNode` had contained `nodeParams` at instantiation. hNode must remain in the graph which was used to instantiate `hGraphExec`. Changed edges to and from hNode are ignored.

The modifications only affect future launches of `hGraphExec`. Already enqueued or running launches of `hGraphExec` are not affected by this call. hNode is also not modified by this call.

Note:

  * Graph objects are not threadsafe. [More here](<graphs-thread-safety.html#graphs-thread-safety>).

  * Note that this function may also return error codes from previous, asynchronous launches.


**See also:**

[cuGraphExecNodeSetParams](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1gb318c5b61ada0e333bb12d1d33dae48b> "Update's a graph node's parameters in an instantiated graph."), [cuGraphAddHostNode](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1g0809d65e85a3c052296373954a05b1d6> "Creates a host execution node and adds it to a graph."), [cuGraphHostNodeSetParams](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1gae021ae8f19ee51044339db9c24dd266> "Sets a host node's parameters."), [cuGraphExecKernelNodeSetParams](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1gd84243569e4c3d6356b9f2eea20ed48c> "Sets the parameters for a kernel node in the given graphExec."), [cuGraphExecMemcpyNodeSetParams](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1g26186d58858ab32ccc7425b53786cce5> "Sets the parameters for a memcpy node in the given graphExec."), [cuGraphExecMemsetNodeSetParams](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1g5df5be09a0b7b3513e740ebbbcd59739> "Sets the parameters for a memset node in the given graphExec."), [cuGraphExecChildGraphNodeSetParams](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1g8f2d9893f6b899f992db1a2942ec03ff> "Updates node parameters in the child graph node in the given graphExec."), [cuGraphExecEventRecordNodeSetEvent](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1g62fea841fdc169c3ef18e9199f28a6a7> "Sets the event for an event record node in the given graphExec."), [cuGraphExecEventWaitNodeSetEvent](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1gfea9619d6ff228401613febae793f996> "Sets the event for an event wait node in the given graphExec."), [cuGraphExecExternalSemaphoresSignalNodeSetParams](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1g96aedf2977d0dce275fa3b3cf3700ade> "Sets the parameters for an external semaphore signal node in the given graphExec."), [cuGraphExecExternalSemaphoresWaitNodeSetParams](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1g98a93c41b057cc1b48c0498811f65ad3> "Sets the parameters for an external semaphore wait node in the given graphExec."), [cuGraphExecUpdate](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1g96efefc56df46927da7297f122adfb9f> "Check whether an executable graph can be updated with a graph and perform the update if possible."), [cuGraphInstantiate](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1gb53b435e178cccfa37ac87285d2c3fa1> "Creates an executable graph from a graph.")

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuGraphExecKernelNodeSetParams ( [CUgraphExec](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gf0abeceeaa9f0a39592fe36a538ea1f0>)Â hGraphExec, [CUgraphNode](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc72514a94dacc85ed0617f979211079c>)Â hNode, const [CUDA_KERNEL_NODE_PARAMS](<structCUDA__KERNEL__NODE__PARAMS__v2.html#structCUDA__KERNEL__NODE__PARAMS__v2>)*Â nodeParams )


Sets the parameters for a kernel node in the given graphExec.

######  Parameters

`hGraphExec`
    \- The executable graph in which to set the specified node
`hNode`
    \- kernel node from the graph from which graphExec was instantiated
`nodeParams`
    \- Updated Parameters to set

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>),

###### Description

Sets the parameters of a kernel node in an executable graph `hGraphExec`. The node is identified by the corresponding node `hNode` in the non-executable graph, from which the executable graph was instantiated.

`hNode` must not have been removed from the original graph. All `nodeParams` fields may change, but the following restrictions apply to `func` updates:

  * The owning context of the function cannot change.

  * A node whose function originally did not use CUDA dynamic parallelism cannot be updated to a function which uses CDP

  * A node whose function originally did not make device-side update calls cannot be updated to a function which makes device-side update calls.

  * If `hGraphExec` was not instantiated for device launch, a node whose function originally did not use device-side [cudaGraphLaunch()](<../cuda-runtime-api/group__CUDART__GRAPH.html#group__CUDART__GRAPH_1g1920584881db959c8c74130d79019b73>) cannot be updated to a function which uses device-side [cudaGraphLaunch()](<../cuda-runtime-api/group__CUDART__GRAPH.html#group__CUDART__GRAPH_1g1920584881db959c8c74130d79019b73>) unless the node resides on the same context as nodes which contained such calls at instantiate-time. If no such calls were present at instantiation, these updates cannot be performed at all.


The modifications only affect future launches of `hGraphExec`. Already enqueued or running launches of `hGraphExec` are not affected by this call. `hNode` is also not modified by this call.

If `hNode` is a device-updatable kernel node, the next upload/launch of `hGraphExec` will overwrite any previous device-side updates. Additionally, applying host updates to a device-updatable kernel node while it is being updated from the device will result in undefined behavior.

Note:

  * Graph objects are not threadsafe. [More here](<graphs-thread-safety.html#graphs-thread-safety>).

  * Note that this function may also return error codes from previous, asynchronous launches.


**See also:**

[cuGraphExecNodeSetParams](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1gb318c5b61ada0e333bb12d1d33dae48b> "Update's a graph node's parameters in an instantiated graph."), [cuGraphAddKernelNode](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1g50d871e3bd06c1b835e52f2966ef366b> "Creates a kernel execution node and adds it to a graph."), [cuGraphKernelNodeSetParams](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1ga268bf2fd520f5aa3a3d700005df6703> "Sets a kernel node's parameters."), [cuGraphExecMemcpyNodeSetParams](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1g26186d58858ab32ccc7425b53786cce5> "Sets the parameters for a memcpy node in the given graphExec."), [cuGraphExecMemsetNodeSetParams](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1g5df5be09a0b7b3513e740ebbbcd59739> "Sets the parameters for a memset node in the given graphExec."), [cuGraphExecHostNodeSetParams](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1ga549b946cedb73dc2596314b2d52f8d8> "Sets the parameters for a host node in the given graphExec."), [cuGraphExecChildGraphNodeSetParams](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1g8f2d9893f6b899f992db1a2942ec03ff> "Updates node parameters in the child graph node in the given graphExec."), [cuGraphExecEventRecordNodeSetEvent](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1g62fea841fdc169c3ef18e9199f28a6a7> "Sets the event for an event record node in the given graphExec."), [cuGraphExecEventWaitNodeSetEvent](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1gfea9619d6ff228401613febae793f996> "Sets the event for an event wait node in the given graphExec."), [cuGraphExecExternalSemaphoresSignalNodeSetParams](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1g96aedf2977d0dce275fa3b3cf3700ade> "Sets the parameters for an external semaphore signal node in the given graphExec."), [cuGraphExecExternalSemaphoresWaitNodeSetParams](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1g98a93c41b057cc1b48c0498811f65ad3> "Sets the parameters for an external semaphore wait node in the given graphExec."), [cuGraphExecUpdate](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1g96efefc56df46927da7297f122adfb9f> "Check whether an executable graph can be updated with a graph and perform the update if possible."), [cuGraphInstantiate](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1gb53b435e178cccfa37ac87285d2c3fa1> "Creates an executable graph from a graph.")

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuGraphExecMemcpyNodeSetParams ( [CUgraphExec](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gf0abeceeaa9f0a39592fe36a538ea1f0>)Â hGraphExec, [CUgraphNode](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc72514a94dacc85ed0617f979211079c>)Â hNode, const [CUDA_MEMCPY3D](<structCUDA__MEMCPY3D__v2.html#structCUDA__MEMCPY3D__v2>)*Â copyParams, [CUcontext](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gf9f5bd81658f866613785b3a0bb7d7d9>)Â ctx )


Sets the parameters for a memcpy node in the given graphExec.

######  Parameters

`hGraphExec`
    \- The executable graph in which to set the specified node
`hNode`
    \- Memcpy node from the graph which was used to instantiate graphExec
`copyParams`
    \- The updated parameters to set
`ctx`
    \- Context on which to run the node

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>),

###### Description

Updates the work represented by `hNode` in `hGraphExec` as though `hNode` had contained `copyParams` at instantiation. hNode must remain in the graph which was used to instantiate `hGraphExec`. Changed edges to and from hNode are ignored.

The source and destination memory in `copyParams` must be allocated from the same contexts as the original source and destination memory. Both the instantiation-time memory operands and the memory operands in `copyParams` must be 1-dimensional. Zero-length operations are not supported.

The modifications only affect future launches of `hGraphExec`. Already enqueued or running launches of `hGraphExec` are not affected by this call. hNode is also not modified by this call.

Returns CUDA_ERROR_INVALID_VALUE if the memory operands' mappings changed or either the original or new memory operands are multidimensional.

Note:

  * Graph objects are not threadsafe. [More here](<graphs-thread-safety.html#graphs-thread-safety>).

  * Note that this function may also return error codes from previous, asynchronous launches.


**See also:**

[cuGraphExecNodeSetParams](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1gb318c5b61ada0e333bb12d1d33dae48b> "Update's a graph node's parameters in an instantiated graph."), [cuGraphAddMemcpyNode](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1g674da6ab54a677f13e0e0e8206ff5073> "Creates a memcpy node and adds it to a graph."), [cuGraphMemcpyNodeSetParams](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1ga278a7ec0700c86abb0b2cfdf4d3dc1d> "Sets a memcpy node's parameters."), [cuGraphExecKernelNodeSetParams](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1gd84243569e4c3d6356b9f2eea20ed48c> "Sets the parameters for a kernel node in the given graphExec."), [cuGraphExecMemsetNodeSetParams](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1g5df5be09a0b7b3513e740ebbbcd59739> "Sets the parameters for a memset node in the given graphExec."), [cuGraphExecHostNodeSetParams](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1ga549b946cedb73dc2596314b2d52f8d8> "Sets the parameters for a host node in the given graphExec."), [cuGraphExecChildGraphNodeSetParams](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1g8f2d9893f6b899f992db1a2942ec03ff> "Updates node parameters in the child graph node in the given graphExec."), [cuGraphExecEventRecordNodeSetEvent](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1g62fea841fdc169c3ef18e9199f28a6a7> "Sets the event for an event record node in the given graphExec."), [cuGraphExecEventWaitNodeSetEvent](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1gfea9619d6ff228401613febae793f996> "Sets the event for an event wait node in the given graphExec."), [cuGraphExecExternalSemaphoresSignalNodeSetParams](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1g96aedf2977d0dce275fa3b3cf3700ade> "Sets the parameters for an external semaphore signal node in the given graphExec."), [cuGraphExecExternalSemaphoresWaitNodeSetParams](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1g98a93c41b057cc1b48c0498811f65ad3> "Sets the parameters for an external semaphore wait node in the given graphExec."), [cuGraphExecUpdate](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1g96efefc56df46927da7297f122adfb9f> "Check whether an executable graph can be updated with a graph and perform the update if possible."), [cuGraphInstantiate](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1gb53b435e178cccfa37ac87285d2c3fa1> "Creates an executable graph from a graph.")

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuGraphExecMemsetNodeSetParams ( [CUgraphExec](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gf0abeceeaa9f0a39592fe36a538ea1f0>)Â hGraphExec, [CUgraphNode](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc72514a94dacc85ed0617f979211079c>)Â hNode, const [CUDA_MEMSET_NODE_PARAMS](<structCUDA__MEMSET__NODE__PARAMS__v1.html#structCUDA__MEMSET__NODE__PARAMS__v1>)*Â memsetParams, [CUcontext](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gf9f5bd81658f866613785b3a0bb7d7d9>)Â ctx )


Sets the parameters for a memset node in the given graphExec.

######  Parameters

`hGraphExec`
    \- The executable graph in which to set the specified node
`hNode`
    \- Memset node from the graph which was used to instantiate graphExec
`memsetParams`
    \- The updated parameters to set
`ctx`
    \- Context on which to run the node

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>),

###### Description

Updates the work represented by `hNode` in `hGraphExec` as though `hNode` had contained `memsetParams` at instantiation. hNode must remain in the graph which was used to instantiate `hGraphExec`. Changed edges to and from hNode are ignored.

Zero sized operations are not supported.

The new destination pointer in memsetParams must be to the same kind of allocation as the original destination pointer and have the same context association and device mapping as the original destination pointer.

Both the value and pointer address may be updated. Changing other aspects of the memset (width, height, element size or pitch) may cause the update to be rejected. Specifically, for 2d memsets, all dimension changes are rejected. For 1d memsets, changes in height are explicitly rejected and other changes are opportunistically allowed if the resulting work maps onto the work resources already allocated for the node.

The modifications only affect future launches of `hGraphExec`. Already enqueued or running launches of `hGraphExec` are not affected by this call. hNode is also not modified by this call.

Note:

  * Graph objects are not threadsafe. [More here](<graphs-thread-safety.html#graphs-thread-safety>).

  * Note that this function may also return error codes from previous, asynchronous launches.


**See also:**

[cuGraphExecNodeSetParams](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1gb318c5b61ada0e333bb12d1d33dae48b> "Update's a graph node's parameters in an instantiated graph."), [cuGraphAddMemsetNode](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1g89dc8fc3743392777c0daa2c4aca40d3> "Creates a memset node and adds it to a graph."), [cuGraphMemsetNodeSetParams](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1gc27f3fd83a6e33c74519066fbaa0de67> "Sets a memset node's parameters."), [cuGraphExecKernelNodeSetParams](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1gd84243569e4c3d6356b9f2eea20ed48c> "Sets the parameters for a kernel node in the given graphExec."), [cuGraphExecMemcpyNodeSetParams](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1g26186d58858ab32ccc7425b53786cce5> "Sets the parameters for a memcpy node in the given graphExec."), [cuGraphExecHostNodeSetParams](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1ga549b946cedb73dc2596314b2d52f8d8> "Sets the parameters for a host node in the given graphExec."), [cuGraphExecChildGraphNodeSetParams](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1g8f2d9893f6b899f992db1a2942ec03ff> "Updates node parameters in the child graph node in the given graphExec."), [cuGraphExecEventRecordNodeSetEvent](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1g62fea841fdc169c3ef18e9199f28a6a7> "Sets the event for an event record node in the given graphExec."), [cuGraphExecEventWaitNodeSetEvent](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1gfea9619d6ff228401613febae793f996> "Sets the event for an event wait node in the given graphExec."), [cuGraphExecExternalSemaphoresSignalNodeSetParams](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1g96aedf2977d0dce275fa3b3cf3700ade> "Sets the parameters for an external semaphore signal node in the given graphExec."), [cuGraphExecExternalSemaphoresWaitNodeSetParams](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1g98a93c41b057cc1b48c0498811f65ad3> "Sets the parameters for an external semaphore wait node in the given graphExec."), [cuGraphExecUpdate](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1g96efefc56df46927da7297f122adfb9f> "Check whether an executable graph can be updated with a graph and perform the update if possible."), [cuGraphInstantiate](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1gb53b435e178cccfa37ac87285d2c3fa1> "Creates an executable graph from a graph.")

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuGraphExecNodeSetParams ( [CUgraphExec](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gf0abeceeaa9f0a39592fe36a538ea1f0>)Â hGraphExec, [CUgraphNode](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc72514a94dacc85ed0617f979211079c>)Â hNode, [CUgraphNodeParams](<structCUgraphNodeParams.html#structCUgraphNodeParams>)*Â nodeParams )


Update's a graph node's parameters in an instantiated graph.

######  Parameters

`hGraphExec`
    \- The executable graph in which to update the specified node
`hNode`
    \- Corresponding node from the graph from which graphExec was instantiated
`nodeParams`
    \- Updated Parameters to set

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>), [CUDA_ERROR_NOT_SUPPORTED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e954756ae7ade0dfd09faeccb513dd831b>)

###### Description

Sets the parameters of a node in an executable graph `hGraphExec`. The node is identified by the corresponding node `hNode` in the non-executable graph from which the executable graph was instantiated. `hNode` must not have been removed from the original graph.

The modifications only affect future launches of `hGraphExec`. Already enqueued or running launches of `hGraphExec` are not affected by this call. `hNode` is also not modified by this call.

Allowed changes to parameters on executable graphs are as follows:

Node type |  Allowed changes
---|---
kernel |  See [cuGraphExecKernelNodeSetParams](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1gd84243569e4c3d6356b9f2eea20ed48c> "Sets the parameters for a kernel node in the given graphExec.")
memcpy |  Addresses for 1-dimensional copies if allocated in same context; see [cuGraphExecMemcpyNodeSetParams](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1g26186d58858ab32ccc7425b53786cce5> "Sets the parameters for a memcpy node in the given graphExec.")
memset |  Addresses for 1-dimensional memsets if allocated in same context; see [cuGraphExecMemsetNodeSetParams](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1g5df5be09a0b7b3513e740ebbbcd59739> "Sets the parameters for a memset node in the given graphExec.")
host |  Unrestricted
child graph |  Topology must match and restrictions apply recursively; see [cuGraphExecUpdate](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1g96efefc56df46927da7297f122adfb9f> "Check whether an executable graph can be updated with a graph and perform the update if possible.")
event wait |  Unrestricted
event record |  Unrestricted
external semaphore signal |  Number of semaphore operations cannot change
external semaphore wait |  Number of semaphore operations cannot change
memory allocation |  API unsupported
memory free |  API unsupported
batch memops |  Addresses, values, and operation type for wait operations; see [cuGraphExecBatchMemOpNodeSetParams](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1g23f51bb4e4c029bb32fac0146e38c076> "Sets the parameters for a batch mem op node in the given graphExec.")

Note:

  * Graph objects are not threadsafe. [More here](<graphs-thread-safety.html#graphs-thread-safety>).

  * Note that this function may also return error codes from previous, asynchronous launches.


**See also:**

[cuGraphAddNode](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1ge01208e62f72a53367a2af903bf17d23> "Adds a node of arbitrary type to a graph."), [cuGraphNodeSetParams](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1gbf18157f40ea2d160cb0b9e4e2b16139> "Update's a graph node's parameters.")[cuGraphExecUpdate](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1g96efefc56df46927da7297f122adfb9f> "Check whether an executable graph can be updated with a graph and perform the update if possible."), [cuGraphInstantiate](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1gb53b435e178cccfa37ac87285d2c3fa1> "Creates an executable graph from a graph.")

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuGraphExecUpdate ( [CUgraphExec](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gf0abeceeaa9f0a39592fe36a538ea1f0>)Â hGraphExec, [CUgraph](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g69f555c38df5b3fa1ed25efef794739a>)Â hGraph, [CUgraphExecUpdateResultInfo](<structCUgraphExecUpdateResultInfo__v1.html#structCUgraphExecUpdateResultInfo__v1>)*Â resultInfo )


Check whether an executable graph can be updated with a graph and perform the update if possible.

######  Parameters

`hGraphExec`
    The instantiated graph to be updated
`hGraph`
    The graph containing the updated parameters
`resultInfo`
    the error info structure

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_GRAPH_EXEC_UPDATE_FAILURE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9114e389888b89d68639b330f478386c6>),

###### Description

Updates the node parameters in the instantiated graph specified by `hGraphExec` with the node parameters in a topologically identical graph specified by `hGraph`.

Limitations:

  * Kernel nodes:
    * The owning context of the function cannot change.

    * A node whose function originally did not use CUDA dynamic parallelism cannot be updated to a function which uses CDP.

    * A node whose function originally did not make device-side update calls cannot be updated to a function which makes device-side update calls.

    * A cooperative node cannot be updated to a non-cooperative node, and vice-versa.

    * If the graph was instantiated with CUDA_GRAPH_INSTANTIATE_FLAG_USE_NODE_PRIORITY, the priority attribute cannot change. Equality is checked on the originally requested priority values, before they are clamped to the device's supported range.

    * If `hGraphExec` was not instantiated for device launch, a node whose function originally did not use device-side [cudaGraphLaunch()](<../cuda-runtime-api/group__CUDART__GRAPH.html#group__CUDART__GRAPH_1g1920584881db959c8c74130d79019b73>) cannot be updated to a function which uses device-side [cudaGraphLaunch()](<../cuda-runtime-api/group__CUDART__GRAPH.html#group__CUDART__GRAPH_1g1920584881db959c8c74130d79019b73>) unless the node resides on the same context as nodes which contained such calls at instantiate-time. If no such calls were present at instantiation, these updates cannot be performed at all.

    * Neither `hGraph` nor `hGraphExec` may contain device-updatable kernel nodes.

  * Memset and memcpy nodes:
    * The CUDA device(s) to which the operand(s) was allocated/mapped cannot change.

    * The source/destination memory must be allocated from the same contexts as the original source/destination memory.

    * For 2d memsets, only address and assigned value may be updated.

    * For 1d memsets, updating dimensions is also allowed, but may fail if the resulting operation doesn't map onto the work resources already allocated for the node.

  * Additional memcpy node restrictions:
    * Changing either the source or destination memory type(i.e. CU_MEMORYTYPE_DEVICE, CU_MEMORYTYPE_ARRAY, etc.) is not supported.

  * External semaphore wait nodes and record nodes:
    * Changing the number of semaphores is not supported.

  * Conditional nodes:
    * Changing node parameters is not supported.

    * Changing parameters of nodes within the conditional body graph is subject to the rules above.

    * Conditional handle flags and default values are updated as part of the graph update.


Note: The API may add further restrictions in future releases. The return code should always be checked.

cuGraphExecUpdate sets the result member of `resultInfo` to CU_GRAPH_EXEC_UPDATE_ERROR_TOPOLOGY_CHANGED under the following conditions:

  * The count of nodes directly in `hGraphExec` and `hGraph` differ, in which case resultInfo->errorNode is set to NULL.

  * `hGraph` has more exit nodes than `hGraph`, in which case resultInfo->errorNode is set to one of the exit nodes in hGraph.

  * A node in `hGraph` has a different number of dependencies than the node from `hGraphExec` it is paired with, in which case resultInfo->errorNode is set to the node from `hGraph`.

  * A node in `hGraph` has a dependency that does not match with the corresponding dependency of the paired node from `hGraphExec`. resultInfo->errorNode will be set to the node from `hGraph`. resultInfo->errorFromNode will be set to the mismatched dependency. The dependencies are paired based on edge order and a dependency does not match when the nodes are already paired based on other edges examined in the graph.


cuGraphExecUpdate sets the result member of `resultInfo` to:

  * CU_GRAPH_EXEC_UPDATE_ERROR if passed an invalid value.

  * CU_GRAPH_EXEC_UPDATE_ERROR_TOPOLOGY_CHANGED if the graph topology changed

  * CU_GRAPH_EXEC_UPDATE_ERROR_NODE_TYPE_CHANGED if the type of a node changed, in which case `hErrorNode_out` is set to the node from `hGraph`.

  * CU_GRAPH_EXEC_UPDATE_ERROR_UNSUPPORTED_FUNCTION_CHANGE if the function changed in an unsupported way(see note above), in which case `hErrorNode_out` is set to the node from `hGraph`

  * CU_GRAPH_EXEC_UPDATE_ERROR_PARAMETERS_CHANGED if any parameters to a node changed in a way that is not supported, in which case `hErrorNode_out` is set to the node from `hGraph`.

  * CU_GRAPH_EXEC_UPDATE_ERROR_ATTRIBUTES_CHANGED if any attributes of a node changed in a way that is not supported, in which case `hErrorNode_out` is set to the node from `hGraph`.

  * CU_GRAPH_EXEC_UPDATE_ERROR_NOT_SUPPORTED if something about a node is unsupported, like the node's type or configuration, in which case `hErrorNode_out` is set to the node from `hGraph`


If the update fails for a reason not listed above, the result member of `resultInfo` will be set to CU_GRAPH_EXEC_UPDATE_ERROR. If the update succeeds, the result member will be set to CU_GRAPH_EXEC_UPDATE_SUCCESS.

cuGraphExecUpdate returns CUDA_SUCCESS when the updated was performed successfully. It returns CUDA_ERROR_GRAPH_EXEC_UPDATE_FAILURE if the graph update was not performed because it included changes which violated constraints specific to instantiated graph update.

Note:

  * Graph objects are not threadsafe. [More here](<graphs-thread-safety.html#graphs-thread-safety>).

  * Note that this function may also return error codes from previous, asynchronous launches.


**See also:**

[cuGraphInstantiate](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1gb53b435e178cccfa37ac87285d2c3fa1> "Creates an executable graph from a graph.")

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuGraphExternalSemaphoresSignalNodeGetParams ( [CUgraphNode](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc72514a94dacc85ed0617f979211079c>)Â hNode, [CUDA_EXT_SEM_SIGNAL_NODE_PARAMS](<structCUDA__EXT__SEM__SIGNAL__NODE__PARAMS__v1.html#structCUDA__EXT__SEM__SIGNAL__NODE__PARAMS__v1>)*Â params_out )


Returns an external semaphore signal node's parameters.

######  Parameters

`hNode`
    \- Node to get the parameters for
`params_out`
    \- Pointer to return the parameters

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_DEINITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9acf52f132faf29b473cdda6061f0f44a>), [CUDA_ERROR_NOT_INITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e98feb999f0af99b4a25ab26b3866f4df8>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>)

###### Description

Returns the parameters of an external semaphore signal node `hNode` in `params_out`. The `extSemArray` and `paramsArray` returned in `params_out`, are owned by the node. This memory remains valid until the node is destroyed or its parameters are modified, and should not be modified directly. Use [cuGraphExternalSemaphoresSignalNodeSetParams](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1g7a344ed4c6a5fcaad7bc7c53b04c6099> "Sets an external semaphore signal node's parameters.") to update the parameters of this node.

Note:

  * Graph objects are not threadsafe. [More here](<graphs-thread-safety.html#graphs-thread-safety>).

  * Note that this function may also return error codes from previous, asynchronous launches.


**See also:**

[cuLaunchKernel](<group__CUDA__EXEC.html#group__CUDA__EXEC_1gb8f3dc3031b40da29d5f9a7139e52e15> "Launches a CUDA function CUfunction or a CUDA kernel CUkernel."), [cuGraphAddExternalSemaphoresSignalNode](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1g6410d5401de205568457fba5e1862ad3> "Creates an external semaphore signal node and adds it to a graph."), [cuGraphExternalSemaphoresSignalNodeSetParams](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1g7a344ed4c6a5fcaad7bc7c53b04c6099> "Sets an external semaphore signal node's parameters."), [cuGraphAddExternalSemaphoresWaitNode](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1g49131c65fcef0b60b3939e008f7b467e> "Creates an external semaphore wait node and adds it to a graph."), [cuSignalExternalSemaphoresAsync](<group__CUDA__EXTRES__INTEROP.html#group__CUDA__EXTRES__INTEROP_1g86cd6c4b3f439ba786f4e65d1b8107c3> "Signals a set of external semaphore objects."), [cuWaitExternalSemaphoresAsync](<group__CUDA__EXTRES__INTEROP.html#group__CUDA__EXTRES__INTEROP_1g063f01a524818ac89bacf521c55a39f0> "Waits on a set of external semaphore objects.")

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuGraphExternalSemaphoresSignalNodeSetParams ( [CUgraphNode](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc72514a94dacc85ed0617f979211079c>)Â hNode, const [CUDA_EXT_SEM_SIGNAL_NODE_PARAMS](<structCUDA__EXT__SEM__SIGNAL__NODE__PARAMS__v1.html#structCUDA__EXT__SEM__SIGNAL__NODE__PARAMS__v1>)*Â nodeParams )


Sets an external semaphore signal node's parameters.

######  Parameters

`hNode`
    \- Node to set the parameters for
`nodeParams`
    \- Parameters to copy

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>), [CUDA_ERROR_INVALID_HANDLE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e90fd2e63260c6317ba943af0f7e4b8d21>), [CUDA_ERROR_OUT_OF_MEMORY](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9264c50688ed110e8476b591befe60c02>)

###### Description

Sets the parameters of an external semaphore signal node `hNode` to `nodeParams`.

Note:

  * Graph objects are not threadsafe. [More here](<graphs-thread-safety.html#graphs-thread-safety>).

  * Note that this function may also return error codes from previous, asynchronous launches.


**See also:**

[cuGraphNodeSetParams](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1gbf18157f40ea2d160cb0b9e4e2b16139> "Update's a graph node's parameters."), [cuGraphAddExternalSemaphoresSignalNode](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1g6410d5401de205568457fba5e1862ad3> "Creates an external semaphore signal node and adds it to a graph."), [cuGraphExternalSemaphoresSignalNodeSetParams](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1g7a344ed4c6a5fcaad7bc7c53b04c6099> "Sets an external semaphore signal node's parameters."), [cuGraphAddExternalSemaphoresWaitNode](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1g49131c65fcef0b60b3939e008f7b467e> "Creates an external semaphore wait node and adds it to a graph."), [cuSignalExternalSemaphoresAsync](<group__CUDA__EXTRES__INTEROP.html#group__CUDA__EXTRES__INTEROP_1g86cd6c4b3f439ba786f4e65d1b8107c3> "Signals a set of external semaphore objects."), [cuWaitExternalSemaphoresAsync](<group__CUDA__EXTRES__INTEROP.html#group__CUDA__EXTRES__INTEROP_1g063f01a524818ac89bacf521c55a39f0> "Waits on a set of external semaphore objects.")

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuGraphExternalSemaphoresWaitNodeGetParams ( [CUgraphNode](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc72514a94dacc85ed0617f979211079c>)Â hNode, [CUDA_EXT_SEM_WAIT_NODE_PARAMS](<structCUDA__EXT__SEM__WAIT__NODE__PARAMS__v1.html#structCUDA__EXT__SEM__WAIT__NODE__PARAMS__v1>)*Â params_out )


Returns an external semaphore wait node's parameters.

######  Parameters

`hNode`
    \- Node to get the parameters for
`params_out`
    \- Pointer to return the parameters

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_DEINITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9acf52f132faf29b473cdda6061f0f44a>), [CUDA_ERROR_NOT_INITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e98feb999f0af99b4a25ab26b3866f4df8>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>)

###### Description

Returns the parameters of an external semaphore wait node `hNode` in `params_out`. The `extSemArray` and `paramsArray` returned in `params_out`, are owned by the node. This memory remains valid until the node is destroyed or its parameters are modified, and should not be modified directly. Use [cuGraphExternalSemaphoresSignalNodeSetParams](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1g7a344ed4c6a5fcaad7bc7c53b04c6099> "Sets an external semaphore signal node's parameters.") to update the parameters of this node.

Note:

  * Graph objects are not threadsafe. [More here](<graphs-thread-safety.html#graphs-thread-safety>).

  * Note that this function may also return error codes from previous, asynchronous launches.


**See also:**

[cuLaunchKernel](<group__CUDA__EXEC.html#group__CUDA__EXEC_1gb8f3dc3031b40da29d5f9a7139e52e15> "Launches a CUDA function CUfunction or a CUDA kernel CUkernel."), [cuGraphAddExternalSemaphoresWaitNode](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1g49131c65fcef0b60b3939e008f7b467e> "Creates an external semaphore wait node and adds it to a graph."), [cuGraphExternalSemaphoresWaitNodeSetParams](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1ge8b93792930a21ec352d6efd2c21c8c0> "Sets an external semaphore wait node's parameters."), [cuGraphAddExternalSemaphoresWaitNode](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1g49131c65fcef0b60b3939e008f7b467e> "Creates an external semaphore wait node and adds it to a graph."), [cuSignalExternalSemaphoresAsync](<group__CUDA__EXTRES__INTEROP.html#group__CUDA__EXTRES__INTEROP_1g86cd6c4b3f439ba786f4e65d1b8107c3> "Signals a set of external semaphore objects."), [cuWaitExternalSemaphoresAsync](<group__CUDA__EXTRES__INTEROP.html#group__CUDA__EXTRES__INTEROP_1g063f01a524818ac89bacf521c55a39f0> "Waits on a set of external semaphore objects.")

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuGraphExternalSemaphoresWaitNodeSetParams ( [CUgraphNode](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc72514a94dacc85ed0617f979211079c>)Â hNode, const [CUDA_EXT_SEM_WAIT_NODE_PARAMS](<structCUDA__EXT__SEM__WAIT__NODE__PARAMS__v1.html#structCUDA__EXT__SEM__WAIT__NODE__PARAMS__v1>)*Â nodeParams )


Sets an external semaphore wait node's parameters.

######  Parameters

`hNode`
    \- Node to set the parameters for
`nodeParams`
    \- Parameters to copy

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>), [CUDA_ERROR_INVALID_HANDLE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e90fd2e63260c6317ba943af0f7e4b8d21>), [CUDA_ERROR_OUT_OF_MEMORY](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9264c50688ed110e8476b591befe60c02>)

###### Description

Sets the parameters of an external semaphore wait node `hNode` to `nodeParams`.

Note:

  * Graph objects are not threadsafe. [More here](<graphs-thread-safety.html#graphs-thread-safety>).

  * Note that this function may also return error codes from previous, asynchronous launches.


**See also:**

[cuGraphNodeSetParams](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1gbf18157f40ea2d160cb0b9e4e2b16139> "Update's a graph node's parameters."), [cuGraphAddExternalSemaphoresWaitNode](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1g49131c65fcef0b60b3939e008f7b467e> "Creates an external semaphore wait node and adds it to a graph."), [cuGraphExternalSemaphoresWaitNodeSetParams](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1ge8b93792930a21ec352d6efd2c21c8c0> "Sets an external semaphore wait node's parameters."), [cuGraphAddExternalSemaphoresWaitNode](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1g49131c65fcef0b60b3939e008f7b467e> "Creates an external semaphore wait node and adds it to a graph."), [cuSignalExternalSemaphoresAsync](<group__CUDA__EXTRES__INTEROP.html#group__CUDA__EXTRES__INTEROP_1g86cd6c4b3f439ba786f4e65d1b8107c3> "Signals a set of external semaphore objects."), [cuWaitExternalSemaphoresAsync](<group__CUDA__EXTRES__INTEROP.html#group__CUDA__EXTRES__INTEROP_1g063f01a524818ac89bacf521c55a39f0> "Waits on a set of external semaphore objects.")

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuGraphGetEdges ( [CUgraph](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g69f555c38df5b3fa1ed25efef794739a>)Â hGraph, [CUgraphNode](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc72514a94dacc85ed0617f979211079c>)*Â from, [CUgraphNode](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc72514a94dacc85ed0617f979211079c>)*Â to, [CUgraphEdgeData](<structCUgraphEdgeData.html#structCUgraphEdgeData>)*Â edgeData, size_t*Â numEdges )


Returns a graph's dependency edges.

######  Parameters

`hGraph`
    \- Graph to get the edges from
`from`
    \- Location to return edge endpoints
`to`
    \- Location to return edge endpoints
`edgeData`
    \- Optional location to return edge data
`numEdges`
    \- See description

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_LOSSY_QUERY](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e90c2195e65483c3e7f0ccbf52370c33f7>), [CUDA_ERROR_DEINITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9acf52f132faf29b473cdda6061f0f44a>), [CUDA_ERROR_NOT_INITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e98feb999f0af99b4a25ab26b3866f4df8>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>)

###### Description

Returns a list of `hGraph's` dependency edges. Edges are returned via corresponding indices in `from`, `to` and `edgeData`; that is, the node in `to`[i] has a dependency on the node in `from`[i] with data `edgeData`[i]. `from` and `to` may both be NULL, in which case this function only returns the number of edges in `numEdges`. Otherwise, `numEdges` entries will be filled in. If `numEdges` is higher than the actual number of edges, the remaining entries in `from` and `to` will be set to NULL, and the number of edges actually returned will be written to `numEdges`. `edgeData` may alone be NULL, in which case the edges must all have default (zeroed) edge data. Attempting a lossy query via NULL `edgeData` will result in [CUDA_ERROR_LOSSY_QUERY](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e90c2195e65483c3e7f0ccbf52370c33f7>). If `edgeData` is non-NULL then `from` and `to` must be as well.

Note:

  * Graph objects are not threadsafe. [More here](<graphs-thread-safety.html#graphs-thread-safety>).

  * Note that this function may also return error codes from previous, asynchronous launches.


**See also:**

[cuGraphGetNodes](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1gfa35a8e2d2fc32f48dbd67ba27cf27e5> "Returns a graph's nodes."), [cuGraphGetRootNodes](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1gf8517646bd8b39ab6359f8e7f0edffbd> "Returns a graph's root nodes."), [cuGraphAddDependencies](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1g5dad91f0be4e0fde6092f15797427e2d> "Adds dependency edges to a graph."), [cuGraphRemoveDependencies](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1g25048b696f56b4d6131f068074176301> "Removes dependency edges from a graph."), [cuGraphNodeGetDependencies](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1gd3fc7f62e46f621f59de2173e08fccc9> "Returns a node's dependencies."), [cuGraphNodeGetDependentNodes](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1g61e907fa6896b5393246d1588c794450> "Returns a node's dependent nodes.")

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuGraphGetId ( [CUgraph](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g69f555c38df5b3fa1ed25efef794739a>)Â hGraph, unsigned int*Â graphId )


Returns the id of a given graph.

######  Parameters

`hGraph`
    \- Graph to query
`graphId`


###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>)[CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>)

###### Description

Returns the id of `hGraph` in `*graphId`. The value in `*graphId` will match that referenced by [cuGraphDebugDotPrint](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1g0fb0c4d319477a0a98da005fcb0dacc4> "Write a DOT file describing graph structure.").

**See also:**

[cuGraphGetNodes](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1gfa35a8e2d2fc32f48dbd67ba27cf27e5> "Returns a graph's nodes."), [cuGraphDebugDotPrint](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1g0fb0c4d319477a0a98da005fcb0dacc4> "Write a DOT file describing graph structure.")[cuGraphNodeGetContainingGraph](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1gbbfe267adf728f1c53aa9d99ba101b92> "Returns the graph that contains a given graph node.")[cuGraphNodeGetLocalId](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1g18fd5107a28aaae1e396efcb0edaa70d> "Returns the local node id of a given graph node.")[cuGraphNodeGetToolsId](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1g10d4cf58921a26acce90ed1a03fcd4c1> "Returns an id used by tools to identify a given node.")[cuGraphExecGetId](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1g7a561a95ac508d0a99bccbf89aa01509> "Returns the id of a given graph exec.")

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuGraphGetNodes ( [CUgraph](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g69f555c38df5b3fa1ed25efef794739a>)Â hGraph, [CUgraphNode](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc72514a94dacc85ed0617f979211079c>)*Â nodes, size_t*Â numNodes )


Returns a graph's nodes.

######  Parameters

`hGraph`
    \- Graph to query
`nodes`
    \- Pointer to return the nodes
`numNodes`
    \- See description

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_DEINITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9acf52f132faf29b473cdda6061f0f44a>), [CUDA_ERROR_NOT_INITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e98feb999f0af99b4a25ab26b3866f4df8>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>)

###### Description

Returns a list of `hGraph's` nodes. `nodes` may be NULL, in which case this function will return the number of nodes in `numNodes`. Otherwise, `numNodes` entries will be filled in. If `numNodes` is higher than the actual number of nodes, the remaining entries in `nodes` will be set to NULL, and the number of nodes actually obtained will be returned in `numNodes`.

Note:

  * Graph objects are not threadsafe. [More here](<graphs-thread-safety.html#graphs-thread-safety>).

  * Note that this function may also return error codes from previous, asynchronous launches.


**See also:**

[cuGraphCreate](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1gd885f719186010727b75c3315f865fdf> "Creates a graph."), [cuGraphGetRootNodes](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1gf8517646bd8b39ab6359f8e7f0edffbd> "Returns a graph's root nodes."), [cuGraphGetEdges](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1g4e3183ca455aae2e832edd4034094082> "Returns a graph's dependency edges."), [cuGraphNodeGetType](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1gdb1776d97aa1c9d5144774b29e4b8c3e> "Returns a node's type."), [cuGraphNodeGetDependencies](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1gd3fc7f62e46f621f59de2173e08fccc9> "Returns a node's dependencies."), [cuGraphNodeGetDependentNodes](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1g61e907fa6896b5393246d1588c794450> "Returns a node's dependent nodes.")

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuGraphGetRootNodes ( [CUgraph](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g69f555c38df5b3fa1ed25efef794739a>)Â hGraph, [CUgraphNode](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc72514a94dacc85ed0617f979211079c>)*Â rootNodes, size_t*Â numRootNodes )


Returns a graph's root nodes.

######  Parameters

`hGraph`
    \- Graph to query
`rootNodes`
    \- Pointer to return the root nodes
`numRootNodes`
    \- See description

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_DEINITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9acf52f132faf29b473cdda6061f0f44a>), [CUDA_ERROR_NOT_INITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e98feb999f0af99b4a25ab26b3866f4df8>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>)

###### Description

Returns a list of `hGraph's` root nodes. `rootNodes` may be NULL, in which case this function will return the number of root nodes in `numRootNodes`. Otherwise, `numRootNodes` entries will be filled in. If `numRootNodes` is higher than the actual number of root nodes, the remaining entries in `rootNodes` will be set to NULL, and the number of nodes actually obtained will be returned in `numRootNodes`.

Note:

  * Graph objects are not threadsafe. [More here](<graphs-thread-safety.html#graphs-thread-safety>).

  * Note that this function may also return error codes from previous, asynchronous launches.


**See also:**

[cuGraphCreate](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1gd885f719186010727b75c3315f865fdf> "Creates a graph."), [cuGraphGetNodes](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1gfa35a8e2d2fc32f48dbd67ba27cf27e5> "Returns a graph's nodes."), [cuGraphGetEdges](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1g4e3183ca455aae2e832edd4034094082> "Returns a graph's dependency edges."), [cuGraphNodeGetType](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1gdb1776d97aa1c9d5144774b29e4b8c3e> "Returns a node's type."), [cuGraphNodeGetDependencies](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1gd3fc7f62e46f621f59de2173e08fccc9> "Returns a node's dependencies."), [cuGraphNodeGetDependentNodes](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1g61e907fa6896b5393246d1588c794450> "Returns a node's dependent nodes.")

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuGraphHostNodeGetParams ( [CUgraphNode](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc72514a94dacc85ed0617f979211079c>)Â hNode, [CUDA_HOST_NODE_PARAMS](<structCUDA__HOST__NODE__PARAMS__v1.html#structCUDA__HOST__NODE__PARAMS__v1>)*Â nodeParams )


Returns a host node's parameters.

######  Parameters

`hNode`
    \- Node to get the parameters for
`nodeParams`
    \- Pointer to return the parameters

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_DEINITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9acf52f132faf29b473cdda6061f0f44a>), [CUDA_ERROR_NOT_INITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e98feb999f0af99b4a25ab26b3866f4df8>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>)

###### Description

Returns the parameters of host node `hNode` in `nodeParams`.

Note:

  * Graph objects are not threadsafe. [More here](<graphs-thread-safety.html#graphs-thread-safety>).

  * Note that this function may also return error codes from previous, asynchronous launches.


**See also:**

[cuLaunchHostFunc](<group__CUDA__EXEC.html#group__CUDA__EXEC_1gab95a78143bae7f21eebb978f91e7f3f> "Enqueues a host function call in a stream."), [cuGraphAddHostNode](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1g0809d65e85a3c052296373954a05b1d6> "Creates a host execution node and adds it to a graph."), [cuGraphHostNodeSetParams](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1gae021ae8f19ee51044339db9c24dd266> "Sets a host node's parameters.")

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuGraphHostNodeSetParams ( [CUgraphNode](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc72514a94dacc85ed0617f979211079c>)Â hNode, const [CUDA_HOST_NODE_PARAMS](<structCUDA__HOST__NODE__PARAMS__v1.html#structCUDA__HOST__NODE__PARAMS__v1>)*Â nodeParams )


Sets a host node's parameters.

######  Parameters

`hNode`
    \- Node to set the parameters for
`nodeParams`
    \- Parameters to copy

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_DEINITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9acf52f132faf29b473cdda6061f0f44a>), [CUDA_ERROR_NOT_INITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e98feb999f0af99b4a25ab26b3866f4df8>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>)

###### Description

Sets the parameters of host node `hNode` to `nodeParams`.

Note:

  * Graph objects are not threadsafe. [More here](<graphs-thread-safety.html#graphs-thread-safety>).

  * Note that this function may also return error codes from previous, asynchronous launches.


**See also:**

[cuGraphNodeSetParams](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1gbf18157f40ea2d160cb0b9e4e2b16139> "Update's a graph node's parameters."), [cuLaunchHostFunc](<group__CUDA__EXEC.html#group__CUDA__EXEC_1gab95a78143bae7f21eebb978f91e7f3f> "Enqueues a host function call in a stream."), [cuGraphAddHostNode](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1g0809d65e85a3c052296373954a05b1d6> "Creates a host execution node and adds it to a graph."), [cuGraphHostNodeGetParams](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1g2e3ea6000089fd5523c197ab5e73d5a2> "Returns a host node's parameters.")

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuGraphInstantiate ( [CUgraphExec](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gf0abeceeaa9f0a39592fe36a538ea1f0>)*Â phGraphExec, [CUgraph](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g69f555c38df5b3fa1ed25efef794739a>)Â hGraph, unsigned long longÂ flags )


Creates an executable graph from a graph.

######  Parameters

`phGraphExec`
    \- Returns instantiated graph
`hGraph`
    \- Graph to instantiate
`flags`
    \- Flags to control instantiation. See [CUgraphInstantiate_flags](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g070bf5517d3a7915667c256eefce4956>).

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_DEINITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9acf52f132faf29b473cdda6061f0f44a>), [CUDA_ERROR_NOT_INITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e98feb999f0af99b4a25ab26b3866f4df8>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>)

###### Description

Instantiates `hGraph` as an executable graph. The graph is validated for any structural constraints or intra-node constraints which were not previously validated. If instantiation is successful, a handle to the instantiated graph is returned in `phGraphExec`.

The `flags` parameter controls the behavior of instantiation and subsequent graph launches. Valid flags are:

  * [CUDA_GRAPH_INSTANTIATE_FLAG_AUTO_FREE_ON_LAUNCH](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg070bf5517d3a7915667c256eefce49561684f715bf05e39afd69aa508299a479>), which configures a graph containing memory allocation nodes to automatically free any unfreed memory allocations before the graph is relaunched.


  * [CUDA_GRAPH_INSTANTIATE_FLAG_DEVICE_LAUNCH](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg070bf5517d3a7915667c256eefce4956eefa4d807b378590e82a916f55f370e1>), which configures the graph for launch from the device. If this flag is passed, the executable graph handle returned can be used to launch the graph from both the host and device. This flag can only be used on platforms which support unified addressing. This flag cannot be used in conjunction with [CUDA_GRAPH_INSTANTIATE_FLAG_AUTO_FREE_ON_LAUNCH](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg070bf5517d3a7915667c256eefce49561684f715bf05e39afd69aa508299a479>).


  * [CUDA_GRAPH_INSTANTIATE_FLAG_USE_NODE_PRIORITY](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg070bf5517d3a7915667c256eefce4956a02ee23c391827d000f1230ad281da29>), which causes the graph to use the priorities from the per-node attributes rather than the priority of the launch stream during execution. Note that priorities are only available on kernel nodes, and are copied from stream priority during stream capture.


If `hGraph` contains any allocation or free nodes, there can be at most one executable graph in existence for that graph at a time. An attempt to instantiate a second executable graph before destroying the first with [cuGraphExecDestroy](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1ga32ad4944cc5d408158207c978bc43a7> "Destroys an executable graph.") will result in an error. The same also applies if `hGraph` contains any device-updatable kernel nodes.

If `hGraph` contains kernels which call device-side [cudaGraphLaunch()](<../cuda-runtime-api/group__CUDART__GRAPH.html#group__CUDART__GRAPH_1g1920584881db959c8c74130d79019b73>) from multiple contexts, this will result in an error.

Graphs instantiated for launch on the device have additional restrictions which do not apply to host graphs:

  * The graph's nodes must reside on a single context.

  * The graph can only contain kernel nodes, memcpy nodes, memset nodes, and child graph nodes.

  * The graph cannot be empty and must contain at least one kernel, memcpy, or memset node. Operation-specific restrictions are outlined below.

  * Kernel nodes:
    * Use of CUDA Dynamic Parallelism is not permitted.

    * Cooperative launches are permitted as long as MPS is not in use.

  * Memcpy nodes:
    * Only copies involving device memory and/or pinned device-mapped host memory are permitted.

    * Copies involving CUDA arrays are not permitted.

    * Both operands must be accessible from the current context, and the current context must match the context of other nodes in the graph.


Note:

  * Graph objects are not threadsafe. [More here](<graphs-thread-safety.html#graphs-thread-safety>).

  * Note that this function may also return error codes from previous, asynchronous launches.


**See also:**

[cuGraphInstantiate](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1gb53b435e178cccfa37ac87285d2c3fa1> "Creates an executable graph from a graph."), [cuGraphCreate](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1gd885f719186010727b75c3315f865fdf> "Creates a graph."), [cuGraphUpload](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1ga7eb9849e6e4604864a482b38f25be48> "Uploads an executable graph in a stream."), [cuGraphLaunch](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1g6b2dceb3901e71a390d2bd8b0491e471> "Launches an executable graph in a stream."), [cuGraphExecDestroy](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1ga32ad4944cc5d408158207c978bc43a7> "Destroys an executable graph.")

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuGraphInstantiateWithParams ( [CUgraphExec](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gf0abeceeaa9f0a39592fe36a538ea1f0>)*Â phGraphExec, [CUgraph](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g69f555c38df5b3fa1ed25efef794739a>)Â hGraph, [CUDA_GRAPH_INSTANTIATE_PARAMS](<structCUDA__GRAPH__INSTANTIATE__PARAMS.html#structCUDA__GRAPH__INSTANTIATE__PARAMS>)*Â instantiateParams )


Creates an executable graph from a graph.

######  Parameters

`phGraphExec`
    \- Returns instantiated graph
`hGraph`
    \- Graph to instantiate
`instantiateParams`
    \- Instantiation parameters

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>),

###### Description

Instantiates `hGraph` as an executable graph according to the `instantiateParams` structure. The graph is validated for any structural constraints or intra-node constraints which were not previously validated. If instantiation is successful, a handle to the instantiated graph is returned in `phGraphExec`.

`instantiateParams` controls the behavior of instantiation and subsequent graph launches, as well as returning more detailed information in the event of an error. [CUDA_GRAPH_INSTANTIATE_PARAMS](<structCUDA__GRAPH__INSTANTIATE__PARAMS.html#structCUDA__GRAPH__INSTANTIATE__PARAMS>) is defined as:


    â    typedef struct {
                  cuuint64_t flags;
                  [CUstream](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gb946c7f02e09efd788a204718015d88a>) hUploadStream;
                  [CUgraphNode](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc72514a94dacc85ed0617f979211079c>) hErrNode_out;
                  [CUgraphInstantiateResult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g863484740f7d9f82c908d228f791cc56>) result_out;
              } [CUDA_GRAPH_INSTANTIATE_PARAMS](<structCUDA__GRAPH__INSTANTIATE__PARAMS.html#structCUDA__GRAPH__INSTANTIATE__PARAMS>);

The `flags` field controls the behavior of instantiation and subsequent graph launches. Valid flags are:

  * [CUDA_GRAPH_INSTANTIATE_FLAG_AUTO_FREE_ON_LAUNCH](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg070bf5517d3a7915667c256eefce49561684f715bf05e39afd69aa508299a479>), which configures a graph containing memory allocation nodes to automatically free any unfreed memory allocations before the graph is relaunched.


  * [CUDA_GRAPH_INSTANTIATE_FLAG_UPLOAD](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg070bf5517d3a7915667c256eefce49569557f13a16fe73b147fb4c9018e92925>), which will perform an upload of the graph into `hUploadStream` once the graph has been instantiated.


  * [CUDA_GRAPH_INSTANTIATE_FLAG_DEVICE_LAUNCH](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg070bf5517d3a7915667c256eefce4956eefa4d807b378590e82a916f55f370e1>), which configures the graph for launch from the device. If this flag is passed, the executable graph handle returned can be used to launch the graph from both the host and device. This flag can only be used on platforms which support unified addressing. This flag cannot be used in conjunction with [CUDA_GRAPH_INSTANTIATE_FLAG_AUTO_FREE_ON_LAUNCH](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg070bf5517d3a7915667c256eefce49561684f715bf05e39afd69aa508299a479>).


  * [CUDA_GRAPH_INSTANTIATE_FLAG_USE_NODE_PRIORITY](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg070bf5517d3a7915667c256eefce4956a02ee23c391827d000f1230ad281da29>), which causes the graph to use the priorities from the per-node attributes rather than the priority of the launch stream during execution. Note that priorities are only available on kernel nodes, and are copied from stream priority during stream capture.


If `hGraph` contains any allocation or free nodes, there can be at most one executable graph in existence for that graph at a time. An attempt to instantiate a second executable graph before destroying the first with [cuGraphExecDestroy](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1ga32ad4944cc5d408158207c978bc43a7> "Destroys an executable graph.") will result in an error. The same also applies if `hGraph` contains any device-updatable kernel nodes.

If `hGraph` contains kernels which call device-side [cudaGraphLaunch()](<../cuda-runtime-api/group__CUDART__GRAPH.html#group__CUDART__GRAPH_1g1920584881db959c8c74130d79019b73>) from multiple contexts, this will result in an error.

Graphs instantiated for launch on the device have additional restrictions which do not apply to host graphs:

  * The graph's nodes must reside on a single context.

  * The graph can only contain kernel nodes, memcpy nodes, memset nodes, and child graph nodes.

  * The graph cannot be empty and must contain at least one kernel, memcpy, or memset node. Operation-specific restrictions are outlined below.

  * Kernel nodes:
    * Use of CUDA Dynamic Parallelism is not permitted.

    * Cooperative launches are permitted as long as MPS is not in use.

  * Memcpy nodes:
    * Only copies involving device memory and/or pinned device-mapped host memory are permitted.

    * Copies involving CUDA arrays are not permitted.

    * Both operands must be accessible from the current context, and the current context must match the context of other nodes in the graph.


In the event of an error, the `result_out` and `hErrNode_out` fields will contain more information about the nature of the error. Possible error reporting includes:

  * [CUDA_GRAPH_INSTANTIATE_ERROR](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg863484740f7d9f82c908d228f791cc56e625bf48bea298c8f002e84ecaa8dbf3>), if passed an invalid value or if an unexpected error occurred which is described by the return value of the function. `hErrNode_out` will be set to NULL.

  * [CUDA_GRAPH_INSTANTIATE_INVALID_STRUCTURE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg863484740f7d9f82c908d228f791cc56bdea682421fdd0bfcd4f466ab02b1d8b>), if the graph structure is invalid. `hErrNode_out` will be set to one of the offending nodes.

  * [CUDA_GRAPH_INSTANTIATE_NODE_OPERATION_NOT_SUPPORTED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg863484740f7d9f82c908d228f791cc562c63d294c9e492a6862bf1d738a63b32>), if the graph is instantiated for device launch but contains a node of an unsupported node type, or a node which performs unsupported operations, such as use of CUDA dynamic parallelism within a kernel node. `hErrNode_out` will be set to this node.

  * [CUDA_GRAPH_INSTANTIATE_MULTIPLE_CTXS_NOT_SUPPORTED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg863484740f7d9f82c908d228f791cc5648704cf82fdc5141cb009b92077b7a19>), if the graph is instantiated for device launch but a nodeâs context differs from that of another node. This error can also be returned if a graph is not instantiated for device launch and it contains kernels which call device-side [cudaGraphLaunch()](<../cuda-runtime-api/group__CUDART__GRAPH.html#group__CUDART__GRAPH_1g1920584881db959c8c74130d79019b73>) from multiple contexts. `hErrNode_out` will be set to this node.


If instantiation is successful, `result_out` will be set to [CUDA_GRAPH_INSTANTIATE_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg863484740f7d9f82c908d228f791cc56668c8105a3caeb8f4bed6b5581900bba>), and `hErrNode_out` will be set to NULL.

Note:

  * Graph objects are not threadsafe. [More here](<graphs-thread-safety.html#graphs-thread-safety>).

  * Note that this function may also return error codes from previous, asynchronous launches.


**See also:**

[cuGraphCreate](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1gd885f719186010727b75c3315f865fdf> "Creates a graph."), [cuGraphInstantiate](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1gb53b435e178cccfa37ac87285d2c3fa1> "Creates an executable graph from a graph."), [cuGraphExecDestroy](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1ga32ad4944cc5d408158207c978bc43a7> "Destroys an executable graph.")

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuGraphKernelNodeCopyAttributes ( [CUgraphNode](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc72514a94dacc85ed0617f979211079c>)Â dst, [CUgraphNode](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc72514a94dacc85ed0617f979211079c>)Â src )


Copies attributes from source node to destination node.

######  Parameters

`dst`
    Destination node
`src`
    Source node For list of attributes see CUkernelNodeAttrID

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>)

###### Description

Copies attributes from source node `src` to destination node `dst`. Both node must have the same context.

Note:

Note that this function may also return error codes from previous, asynchronous launches.

**See also:**

[CUaccessPolicyWindow](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g1838e6438f39944217e384bf2adad477>)

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuGraphKernelNodeGetAttribute ( [CUgraphNode](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc72514a94dacc85ed0617f979211079c>)Â hNode, [CUkernelNodeAttrID](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g6f6565b334be6bb3134868e10bbdd331>)Â attr, [CUkernelNodeAttrValue](<unionCUlaunchAttributeValue.html#unionCUlaunchAttributeValue>)*Â value_out )


Queries node attribute.

######  Parameters

`hNode`

`attr`

`value_out`


###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>), [CUDA_ERROR_INVALID_HANDLE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e90fd2e63260c6317ba943af0f7e4b8d21>)

###### Description

Queries attribute `attr` from node `hNode` and stores it in corresponding member of `value_out`.

Note:

Note that this function may also return error codes from previous, asynchronous launches.

**See also:**

[CUaccessPolicyWindow](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g1838e6438f39944217e384bf2adad477>)

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuGraphKernelNodeGetParams ( [CUgraphNode](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc72514a94dacc85ed0617f979211079c>)Â hNode, [CUDA_KERNEL_NODE_PARAMS](<structCUDA__KERNEL__NODE__PARAMS__v2.html#structCUDA__KERNEL__NODE__PARAMS__v2>)*Â nodeParams )


Returns a kernel node's parameters.

######  Parameters

`hNode`
    \- Node to get the parameters for
`nodeParams`
    \- Pointer to return the parameters

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_DEINITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9acf52f132faf29b473cdda6061f0f44a>), [CUDA_ERROR_NOT_INITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e98feb999f0af99b4a25ab26b3866f4df8>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>)

###### Description

Returns the parameters of kernel node `hNode` in `nodeParams`. The `kernelParams` or `extra` array returned in `nodeParams`, as well as the argument values it points to, are owned by the node. This memory remains valid until the node is destroyed or its parameters are modified, and should not be modified directly. Use [cuGraphKernelNodeSetParams](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1ga268bf2fd520f5aa3a3d700005df6703> "Sets a kernel node's parameters.") to update the parameters of this node.

The params will contain either `kernelParams` or `extra`, according to which of these was most recently set on the node.

Note:

  * Graph objects are not threadsafe. [More here](<graphs-thread-safety.html#graphs-thread-safety>).

  * Note that this function may also return error codes from previous, asynchronous launches.


**See also:**

[cuLaunchKernel](<group__CUDA__EXEC.html#group__CUDA__EXEC_1gb8f3dc3031b40da29d5f9a7139e52e15> "Launches a CUDA function CUfunction or a CUDA kernel CUkernel."), [cuGraphAddKernelNode](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1g50d871e3bd06c1b835e52f2966ef366b> "Creates a kernel execution node and adds it to a graph."), [cuGraphKernelNodeSetParams](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1ga268bf2fd520f5aa3a3d700005df6703> "Sets a kernel node's parameters.")

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuGraphKernelNodeSetAttribute ( [CUgraphNode](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc72514a94dacc85ed0617f979211079c>)Â hNode, [CUkernelNodeAttrID](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g6f6565b334be6bb3134868e10bbdd331>)Â attr, const [CUkernelNodeAttrValue](<unionCUlaunchAttributeValue.html#unionCUlaunchAttributeValue>)*Â value )


Sets node attribute.

######  Parameters

`hNode`

`attr`

`value`


###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>), [CUDA_ERROR_INVALID_HANDLE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e90fd2e63260c6317ba943af0f7e4b8d21>)

###### Description

Sets attribute `attr` on node `hNode` from corresponding attribute of `value`.

Note:

Note that this function may also return error codes from previous, asynchronous launches.

**See also:**

[CUaccessPolicyWindow](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g1838e6438f39944217e384bf2adad477>)

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuGraphKernelNodeSetParams ( [CUgraphNode](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc72514a94dacc85ed0617f979211079c>)Â hNode, const [CUDA_KERNEL_NODE_PARAMS](<structCUDA__KERNEL__NODE__PARAMS__v2.html#structCUDA__KERNEL__NODE__PARAMS__v2>)*Â nodeParams )


Sets a kernel node's parameters.

######  Parameters

`hNode`
    \- Node to set the parameters for
`nodeParams`
    \- Parameters to copy

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>), [CUDA_ERROR_INVALID_HANDLE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e90fd2e63260c6317ba943af0f7e4b8d21>), [CUDA_ERROR_OUT_OF_MEMORY](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9264c50688ed110e8476b591befe60c02>)

###### Description

Sets the parameters of kernel node `hNode` to `nodeParams`.

Note:

  * Graph objects are not threadsafe. [More here](<graphs-thread-safety.html#graphs-thread-safety>).

  * Note that this function may also return error codes from previous, asynchronous launches.


**See also:**

[cuGraphNodeSetParams](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1gbf18157f40ea2d160cb0b9e4e2b16139> "Update's a graph node's parameters."), [cuLaunchKernel](<group__CUDA__EXEC.html#group__CUDA__EXEC_1gb8f3dc3031b40da29d5f9a7139e52e15> "Launches a CUDA function CUfunction or a CUDA kernel CUkernel."), [cuGraphAddKernelNode](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1g50d871e3bd06c1b835e52f2966ef366b> "Creates a kernel execution node and adds it to a graph."), [cuGraphKernelNodeGetParams](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1gb8df3f99e8dd5e4f4a5a0f19a5518252> "Returns a kernel node's parameters.")

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuGraphLaunch ( [CUgraphExec](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gf0abeceeaa9f0a39592fe36a538ea1f0>)Â hGraphExec, [CUstream](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gb946c7f02e09efd788a204718015d88a>)Â hStream )


Launches an executable graph in a stream.

######  Parameters

`hGraphExec`
    \- Executable graph to launch
`hStream`
    \- Stream in which to launch the graph

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_DEINITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9acf52f132faf29b473cdda6061f0f44a>), [CUDA_ERROR_NOT_INITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e98feb999f0af99b4a25ab26b3866f4df8>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>)

###### Description

Executes `hGraphExec` in `hStream`. Only one instance of `hGraphExec` may be executing at a time. Each launch is ordered behind both any previous work in `hStream` and any previous launches of `hGraphExec`. To execute a graph concurrently, it must be instantiated multiple times into multiple executable graphs.

If any allocations created by `hGraphExec` remain unfreed (from a previous launch) and `hGraphExec` was not instantiated with [CUDA_GRAPH_INSTANTIATE_FLAG_AUTO_FREE_ON_LAUNCH](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg070bf5517d3a7915667c256eefce49561684f715bf05e39afd69aa508299a479>), the launch will fail with [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>).

Note:

  * Graph objects are not threadsafe. [More here](<graphs-thread-safety.html#graphs-thread-safety>).

  * Note that this function may also return error codes from previous, asynchronous launches.


**See also:**

[cuGraphInstantiate](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1gb53b435e178cccfa37ac87285d2c3fa1> "Creates an executable graph from a graph."), [cuGraphUpload](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1ga7eb9849e6e4604864a482b38f25be48> "Uploads an executable graph in a stream."), [cuGraphExecDestroy](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1ga32ad4944cc5d408158207c978bc43a7> "Destroys an executable graph.")

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuGraphMemAllocNodeGetParams ( [CUgraphNode](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc72514a94dacc85ed0617f979211079c>)Â hNode, [CUDA_MEM_ALLOC_NODE_PARAMS](<structCUDA__MEM__ALLOC__NODE__PARAMS__v1.html#structCUDA__MEM__ALLOC__NODE__PARAMS__v1>)*Â params_out )


Returns a memory alloc node's parameters.

######  Parameters

`hNode`
    \- Node to get the parameters for
`params_out`
    \- Pointer to return the parameters

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_DEINITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9acf52f132faf29b473cdda6061f0f44a>), [CUDA_ERROR_NOT_INITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e98feb999f0af99b4a25ab26b3866f4df8>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>)

###### Description

Returns the parameters of a memory alloc node `hNode` in `params_out`. The `poolProps` and `accessDescs` returned in `params_out`, are owned by the node. This memory remains valid until the node is destroyed. The returned parameters must not be modified.

Note:

  * Graph objects are not threadsafe. [More here](<graphs-thread-safety.html#graphs-thread-safety>).

  * Note that this function may also return error codes from previous, asynchronous launches.


**See also:**

[cuGraphAddMemAllocNode](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1g73a351cb71b2945a0bcb913a93f69ec9> "Creates an allocation node and adds it to a graph."), [cuGraphMemFreeNodeGetParams](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1gd24d9fe5769222a2367e3f571fb2f28b> "Returns a memory free node's parameters.")

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuGraphMemFreeNodeGetParams ( [CUgraphNode](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc72514a94dacc85ed0617f979211079c>)Â hNode, [CUdeviceptr](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g183f7b0d8ad008ea2a5fd552537ace4e>)*Â dptr_out )


Returns a memory free node's parameters.

######  Parameters

`hNode`
    \- Node to get the parameters for
`dptr_out`
    \- Pointer to return the device address

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_DEINITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9acf52f132faf29b473cdda6061f0f44a>), [CUDA_ERROR_NOT_INITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e98feb999f0af99b4a25ab26b3866f4df8>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>)

###### Description

Returns the address of a memory free node `hNode` in `dptr_out`.

Note:

  * Graph objects are not threadsafe. [More here](<graphs-thread-safety.html#graphs-thread-safety>).

  * Note that this function may also return error codes from previous, asynchronous launches.


**See also:**

[cuGraphAddMemFreeNode](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1geb7cdce5d9be2d28d9428e74eb00fa53> "Creates a memory free node and adds it to a graph."), [cuGraphMemAllocNodeGetParams](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1gee2c7d66d3d96b1470c1d1a769f250a2> "Returns a memory alloc node's parameters.")

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuGraphMemcpyNodeGetParams ( [CUgraphNode](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc72514a94dacc85ed0617f979211079c>)Â hNode, [CUDA_MEMCPY3D](<structCUDA__MEMCPY3D__v2.html#structCUDA__MEMCPY3D__v2>)*Â nodeParams )


Returns a memcpy node's parameters.

######  Parameters

`hNode`
    \- Node to get the parameters for
`nodeParams`
    \- Pointer to return the parameters

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_DEINITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9acf52f132faf29b473cdda6061f0f44a>), [CUDA_ERROR_NOT_INITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e98feb999f0af99b4a25ab26b3866f4df8>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>)

###### Description

Returns the parameters of memcpy node `hNode` in `nodeParams`.

Note:

  * Graph objects are not threadsafe. [More here](<graphs-thread-safety.html#graphs-thread-safety>).

  * Note that this function may also return error codes from previous, asynchronous launches.


**See also:**

[cuMemcpy3D](<group__CUDA__MEM.html#group__CUDA__MEM_1g4b5238975579f002c0199a3800ca44df> "Copies memory for 3D arrays."), [cuGraphAddMemcpyNode](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1g674da6ab54a677f13e0e0e8206ff5073> "Creates a memcpy node and adds it to a graph."), [cuGraphMemcpyNodeSetParams](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1ga278a7ec0700c86abb0b2cfdf4d3dc1d> "Sets a memcpy node's parameters.")

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuGraphMemcpyNodeSetParams ( [CUgraphNode](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc72514a94dacc85ed0617f979211079c>)Â hNode, const [CUDA_MEMCPY3D](<structCUDA__MEMCPY3D__v2.html#structCUDA__MEMCPY3D__v2>)*Â nodeParams )


Sets a memcpy node's parameters.

######  Parameters

`hNode`
    \- Node to set the parameters for
`nodeParams`
    \- Parameters to copy

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_DEINITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9acf52f132faf29b473cdda6061f0f44a>), [CUDA_ERROR_NOT_INITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e98feb999f0af99b4a25ab26b3866f4df8>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>),

###### Description

Sets the parameters of memcpy node `hNode` to `nodeParams`.

Note:

  * Graph objects are not threadsafe. [More here](<graphs-thread-safety.html#graphs-thread-safety>).

  * Note that this function may also return error codes from previous, asynchronous launches.


**See also:**

[cuGraphNodeSetParams](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1gbf18157f40ea2d160cb0b9e4e2b16139> "Update's a graph node's parameters."), [cuMemcpy3D](<group__CUDA__MEM.html#group__CUDA__MEM_1g4b5238975579f002c0199a3800ca44df> "Copies memory for 3D arrays."), [cuGraphAddMemcpyNode](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1g674da6ab54a677f13e0e0e8206ff5073> "Creates a memcpy node and adds it to a graph."), [cuGraphMemcpyNodeGetParams](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1g572889131dbc31720eff94b130f4005b> "Returns a memcpy node's parameters.")

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuGraphMemsetNodeGetParams ( [CUgraphNode](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc72514a94dacc85ed0617f979211079c>)Â hNode, [CUDA_MEMSET_NODE_PARAMS](<structCUDA__MEMSET__NODE__PARAMS__v1.html#structCUDA__MEMSET__NODE__PARAMS__v1>)*Â nodeParams )


Returns a memset node's parameters.

######  Parameters

`hNode`
    \- Node to get the parameters for
`nodeParams`
    \- Pointer to return the parameters

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_DEINITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9acf52f132faf29b473cdda6061f0f44a>), [CUDA_ERROR_NOT_INITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e98feb999f0af99b4a25ab26b3866f4df8>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>)

###### Description

Returns the parameters of memset node `hNode` in `nodeParams`.

Note:

  * Graph objects are not threadsafe. [More here](<graphs-thread-safety.html#graphs-thread-safety>).

  * Note that this function may also return error codes from previous, asynchronous launches.


**See also:**

[cuMemsetD2D32](<group__CUDA__MEM.html#group__CUDA__MEM_1g74b359b2d026bfeb7c795b5038d07523> "Initializes device memory."), [cuGraphAddMemsetNode](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1g89dc8fc3743392777c0daa2c4aca40d3> "Creates a memset node and adds it to a graph."), [cuGraphMemsetNodeSetParams](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1gc27f3fd83a6e33c74519066fbaa0de67> "Sets a memset node's parameters.")

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuGraphMemsetNodeSetParams ( [CUgraphNode](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc72514a94dacc85ed0617f979211079c>)Â hNode, const [CUDA_MEMSET_NODE_PARAMS](<structCUDA__MEMSET__NODE__PARAMS__v1.html#structCUDA__MEMSET__NODE__PARAMS__v1>)*Â nodeParams )


Sets a memset node's parameters.

######  Parameters

`hNode`
    \- Node to set the parameters for
`nodeParams`
    \- Parameters to copy

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_DEINITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9acf52f132faf29b473cdda6061f0f44a>), [CUDA_ERROR_NOT_INITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e98feb999f0af99b4a25ab26b3866f4df8>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>)

###### Description

Sets the parameters of memset node `hNode` to `nodeParams`.

Note:

  * Graph objects are not threadsafe. [More here](<graphs-thread-safety.html#graphs-thread-safety>).

  * Note that this function may also return error codes from previous, asynchronous launches.


**See also:**

[cuGraphNodeSetParams](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1gbf18157f40ea2d160cb0b9e4e2b16139> "Update's a graph node's parameters."), [cuMemsetD2D32](<group__CUDA__MEM.html#group__CUDA__MEM_1g74b359b2d026bfeb7c795b5038d07523> "Initializes device memory."), [cuGraphAddMemsetNode](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1g89dc8fc3743392777c0daa2c4aca40d3> "Creates a memset node and adds it to a graph."), [cuGraphMemsetNodeGetParams](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1g18830edcfd982f952820a0d7f91b894a> "Returns a memset node's parameters.")

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuGraphNodeFindInClone ( [CUgraphNode](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc72514a94dacc85ed0617f979211079c>)*Â phNode, [CUgraphNode](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc72514a94dacc85ed0617f979211079c>)Â hOriginalNode, [CUgraph](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g69f555c38df5b3fa1ed25efef794739a>)Â hClonedGraph )


Finds a cloned version of a node.

######  Parameters

`phNode`
    \- Returns handle to the cloned node
`hOriginalNode`
    \- Handle to the original node
`hClonedGraph`
    \- Cloned graph to query

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>),

###### Description

This function returns the node in `hClonedGraph` corresponding to `hOriginalNode` in the original graph.

`hClonedGraph` must have been cloned from `hOriginalGraph` via [cuGraphClone](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1g3603974654e463f2231c71d9b9d1517e> "Clones a graph."). `hOriginalNode` must have been in `hOriginalGraph` at the time of the call to [cuGraphClone](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1g3603974654e463f2231c71d9b9d1517e> "Clones a graph."), and the corresponding cloned node in `hClonedGraph` must not have been removed. The cloned node is then returned via `phClonedNode`.

Note:

  * Graph objects are not threadsafe. [More here](<graphs-thread-safety.html#graphs-thread-safety>).

  * Note that this function may also return error codes from previous, asynchronous launches.


**See also:**

[cuGraphClone](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1g3603974654e463f2231c71d9b9d1517e> "Clones a graph.")

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuGraphNodeGetContainingGraph ( [CUgraphNode](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc72514a94dacc85ed0617f979211079c>)Â hNode, [CUgraph](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g69f555c38df5b3fa1ed25efef794739a>)*Â phGraph )


Returns the graph that contains a given graph node.

######  Parameters

`hNode`
    \- Node to query
`phGraph`


###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>)[CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>)

###### Description

Returns the graph that contains `hNode` in `*phGraph`. If `hNode` is in a child graph, the child graph it is in is returned.

**See also:**

[cuGraphGetNodes](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1gfa35a8e2d2fc32f48dbd67ba27cf27e5> "Returns a graph's nodes."), [cuGraphDebugDotPrint](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1g0fb0c4d319477a0a98da005fcb0dacc4> "Write a DOT file describing graph structure.")[cuGraphNodeGetLocalId](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1g18fd5107a28aaae1e396efcb0edaa70d> "Returns the local node id of a given graph node.")[cuGraphNodeGetToolsId](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1g10d4cf58921a26acce90ed1a03fcd4c1> "Returns an id used by tools to identify a given node.")[cuGraphGetId](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1g0f05ae29d14198ff57d722156d60aa41> "Returns the id of a given graph.")[cuGraphExecGetId](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1g7a561a95ac508d0a99bccbf89aa01509> "Returns the id of a given graph exec.")

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuGraphNodeGetDependencies ( [CUgraphNode](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc72514a94dacc85ed0617f979211079c>)Â hNode, [CUgraphNode](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc72514a94dacc85ed0617f979211079c>)*Â dependencies, [CUgraphEdgeData](<structCUgraphEdgeData.html#structCUgraphEdgeData>)*Â edgeData, size_t*Â numDependencies )


Returns a node's dependencies.

######  Parameters

`hNode`
    \- Node to query
`dependencies`
    \- Pointer to return the dependencies
`edgeData`
    \- Optional array to return edge data for each dependency
`numDependencies`
    \- See description

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_LOSSY_QUERY](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e90c2195e65483c3e7f0ccbf52370c33f7>), [CUDA_ERROR_DEINITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9acf52f132faf29b473cdda6061f0f44a>), [CUDA_ERROR_NOT_INITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e98feb999f0af99b4a25ab26b3866f4df8>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>)

###### Description

Returns a list of `node's` dependencies. `dependencies` may be NULL, in which case this function will return the number of dependencies in `numDependencies`. Otherwise, `numDependencies` entries will be filled in. If `numDependencies` is higher than the actual number of dependencies, the remaining entries in `dependencies` will be set to NULL, and the number of nodes actually obtained will be returned in `numDependencies`.

Note that if an edge has non-zero (non-default) edge data and `edgeData` is NULL, this API will return [CUDA_ERROR_LOSSY_QUERY](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e90c2195e65483c3e7f0ccbf52370c33f7>). If `edgeData` is non-NULL, then `dependencies` must be as well.

Note:

  * Graph objects are not threadsafe. [More here](<graphs-thread-safety.html#graphs-thread-safety>).

  * Note that this function may also return error codes from previous, asynchronous launches.


**See also:**

[cuGraphNodeGetDependentNodes](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1g61e907fa6896b5393246d1588c794450> "Returns a node's dependent nodes."), [cuGraphGetNodes](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1gfa35a8e2d2fc32f48dbd67ba27cf27e5> "Returns a graph's nodes."), [cuGraphGetRootNodes](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1gf8517646bd8b39ab6359f8e7f0edffbd> "Returns a graph's root nodes."), [cuGraphGetEdges](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1g4e3183ca455aae2e832edd4034094082> "Returns a graph's dependency edges."), [cuGraphAddDependencies](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1g5dad91f0be4e0fde6092f15797427e2d> "Adds dependency edges to a graph."), [cuGraphRemoveDependencies](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1g25048b696f56b4d6131f068074176301> "Removes dependency edges from a graph.")

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuGraphNodeGetDependentNodes ( [CUgraphNode](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc72514a94dacc85ed0617f979211079c>)Â hNode, [CUgraphNode](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc72514a94dacc85ed0617f979211079c>)*Â dependentNodes, [CUgraphEdgeData](<structCUgraphEdgeData.html#structCUgraphEdgeData>)*Â edgeData, size_t*Â numDependentNodes )


Returns a node's dependent nodes.

######  Parameters

`hNode`
    \- Node to query
`dependentNodes`
    \- Pointer to return the dependent nodes
`edgeData`
    \- Optional pointer to return edge data for dependent nodes
`numDependentNodes`
    \- See description

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_LOSSY_QUERY](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e90c2195e65483c3e7f0ccbf52370c33f7>), [CUDA_ERROR_DEINITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9acf52f132faf29b473cdda6061f0f44a>), [CUDA_ERROR_NOT_INITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e98feb999f0af99b4a25ab26b3866f4df8>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>)

###### Description

Returns a list of `node's` dependent nodes. `dependentNodes` may be NULL, in which case this function will return the number of dependent nodes in `numDependentNodes`. Otherwise, `numDependentNodes` entries will be filled in. If `numDependentNodes` is higher than the actual number of dependent nodes, the remaining entries in `dependentNodes` will be set to NULL, and the number of nodes actually obtained will be returned in `numDependentNodes`.

Note that if an edge has non-zero (non-default) edge data and `edgeData` is NULL, this API will return [CUDA_ERROR_LOSSY_QUERY](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e90c2195e65483c3e7f0ccbf52370c33f7>). If `edgeData` is non-NULL, then `dependentNodes` must be as well.

Note:

  * Graph objects are not threadsafe. [More here](<graphs-thread-safety.html#graphs-thread-safety>).

  * Note that this function may also return error codes from previous, asynchronous launches.


**See also:**

[cuGraphNodeGetDependencies](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1gd3fc7f62e46f621f59de2173e08fccc9> "Returns a node's dependencies."), [cuGraphGetNodes](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1gfa35a8e2d2fc32f48dbd67ba27cf27e5> "Returns a graph's nodes."), [cuGraphGetRootNodes](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1gf8517646bd8b39ab6359f8e7f0edffbd> "Returns a graph's root nodes."), [cuGraphGetEdges](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1g4e3183ca455aae2e832edd4034094082> "Returns a graph's dependency edges."), [cuGraphAddDependencies](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1g5dad91f0be4e0fde6092f15797427e2d> "Adds dependency edges to a graph."), [cuGraphRemoveDependencies](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1g25048b696f56b4d6131f068074176301> "Removes dependency edges from a graph.")

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuGraphNodeGetEnabled ( [CUgraphExec](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gf0abeceeaa9f0a39592fe36a538ea1f0>)Â hGraphExec, [CUgraphNode](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc72514a94dacc85ed0617f979211079c>)Â hNode, unsigned int*Â isEnabled )


Query whether a node in the given graphExec is enabled.

######  Parameters

`hGraphExec`
    \- The executable graph in which to set the specified node
`hNode`
    \- Node from the graph from which graphExec was instantiated
`isEnabled`
    \- Location to return the enabled status of the node

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>),

###### Description

Sets isEnabled to 1 if `hNode` is enabled, or 0 if `hNode` is disabled.

The node is identified by the corresponding node `hNode` in the non-executable graph, from which the executable graph was instantiated.

`hNode` must not have been removed from the original graph.

Note:

  * Currently only kernel, memset and memcpy nodes are supported.

  * This function will not reflect device-side updates for device-updatable kernel nodes.


Note:

  * Graph objects are not threadsafe. [More here](<graphs-thread-safety.html#graphs-thread-safety>).

  * Note that this function may also return error codes from previous, asynchronous launches.


**See also:**

[cuGraphNodeSetEnabled](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1g371b20eb0c0658731e38db7e68f12c78> "Enables or disables the specified node in the given graphExec."), [cuGraphExecUpdate](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1g96efefc56df46927da7297f122adfb9f> "Check whether an executable graph can be updated with a graph and perform the update if possible."), [cuGraphInstantiate](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1gb53b435e178cccfa37ac87285d2c3fa1> "Creates an executable graph from a graph.")[cuGraphLaunch](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1g6b2dceb3901e71a390d2bd8b0491e471> "Launches an executable graph in a stream.")

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuGraphNodeGetLocalId ( [CUgraphNode](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc72514a94dacc85ed0617f979211079c>)Â hNode, unsigned int*Â nodeId )


Returns the local node id of a given graph node.

######  Parameters

`hNode`
    \- Node to query
`nodeId`
    \- Pointer to return the nodeId

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>)[CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>)

###### Description

Returns the node id of `hNode` in `*nodeId`. The nodeId matches that referenced by [cuGraphDebugDotPrint](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1g0fb0c4d319477a0a98da005fcb0dacc4> "Write a DOT file describing graph structure."). The local nodeId and graphId together can uniquely identify the node.

**See also:**

[cuGraphGetNodes](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1gfa35a8e2d2fc32f48dbd67ba27cf27e5> "Returns a graph's nodes."), [cuGraphDebugDotPrint](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1g0fb0c4d319477a0a98da005fcb0dacc4> "Write a DOT file describing graph structure.")[cuGraphNodeGetContainingGraph](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1gbbfe267adf728f1c53aa9d99ba101b92> "Returns the graph that contains a given graph node.")[cuGraphNodeGetToolsId](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1g10d4cf58921a26acce90ed1a03fcd4c1> "Returns an id used by tools to identify a given node.")[cuGraphGetId](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1g0f05ae29d14198ff57d722156d60aa41> "Returns the id of a given graph.")[cuGraphExecGetId](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1g7a561a95ac508d0a99bccbf89aa01509> "Returns the id of a given graph exec.")

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuGraphNodeGetToolsId ( [CUgraphNode](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc72514a94dacc85ed0617f979211079c>)Â hNode, unsigned long long*Â toolsNodeId )


Returns an id used by tools to identify a given node.

######  Parameters

`hNode`
    \- Node to query
`toolsNodeId`


###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>)[CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>)

###### Description

**See also:**

[cuGraphGetNodes](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1gfa35a8e2d2fc32f48dbd67ba27cf27e5> "Returns a graph's nodes."), [cuGraphDebugDotPrint](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1g0fb0c4d319477a0a98da005fcb0dacc4> "Write a DOT file describing graph structure.")[cuGraphNodeGetContainingGraph](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1gbbfe267adf728f1c53aa9d99ba101b92> "Returns the graph that contains a given graph node.")[cuGraphNodeGetLocalId](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1g18fd5107a28aaae1e396efcb0edaa70d> "Returns the local node id of a given graph node.")[cuGraphGetId](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1g0f05ae29d14198ff57d722156d60aa41> "Returns the id of a given graph.")[cuGraphExecGetId](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1g7a561a95ac508d0a99bccbf89aa01509> "Returns the id of a given graph exec.")

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuGraphNodeGetType ( [CUgraphNode](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc72514a94dacc85ed0617f979211079c>)Â hNode, [CUgraphNodeType](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g0731a28f826922120d783d8444e154dc>)*Â type )


Returns a node's type.

######  Parameters

`hNode`
    \- Node to query
`type`
    \- Pointer to return the node type

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_DEINITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9acf52f132faf29b473cdda6061f0f44a>), [CUDA_ERROR_NOT_INITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e98feb999f0af99b4a25ab26b3866f4df8>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>)

###### Description

Returns the node type of `hNode` in `type`.

Note:

  * Graph objects are not threadsafe. [More here](<graphs-thread-safety.html#graphs-thread-safety>).

  * Note that this function may also return error codes from previous, asynchronous launches.


**See also:**

[cuGraphGetNodes](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1gfa35a8e2d2fc32f48dbd67ba27cf27e5> "Returns a graph's nodes."), [cuGraphGetRootNodes](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1gf8517646bd8b39ab6359f8e7f0edffbd> "Returns a graph's root nodes."), [cuGraphChildGraphNodeGetGraph](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1gbe9fc9267316b3778ef0db507917b4fd> "Gets a handle to the embedded graph of a child graph node."), [cuGraphKernelNodeGetParams](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1gb8df3f99e8dd5e4f4a5a0f19a5518252> "Returns a kernel node's parameters."), [cuGraphKernelNodeSetParams](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1ga268bf2fd520f5aa3a3d700005df6703> "Sets a kernel node's parameters."), [cuGraphHostNodeGetParams](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1g2e3ea6000089fd5523c197ab5e73d5a2> "Returns a host node's parameters."), [cuGraphHostNodeSetParams](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1gae021ae8f19ee51044339db9c24dd266> "Sets a host node's parameters."), [cuGraphMemcpyNodeGetParams](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1g572889131dbc31720eff94b130f4005b> "Returns a memcpy node's parameters."), [cuGraphMemcpyNodeSetParams](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1ga278a7ec0700c86abb0b2cfdf4d3dc1d> "Sets a memcpy node's parameters."), [cuGraphMemsetNodeGetParams](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1g18830edcfd982f952820a0d7f91b894a> "Returns a memset node's parameters."), [cuGraphMemsetNodeSetParams](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1gc27f3fd83a6e33c74519066fbaa0de67> "Sets a memset node's parameters.")

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuGraphNodeSetEnabled ( [CUgraphExec](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gf0abeceeaa9f0a39592fe36a538ea1f0>)Â hGraphExec, [CUgraphNode](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc72514a94dacc85ed0617f979211079c>)Â hNode, unsigned int Â isEnabled )


Enables or disables the specified node in the given graphExec.

######  Parameters

`hGraphExec`
    \- The executable graph in which to set the specified node
`hNode`
    \- Node from the graph from which graphExec was instantiated
`isEnabled`
    \- Node is enabled if != 0, otherwise the node is disabled

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>),

###### Description

Sets `hNode` to be either enabled or disabled. Disabled nodes are functionally equivalent to empty nodes until they are reenabled. Existing node parameters are not affected by disabling/enabling the node.

The node is identified by the corresponding node `hNode` in the non-executable graph, from which the executable graph was instantiated.

`hNode` must not have been removed from the original graph.

The modifications only affect future launches of `hGraphExec`. Already enqueued or running launches of `hGraphExec` are not affected by this call. `hNode` is also not modified by this call.

If `hNode` is a device-updatable kernel node, the next upload/launch of `hGraphExec` will overwrite any previous device-side updates. Additionally, applying host updates to a device-updatable kernel node while it is being updated from the device will result in undefined behavior.

Note:

Currently only kernel, memset and memcpy nodes are supported.

Note:

  * Graph objects are not threadsafe. [More here](<graphs-thread-safety.html#graphs-thread-safety>).

  * Note that this function may also return error codes from previous, asynchronous launches.


**See also:**

[cuGraphNodeGetEnabled](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1g428f51dceec6f6211bb9c1d710925a3d> "Query whether a node in the given graphExec is enabled."), [cuGraphExecUpdate](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1g96efefc56df46927da7297f122adfb9f> "Check whether an executable graph can be updated with a graph and perform the update if possible."), [cuGraphInstantiate](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1gb53b435e178cccfa37ac87285d2c3fa1> "Creates an executable graph from a graph.")[cuGraphLaunch](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1g6b2dceb3901e71a390d2bd8b0491e471> "Launches an executable graph in a stream.")

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuGraphNodeSetParams ( [CUgraphNode](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc72514a94dacc85ed0617f979211079c>)Â hNode, [CUgraphNodeParams](<structCUgraphNodeParams.html#structCUgraphNodeParams>)*Â nodeParams )


Update's a graph node's parameters.

######  Parameters

`hNode`
    \- Node to set the parameters for
`nodeParams`
    \- Parameters to copy

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>), [CUDA_ERROR_NOT_SUPPORTED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e954756ae7ade0dfd09faeccb513dd831b>)

###### Description

Sets the parameters of graph node `hNode` to `nodeParams`. The node type specified by `nodeParams->type` must match the type of `hNode`. `nodeParams` must be fully initialized and all unused bytes (reserved, padding) zeroed.

Modifying parameters is not supported for node types CU_GRAPH_NODE_TYPE_MEM_ALLOC and CU_GRAPH_NODE_TYPE_MEM_FREE.

Note:

  * Graph objects are not threadsafe. [More here](<graphs-thread-safety.html#graphs-thread-safety>).

  * Note that this function may also return error codes from previous, asynchronous launches.


**See also:**

[cuGraphAddNode](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1ge01208e62f72a53367a2af903bf17d23> "Adds a node of arbitrary type to a graph."), [cuGraphExecNodeSetParams](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1gb318c5b61ada0e333bb12d1d33dae48b> "Update's a graph node's parameters in an instantiated graph.")

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuGraphReleaseUserObject ( [CUgraph](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g69f555c38df5b3fa1ed25efef794739a>)Â graph, [CUuserObject](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g2578b65c87dc98d336f99edca913e92b>)Â object, unsigned int Â count )


Release a user object reference from a graph.

######  Parameters

`graph`
    \- The graph that will release the reference
`object`
    \- The user object to release a reference for
`count`
    \- The number of references to release, typically 1. Must be nonzero and not larger than INT_MAX.

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>)

###### Description

Releases user object references owned by a graph.

See CUDA User Objects in the CUDA C++ Programming Guide for more information on user objects.

**See also:**

[cuUserObjectCreate](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1g58f04e0ac0ad23d2f15ea6e9f6c8a999> "Create a user object."), [cuUserObjectRetain](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1ge022bcecdeca2d14cc8f28afc6a2eaf6> "Retain a reference to a user object."), [cuUserObjectRelease](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1ga2c16918341b8d020c9246e75658cc80> "Release a reference to a user object."), [cuGraphRetainUserObject](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1gaffd130c928e56740a2a5aaeb6125c8a> "Retain a reference to a user object from a graph."), [cuGraphCreate](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1gd885f719186010727b75c3315f865fdf> "Creates a graph.")

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuGraphRemoveDependencies ( [CUgraph](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g69f555c38df5b3fa1ed25efef794739a>)Â hGraph, const [CUgraphNode](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc72514a94dacc85ed0617f979211079c>)*Â from, const [CUgraphNode](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc72514a94dacc85ed0617f979211079c>)*Â to, const [CUgraphEdgeData](<structCUgraphEdgeData.html#structCUgraphEdgeData>)*Â edgeData, size_tÂ numDependencies )


Removes dependency edges from a graph.

######  Parameters

`hGraph`
    \- Graph from which to remove dependencies
`from`
    \- Array of nodes that provide the dependencies
`to`
    \- Array of dependent nodes
`edgeData`
    \- Optional array of edge data. If NULL, edge data is assumed to be default (zeroed).
`numDependencies`
    \- Number of dependencies to be removed

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>)

###### Description

The number of `dependencies` to be removed is defined by `numDependencies`. Elements in `from` and `to` at corresponding indices define a dependency. Each node in `from` and `to` must belong to `hGraph`.

If `numDependencies` is 0, elements in `from` and `to` will be ignored. Specifying an edge that does not exist in the graph, with data matching `edgeData`, results in an error. `edgeData` is nullable, which is equivalent to passing default (zeroed) data for each edge.

Dependencies cannot be removed from graphs which contain allocation or free nodes. Any attempt to do so will return an error.

Note:

  * Graph objects are not threadsafe. [More here](<graphs-thread-safety.html#graphs-thread-safety>).

  * Note that this function may also return error codes from previous, asynchronous launches.


**See also:**

[cuGraphAddDependencies](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1g5dad91f0be4e0fde6092f15797427e2d> "Adds dependency edges to a graph."), [cuGraphGetEdges](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1g4e3183ca455aae2e832edd4034094082> "Returns a graph's dependency edges."), [cuGraphNodeGetDependencies](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1gd3fc7f62e46f621f59de2173e08fccc9> "Returns a node's dependencies."), [cuGraphNodeGetDependentNodes](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1g61e907fa6896b5393246d1588c794450> "Returns a node's dependent nodes.")

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuGraphRetainUserObject ( [CUgraph](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g69f555c38df5b3fa1ed25efef794739a>)Â graph, [CUuserObject](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g2578b65c87dc98d336f99edca913e92b>)Â object, unsigned int Â count, unsigned int Â flags )


Retain a reference to a user object from a graph.

######  Parameters

`graph`
    \- The graph to associate the reference with
`object`
    \- The user object to retain a reference for
`count`
    \- The number of references to add to the graph, typically 1. Must be nonzero and not larger than INT_MAX.
`flags`
    \- The optional flag [CU_GRAPH_USER_OBJECT_MOVE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg1649c3055c83c32f812faac63c8da0b1f9b815bff431e87e54037568c4677b9d>) transfers references from the calling thread, rather than create new references. Pass 0 to create new references.

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>)

###### Description

Creates or moves user object references that will be owned by a CUDA graph.

See CUDA User Objects in the CUDA C++ Programming Guide for more information on user objects.

**See also:**

[cuUserObjectCreate](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1g58f04e0ac0ad23d2f15ea6e9f6c8a999> "Create a user object."), [cuUserObjectRetain](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1ge022bcecdeca2d14cc8f28afc6a2eaf6> "Retain a reference to a user object."), [cuUserObjectRelease](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1ga2c16918341b8d020c9246e75658cc80> "Release a reference to a user object."), [cuGraphReleaseUserObject](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1g232c84cc31e13e4201a421e28561eebf> "Release a user object reference from a graph."), [cuGraphCreate](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1gd885f719186010727b75c3315f865fdf> "Creates a graph.")

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuGraphUpload ( [CUgraphExec](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gf0abeceeaa9f0a39592fe36a538ea1f0>)Â hGraphExec, [CUstream](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gb946c7f02e09efd788a204718015d88a>)Â hStream )


Uploads an executable graph in a stream.

######  Parameters

`hGraphExec`
    \- Executable graph to upload
`hStream`
    \- Stream in which to upload the graph

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_DEINITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9acf52f132faf29b473cdda6061f0f44a>), [CUDA_ERROR_NOT_INITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e98feb999f0af99b4a25ab26b3866f4df8>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>)

###### Description

Uploads `hGraphExec` to the device in `hStream` without executing it. Uploads of the same `hGraphExec` will be serialized. Each upload is ordered behind both any previous work in `hStream` and any previous launches of `hGraphExec`. Uses memory cached by `stream` to back the allocations owned by `hGraphExec`.

Note:

  * Graph objects are not threadsafe. [More here](<graphs-thread-safety.html#graphs-thread-safety>).

  * Note that this function may also return error codes from previous, asynchronous launches.


**See also:**

[cuGraphInstantiate](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1gb53b435e178cccfa37ac87285d2c3fa1> "Creates an executable graph from a graph."), [cuGraphLaunch](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1g6b2dceb3901e71a390d2bd8b0491e471> "Launches an executable graph in a stream."), [cuGraphExecDestroy](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1ga32ad4944cc5d408158207c978bc43a7> "Destroys an executable graph.")

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuUserObjectCreate ( [CUuserObject](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g2578b65c87dc98d336f99edca913e92b>)*Â object_out, void*Â ptr, [CUhostFn](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g262cd3570ff5d396db4e3dabede3c355>)Â destroy, unsigned int Â initialRefcount, unsigned int Â flags )


Create a user object.

######  Parameters

`object_out`
    \- Location to return the user object handle
`ptr`
    \- The pointer to pass to the destroy function
`destroy`
    \- Callback to free the user object when it is no longer in use
`initialRefcount`
    \- The initial refcount to create the object with, typically 1. The initial references are owned by the calling thread.
`flags`
    \- Currently it is required to pass [CU_USER_OBJECT_NO_DESTRUCTOR_SYNC](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg11c53cd19ee840b3b0f597d57451e94330bb85019bed1f36b8130cef76085e27>), which is the only defined flag. This indicates that the destroy callback cannot be waited on by any CUDA API. Users requiring synchronization of the callback should signal its completion manually.

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>)

###### Description

Create a user object with the specified destructor callback and initial reference count. The initial references are owned by the caller.

Destructor callbacks cannot make CUDA API calls and should avoid blocking behavior, as they are executed by a shared internal thread. Another thread may be signaled to perform such actions, if it does not block forward progress of tasks scheduled through CUDA.

See CUDA User Objects in the CUDA C++ Programming Guide for more information on user objects.

**See also:**

[cuUserObjectRetain](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1ge022bcecdeca2d14cc8f28afc6a2eaf6> "Retain a reference to a user object."), [cuUserObjectRelease](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1ga2c16918341b8d020c9246e75658cc80> "Release a reference to a user object."), [cuGraphRetainUserObject](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1gaffd130c928e56740a2a5aaeb6125c8a> "Retain a reference to a user object from a graph."), [cuGraphReleaseUserObject](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1g232c84cc31e13e4201a421e28561eebf> "Release a user object reference from a graph."), [cuGraphCreate](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1gd885f719186010727b75c3315f865fdf> "Creates a graph.")

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuUserObjectRelease ( [CUuserObject](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g2578b65c87dc98d336f99edca913e92b>)Â object, unsigned int Â count )


Release a reference to a user object.

######  Parameters

`object`
    \- The object to release
`count`
    \- The number of references to release, typically 1. Must be nonzero and not larger than INT_MAX.

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>)

###### Description

Releases user object references owned by the caller. The object's destructor is invoked if the reference count reaches zero.

It is undefined behavior to release references not owned by the caller, or to use a user object handle after all references are released.

See CUDA User Objects in the CUDA C++ Programming Guide for more information on user objects.

**See also:**

[cuUserObjectCreate](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1g58f04e0ac0ad23d2f15ea6e9f6c8a999> "Create a user object."), [cuUserObjectRetain](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1ge022bcecdeca2d14cc8f28afc6a2eaf6> "Retain a reference to a user object."), [cuGraphRetainUserObject](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1gaffd130c928e56740a2a5aaeb6125c8a> "Retain a reference to a user object from a graph."), [cuGraphReleaseUserObject](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1g232c84cc31e13e4201a421e28561eebf> "Release a user object reference from a graph."), [cuGraphCreate](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1gd885f719186010727b75c3315f865fdf> "Creates a graph.")

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuUserObjectRetain ( [CUuserObject](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g2578b65c87dc98d336f99edca913e92b>)Â object, unsigned int Â count )


Retain a reference to a user object.

######  Parameters

`object`
    \- The object to retain
`count`
    \- The number of references to retain, typically 1. Must be nonzero and not larger than INT_MAX.

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>)

###### Description

Retains new references to a user object. The new references are owned by the caller.

See CUDA User Objects in the CUDA C++ Programming Guide for more information on user objects.

**See also:**

[cuUserObjectCreate](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1g58f04e0ac0ad23d2f15ea6e9f6c8a999> "Create a user object."), [cuUserObjectRelease](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1ga2c16918341b8d020c9246e75658cc80> "Release a reference to a user object."), [cuGraphRetainUserObject](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1gaffd130c928e56740a2a5aaeb6125c8a> "Retain a reference to a user object from a graph."), [cuGraphReleaseUserObject](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1g232c84cc31e13e4201a421e28561eebf> "Release a user object reference from a graph."), [cuGraphCreate](<group__CUDA__GRAPH.html#group__CUDA__GRAPH_1gd885f719186010727b75c3315f865fdf> "Creates a graph.")

* * *


---

# Occupancy

## 6.25.Â Occupancy

This section describes the occupancy calculation functions of the low-level CUDA driver application programming interface.

### Functions

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuOccupancyAvailableDynamicSMemPerBlock](<#group__CUDA__OCCUPANCY_1gae02af6a9df9e1bbd51941af631bce69>) ( size_t*Â dynamicSmemSize, [CUfunction](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gba6128b948022f495706d93bc2cea9c8>)Â func, int Â numBlocks, int Â blockSize )
     Returns dynamic shared memory available per block when launching `numBlocks` blocks on SM.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuOccupancyMaxActiveBlocksPerMultiprocessor](<#group__CUDA__OCCUPANCY_1gcc6e1094d05cba2cee17fe33ddd04a98>) ( int*Â numBlocks, [CUfunction](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gba6128b948022f495706d93bc2cea9c8>)Â func, int Â blockSize, size_tÂ dynamicSMemSize )
     Returns occupancy of a function.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuOccupancyMaxActiveBlocksPerMultiprocessorWithFlags](<#group__CUDA__OCCUPANCY_1g8f1da4d4983e5c3025447665423ae2c2>) ( int*Â numBlocks, [CUfunction](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gba6128b948022f495706d93bc2cea9c8>)Â func, int Â blockSize, size_tÂ dynamicSMemSize, unsigned int Â flags )
     Returns occupancy of a function.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuOccupancyMaxActiveClusters](<#group__CUDA__OCCUPANCY_1g4f52cbf144d74ed20351a594dc26386b>) ( int*Â numClusters, [CUfunction](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gba6128b948022f495706d93bc2cea9c8>)Â func, const [CUlaunchConfig](<structCUlaunchConfig.html#structCUlaunchConfig>)*Â config )
     Given the kernel function (`func`) and launch configuration (`config`), return the maximum number of clusters that could co-exist on the target device in `*numClusters`.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuOccupancyMaxPotentialBlockSize](<#group__CUDA__OCCUPANCY_1gf179c4ab78962a8468e41c3f57851f03>) ( int*Â minGridSize, int*Â blockSize, [CUfunction](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gba6128b948022f495706d93bc2cea9c8>)Â func, [CUoccupancyB2DSize](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g6cb31f1273726f5567051e3e21607a45>)Â blockSizeToDynamicSMemSize, size_tÂ dynamicSMemSize, int Â blockSizeLimit )
     Suggest a launch configuration with reasonable occupancy.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuOccupancyMaxPotentialBlockSizeWithFlags](<#group__CUDA__OCCUPANCY_1g04c0bb65630f82d9b99a5ca0203ee5aa>) ( int*Â minGridSize, int*Â blockSize, [CUfunction](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gba6128b948022f495706d93bc2cea9c8>)Â func, [CUoccupancyB2DSize](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g6cb31f1273726f5567051e3e21607a45>)Â blockSizeToDynamicSMemSize, size_tÂ dynamicSMemSize, int Â blockSizeLimit, unsigned int Â flags )
     Suggest a launch configuration with reasonable occupancy.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuOccupancyMaxPotentialClusterSize](<#group__CUDA__OCCUPANCY_1gd6f60814c1e3440145115ade3730365f>) ( int*Â clusterSize, [CUfunction](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gba6128b948022f495706d93bc2cea9c8>)Â func, const [CUlaunchConfig](<structCUlaunchConfig.html#structCUlaunchConfig>)*Â config )
     Given the kernel function (`func`) and launch configuration (`config`), return the maximum cluster size in `*clusterSize`.

### Functions

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuOccupancyAvailableDynamicSMemPerBlock ( size_t*Â dynamicSmemSize, [CUfunction](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gba6128b948022f495706d93bc2cea9c8>)Â func, int Â numBlocks, int Â blockSize )


Returns dynamic shared memory available per block when launching `numBlocks` blocks on SM.

######  Parameters

`dynamicSmemSize`
    \- Returned maximum dynamic shared memory
`func`
    \- Kernel function for which occupancy is calculated
`numBlocks`
    \- Number of blocks to fit on SM
`blockSize`
    \- Size of the blocks

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_DEINITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9acf52f132faf29b473cdda6061f0f44a>), [CUDA_ERROR_NOT_INITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e98feb999f0af99b4a25ab26b3866f4df8>), [CUDA_ERROR_INVALID_CONTEXT](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a484e9af32c1e9893ff21f0e0191a12d>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>), [CUDA_ERROR_UNKNOWN](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9c5a6ab0245179d297f1fa56ed0097183>)

###### Description

Returns in `*dynamicSmemSize` the maximum size of dynamic shared memory to allow `numBlocks` blocks per SM.

Note that the API can also be used with context-less kernel [CUkernel](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g612028921e5736db673e4307589989ed>) by querying the handle using [cuLibraryGetKernel()](<group__CUDA__LIBRARY.html#group__CUDA__LIBRARY_1g15336d865f5abd63e3dc6004d5bc037a> "Returns a kernel handle.") and then passing it to the API by casting to [CUfunction](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gba6128b948022f495706d93bc2cea9c8>). Here, the context to use for calculations will be the current context.

Note:

Note that this function may also return error codes from previous, asynchronous launches.

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuOccupancyMaxActiveBlocksPerMultiprocessor ( int*Â numBlocks, [CUfunction](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gba6128b948022f495706d93bc2cea9c8>)Â func, int Â blockSize, size_tÂ dynamicSMemSize )


Returns occupancy of a function.

######  Parameters

`numBlocks`
    \- Returned occupancy
`func`
    \- Kernel for which occupancy is calculated
`blockSize`
    \- Block size the kernel is intended to be launched with
`dynamicSMemSize`
    \- Per-block dynamic shared memory usage intended, in bytes

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_DEINITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9acf52f132faf29b473cdda6061f0f44a>), [CUDA_ERROR_NOT_INITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e98feb999f0af99b4a25ab26b3866f4df8>), [CUDA_ERROR_INVALID_CONTEXT](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a484e9af32c1e9893ff21f0e0191a12d>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>), [CUDA_ERROR_UNKNOWN](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9c5a6ab0245179d297f1fa56ed0097183>)

###### Description

Returns in `*numBlocks` the number of the maximum active blocks per streaming multiprocessor.

Note that the API can also be used with context-less kernel [CUkernel](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g612028921e5736db673e4307589989ed>) by querying the handle using [cuLibraryGetKernel()](<group__CUDA__LIBRARY.html#group__CUDA__LIBRARY_1g15336d865f5abd63e3dc6004d5bc037a> "Returns a kernel handle.") and then passing it to the API by casting to [CUfunction](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gba6128b948022f495706d93bc2cea9c8>). Here, the context to use for calculations will be the current context.

Note:

Note that this function may also return error codes from previous, asynchronous launches.

**See also:**

[cudaOccupancyMaxActiveBlocksPerMultiprocessor](<../cuda-runtime-api/group__CUDART__HIGHLEVEL.html#group__CUDART__HIGHLEVEL_1g5a5d67a3c907371559ba692195e8a38c>)

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuOccupancyMaxActiveBlocksPerMultiprocessorWithFlags ( int*Â numBlocks, [CUfunction](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gba6128b948022f495706d93bc2cea9c8>)Â func, int Â blockSize, size_tÂ dynamicSMemSize, unsigned int Â flags )


Returns occupancy of a function.

######  Parameters

`numBlocks`
    \- Returned occupancy
`func`
    \- Kernel for which occupancy is calculated
`blockSize`
    \- Block size the kernel is intended to be launched with
`dynamicSMemSize`
    \- Per-block dynamic shared memory usage intended, in bytes
`flags`
    \- Requested behavior for the occupancy calculator

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_DEINITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9acf52f132faf29b473cdda6061f0f44a>), [CUDA_ERROR_NOT_INITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e98feb999f0af99b4a25ab26b3866f4df8>), [CUDA_ERROR_INVALID_CONTEXT](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a484e9af32c1e9893ff21f0e0191a12d>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>), [CUDA_ERROR_UNKNOWN](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9c5a6ab0245179d297f1fa56ed0097183>)

###### Description

Returns in `*numBlocks` the number of the maximum active blocks per streaming multiprocessor.

The `Flags` parameter controls how special cases are handled. The valid flags are:

  * [CU_OCCUPANCY_DEFAULT](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg40caa223198d058e073116b6a55eb895996ff3316265d9adf180fc54aa6c4b85>), which maintains the default behavior as [cuOccupancyMaxActiveBlocksPerMultiprocessor](<group__CUDA__OCCUPANCY.html#group__CUDA__OCCUPANCY_1gcc6e1094d05cba2cee17fe33ddd04a98> "Returns occupancy of a function.");


  * [CU_OCCUPANCY_DISABLE_CACHING_OVERRIDE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg40caa223198d058e073116b6a55eb8955f3f3738f84d2fd569e4b574350d09bb>), which suppresses the default behavior on platform where global caching affects occupancy. On such platforms, if caching is enabled, but per-block SM resource usage would result in zero occupancy, the occupancy calculator will calculate the occupancy as if caching is disabled. Setting [CU_OCCUPANCY_DISABLE_CACHING_OVERRIDE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg40caa223198d058e073116b6a55eb8955f3f3738f84d2fd569e4b574350d09bb>) makes the occupancy calculator to return 0 in such cases. More information can be found about this feature in the "Unified L1/Texture Cache" section of the Maxwell tuning guide.


Note that the API can also be with launch context-less kernel [CUkernel](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g612028921e5736db673e4307589989ed>) by querying the handle using [cuLibraryGetKernel()](<group__CUDA__LIBRARY.html#group__CUDA__LIBRARY_1g15336d865f5abd63e3dc6004d5bc037a> "Returns a kernel handle.") and then passing it to the API by casting to [CUfunction](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gba6128b948022f495706d93bc2cea9c8>). Here, the context to use for calculations will be the current context.

Note:

Note that this function may also return error codes from previous, asynchronous launches.

**See also:**

[cudaOccupancyMaxActiveBlocksPerMultiprocessorWithFlags](<../cuda-runtime-api/group__CUDART__HIGHLEVEL.html#group__CUDART__HIGHLEVEL_1g603b86b20b37823253ff89fe8688ba83>)

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuOccupancyMaxActiveClusters ( int*Â numClusters, [CUfunction](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gba6128b948022f495706d93bc2cea9c8>)Â func, const [CUlaunchConfig](<structCUlaunchConfig.html#structCUlaunchConfig>)*Â config )


Given the kernel function (`func`) and launch configuration (`config`), return the maximum number of clusters that could co-exist on the target device in `*numClusters`.

######  Parameters

`numClusters`
    \- Returned maximum number of clusters that could co-exist on the target device
`func`
    \- Kernel function for which maximum number of clusters are calculated
`config`
    \- Launch configuration for the given kernel function

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_DEINITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9acf52f132faf29b473cdda6061f0f44a>), [CUDA_ERROR_NOT_INITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e98feb999f0af99b4a25ab26b3866f4df8>), [CUDA_ERROR_INVALID_CONTEXT](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a484e9af32c1e9893ff21f0e0191a12d>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>), [CUDA_ERROR_INVALID_CLUSTER_SIZE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e927b783c2a2b1e62e8a9edc9044c70e66>), [CUDA_ERROR_UNKNOWN](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9c5a6ab0245179d297f1fa56ed0097183>)

###### Description

If the function has required cluster size already set (see [cudaFuncGetAttributes](<../cuda-runtime-api/group__CUDART__HIGHLEVEL.html#group__CUDART__HIGHLEVEL_1g0e78e02c6d12ebddd4577ac6ebadf494>) / [cuFuncGetAttribute](<group__CUDA__EXEC.html#group__CUDA__EXEC_1g5e92a1b0d8d1b82cb00dcfb2de15961b> "Returns information about a function.")), the cluster size from config must either be unspecified or match the required size. Without required sizes, the cluster size must be specified in config, else the function will return an error.

Note that various attributes of the kernel function may affect occupancy calculation. Runtime environment may affect how the hardware schedules the clusters, so the calculated occupancy is not guaranteed to be achievable.

Note that the API can also be used with context-less kernel [CUkernel](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g612028921e5736db673e4307589989ed>) by querying the handle using [cuLibraryGetKernel()](<group__CUDA__LIBRARY.html#group__CUDA__LIBRARY_1g15336d865f5abd63e3dc6004d5bc037a> "Returns a kernel handle.") and then passing it to the API by casting to [CUfunction](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gba6128b948022f495706d93bc2cea9c8>). Here, the context to use for calculations will either be taken from the specified stream `config->hStream` or the current context in case of NULL stream.

Note:

Note that this function may also return error codes from previous, asynchronous launches.

**See also:**

[cudaFuncGetAttributes](<../cuda-runtime-api/group__CUDART__HIGHLEVEL.html#group__CUDART__HIGHLEVEL_1g0e78e02c6d12ebddd4577ac6ebadf494>), [cuFuncGetAttribute](<group__CUDA__EXEC.html#group__CUDA__EXEC_1g5e92a1b0d8d1b82cb00dcfb2de15961b> "Returns information about a function.")

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuOccupancyMaxPotentialBlockSize ( int*Â minGridSize, int*Â blockSize, [CUfunction](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gba6128b948022f495706d93bc2cea9c8>)Â func, [CUoccupancyB2DSize](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g6cb31f1273726f5567051e3e21607a45>)Â blockSizeToDynamicSMemSize, size_tÂ dynamicSMemSize, int Â blockSizeLimit )


Suggest a launch configuration with reasonable occupancy.

######  Parameters

`minGridSize`
    \- Returned minimum grid size needed to achieve the maximum occupancy
`blockSize`
    \- Returned maximum block size that can achieve the maximum occupancy
`func`
    \- Kernel for which launch configuration is calculated
`blockSizeToDynamicSMemSize`
    \- A function that calculates how much per-block dynamic shared memory `func` uses based on the block size
`dynamicSMemSize`
    \- Dynamic shared memory usage intended, in bytes
`blockSizeLimit`
    \- The maximum block size `func` is designed to handle

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_DEINITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9acf52f132faf29b473cdda6061f0f44a>), [CUDA_ERROR_NOT_INITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e98feb999f0af99b4a25ab26b3866f4df8>), [CUDA_ERROR_INVALID_CONTEXT](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a484e9af32c1e9893ff21f0e0191a12d>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>), [CUDA_ERROR_UNKNOWN](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9c5a6ab0245179d297f1fa56ed0097183>)

###### Description

Returns in `*blockSize` a reasonable block size that can achieve the maximum occupancy (or, the maximum number of active warps with the fewest blocks per multiprocessor), and in `*minGridSize` the minimum grid size to achieve the maximum occupancy.

If `blockSizeLimit` is 0, the configurator will use the maximum block size permitted by the device / function instead.

If per-block dynamic shared memory allocation is not needed, the user should leave both `blockSizeToDynamicSMemSize` and `dynamicSMemSize` as 0.

If per-block dynamic shared memory allocation is needed, then if the dynamic shared memory size is constant regardless of block size, the size should be passed through `dynamicSMemSize`, and `blockSizeToDynamicSMemSize` should be NULL.

Otherwise, if the per-block dynamic shared memory size varies with different block sizes, the user needs to provide a unary function through `blockSizeToDynamicSMemSize` that computes the dynamic shared memory needed by `func` for any given block size. `dynamicSMemSize` is ignored. An example signature is:


    â    // Take block size, returns dynamic shared memory needed
              size_t blockToSmem(int blockSize);

Note that the API can also be used with context-less kernel [CUkernel](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g612028921e5736db673e4307589989ed>) by querying the handle using [cuLibraryGetKernel()](<group__CUDA__LIBRARY.html#group__CUDA__LIBRARY_1g15336d865f5abd63e3dc6004d5bc037a> "Returns a kernel handle.") and then passing it to the API by casting to [CUfunction](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gba6128b948022f495706d93bc2cea9c8>). Here, the context to use for calculations will be the current context.

Note:

Note that this function may also return error codes from previous, asynchronous launches.

**See also:**

[cudaOccupancyMaxPotentialBlockSize](<../cuda-runtime-api/group__CUDART__HIGHLEVEL.html#group__CUDART__HIGHLEVEL_1gee5334618ed4bb0871e4559a77643fc1>)

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuOccupancyMaxPotentialBlockSizeWithFlags ( int*Â minGridSize, int*Â blockSize, [CUfunction](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gba6128b948022f495706d93bc2cea9c8>)Â func, [CUoccupancyB2DSize](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g6cb31f1273726f5567051e3e21607a45>)Â blockSizeToDynamicSMemSize, size_tÂ dynamicSMemSize, int Â blockSizeLimit, unsigned int Â flags )


Suggest a launch configuration with reasonable occupancy.

######  Parameters

`minGridSize`
    \- Returned minimum grid size needed to achieve the maximum occupancy
`blockSize`
    \- Returned maximum block size that can achieve the maximum occupancy
`func`
    \- Kernel for which launch configuration is calculated
`blockSizeToDynamicSMemSize`
    \- A function that calculates how much per-block dynamic shared memory `func` uses based on the block size
`dynamicSMemSize`
    \- Dynamic shared memory usage intended, in bytes
`blockSizeLimit`
    \- The maximum block size `func` is designed to handle
`flags`
    \- Options

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_DEINITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9acf52f132faf29b473cdda6061f0f44a>), [CUDA_ERROR_NOT_INITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e98feb999f0af99b4a25ab26b3866f4df8>), [CUDA_ERROR_INVALID_CONTEXT](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a484e9af32c1e9893ff21f0e0191a12d>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>), [CUDA_ERROR_UNKNOWN](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9c5a6ab0245179d297f1fa56ed0097183>)

###### Description

An extended version of [cuOccupancyMaxPotentialBlockSize](<group__CUDA__OCCUPANCY.html#group__CUDA__OCCUPANCY_1gf179c4ab78962a8468e41c3f57851f03> "Suggest a launch configuration with reasonable occupancy."). In addition to arguments passed to [cuOccupancyMaxPotentialBlockSize](<group__CUDA__OCCUPANCY.html#group__CUDA__OCCUPANCY_1gf179c4ab78962a8468e41c3f57851f03> "Suggest a launch configuration with reasonable occupancy."), [cuOccupancyMaxPotentialBlockSizeWithFlags](<group__CUDA__OCCUPANCY.html#group__CUDA__OCCUPANCY_1g04c0bb65630f82d9b99a5ca0203ee5aa> "Suggest a launch configuration with reasonable occupancy.") also takes a `Flags` parameter.

The `Flags` parameter controls how special cases are handled. The valid flags are:

  * [CU_OCCUPANCY_DEFAULT](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg40caa223198d058e073116b6a55eb895996ff3316265d9adf180fc54aa6c4b85>), which maintains the default behavior as [cuOccupancyMaxPotentialBlockSize](<group__CUDA__OCCUPANCY.html#group__CUDA__OCCUPANCY_1gf179c4ab78962a8468e41c3f57851f03> "Suggest a launch configuration with reasonable occupancy.");


  * [CU_OCCUPANCY_DISABLE_CACHING_OVERRIDE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg40caa223198d058e073116b6a55eb8955f3f3738f84d2fd569e4b574350d09bb>), which suppresses the default behavior on platform where global caching affects occupancy. On such platforms, the launch configurations that produces maximal occupancy might not support global caching. Setting [CU_OCCUPANCY_DISABLE_CACHING_OVERRIDE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg40caa223198d058e073116b6a55eb8955f3f3738f84d2fd569e4b574350d09bb>) guarantees that the the produced launch configuration is global caching compatible at a potential cost of occupancy. More information can be found about this feature in the "Unified L1/Texture Cache" section of the Maxwell tuning guide.


Note that the API can also be used with context-less kernel [CUkernel](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g612028921e5736db673e4307589989ed>) by querying the handle using [cuLibraryGetKernel()](<group__CUDA__LIBRARY.html#group__CUDA__LIBRARY_1g15336d865f5abd63e3dc6004d5bc037a> "Returns a kernel handle.") and then passing it to the API by casting to [CUfunction](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gba6128b948022f495706d93bc2cea9c8>). Here, the context to use for calculations will be the current context.

Note:

Note that this function may also return error codes from previous, asynchronous launches.

**See also:**

[cudaOccupancyMaxPotentialBlockSizeWithFlags](<../cuda-runtime-api/group__CUDART__HIGHLEVEL.html#group__CUDART__HIGHLEVEL_1gd0524825c5c01bbc9a5e29e890745800>)

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuOccupancyMaxPotentialClusterSize ( int*Â clusterSize, [CUfunction](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gba6128b948022f495706d93bc2cea9c8>)Â func, const [CUlaunchConfig](<structCUlaunchConfig.html#structCUlaunchConfig>)*Â config )


Given the kernel function (`func`) and launch configuration (`config`), return the maximum cluster size in `*clusterSize`.

######  Parameters

`clusterSize`
    \- Returned maximum cluster size that can be launched for the given kernel function and launch configuration
`func`
    \- Kernel function for which maximum cluster size is calculated
`config`
    \- Launch configuration for the given kernel function

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_DEINITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9acf52f132faf29b473cdda6061f0f44a>), [CUDA_ERROR_NOT_INITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e98feb999f0af99b4a25ab26b3866f4df8>), [CUDA_ERROR_INVALID_CONTEXT](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a484e9af32c1e9893ff21f0e0191a12d>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>), [CUDA_ERROR_UNKNOWN](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9c5a6ab0245179d297f1fa56ed0097183>)

###### Description

The cluster dimensions in `config` are ignored. If func has a required cluster size set (see [cudaFuncGetAttributes](<../cuda-runtime-api/group__CUDART__HIGHLEVEL.html#group__CUDART__HIGHLEVEL_1g0e78e02c6d12ebddd4577ac6ebadf494>) / [cuFuncGetAttribute](<group__CUDA__EXEC.html#group__CUDA__EXEC_1g5e92a1b0d8d1b82cb00dcfb2de15961b> "Returns information about a function.")),`*clusterSize` will reflect the required cluster size.

By default this function will always return a value that's portable on future hardware. A higher value may be returned if the kernel function allows non-portable cluster sizes.

This function will respect the compile time launch bounds.

Note that the API can also be used with context-less kernel [CUkernel](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g612028921e5736db673e4307589989ed>) by querying the handle using [cuLibraryGetKernel()](<group__CUDA__LIBRARY.html#group__CUDA__LIBRARY_1g15336d865f5abd63e3dc6004d5bc037a> "Returns a kernel handle.") and then passing it to the API by casting to [CUfunction](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gba6128b948022f495706d93bc2cea9c8>). Here, the context to use for calculations will either be taken from the specified stream `config->hStream` or the current context in case of NULL stream.

Note:

Note that this function may also return error codes from previous, asynchronous launches.

**See also:**

[cudaFuncGetAttributes](<../cuda-runtime-api/group__CUDART__HIGHLEVEL.html#group__CUDART__HIGHLEVEL_1g0e78e02c6d12ebddd4577ac6ebadf494>), [cuFuncGetAttribute](<group__CUDA__EXEC.html#group__CUDA__EXEC_1g5e92a1b0d8d1b82cb00dcfb2de15961b> "Returns information about a function.")

* * *


---

# Texture Reference Management

Failed to fetch documentation.


---

# Texture Reference (Deprecated)

## 6.26.Â Texture Reference Management [DEPRECATED]

This section describes the deprecated texture reference management functions of the low-level CUDA driver application programming interface.

### Functions

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuTexRefCreate](<#group__CUDA__TEXREF__DEPRECATED_1g3b7632ddefba6033dc44bc149793619b>) ( [CUtexref](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gec1e8eb9dc48ad748765d1fcc020d6b5>)*Â pTexRef )
     Creates a texture reference.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuTexRefDestroy](<#group__CUDA__TEXREF__DEPRECATED_1g80c407e5759db31015f50fea94c10fa1>) ( [CUtexref](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gec1e8eb9dc48ad748765d1fcc020d6b5>)Â hTexRef )
     Destroys a texture reference.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuTexRefGetAddress](<#group__CUDA__TEXREF__DEPRECATED_1g56a175420c7fef8e547a66bc79671488>) ( [CUdeviceptr](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g183f7b0d8ad008ea2a5fd552537ace4e>)*Â pdptr, [CUtexref](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gec1e8eb9dc48ad748765d1fcc020d6b5>)Â hTexRef )
     Gets the address associated with a texture reference.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuTexRefGetAddressMode](<#group__CUDA__TEXREF__DEPRECATED_1ga41ceb7f8a452d59ae7e874b1c8e0c67>) ( [CUaddress_mode](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc925457ee7128d6251071f6ff7608887>)*Â pam, [CUtexref](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gec1e8eb9dc48ad748765d1fcc020d6b5>)Â hTexRef, int Â dim )
     Gets the addressing mode used by a texture reference.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuTexRefGetArray](<#group__CUDA__TEXREF__DEPRECATED_1g7f74aff0d999af6613dfc9aff3a21087>) ( [CUarray](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gd550651524a56766b60f10f0e7628042>)*Â phArray, [CUtexref](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gec1e8eb9dc48ad748765d1fcc020d6b5>)Â hTexRef )
     Gets the array bound to a texture reference.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuTexRefGetBorderColor](<#group__CUDA__TEXREF__DEPRECATED_1g04303cad6225620089ad34ffb50caf48>) ( float*Â pBorderColor, [CUtexref](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gec1e8eb9dc48ad748765d1fcc020d6b5>)Â hTexRef )
     Gets the border color used by a texture reference.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuTexRefGetFilterMode](<#group__CUDA__TEXREF__DEPRECATED_1g941748b72fe9c6f9767be38b8d02c95d>) ( [CUfilter_mode](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g4fb799d90872f1d6cd074b4349f37c2a>)*Â pfm, [CUtexref](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gec1e8eb9dc48ad748765d1fcc020d6b5>)Â hTexRef )
     Gets the filter-mode used by a texture reference.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuTexRefGetFlags](<#group__CUDA__TEXREF__DEPRECATED_1g0eb1b87656d661c4fbd4ddbbc0dd7b94>) ( unsigned int*Â pFlags, [CUtexref](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gec1e8eb9dc48ad748765d1fcc020d6b5>)Â hTexRef )
     Gets the flags used by a texture reference.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuTexRefGetFormat](<#group__CUDA__TEXREF__DEPRECATED_1g0453d286f81825e1d503d651f8b079d8>) ( [CUarray_format](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g9b009d9a6aa4c5765c8a00289b6068f9>)*Â pFormat, int*Â pNumChannels, [CUtexref](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gec1e8eb9dc48ad748765d1fcc020d6b5>)Â hTexRef )
     Gets the format used by a texture reference.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuTexRefGetMaxAnisotropy](<#group__CUDA__TEXREF__DEPRECATED_1g9e101cc5a0dcab4a9a7c709ab9ecfd1c>) ( int*Â pmaxAniso, [CUtexref](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gec1e8eb9dc48ad748765d1fcc020d6b5>)Â hTexRef )
     Gets the maximum anisotropy for a texture reference.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuTexRefGetMipmapFilterMode](<#group__CUDA__TEXREF__DEPRECATED_1ge2726d645a4d84df974f9da2f5a85b11>) ( [CUfilter_mode](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g4fb799d90872f1d6cd074b4349f37c2a>)*Â pfm, [CUtexref](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gec1e8eb9dc48ad748765d1fcc020d6b5>)Â hTexRef )
     Gets the mipmap filtering mode for a texture reference.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuTexRefGetMipmapLevelBias](<#group__CUDA__TEXREF__DEPRECATED_1g46dca9c5a96a5494b60499fe81c15f82>) ( float*Â pbias, [CUtexref](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gec1e8eb9dc48ad748765d1fcc020d6b5>)Â hTexRef )
     Gets the mipmap level bias for a texture reference.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuTexRefGetMipmapLevelClamp](<#group__CUDA__TEXREF__DEPRECATED_1g7e0b66c45535bd2b753d9860f212d848>) ( float*Â pminMipmapLevelClamp, float*Â pmaxMipmapLevelClamp, [CUtexref](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gec1e8eb9dc48ad748765d1fcc020d6b5>)Â hTexRef )
     Gets the min/max mipmap level clamps for a texture reference.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuTexRefGetMipmappedArray](<#group__CUDA__TEXREF__DEPRECATED_1g3bc191d80a7a6e1cf7405a00fde9131a>) ( [CUmipmappedArray](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g96db856ab3d2940fb694ce4501d9b583>)*Â phMipmappedArray, [CUtexref](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gec1e8eb9dc48ad748765d1fcc020d6b5>)Â hTexRef )
     Gets the mipmapped array bound to a texture reference.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuTexRefSetAddress](<#group__CUDA__TEXREF__DEPRECATED_1ga6e288992f58e7a6e3350614bc9e813b>) ( size_t*Â ByteOffset, [CUtexref](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gec1e8eb9dc48ad748765d1fcc020d6b5>)Â hTexRef, [CUdeviceptr](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g183f7b0d8ad008ea2a5fd552537ace4e>)Â dptr, size_tÂ bytes )
     Binds an address as a texture reference.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuTexRefSetAddress2D](<#group__CUDA__TEXREF__DEPRECATED_1gbdec8983628f68bcde5db4b4c3f90851>) ( [CUtexref](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gec1e8eb9dc48ad748765d1fcc020d6b5>)Â hTexRef, const [CUDA_ARRAY_DESCRIPTOR](<structCUDA__ARRAY__DESCRIPTOR__v2.html#structCUDA__ARRAY__DESCRIPTOR__v2>)*Â desc, [CUdeviceptr](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g183f7b0d8ad008ea2a5fd552537ace4e>)Â dptr, size_tÂ Pitch )
     Binds an address as a 2D texture reference.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuTexRefSetAddressMode](<#group__CUDA__TEXREF__DEPRECATED_1ga45732a5c4ec291c0682fffcbaa6d393>) ( [CUtexref](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gec1e8eb9dc48ad748765d1fcc020d6b5>)Â hTexRef, int Â dim, [CUaddress_mode](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc925457ee7128d6251071f6ff7608887>)Â am )
     Sets the addressing mode for a texture reference.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuTexRefSetArray](<#group__CUDA__TEXREF__DEPRECATED_1gac3a34b4b10983433865fdadb83b9118>) ( [CUtexref](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gec1e8eb9dc48ad748765d1fcc020d6b5>)Â hTexRef, [CUarray](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gd550651524a56766b60f10f0e7628042>)Â hArray, unsigned int Â Flags )
     Binds an array as a texture reference.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuTexRefSetBorderColor](<#group__CUDA__TEXREF__DEPRECATED_1g1db39c355bedd9e7ffb00e2011784dea>) ( [CUtexref](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gec1e8eb9dc48ad748765d1fcc020d6b5>)Â hTexRef, float*Â pBorderColor )
     Sets the border color for a texture reference.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuTexRefSetFilterMode](<#group__CUDA__TEXREF__DEPRECATED_1g93819286c48db39afc253c0f10358d2e>) ( [CUtexref](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gec1e8eb9dc48ad748765d1fcc020d6b5>)Â hTexRef, [CUfilter_mode](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g4fb799d90872f1d6cd074b4349f37c2a>)Â fm )
     Sets the filtering mode for a texture reference.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuTexRefSetFlags](<#group__CUDA__TEXREF__DEPRECATED_1g9d4816a6561e1d09e0eef9f9c0cdbfa2>) ( [CUtexref](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gec1e8eb9dc48ad748765d1fcc020d6b5>)Â hTexRef, unsigned int Â Flags )
     Sets the flags for a texture reference.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuTexRefSetFormat](<#group__CUDA__TEXREF__DEPRECATED_1g2d57eabbd5ef6780307c008b0f4ce83d>) ( [CUtexref](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gec1e8eb9dc48ad748765d1fcc020d6b5>)Â hTexRef, [CUarray_format](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g9b009d9a6aa4c5765c8a00289b6068f9>)Â fmt, int Â NumPackedComponents )
     Sets the format for a texture reference.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuTexRefSetMaxAnisotropy](<#group__CUDA__TEXREF__DEPRECATED_1g2b144345d6089ec4053c334fb7d04490>) ( [CUtexref](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gec1e8eb9dc48ad748765d1fcc020d6b5>)Â hTexRef, unsigned int Â maxAniso )
     Sets the maximum anisotropy for a texture reference.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuTexRefSetMipmapFilterMode](<#group__CUDA__TEXREF__DEPRECATED_1g82a54190706dd35d8923966b60f320eb>) ( [CUtexref](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gec1e8eb9dc48ad748765d1fcc020d6b5>)Â hTexRef, [CUfilter_mode](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g4fb799d90872f1d6cd074b4349f37c2a>)Â fm )
     Sets the mipmap filtering mode for a texture reference.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuTexRefSetMipmapLevelBias](<#group__CUDA__TEXREF__DEPRECATED_1g6d208de7a968f051fc54224883b1994c>) ( [CUtexref](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gec1e8eb9dc48ad748765d1fcc020d6b5>)Â hTexRef, float Â bias )
     Sets the mipmap level bias for a texture reference.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuTexRefSetMipmapLevelClamp](<#group__CUDA__TEXREF__DEPRECATED_1g9b39decf969353890454895e988e9018>) ( [CUtexref](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gec1e8eb9dc48ad748765d1fcc020d6b5>)Â hTexRef, float Â minMipmapLevelClamp, float Â maxMipmapLevelClamp )
     Sets the mipmap min/max mipmap level clamps for a texture reference.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuTexRefSetMipmappedArray](<#group__CUDA__TEXREF__DEPRECATED_1gb35f38ee0738f00c988db5c1ed8c38ea>) ( [CUtexref](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gec1e8eb9dc48ad748765d1fcc020d6b5>)Â hTexRef, [CUmipmappedArray](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g96db856ab3d2940fb694ce4501d9b583>)Â hMipmappedArray, unsigned int Â Flags )
     Binds a mipmapped array to a texture reference.

### Functions

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuTexRefCreate ( [CUtexref](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gec1e8eb9dc48ad748765d1fcc020d6b5>)*Â pTexRef )


Creates a texture reference.

######  Parameters

`pTexRef`
    \- Returned texture reference

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_DEINITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9acf52f132faf29b473cdda6061f0f44a>), [CUDA_ERROR_NOT_INITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e98feb999f0af99b4a25ab26b3866f4df8>), [CUDA_ERROR_INVALID_CONTEXT](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a484e9af32c1e9893ff21f0e0191a12d>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>)

###### [Deprecated](<deprecated.html#deprecated__deprecated_1_deprecated000047>)

###### Description

Creates a texture reference and returns its handle in `*pTexRef`. Once created, the application must call [cuTexRefSetArray()](<group__CUDA__TEXREF__DEPRECATED.html#group__CUDA__TEXREF__DEPRECATED_1gac3a34b4b10983433865fdadb83b9118> "Binds an array as a texture reference.") or [cuTexRefSetAddress()](<group__CUDA__TEXREF__DEPRECATED.html#group__CUDA__TEXREF__DEPRECATED_1ga6e288992f58e7a6e3350614bc9e813b> "Binds an address as a texture reference.") to associate the reference with allocated memory. Other texture reference functions are used to specify the format and interpretation (addressing, filtering, etc.) to be used when the memory is read through this texture reference.

**See also:**

[cuTexRefDestroy](<group__CUDA__TEXREF__DEPRECATED.html#group__CUDA__TEXREF__DEPRECATED_1g80c407e5759db31015f50fea94c10fa1> "Destroys a texture reference.")

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuTexRefDestroy ( [CUtexref](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gec1e8eb9dc48ad748765d1fcc020d6b5>)Â hTexRef )


Destroys a texture reference.

######  Parameters

`hTexRef`
    \- Texture reference to destroy

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_DEINITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9acf52f132faf29b473cdda6061f0f44a>), [CUDA_ERROR_NOT_INITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e98feb999f0af99b4a25ab26b3866f4df8>), [CUDA_ERROR_INVALID_CONTEXT](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a484e9af32c1e9893ff21f0e0191a12d>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>)

###### [Deprecated](<deprecated.html#deprecated__deprecated_1_deprecated000048>)

###### Description

Destroys the texture reference specified by `hTexRef`.

**See also:**

[cuTexRefCreate](<group__CUDA__TEXREF__DEPRECATED.html#group__CUDA__TEXREF__DEPRECATED_1g3b7632ddefba6033dc44bc149793619b> "Creates a texture reference.")

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuTexRefGetAddress ( [CUdeviceptr](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g183f7b0d8ad008ea2a5fd552537ace4e>)*Â pdptr, [CUtexref](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gec1e8eb9dc48ad748765d1fcc020d6b5>)Â hTexRef )


Gets the address associated with a texture reference.

######  Parameters

`pdptr`
    \- Returned device address
`hTexRef`
    \- Texture reference

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_DEINITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9acf52f132faf29b473cdda6061f0f44a>), [CUDA_ERROR_NOT_INITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e98feb999f0af99b4a25ab26b3866f4df8>), [CUDA_ERROR_INVALID_CONTEXT](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a484e9af32c1e9893ff21f0e0191a12d>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>)

###### [Deprecated](<deprecated.html#deprecated__deprecated_1_deprecated000035>)

###### Description

Returns in `*pdptr` the base address bound to the texture reference `hTexRef`, or returns [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>) if the texture reference is not bound to any device memory range.

**See also:**

[cuTexRefSetAddress](<group__CUDA__TEXREF__DEPRECATED.html#group__CUDA__TEXREF__DEPRECATED_1ga6e288992f58e7a6e3350614bc9e813b> "Binds an address as a texture reference."), [cuTexRefSetAddress2D](<group__CUDA__TEXREF__DEPRECATED.html#group__CUDA__TEXREF__DEPRECATED_1gbdec8983628f68bcde5db4b4c3f90851> "Binds an address as a 2D texture reference."), [cuTexRefSetAddressMode](<group__CUDA__TEXREF__DEPRECATED.html#group__CUDA__TEXREF__DEPRECATED_1ga45732a5c4ec291c0682fffcbaa6d393> "Sets the addressing mode for a texture reference."), [cuTexRefSetArray](<group__CUDA__TEXREF__DEPRECATED.html#group__CUDA__TEXREF__DEPRECATED_1gac3a34b4b10983433865fdadb83b9118> "Binds an array as a texture reference."), [cuTexRefSetFilterMode](<group__CUDA__TEXREF__DEPRECATED.html#group__CUDA__TEXREF__DEPRECATED_1g93819286c48db39afc253c0f10358d2e> "Sets the filtering mode for a texture reference."), [cuTexRefSetFlags](<group__CUDA__TEXREF__DEPRECATED.html#group__CUDA__TEXREF__DEPRECATED_1g9d4816a6561e1d09e0eef9f9c0cdbfa2> "Sets the flags for a texture reference."), [cuTexRefSetFormat](<group__CUDA__TEXREF__DEPRECATED.html#group__CUDA__TEXREF__DEPRECATED_1g2d57eabbd5ef6780307c008b0f4ce83d> "Sets the format for a texture reference."), [cuTexRefGetAddressMode](<group__CUDA__TEXREF__DEPRECATED.html#group__CUDA__TEXREF__DEPRECATED_1ga41ceb7f8a452d59ae7e874b1c8e0c67> "Gets the addressing mode used by a texture reference."), [cuTexRefGetArray](<group__CUDA__TEXREF__DEPRECATED.html#group__CUDA__TEXREF__DEPRECATED_1g7f74aff0d999af6613dfc9aff3a21087> "Gets the array bound to a texture reference."), [cuTexRefGetFilterMode](<group__CUDA__TEXREF__DEPRECATED.html#group__CUDA__TEXREF__DEPRECATED_1g941748b72fe9c6f9767be38b8d02c95d> "Gets the filter-mode used by a texture reference."), [cuTexRefGetFlags](<group__CUDA__TEXREF__DEPRECATED.html#group__CUDA__TEXREF__DEPRECATED_1g0eb1b87656d661c4fbd4ddbbc0dd7b94> "Gets the flags used by a texture reference."), [cuTexRefGetFormat](<group__CUDA__TEXREF__DEPRECATED.html#group__CUDA__TEXREF__DEPRECATED_1g0453d286f81825e1d503d651f8b079d8> "Gets the format used by a texture reference.")

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuTexRefGetAddressMode ( [CUaddress_mode](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc925457ee7128d6251071f6ff7608887>)*Â pam, [CUtexref](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gec1e8eb9dc48ad748765d1fcc020d6b5>)Â hTexRef, int Â dim )


Gets the addressing mode used by a texture reference.

######  Parameters

`pam`
    \- Returned addressing mode
`hTexRef`
    \- Texture reference
`dim`
    \- Dimension

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_DEINITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9acf52f132faf29b473cdda6061f0f44a>), [CUDA_ERROR_NOT_INITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e98feb999f0af99b4a25ab26b3866f4df8>), [CUDA_ERROR_INVALID_CONTEXT](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a484e9af32c1e9893ff21f0e0191a12d>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>)

###### [Deprecated](<deprecated.html#deprecated__deprecated_1_deprecated000038>)

###### Description

Returns in `*pam` the addressing mode corresponding to the dimension `dim` of the texture reference `hTexRef`. Currently, the only valid value for `dim` are 0 and 1.

**See also:**

[cuTexRefSetAddress](<group__CUDA__TEXREF__DEPRECATED.html#group__CUDA__TEXREF__DEPRECATED_1ga6e288992f58e7a6e3350614bc9e813b> "Binds an address as a texture reference."), [cuTexRefSetAddress2D](<group__CUDA__TEXREF__DEPRECATED.html#group__CUDA__TEXREF__DEPRECATED_1gbdec8983628f68bcde5db4b4c3f90851> "Binds an address as a 2D texture reference."), [cuTexRefSetAddressMode](<group__CUDA__TEXREF__DEPRECATED.html#group__CUDA__TEXREF__DEPRECATED_1ga45732a5c4ec291c0682fffcbaa6d393> "Sets the addressing mode for a texture reference."), [cuTexRefSetArray](<group__CUDA__TEXREF__DEPRECATED.html#group__CUDA__TEXREF__DEPRECATED_1gac3a34b4b10983433865fdadb83b9118> "Binds an array as a texture reference."), [cuTexRefSetFilterMode](<group__CUDA__TEXREF__DEPRECATED.html#group__CUDA__TEXREF__DEPRECATED_1g93819286c48db39afc253c0f10358d2e> "Sets the filtering mode for a texture reference."), [cuTexRefSetFlags](<group__CUDA__TEXREF__DEPRECATED.html#group__CUDA__TEXREF__DEPRECATED_1g9d4816a6561e1d09e0eef9f9c0cdbfa2> "Sets the flags for a texture reference."), [cuTexRefSetFormat](<group__CUDA__TEXREF__DEPRECATED.html#group__CUDA__TEXREF__DEPRECATED_1g2d57eabbd5ef6780307c008b0f4ce83d> "Sets the format for a texture reference."), [cuTexRefGetAddress](<group__CUDA__TEXREF__DEPRECATED.html#group__CUDA__TEXREF__DEPRECATED_1g56a175420c7fef8e547a66bc79671488> "Gets the address associated with a texture reference."), [cuTexRefGetArray](<group__CUDA__TEXREF__DEPRECATED.html#group__CUDA__TEXREF__DEPRECATED_1g7f74aff0d999af6613dfc9aff3a21087> "Gets the array bound to a texture reference."), [cuTexRefGetFilterMode](<group__CUDA__TEXREF__DEPRECATED.html#group__CUDA__TEXREF__DEPRECATED_1g941748b72fe9c6f9767be38b8d02c95d> "Gets the filter-mode used by a texture reference."), [cuTexRefGetFlags](<group__CUDA__TEXREF__DEPRECATED.html#group__CUDA__TEXREF__DEPRECATED_1g0eb1b87656d661c4fbd4ddbbc0dd7b94> "Gets the flags used by a texture reference."), [cuTexRefGetFormat](<group__CUDA__TEXREF__DEPRECATED.html#group__CUDA__TEXREF__DEPRECATED_1g0453d286f81825e1d503d651f8b079d8> "Gets the format used by a texture reference.")

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuTexRefGetArray ( [CUarray](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gd550651524a56766b60f10f0e7628042>)*Â phArray, [CUtexref](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gec1e8eb9dc48ad748765d1fcc020d6b5>)Â hTexRef )


Gets the array bound to a texture reference.

######  Parameters

`phArray`
    \- Returned array
`hTexRef`
    \- Texture reference

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_DEINITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9acf52f132faf29b473cdda6061f0f44a>), [CUDA_ERROR_NOT_INITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e98feb999f0af99b4a25ab26b3866f4df8>), [CUDA_ERROR_INVALID_CONTEXT](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a484e9af32c1e9893ff21f0e0191a12d>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>)

###### [Deprecated](<deprecated.html#deprecated__deprecated_1_deprecated000036>)

###### Description

Returns in `*phArray` the CUDA array bound to the texture reference `hTexRef`, or returns [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>) if the texture reference is not bound to any CUDA array.

**See also:**

[cuTexRefSetAddress](<group__CUDA__TEXREF__DEPRECATED.html#group__CUDA__TEXREF__DEPRECATED_1ga6e288992f58e7a6e3350614bc9e813b> "Binds an address as a texture reference."), [cuTexRefSetAddress2D](<group__CUDA__TEXREF__DEPRECATED.html#group__CUDA__TEXREF__DEPRECATED_1gbdec8983628f68bcde5db4b4c3f90851> "Binds an address as a 2D texture reference."), [cuTexRefSetAddressMode](<group__CUDA__TEXREF__DEPRECATED.html#group__CUDA__TEXREF__DEPRECATED_1ga45732a5c4ec291c0682fffcbaa6d393> "Sets the addressing mode for a texture reference."), [cuTexRefSetArray](<group__CUDA__TEXREF__DEPRECATED.html#group__CUDA__TEXREF__DEPRECATED_1gac3a34b4b10983433865fdadb83b9118> "Binds an array as a texture reference."), [cuTexRefSetFilterMode](<group__CUDA__TEXREF__DEPRECATED.html#group__CUDA__TEXREF__DEPRECATED_1g93819286c48db39afc253c0f10358d2e> "Sets the filtering mode for a texture reference."), [cuTexRefSetFlags](<group__CUDA__TEXREF__DEPRECATED.html#group__CUDA__TEXREF__DEPRECATED_1g9d4816a6561e1d09e0eef9f9c0cdbfa2> "Sets the flags for a texture reference."), [cuTexRefSetFormat](<group__CUDA__TEXREF__DEPRECATED.html#group__CUDA__TEXREF__DEPRECATED_1g2d57eabbd5ef6780307c008b0f4ce83d> "Sets the format for a texture reference."), [cuTexRefGetAddress](<group__CUDA__TEXREF__DEPRECATED.html#group__CUDA__TEXREF__DEPRECATED_1g56a175420c7fef8e547a66bc79671488> "Gets the address associated with a texture reference."), [cuTexRefGetAddressMode](<group__CUDA__TEXREF__DEPRECATED.html#group__CUDA__TEXREF__DEPRECATED_1ga41ceb7f8a452d59ae7e874b1c8e0c67> "Gets the addressing mode used by a texture reference."), [cuTexRefGetFilterMode](<group__CUDA__TEXREF__DEPRECATED.html#group__CUDA__TEXREF__DEPRECATED_1g941748b72fe9c6f9767be38b8d02c95d> "Gets the filter-mode used by a texture reference."), [cuTexRefGetFlags](<group__CUDA__TEXREF__DEPRECATED.html#group__CUDA__TEXREF__DEPRECATED_1g0eb1b87656d661c4fbd4ddbbc0dd7b94> "Gets the flags used by a texture reference."), [cuTexRefGetFormat](<group__CUDA__TEXREF__DEPRECATED.html#group__CUDA__TEXREF__DEPRECATED_1g0453d286f81825e1d503d651f8b079d8> "Gets the format used by a texture reference.")

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuTexRefGetBorderColor ( float*Â pBorderColor, [CUtexref](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gec1e8eb9dc48ad748765d1fcc020d6b5>)Â hTexRef )


Gets the border color used by a texture reference.

######  Parameters

`pBorderColor`
    \- Returned Type and Value of RGBA color
`hTexRef`
    \- Texture reference

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_DEINITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9acf52f132faf29b473cdda6061f0f44a>), [CUDA_ERROR_NOT_INITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e98feb999f0af99b4a25ab26b3866f4df8>), [CUDA_ERROR_INVALID_CONTEXT](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a484e9af32c1e9893ff21f0e0191a12d>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>)

###### [Deprecated](<deprecated.html#deprecated__deprecated_1_deprecated000045>)

###### Description

Returns in `pBorderColor`, values of the RGBA color used by the texture reference `hTexRef`. The color value is of type float and holds color components in the following sequence: pBorderColor[0] holds 'R' component pBorderColor[1] holds 'G' component pBorderColor[2] holds 'B' component pBorderColor[3] holds 'A' component

**See also:**

[cuTexRefSetAddressMode](<group__CUDA__TEXREF__DEPRECATED.html#group__CUDA__TEXREF__DEPRECATED_1ga45732a5c4ec291c0682fffcbaa6d393> "Sets the addressing mode for a texture reference."), [cuTexRefSetAddressMode](<group__CUDA__TEXREF__DEPRECATED.html#group__CUDA__TEXREF__DEPRECATED_1ga45732a5c4ec291c0682fffcbaa6d393> "Sets the addressing mode for a texture reference."), [cuTexRefSetBorderColor](<group__CUDA__TEXREF__DEPRECATED.html#group__CUDA__TEXREF__DEPRECATED_1g1db39c355bedd9e7ffb00e2011784dea> "Sets the border color for a texture reference.")

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuTexRefGetFilterMode ( [CUfilter_mode](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g4fb799d90872f1d6cd074b4349f37c2a>)*Â pfm, [CUtexref](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gec1e8eb9dc48ad748765d1fcc020d6b5>)Â hTexRef )


Gets the filter-mode used by a texture reference.

######  Parameters

`pfm`
    \- Returned filtering mode
`hTexRef`
    \- Texture reference

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_DEINITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9acf52f132faf29b473cdda6061f0f44a>), [CUDA_ERROR_NOT_INITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e98feb999f0af99b4a25ab26b3866f4df8>), [CUDA_ERROR_INVALID_CONTEXT](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a484e9af32c1e9893ff21f0e0191a12d>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>)

###### [Deprecated](<deprecated.html#deprecated__deprecated_1_deprecated000039>)

###### Description

Returns in `*pfm` the filtering mode of the texture reference `hTexRef`.

**See also:**

[cuTexRefSetAddress](<group__CUDA__TEXREF__DEPRECATED.html#group__CUDA__TEXREF__DEPRECATED_1ga6e288992f58e7a6e3350614bc9e813b> "Binds an address as a texture reference."), [cuTexRefSetAddress2D](<group__CUDA__TEXREF__DEPRECATED.html#group__CUDA__TEXREF__DEPRECATED_1gbdec8983628f68bcde5db4b4c3f90851> "Binds an address as a 2D texture reference."), [cuTexRefSetAddressMode](<group__CUDA__TEXREF__DEPRECATED.html#group__CUDA__TEXREF__DEPRECATED_1ga45732a5c4ec291c0682fffcbaa6d393> "Sets the addressing mode for a texture reference."), [cuTexRefSetArray](<group__CUDA__TEXREF__DEPRECATED.html#group__CUDA__TEXREF__DEPRECATED_1gac3a34b4b10983433865fdadb83b9118> "Binds an array as a texture reference."), [cuTexRefSetFilterMode](<group__CUDA__TEXREF__DEPRECATED.html#group__CUDA__TEXREF__DEPRECATED_1g93819286c48db39afc253c0f10358d2e> "Sets the filtering mode for a texture reference."), [cuTexRefSetFlags](<group__CUDA__TEXREF__DEPRECATED.html#group__CUDA__TEXREF__DEPRECATED_1g9d4816a6561e1d09e0eef9f9c0cdbfa2> "Sets the flags for a texture reference."), [cuTexRefSetFormat](<group__CUDA__TEXREF__DEPRECATED.html#group__CUDA__TEXREF__DEPRECATED_1g2d57eabbd5ef6780307c008b0f4ce83d> "Sets the format for a texture reference."), [cuTexRefGetAddress](<group__CUDA__TEXREF__DEPRECATED.html#group__CUDA__TEXREF__DEPRECATED_1g56a175420c7fef8e547a66bc79671488> "Gets the address associated with a texture reference."), [cuTexRefGetAddressMode](<group__CUDA__TEXREF__DEPRECATED.html#group__CUDA__TEXREF__DEPRECATED_1ga41ceb7f8a452d59ae7e874b1c8e0c67> "Gets the addressing mode used by a texture reference."), [cuTexRefGetArray](<group__CUDA__TEXREF__DEPRECATED.html#group__CUDA__TEXREF__DEPRECATED_1g7f74aff0d999af6613dfc9aff3a21087> "Gets the array bound to a texture reference."), [cuTexRefGetFlags](<group__CUDA__TEXREF__DEPRECATED.html#group__CUDA__TEXREF__DEPRECATED_1g0eb1b87656d661c4fbd4ddbbc0dd7b94> "Gets the flags used by a texture reference."), [cuTexRefGetFormat](<group__CUDA__TEXREF__DEPRECATED.html#group__CUDA__TEXREF__DEPRECATED_1g0453d286f81825e1d503d651f8b079d8> "Gets the format used by a texture reference.")

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuTexRefGetFlags ( unsigned int*Â pFlags, [CUtexref](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gec1e8eb9dc48ad748765d1fcc020d6b5>)Â hTexRef )


Gets the flags used by a texture reference.

######  Parameters

`pFlags`
    \- Returned flags
`hTexRef`
    \- Texture reference

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_DEINITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9acf52f132faf29b473cdda6061f0f44a>), [CUDA_ERROR_NOT_INITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e98feb999f0af99b4a25ab26b3866f4df8>), [CUDA_ERROR_INVALID_CONTEXT](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a484e9af32c1e9893ff21f0e0191a12d>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>)

###### [Deprecated](<deprecated.html#deprecated__deprecated_1_deprecated000046>)

###### Description

Returns in `*pFlags` the flags of the texture reference `hTexRef`.

**See also:**

[cuTexRefSetAddress](<group__CUDA__TEXREF__DEPRECATED.html#group__CUDA__TEXREF__DEPRECATED_1ga6e288992f58e7a6e3350614bc9e813b> "Binds an address as a texture reference."), [cuTexRefSetAddress2D](<group__CUDA__TEXREF__DEPRECATED.html#group__CUDA__TEXREF__DEPRECATED_1gbdec8983628f68bcde5db4b4c3f90851> "Binds an address as a 2D texture reference."), [cuTexRefSetAddressMode](<group__CUDA__TEXREF__DEPRECATED.html#group__CUDA__TEXREF__DEPRECATED_1ga45732a5c4ec291c0682fffcbaa6d393> "Sets the addressing mode for a texture reference."), [cuTexRefSetArray](<group__CUDA__TEXREF__DEPRECATED.html#group__CUDA__TEXREF__DEPRECATED_1gac3a34b4b10983433865fdadb83b9118> "Binds an array as a texture reference."), [cuTexRefSetFilterMode](<group__CUDA__TEXREF__DEPRECATED.html#group__CUDA__TEXREF__DEPRECATED_1g93819286c48db39afc253c0f10358d2e> "Sets the filtering mode for a texture reference."), [cuTexRefSetFlags](<group__CUDA__TEXREF__DEPRECATED.html#group__CUDA__TEXREF__DEPRECATED_1g9d4816a6561e1d09e0eef9f9c0cdbfa2> "Sets the flags for a texture reference."), [cuTexRefSetFormat](<group__CUDA__TEXREF__DEPRECATED.html#group__CUDA__TEXREF__DEPRECATED_1g2d57eabbd5ef6780307c008b0f4ce83d> "Sets the format for a texture reference."), [cuTexRefGetAddress](<group__CUDA__TEXREF__DEPRECATED.html#group__CUDA__TEXREF__DEPRECATED_1g56a175420c7fef8e547a66bc79671488> "Gets the address associated with a texture reference."), [cuTexRefGetAddressMode](<group__CUDA__TEXREF__DEPRECATED.html#group__CUDA__TEXREF__DEPRECATED_1ga41ceb7f8a452d59ae7e874b1c8e0c67> "Gets the addressing mode used by a texture reference."), [cuTexRefGetArray](<group__CUDA__TEXREF__DEPRECATED.html#group__CUDA__TEXREF__DEPRECATED_1g7f74aff0d999af6613dfc9aff3a21087> "Gets the array bound to a texture reference."), [cuTexRefGetFilterMode](<group__CUDA__TEXREF__DEPRECATED.html#group__CUDA__TEXREF__DEPRECATED_1g941748b72fe9c6f9767be38b8d02c95d> "Gets the filter-mode used by a texture reference."), [cuTexRefGetFormat](<group__CUDA__TEXREF__DEPRECATED.html#group__CUDA__TEXREF__DEPRECATED_1g0453d286f81825e1d503d651f8b079d8> "Gets the format used by a texture reference.")

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuTexRefGetFormat ( [CUarray_format](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g9b009d9a6aa4c5765c8a00289b6068f9>)*Â pFormat, int*Â pNumChannels, [CUtexref](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gec1e8eb9dc48ad748765d1fcc020d6b5>)Â hTexRef )


Gets the format used by a texture reference.

######  Parameters

`pFormat`
    \- Returned format
`pNumChannels`
    \- Returned number of components
`hTexRef`
    \- Texture reference

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_DEINITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9acf52f132faf29b473cdda6061f0f44a>), [CUDA_ERROR_NOT_INITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e98feb999f0af99b4a25ab26b3866f4df8>), [CUDA_ERROR_INVALID_CONTEXT](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a484e9af32c1e9893ff21f0e0191a12d>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>)

###### [Deprecated](<deprecated.html#deprecated__deprecated_1_deprecated000040>)

###### Description

Returns in `*pFormat` and `*pNumChannels` the format and number of components of the CUDA array bound to the texture reference `hTexRef`. If `pFormat` or `pNumChannels` is NULL, it will be ignored.

**See also:**

[cuTexRefSetAddress](<group__CUDA__TEXREF__DEPRECATED.html#group__CUDA__TEXREF__DEPRECATED_1ga6e288992f58e7a6e3350614bc9e813b> "Binds an address as a texture reference."), [cuTexRefSetAddress2D](<group__CUDA__TEXREF__DEPRECATED.html#group__CUDA__TEXREF__DEPRECATED_1gbdec8983628f68bcde5db4b4c3f90851> "Binds an address as a 2D texture reference."), [cuTexRefSetAddressMode](<group__CUDA__TEXREF__DEPRECATED.html#group__CUDA__TEXREF__DEPRECATED_1ga45732a5c4ec291c0682fffcbaa6d393> "Sets the addressing mode for a texture reference."), [cuTexRefSetArray](<group__CUDA__TEXREF__DEPRECATED.html#group__CUDA__TEXREF__DEPRECATED_1gac3a34b4b10983433865fdadb83b9118> "Binds an array as a texture reference."), [cuTexRefSetFilterMode](<group__CUDA__TEXREF__DEPRECATED.html#group__CUDA__TEXREF__DEPRECATED_1g93819286c48db39afc253c0f10358d2e> "Sets the filtering mode for a texture reference."), [cuTexRefSetFlags](<group__CUDA__TEXREF__DEPRECATED.html#group__CUDA__TEXREF__DEPRECATED_1g9d4816a6561e1d09e0eef9f9c0cdbfa2> "Sets the flags for a texture reference."), [cuTexRefSetFormat](<group__CUDA__TEXREF__DEPRECATED.html#group__CUDA__TEXREF__DEPRECATED_1g2d57eabbd5ef6780307c008b0f4ce83d> "Sets the format for a texture reference."), [cuTexRefGetAddress](<group__CUDA__TEXREF__DEPRECATED.html#group__CUDA__TEXREF__DEPRECATED_1g56a175420c7fef8e547a66bc79671488> "Gets the address associated with a texture reference."), [cuTexRefGetAddressMode](<group__CUDA__TEXREF__DEPRECATED.html#group__CUDA__TEXREF__DEPRECATED_1ga41ceb7f8a452d59ae7e874b1c8e0c67> "Gets the addressing mode used by a texture reference."), [cuTexRefGetArray](<group__CUDA__TEXREF__DEPRECATED.html#group__CUDA__TEXREF__DEPRECATED_1g7f74aff0d999af6613dfc9aff3a21087> "Gets the array bound to a texture reference."), [cuTexRefGetFilterMode](<group__CUDA__TEXREF__DEPRECATED.html#group__CUDA__TEXREF__DEPRECATED_1g941748b72fe9c6f9767be38b8d02c95d> "Gets the filter-mode used by a texture reference."), [cuTexRefGetFlags](<group__CUDA__TEXREF__DEPRECATED.html#group__CUDA__TEXREF__DEPRECATED_1g0eb1b87656d661c4fbd4ddbbc0dd7b94> "Gets the flags used by a texture reference.")

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuTexRefGetMaxAnisotropy ( int*Â pmaxAniso, [CUtexref](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gec1e8eb9dc48ad748765d1fcc020d6b5>)Â hTexRef )


Gets the maximum anisotropy for a texture reference.

######  Parameters

`pmaxAniso`
    \- Returned maximum anisotropy
`hTexRef`
    \- Texture reference

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_DEINITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9acf52f132faf29b473cdda6061f0f44a>), [CUDA_ERROR_NOT_INITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e98feb999f0af99b4a25ab26b3866f4df8>), [CUDA_ERROR_INVALID_CONTEXT](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a484e9af32c1e9893ff21f0e0191a12d>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>)

###### [Deprecated](<deprecated.html#deprecated__deprecated_1_deprecated000044>)

###### Description

Returns the maximum anisotropy in `pmaxAniso` that's used when reading memory through the texture reference `hTexRef`.

**See also:**

[cuTexRefSetAddress](<group__CUDA__TEXREF__DEPRECATED.html#group__CUDA__TEXREF__DEPRECATED_1ga6e288992f58e7a6e3350614bc9e813b> "Binds an address as a texture reference."), [cuTexRefSetAddress2D](<group__CUDA__TEXREF__DEPRECATED.html#group__CUDA__TEXREF__DEPRECATED_1gbdec8983628f68bcde5db4b4c3f90851> "Binds an address as a 2D texture reference."), [cuTexRefSetAddressMode](<group__CUDA__TEXREF__DEPRECATED.html#group__CUDA__TEXREF__DEPRECATED_1ga45732a5c4ec291c0682fffcbaa6d393> "Sets the addressing mode for a texture reference."), [cuTexRefSetArray](<group__CUDA__TEXREF__DEPRECATED.html#group__CUDA__TEXREF__DEPRECATED_1gac3a34b4b10983433865fdadb83b9118> "Binds an array as a texture reference."), [cuTexRefSetFlags](<group__CUDA__TEXREF__DEPRECATED.html#group__CUDA__TEXREF__DEPRECATED_1g9d4816a6561e1d09e0eef9f9c0cdbfa2> "Sets the flags for a texture reference."), [cuTexRefSetFormat](<group__CUDA__TEXREF__DEPRECATED.html#group__CUDA__TEXREF__DEPRECATED_1g2d57eabbd5ef6780307c008b0f4ce83d> "Sets the format for a texture reference."), [cuTexRefGetAddress](<group__CUDA__TEXREF__DEPRECATED.html#group__CUDA__TEXREF__DEPRECATED_1g56a175420c7fef8e547a66bc79671488> "Gets the address associated with a texture reference."), [cuTexRefGetAddressMode](<group__CUDA__TEXREF__DEPRECATED.html#group__CUDA__TEXREF__DEPRECATED_1ga41ceb7f8a452d59ae7e874b1c8e0c67> "Gets the addressing mode used by a texture reference."), [cuTexRefGetArray](<group__CUDA__TEXREF__DEPRECATED.html#group__CUDA__TEXREF__DEPRECATED_1g7f74aff0d999af6613dfc9aff3a21087> "Gets the array bound to a texture reference."), [cuTexRefGetFilterMode](<group__CUDA__TEXREF__DEPRECATED.html#group__CUDA__TEXREF__DEPRECATED_1g941748b72fe9c6f9767be38b8d02c95d> "Gets the filter-mode used by a texture reference."), [cuTexRefGetFlags](<group__CUDA__TEXREF__DEPRECATED.html#group__CUDA__TEXREF__DEPRECATED_1g0eb1b87656d661c4fbd4ddbbc0dd7b94> "Gets the flags used by a texture reference."), [cuTexRefGetFormat](<group__CUDA__TEXREF__DEPRECATED.html#group__CUDA__TEXREF__DEPRECATED_1g0453d286f81825e1d503d651f8b079d8> "Gets the format used by a texture reference.")

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuTexRefGetMipmapFilterMode ( [CUfilter_mode](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g4fb799d90872f1d6cd074b4349f37c2a>)*Â pfm, [CUtexref](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gec1e8eb9dc48ad748765d1fcc020d6b5>)Â hTexRef )


Gets the mipmap filtering mode for a texture reference.

######  Parameters

`pfm`
    \- Returned mipmap filtering mode
`hTexRef`
    \- Texture reference

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_DEINITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9acf52f132faf29b473cdda6061f0f44a>), [CUDA_ERROR_NOT_INITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e98feb999f0af99b4a25ab26b3866f4df8>), [CUDA_ERROR_INVALID_CONTEXT](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a484e9af32c1e9893ff21f0e0191a12d>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>)

###### [Deprecated](<deprecated.html#deprecated__deprecated_1_deprecated000041>)

###### Description

Returns the mipmap filtering mode in `pfm` that's used when reading memory through the texture reference `hTexRef`.

**See also:**

[cuTexRefSetAddress](<group__CUDA__TEXREF__DEPRECATED.html#group__CUDA__TEXREF__DEPRECATED_1ga6e288992f58e7a6e3350614bc9e813b> "Binds an address as a texture reference."), [cuTexRefSetAddress2D](<group__CUDA__TEXREF__DEPRECATED.html#group__CUDA__TEXREF__DEPRECATED_1gbdec8983628f68bcde5db4b4c3f90851> "Binds an address as a 2D texture reference."), [cuTexRefSetAddressMode](<group__CUDA__TEXREF__DEPRECATED.html#group__CUDA__TEXREF__DEPRECATED_1ga45732a5c4ec291c0682fffcbaa6d393> "Sets the addressing mode for a texture reference."), [cuTexRefSetArray](<group__CUDA__TEXREF__DEPRECATED.html#group__CUDA__TEXREF__DEPRECATED_1gac3a34b4b10983433865fdadb83b9118> "Binds an array as a texture reference."), [cuTexRefSetFlags](<group__CUDA__TEXREF__DEPRECATED.html#group__CUDA__TEXREF__DEPRECATED_1g9d4816a6561e1d09e0eef9f9c0cdbfa2> "Sets the flags for a texture reference."), [cuTexRefSetFormat](<group__CUDA__TEXREF__DEPRECATED.html#group__CUDA__TEXREF__DEPRECATED_1g2d57eabbd5ef6780307c008b0f4ce83d> "Sets the format for a texture reference."), [cuTexRefGetAddress](<group__CUDA__TEXREF__DEPRECATED.html#group__CUDA__TEXREF__DEPRECATED_1g56a175420c7fef8e547a66bc79671488> "Gets the address associated with a texture reference."), [cuTexRefGetAddressMode](<group__CUDA__TEXREF__DEPRECATED.html#group__CUDA__TEXREF__DEPRECATED_1ga41ceb7f8a452d59ae7e874b1c8e0c67> "Gets the addressing mode used by a texture reference."), [cuTexRefGetArray](<group__CUDA__TEXREF__DEPRECATED.html#group__CUDA__TEXREF__DEPRECATED_1g7f74aff0d999af6613dfc9aff3a21087> "Gets the array bound to a texture reference."), [cuTexRefGetFilterMode](<group__CUDA__TEXREF__DEPRECATED.html#group__CUDA__TEXREF__DEPRECATED_1g941748b72fe9c6f9767be38b8d02c95d> "Gets the filter-mode used by a texture reference."), [cuTexRefGetFlags](<group__CUDA__TEXREF__DEPRECATED.html#group__CUDA__TEXREF__DEPRECATED_1g0eb1b87656d661c4fbd4ddbbc0dd7b94> "Gets the flags used by a texture reference."), [cuTexRefGetFormat](<group__CUDA__TEXREF__DEPRECATED.html#group__CUDA__TEXREF__DEPRECATED_1g0453d286f81825e1d503d651f8b079d8> "Gets the format used by a texture reference.")

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuTexRefGetMipmapLevelBias ( float*Â pbias, [CUtexref](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gec1e8eb9dc48ad748765d1fcc020d6b5>)Â hTexRef )


Gets the mipmap level bias for a texture reference.

######  Parameters

`pbias`
    \- Returned mipmap level bias
`hTexRef`
    \- Texture reference

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_DEINITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9acf52f132faf29b473cdda6061f0f44a>), [CUDA_ERROR_NOT_INITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e98feb999f0af99b4a25ab26b3866f4df8>), [CUDA_ERROR_INVALID_CONTEXT](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a484e9af32c1e9893ff21f0e0191a12d>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>)

###### [Deprecated](<deprecated.html#deprecated__deprecated_1_deprecated000042>)

###### Description

Returns the mipmap level bias in `pBias` that's added to the specified mipmap level when reading memory through the texture reference `hTexRef`.

**See also:**

[cuTexRefSetAddress](<group__CUDA__TEXREF__DEPRECATED.html#group__CUDA__TEXREF__DEPRECATED_1ga6e288992f58e7a6e3350614bc9e813b> "Binds an address as a texture reference."), [cuTexRefSetAddress2D](<group__CUDA__TEXREF__DEPRECATED.html#group__CUDA__TEXREF__DEPRECATED_1gbdec8983628f68bcde5db4b4c3f90851> "Binds an address as a 2D texture reference."), [cuTexRefSetAddressMode](<group__CUDA__TEXREF__DEPRECATED.html#group__CUDA__TEXREF__DEPRECATED_1ga45732a5c4ec291c0682fffcbaa6d393> "Sets the addressing mode for a texture reference."), [cuTexRefSetArray](<group__CUDA__TEXREF__DEPRECATED.html#group__CUDA__TEXREF__DEPRECATED_1gac3a34b4b10983433865fdadb83b9118> "Binds an array as a texture reference."), [cuTexRefSetFlags](<group__CUDA__TEXREF__DEPRECATED.html#group__CUDA__TEXREF__DEPRECATED_1g9d4816a6561e1d09e0eef9f9c0cdbfa2> "Sets the flags for a texture reference."), [cuTexRefSetFormat](<group__CUDA__TEXREF__DEPRECATED.html#group__CUDA__TEXREF__DEPRECATED_1g2d57eabbd5ef6780307c008b0f4ce83d> "Sets the format for a texture reference."), [cuTexRefGetAddress](<group__CUDA__TEXREF__DEPRECATED.html#group__CUDA__TEXREF__DEPRECATED_1g56a175420c7fef8e547a66bc79671488> "Gets the address associated with a texture reference."), [cuTexRefGetAddressMode](<group__CUDA__TEXREF__DEPRECATED.html#group__CUDA__TEXREF__DEPRECATED_1ga41ceb7f8a452d59ae7e874b1c8e0c67> "Gets the addressing mode used by a texture reference."), [cuTexRefGetArray](<group__CUDA__TEXREF__DEPRECATED.html#group__CUDA__TEXREF__DEPRECATED_1g7f74aff0d999af6613dfc9aff3a21087> "Gets the array bound to a texture reference."), [cuTexRefGetFilterMode](<group__CUDA__TEXREF__DEPRECATED.html#group__CUDA__TEXREF__DEPRECATED_1g941748b72fe9c6f9767be38b8d02c95d> "Gets the filter-mode used by a texture reference."), [cuTexRefGetFlags](<group__CUDA__TEXREF__DEPRECATED.html#group__CUDA__TEXREF__DEPRECATED_1g0eb1b87656d661c4fbd4ddbbc0dd7b94> "Gets the flags used by a texture reference."), [cuTexRefGetFormat](<group__CUDA__TEXREF__DEPRECATED.html#group__CUDA__TEXREF__DEPRECATED_1g0453d286f81825e1d503d651f8b079d8> "Gets the format used by a texture reference.")

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuTexRefGetMipmapLevelClamp ( float*Â pminMipmapLevelClamp, float*Â pmaxMipmapLevelClamp, [CUtexref](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gec1e8eb9dc48ad748765d1fcc020d6b5>)Â hTexRef )


Gets the min/max mipmap level clamps for a texture reference.

######  Parameters

`pminMipmapLevelClamp`
    \- Returned mipmap min level clamp
`pmaxMipmapLevelClamp`
    \- Returned mipmap max level clamp
`hTexRef`
    \- Texture reference

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_DEINITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9acf52f132faf29b473cdda6061f0f44a>), [CUDA_ERROR_NOT_INITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e98feb999f0af99b4a25ab26b3866f4df8>), [CUDA_ERROR_INVALID_CONTEXT](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a484e9af32c1e9893ff21f0e0191a12d>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>)

###### [Deprecated](<deprecated.html#deprecated__deprecated_1_deprecated000043>)

###### Description

Returns the min/max mipmap level clamps in `pminMipmapLevelClamp` and `pmaxMipmapLevelClamp` that's used when reading memory through the texture reference `hTexRef`.

**See also:**

[cuTexRefSetAddress](<group__CUDA__TEXREF__DEPRECATED.html#group__CUDA__TEXREF__DEPRECATED_1ga6e288992f58e7a6e3350614bc9e813b> "Binds an address as a texture reference."), [cuTexRefSetAddress2D](<group__CUDA__TEXREF__DEPRECATED.html#group__CUDA__TEXREF__DEPRECATED_1gbdec8983628f68bcde5db4b4c3f90851> "Binds an address as a 2D texture reference."), [cuTexRefSetAddressMode](<group__CUDA__TEXREF__DEPRECATED.html#group__CUDA__TEXREF__DEPRECATED_1ga45732a5c4ec291c0682fffcbaa6d393> "Sets the addressing mode for a texture reference."), [cuTexRefSetArray](<group__CUDA__TEXREF__DEPRECATED.html#group__CUDA__TEXREF__DEPRECATED_1gac3a34b4b10983433865fdadb83b9118> "Binds an array as a texture reference."), [cuTexRefSetFlags](<group__CUDA__TEXREF__DEPRECATED.html#group__CUDA__TEXREF__DEPRECATED_1g9d4816a6561e1d09e0eef9f9c0cdbfa2> "Sets the flags for a texture reference."), [cuTexRefSetFormat](<group__CUDA__TEXREF__DEPRECATED.html#group__CUDA__TEXREF__DEPRECATED_1g2d57eabbd5ef6780307c008b0f4ce83d> "Sets the format for a texture reference."), [cuTexRefGetAddress](<group__CUDA__TEXREF__DEPRECATED.html#group__CUDA__TEXREF__DEPRECATED_1g56a175420c7fef8e547a66bc79671488> "Gets the address associated with a texture reference."), [cuTexRefGetAddressMode](<group__CUDA__TEXREF__DEPRECATED.html#group__CUDA__TEXREF__DEPRECATED_1ga41ceb7f8a452d59ae7e874b1c8e0c67> "Gets the addressing mode used by a texture reference."), [cuTexRefGetArray](<group__CUDA__TEXREF__DEPRECATED.html#group__CUDA__TEXREF__DEPRECATED_1g7f74aff0d999af6613dfc9aff3a21087> "Gets the array bound to a texture reference."), [cuTexRefGetFilterMode](<group__CUDA__TEXREF__DEPRECATED.html#group__CUDA__TEXREF__DEPRECATED_1g941748b72fe9c6f9767be38b8d02c95d> "Gets the filter-mode used by a texture reference."), [cuTexRefGetFlags](<group__CUDA__TEXREF__DEPRECATED.html#group__CUDA__TEXREF__DEPRECATED_1g0eb1b87656d661c4fbd4ddbbc0dd7b94> "Gets the flags used by a texture reference."), [cuTexRefGetFormat](<group__CUDA__TEXREF__DEPRECATED.html#group__CUDA__TEXREF__DEPRECATED_1g0453d286f81825e1d503d651f8b079d8> "Gets the format used by a texture reference.")

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuTexRefGetMipmappedArray ( [CUmipmappedArray](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g96db856ab3d2940fb694ce4501d9b583>)*Â phMipmappedArray, [CUtexref](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gec1e8eb9dc48ad748765d1fcc020d6b5>)Â hTexRef )


Gets the mipmapped array bound to a texture reference.

######  Parameters

`phMipmappedArray`
    \- Returned mipmapped array
`hTexRef`
    \- Texture reference

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_DEINITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9acf52f132faf29b473cdda6061f0f44a>), [CUDA_ERROR_NOT_INITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e98feb999f0af99b4a25ab26b3866f4df8>), [CUDA_ERROR_INVALID_CONTEXT](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a484e9af32c1e9893ff21f0e0191a12d>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>)

###### [Deprecated](<deprecated.html#deprecated__deprecated_1_deprecated000037>)

###### Description

Returns in `*phMipmappedArray` the CUDA mipmapped array bound to the texture reference `hTexRef`, or returns [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>) if the texture reference is not bound to any CUDA mipmapped array.

**See also:**

[cuTexRefSetAddress](<group__CUDA__TEXREF__DEPRECATED.html#group__CUDA__TEXREF__DEPRECATED_1ga6e288992f58e7a6e3350614bc9e813b> "Binds an address as a texture reference."), [cuTexRefSetAddress2D](<group__CUDA__TEXREF__DEPRECATED.html#group__CUDA__TEXREF__DEPRECATED_1gbdec8983628f68bcde5db4b4c3f90851> "Binds an address as a 2D texture reference."), [cuTexRefSetAddressMode](<group__CUDA__TEXREF__DEPRECATED.html#group__CUDA__TEXREF__DEPRECATED_1ga45732a5c4ec291c0682fffcbaa6d393> "Sets the addressing mode for a texture reference."), [cuTexRefSetArray](<group__CUDA__TEXREF__DEPRECATED.html#group__CUDA__TEXREF__DEPRECATED_1gac3a34b4b10983433865fdadb83b9118> "Binds an array as a texture reference."), [cuTexRefSetFilterMode](<group__CUDA__TEXREF__DEPRECATED.html#group__CUDA__TEXREF__DEPRECATED_1g93819286c48db39afc253c0f10358d2e> "Sets the filtering mode for a texture reference."), [cuTexRefSetFlags](<group__CUDA__TEXREF__DEPRECATED.html#group__CUDA__TEXREF__DEPRECATED_1g9d4816a6561e1d09e0eef9f9c0cdbfa2> "Sets the flags for a texture reference."), [cuTexRefSetFormat](<group__CUDA__TEXREF__DEPRECATED.html#group__CUDA__TEXREF__DEPRECATED_1g2d57eabbd5ef6780307c008b0f4ce83d> "Sets the format for a texture reference."), [cuTexRefGetAddress](<group__CUDA__TEXREF__DEPRECATED.html#group__CUDA__TEXREF__DEPRECATED_1g56a175420c7fef8e547a66bc79671488> "Gets the address associated with a texture reference."), [cuTexRefGetAddressMode](<group__CUDA__TEXREF__DEPRECATED.html#group__CUDA__TEXREF__DEPRECATED_1ga41ceb7f8a452d59ae7e874b1c8e0c67> "Gets the addressing mode used by a texture reference."), [cuTexRefGetFilterMode](<group__CUDA__TEXREF__DEPRECATED.html#group__CUDA__TEXREF__DEPRECATED_1g941748b72fe9c6f9767be38b8d02c95d> "Gets the filter-mode used by a texture reference."), [cuTexRefGetFlags](<group__CUDA__TEXREF__DEPRECATED.html#group__CUDA__TEXREF__DEPRECATED_1g0eb1b87656d661c4fbd4ddbbc0dd7b94> "Gets the flags used by a texture reference."), [cuTexRefGetFormat](<group__CUDA__TEXREF__DEPRECATED.html#group__CUDA__TEXREF__DEPRECATED_1g0453d286f81825e1d503d651f8b079d8> "Gets the format used by a texture reference.")

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuTexRefSetAddress ( size_t*Â ByteOffset, [CUtexref](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gec1e8eb9dc48ad748765d1fcc020d6b5>)Â hTexRef, [CUdeviceptr](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g183f7b0d8ad008ea2a5fd552537ace4e>)Â dptr, size_tÂ bytes )


Binds an address as a texture reference.

######  Parameters

`ByteOffset`
    \- Returned byte offset
`hTexRef`
    \- Texture reference to bind
`dptr`
    \- Device pointer to bind
`bytes`
    \- Size of memory to bind in bytes

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_DEINITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9acf52f132faf29b473cdda6061f0f44a>), [CUDA_ERROR_NOT_INITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e98feb999f0af99b4a25ab26b3866f4df8>), [CUDA_ERROR_INVALID_CONTEXT](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a484e9af32c1e9893ff21f0e0191a12d>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>)

###### [Deprecated](<deprecated.html#deprecated__deprecated_1_deprecated000024>)

###### Description

Binds a linear address range to the texture reference `hTexRef`. Any previous address or CUDA array state associated with the texture reference is superseded by this function. Any memory previously bound to `hTexRef` is unbound.

Since the hardware enforces an alignment requirement on texture base addresses, [cuTexRefSetAddress()](<group__CUDA__TEXREF__DEPRECATED.html#group__CUDA__TEXREF__DEPRECATED_1ga6e288992f58e7a6e3350614bc9e813b> "Binds an address as a texture reference.") passes back a byte offset in `*ByteOffset` that must be applied to texture fetches in order to read from the desired memory. This offset must be divided by the texel size and passed to kernels that read from the texture so they can be applied to the tex1Dfetch() function.

If the device memory pointer was returned from [cuMemAlloc()](<group__CUDA__MEM.html#group__CUDA__MEM_1gb82d2a09844a58dd9e744dc31e8aa467> "Allocates device memory."), the offset is guaranteed to be 0 and NULL may be passed as the `ByteOffset` parameter.

The total number of elements (or texels) in the linear address range cannot exceed [CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE1D_LINEAR_WIDTH](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gge12b8a782bebe21b1ac0091bf9f4e2a3335584a4bc5128e2a5ae9a4417f5b758>). The number of elements is computed as (`bytes` / bytesPerElement), where bytesPerElement is determined from the data format and number of components set using [cuTexRefSetFormat()](<group__CUDA__TEXREF__DEPRECATED.html#group__CUDA__TEXREF__DEPRECATED_1g2d57eabbd5ef6780307c008b0f4ce83d> "Sets the format for a texture reference.").

**See also:**

[cuTexRefSetAddress2D](<group__CUDA__TEXREF__DEPRECATED.html#group__CUDA__TEXREF__DEPRECATED_1gbdec8983628f68bcde5db4b4c3f90851> "Binds an address as a 2D texture reference."), [cuTexRefSetAddressMode](<group__CUDA__TEXREF__DEPRECATED.html#group__CUDA__TEXREF__DEPRECATED_1ga45732a5c4ec291c0682fffcbaa6d393> "Sets the addressing mode for a texture reference."), [cuTexRefSetArray](<group__CUDA__TEXREF__DEPRECATED.html#group__CUDA__TEXREF__DEPRECATED_1gac3a34b4b10983433865fdadb83b9118> "Binds an array as a texture reference."), [cuTexRefSetFilterMode](<group__CUDA__TEXREF__DEPRECATED.html#group__CUDA__TEXREF__DEPRECATED_1g93819286c48db39afc253c0f10358d2e> "Sets the filtering mode for a texture reference."), [cuTexRefSetFlags](<group__CUDA__TEXREF__DEPRECATED.html#group__CUDA__TEXREF__DEPRECATED_1g9d4816a6561e1d09e0eef9f9c0cdbfa2> "Sets the flags for a texture reference."), [cuTexRefSetFormat](<group__CUDA__TEXREF__DEPRECATED.html#group__CUDA__TEXREF__DEPRECATED_1g2d57eabbd5ef6780307c008b0f4ce83d> "Sets the format for a texture reference."), [cuTexRefGetAddress](<group__CUDA__TEXREF__DEPRECATED.html#group__CUDA__TEXREF__DEPRECATED_1g56a175420c7fef8e547a66bc79671488> "Gets the address associated with a texture reference."), [cuTexRefGetAddressMode](<group__CUDA__TEXREF__DEPRECATED.html#group__CUDA__TEXREF__DEPRECATED_1ga41ceb7f8a452d59ae7e874b1c8e0c67> "Gets the addressing mode used by a texture reference."), [cuTexRefGetArray](<group__CUDA__TEXREF__DEPRECATED.html#group__CUDA__TEXREF__DEPRECATED_1g7f74aff0d999af6613dfc9aff3a21087> "Gets the array bound to a texture reference."), [cuTexRefGetFilterMode](<group__CUDA__TEXREF__DEPRECATED.html#group__CUDA__TEXREF__DEPRECATED_1g941748b72fe9c6f9767be38b8d02c95d> "Gets the filter-mode used by a texture reference."), [cuTexRefGetFlags](<group__CUDA__TEXREF__DEPRECATED.html#group__CUDA__TEXREF__DEPRECATED_1g0eb1b87656d661c4fbd4ddbbc0dd7b94> "Gets the flags used by a texture reference."), [cuTexRefGetFormat](<group__CUDA__TEXREF__DEPRECATED.html#group__CUDA__TEXREF__DEPRECATED_1g0453d286f81825e1d503d651f8b079d8> "Gets the format used by a texture reference.")

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuTexRefSetAddress2D ( [CUtexref](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gec1e8eb9dc48ad748765d1fcc020d6b5>)Â hTexRef, const [CUDA_ARRAY_DESCRIPTOR](<structCUDA__ARRAY__DESCRIPTOR__v2.html#structCUDA__ARRAY__DESCRIPTOR__v2>)*Â desc, [CUdeviceptr](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g183f7b0d8ad008ea2a5fd552537ace4e>)Â dptr, size_tÂ Pitch )


Binds an address as a 2D texture reference.

######  Parameters

`hTexRef`
    \- Texture reference to bind
`desc`
    \- Descriptor of CUDA array
`dptr`
    \- Device pointer to bind
`Pitch`
    \- Line pitch in bytes

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_DEINITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9acf52f132faf29b473cdda6061f0f44a>), [CUDA_ERROR_NOT_INITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e98feb999f0af99b4a25ab26b3866f4df8>), [CUDA_ERROR_INVALID_CONTEXT](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a484e9af32c1e9893ff21f0e0191a12d>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>)

###### [Deprecated](<deprecated.html#deprecated__deprecated_1_deprecated000025>)

###### Description

Binds a linear address range to the texture reference `hTexRef`. Any previous address or CUDA array state associated with the texture reference is superseded by this function. Any memory previously bound to `hTexRef` is unbound.

Using a tex2D() function inside a kernel requires a call to either [cuTexRefSetArray()](<group__CUDA__TEXREF__DEPRECATED.html#group__CUDA__TEXREF__DEPRECATED_1gac3a34b4b10983433865fdadb83b9118> "Binds an array as a texture reference.") to bind the corresponding texture reference to an array, or [cuTexRefSetAddress2D()](<group__CUDA__TEXREF__DEPRECATED.html#group__CUDA__TEXREF__DEPRECATED_1gbdec8983628f68bcde5db4b4c3f90851> "Binds an address as a 2D texture reference.") to bind the texture reference to linear memory.

Function calls to [cuTexRefSetFormat()](<group__CUDA__TEXREF__DEPRECATED.html#group__CUDA__TEXREF__DEPRECATED_1g2d57eabbd5ef6780307c008b0f4ce83d> "Sets the format for a texture reference.") cannot follow calls to [cuTexRefSetAddress2D()](<group__CUDA__TEXREF__DEPRECATED.html#group__CUDA__TEXREF__DEPRECATED_1gbdec8983628f68bcde5db4b4c3f90851> "Binds an address as a 2D texture reference.") for the same texture reference.

It is required that `dptr` be aligned to the appropriate hardware-specific texture alignment. You can query this value using the device attribute [CU_DEVICE_ATTRIBUTE_TEXTURE_ALIGNMENT](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gge12b8a782bebe21b1ac0091bf9f4e2a39531a2b5f533e749109e9e0189f38196>). If an unaligned `dptr` is supplied, [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>) is returned.

`Pitch` has to be aligned to the hardware-specific texture pitch alignment. This value can be queried using the device attribute [CU_DEVICE_ATTRIBUTE_TEXTURE_PITCH_ALIGNMENT](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gge12b8a782bebe21b1ac0091bf9f4e2a3551f1067be9a6187d75da5fcda7960d0>). If an unaligned `Pitch` is supplied, [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>) is returned.

Width and Height, which are specified in elements (or texels), cannot exceed [CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_LINEAR_WIDTH](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gge12b8a782bebe21b1ac0091bf9f4e2a3afe638125896be2c465876a4955d699e>) and [CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_LINEAR_HEIGHT](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gge12b8a782bebe21b1ac0091bf9f4e2a3ff1c959cba47edce2374f66f161489c4>) respectively. `Pitch`, which is specified in bytes, cannot exceed [CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_LINEAR_PITCH](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gge12b8a782bebe21b1ac0091bf9f4e2a3ad66050d059c337dd9635bfb7574f3d7>).

**See also:**

[cuTexRefSetAddress](<group__CUDA__TEXREF__DEPRECATED.html#group__CUDA__TEXREF__DEPRECATED_1ga6e288992f58e7a6e3350614bc9e813b> "Binds an address as a texture reference."), [cuTexRefSetAddressMode](<group__CUDA__TEXREF__DEPRECATED.html#group__CUDA__TEXREF__DEPRECATED_1ga45732a5c4ec291c0682fffcbaa6d393> "Sets the addressing mode for a texture reference."), [cuTexRefSetArray](<group__CUDA__TEXREF__DEPRECATED.html#group__CUDA__TEXREF__DEPRECATED_1gac3a34b4b10983433865fdadb83b9118> "Binds an array as a texture reference."), [cuTexRefSetFilterMode](<group__CUDA__TEXREF__DEPRECATED.html#group__CUDA__TEXREF__DEPRECATED_1g93819286c48db39afc253c0f10358d2e> "Sets the filtering mode for a texture reference."), [cuTexRefSetFlags](<group__CUDA__TEXREF__DEPRECATED.html#group__CUDA__TEXREF__DEPRECATED_1g9d4816a6561e1d09e0eef9f9c0cdbfa2> "Sets the flags for a texture reference."), [cuTexRefSetFormat](<group__CUDA__TEXREF__DEPRECATED.html#group__CUDA__TEXREF__DEPRECATED_1g2d57eabbd5ef6780307c008b0f4ce83d> "Sets the format for a texture reference."), [cuTexRefGetAddress](<group__CUDA__TEXREF__DEPRECATED.html#group__CUDA__TEXREF__DEPRECATED_1g56a175420c7fef8e547a66bc79671488> "Gets the address associated with a texture reference."), [cuTexRefGetAddressMode](<group__CUDA__TEXREF__DEPRECATED.html#group__CUDA__TEXREF__DEPRECATED_1ga41ceb7f8a452d59ae7e874b1c8e0c67> "Gets the addressing mode used by a texture reference."), [cuTexRefGetArray](<group__CUDA__TEXREF__DEPRECATED.html#group__CUDA__TEXREF__DEPRECATED_1g7f74aff0d999af6613dfc9aff3a21087> "Gets the array bound to a texture reference."), [cuTexRefGetFilterMode](<group__CUDA__TEXREF__DEPRECATED.html#group__CUDA__TEXREF__DEPRECATED_1g941748b72fe9c6f9767be38b8d02c95d> "Gets the filter-mode used by a texture reference."), [cuTexRefGetFlags](<group__CUDA__TEXREF__DEPRECATED.html#group__CUDA__TEXREF__DEPRECATED_1g0eb1b87656d661c4fbd4ddbbc0dd7b94> "Gets the flags used by a texture reference."), [cuTexRefGetFormat](<group__CUDA__TEXREF__DEPRECATED.html#group__CUDA__TEXREF__DEPRECATED_1g0453d286f81825e1d503d651f8b079d8> "Gets the format used by a texture reference.")

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuTexRefSetAddressMode ( [CUtexref](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gec1e8eb9dc48ad748765d1fcc020d6b5>)Â hTexRef, int Â dim, [CUaddress_mode](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc925457ee7128d6251071f6ff7608887>)Â am )


Sets the addressing mode for a texture reference.

######  Parameters

`hTexRef`
    \- Texture reference
`dim`
    \- Dimension
`am`
    \- Addressing mode to set

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_DEINITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9acf52f132faf29b473cdda6061f0f44a>), [CUDA_ERROR_NOT_INITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e98feb999f0af99b4a25ab26b3866f4df8>), [CUDA_ERROR_INVALID_CONTEXT](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a484e9af32c1e9893ff21f0e0191a12d>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>)

###### [Deprecated](<deprecated.html#deprecated__deprecated_1_deprecated000027>)

###### Description

Specifies the addressing mode `am` for the given dimension `dim` of the texture reference `hTexRef`. If `dim` is zero, the addressing mode is applied to the first parameter of the functions used to fetch from the texture; if `dim` is 1, the second, and so on. [CUaddress_mode](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc925457ee7128d6251071f6ff7608887>) is defined as:


    â   typedef enum CUaddress_mode_enum {
                [CU_TR_ADDRESS_MODE_WRAP](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc925457ee7128d6251071f6ff760888787d43274db1dfed07818895b04197fcb>) = 0,
                [CU_TR_ADDRESS_MODE_CLAMP](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc925457ee7128d6251071f6ff76088878ed20ebe21592443f61ecc06d61f32f4>) = 1,
                [CU_TR_ADDRESS_MODE_MIRROR](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc925457ee7128d6251071f6ff76088872490f71f92668604bd10d49d77d198b8>) = 2,
                [CU_TR_ADDRESS_MODE_BORDER](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc925457ee7128d6251071f6ff7608887ccee8c7882028f0865e8a2e542524fa4>) = 3
             } [CUaddress_mode](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc925457ee7128d6251071f6ff7608887>);

Note that this call has no effect if `hTexRef` is bound to linear memory. Also, if the flag, [CU_TRSF_NORMALIZED_COORDINATES](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g7a19eb49fd506ecded6e8f314298d486>), is not set, the only supported address mode is [CU_TR_ADDRESS_MODE_CLAMP](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc925457ee7128d6251071f6ff76088878ed20ebe21592443f61ecc06d61f32f4>).

**See also:**

[cuTexRefSetAddress](<group__CUDA__TEXREF__DEPRECATED.html#group__CUDA__TEXREF__DEPRECATED_1ga6e288992f58e7a6e3350614bc9e813b> "Binds an address as a texture reference."), [cuTexRefSetAddress2D](<group__CUDA__TEXREF__DEPRECATED.html#group__CUDA__TEXREF__DEPRECATED_1gbdec8983628f68bcde5db4b4c3f90851> "Binds an address as a 2D texture reference."), [cuTexRefSetArray](<group__CUDA__TEXREF__DEPRECATED.html#group__CUDA__TEXREF__DEPRECATED_1gac3a34b4b10983433865fdadb83b9118> "Binds an array as a texture reference."), [cuTexRefSetFilterMode](<group__CUDA__TEXREF__DEPRECATED.html#group__CUDA__TEXREF__DEPRECATED_1g93819286c48db39afc253c0f10358d2e> "Sets the filtering mode for a texture reference."), [cuTexRefSetFlags](<group__CUDA__TEXREF__DEPRECATED.html#group__CUDA__TEXREF__DEPRECATED_1g9d4816a6561e1d09e0eef9f9c0cdbfa2> "Sets the flags for a texture reference."), [cuTexRefSetFormat](<group__CUDA__TEXREF__DEPRECATED.html#group__CUDA__TEXREF__DEPRECATED_1g2d57eabbd5ef6780307c008b0f4ce83d> "Sets the format for a texture reference."), [cuTexRefGetAddress](<group__CUDA__TEXREF__DEPRECATED.html#group__CUDA__TEXREF__DEPRECATED_1g56a175420c7fef8e547a66bc79671488> "Gets the address associated with a texture reference."), [cuTexRefGetAddressMode](<group__CUDA__TEXREF__DEPRECATED.html#group__CUDA__TEXREF__DEPRECATED_1ga41ceb7f8a452d59ae7e874b1c8e0c67> "Gets the addressing mode used by a texture reference."), [cuTexRefGetArray](<group__CUDA__TEXREF__DEPRECATED.html#group__CUDA__TEXREF__DEPRECATED_1g7f74aff0d999af6613dfc9aff3a21087> "Gets the array bound to a texture reference."), [cuTexRefGetFilterMode](<group__CUDA__TEXREF__DEPRECATED.html#group__CUDA__TEXREF__DEPRECATED_1g941748b72fe9c6f9767be38b8d02c95d> "Gets the filter-mode used by a texture reference."), [cuTexRefGetFlags](<group__CUDA__TEXREF__DEPRECATED.html#group__CUDA__TEXREF__DEPRECATED_1g0eb1b87656d661c4fbd4ddbbc0dd7b94> "Gets the flags used by a texture reference."), [cuTexRefGetFormat](<group__CUDA__TEXREF__DEPRECATED.html#group__CUDA__TEXREF__DEPRECATED_1g0453d286f81825e1d503d651f8b079d8> "Gets the format used by a texture reference.")

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuTexRefSetArray ( [CUtexref](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gec1e8eb9dc48ad748765d1fcc020d6b5>)Â hTexRef, [CUarray](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gd550651524a56766b60f10f0e7628042>)Â hArray, unsigned int Â Flags )


Binds an array as a texture reference.

######  Parameters

`hTexRef`
    \- Texture reference to bind
`hArray`
    \- Array to bind
`Flags`
    \- Options (must be [CU_TRSA_OVERRIDE_FORMAT](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gf9f0c76f9c215b3bdeca06456bec3e68>))

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_DEINITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9acf52f132faf29b473cdda6061f0f44a>), [CUDA_ERROR_NOT_INITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e98feb999f0af99b4a25ab26b3866f4df8>), [CUDA_ERROR_INVALID_CONTEXT](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a484e9af32c1e9893ff21f0e0191a12d>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>)

###### [Deprecated](<deprecated.html#deprecated__deprecated_1_deprecated000022>)

###### Description

Binds the CUDA array `hArray` to the texture reference `hTexRef`. Any previous address or CUDA array state associated with the texture reference is superseded by this function. `Flags` must be set to [CU_TRSA_OVERRIDE_FORMAT](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gf9f0c76f9c215b3bdeca06456bec3e68>). Any CUDA array previously bound to `hTexRef` is unbound.

**See also:**

[cuTexRefSetAddress](<group__CUDA__TEXREF__DEPRECATED.html#group__CUDA__TEXREF__DEPRECATED_1ga6e288992f58e7a6e3350614bc9e813b> "Binds an address as a texture reference."), [cuTexRefSetAddress2D](<group__CUDA__TEXREF__DEPRECATED.html#group__CUDA__TEXREF__DEPRECATED_1gbdec8983628f68bcde5db4b4c3f90851> "Binds an address as a 2D texture reference."), [cuTexRefSetAddressMode](<group__CUDA__TEXREF__DEPRECATED.html#group__CUDA__TEXREF__DEPRECATED_1ga45732a5c4ec291c0682fffcbaa6d393> "Sets the addressing mode for a texture reference."), [cuTexRefSetFilterMode](<group__CUDA__TEXREF__DEPRECATED.html#group__CUDA__TEXREF__DEPRECATED_1g93819286c48db39afc253c0f10358d2e> "Sets the filtering mode for a texture reference."), [cuTexRefSetFlags](<group__CUDA__TEXREF__DEPRECATED.html#group__CUDA__TEXREF__DEPRECATED_1g9d4816a6561e1d09e0eef9f9c0cdbfa2> "Sets the flags for a texture reference."), [cuTexRefSetFormat](<group__CUDA__TEXREF__DEPRECATED.html#group__CUDA__TEXREF__DEPRECATED_1g2d57eabbd5ef6780307c008b0f4ce83d> "Sets the format for a texture reference."), [cuTexRefGetAddress](<group__CUDA__TEXREF__DEPRECATED.html#group__CUDA__TEXREF__DEPRECATED_1g56a175420c7fef8e547a66bc79671488> "Gets the address associated with a texture reference."), [cuTexRefGetAddressMode](<group__CUDA__TEXREF__DEPRECATED.html#group__CUDA__TEXREF__DEPRECATED_1ga41ceb7f8a452d59ae7e874b1c8e0c67> "Gets the addressing mode used by a texture reference."), [cuTexRefGetArray](<group__CUDA__TEXREF__DEPRECATED.html#group__CUDA__TEXREF__DEPRECATED_1g7f74aff0d999af6613dfc9aff3a21087> "Gets the array bound to a texture reference."), [cuTexRefGetFilterMode](<group__CUDA__TEXREF__DEPRECATED.html#group__CUDA__TEXREF__DEPRECATED_1g941748b72fe9c6f9767be38b8d02c95d> "Gets the filter-mode used by a texture reference."), [cuTexRefGetFlags](<group__CUDA__TEXREF__DEPRECATED.html#group__CUDA__TEXREF__DEPRECATED_1g0eb1b87656d661c4fbd4ddbbc0dd7b94> "Gets the flags used by a texture reference."), [cuTexRefGetFormat](<group__CUDA__TEXREF__DEPRECATED.html#group__CUDA__TEXREF__DEPRECATED_1g0453d286f81825e1d503d651f8b079d8> "Gets the format used by a texture reference.")

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuTexRefSetBorderColor ( [CUtexref](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gec1e8eb9dc48ad748765d1fcc020d6b5>)Â hTexRef, float*Â pBorderColor )


Sets the border color for a texture reference.

######  Parameters

`hTexRef`
    \- Texture reference
`pBorderColor`
    \- RGBA color

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_DEINITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9acf52f132faf29b473cdda6061f0f44a>), [CUDA_ERROR_NOT_INITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e98feb999f0af99b4a25ab26b3866f4df8>), [CUDA_ERROR_INVALID_CONTEXT](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a484e9af32c1e9893ff21f0e0191a12d>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>)

###### [Deprecated](<deprecated.html#deprecated__deprecated_1_deprecated000033>)

###### Description

Specifies the value of the RGBA color via the `pBorderColor` to the texture reference `hTexRef`. The color value supports only float type and holds color components in the following sequence: pBorderColor[0] holds 'R' component pBorderColor[1] holds 'G' component pBorderColor[2] holds 'B' component pBorderColor[3] holds 'A' component

Note that the color values can be set only when the Address mode is set to CU_TR_ADDRESS_MODE_BORDER using [cuTexRefSetAddressMode](<group__CUDA__TEXREF__DEPRECATED.html#group__CUDA__TEXREF__DEPRECATED_1ga45732a5c4ec291c0682fffcbaa6d393> "Sets the addressing mode for a texture reference."). Applications using integer border color values have to "reinterpret_cast" their values to float.

**See also:**

[cuTexRefSetAddressMode](<group__CUDA__TEXREF__DEPRECATED.html#group__CUDA__TEXREF__DEPRECATED_1ga45732a5c4ec291c0682fffcbaa6d393> "Sets the addressing mode for a texture reference."), [cuTexRefGetAddressMode](<group__CUDA__TEXREF__DEPRECATED.html#group__CUDA__TEXREF__DEPRECATED_1ga41ceb7f8a452d59ae7e874b1c8e0c67> "Gets the addressing mode used by a texture reference."), [cuTexRefGetBorderColor](<group__CUDA__TEXREF__DEPRECATED.html#group__CUDA__TEXREF__DEPRECATED_1g04303cad6225620089ad34ffb50caf48> "Gets the border color used by a texture reference.")

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuTexRefSetFilterMode ( [CUtexref](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gec1e8eb9dc48ad748765d1fcc020d6b5>)Â hTexRef, [CUfilter_mode](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g4fb799d90872f1d6cd074b4349f37c2a>)Â fm )


Sets the filtering mode for a texture reference.

######  Parameters

`hTexRef`
    \- Texture reference
`fm`
    \- Filtering mode to set

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_DEINITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9acf52f132faf29b473cdda6061f0f44a>), [CUDA_ERROR_NOT_INITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e98feb999f0af99b4a25ab26b3866f4df8>), [CUDA_ERROR_INVALID_CONTEXT](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a484e9af32c1e9893ff21f0e0191a12d>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>)

###### [Deprecated](<deprecated.html#deprecated__deprecated_1_deprecated000028>)

###### Description

Specifies the filtering mode `fm` to be used when reading memory through the texture reference `hTexRef`. CUfilter_mode_enum is defined as:


    â   typedef enum CUfilter_mode_enum {
                [CU_TR_FILTER_MODE_POINT](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg4fb799d90872f1d6cd074b4349f37c2ae1e747d9e41685f6b6a5b85baf43e60d>) = 0,
                [CU_TR_FILTER_MODE_LINEAR](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg4fb799d90872f1d6cd074b4349f37c2a517adfbd8a0e09592378d77ba2d922d8>) = 1
             } [CUfilter_mode](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g4fb799d90872f1d6cd074b4349f37c2a>);

Note that this call has no effect if `hTexRef` is bound to linear memory.

**See also:**

[cuTexRefSetAddress](<group__CUDA__TEXREF__DEPRECATED.html#group__CUDA__TEXREF__DEPRECATED_1ga6e288992f58e7a6e3350614bc9e813b> "Binds an address as a texture reference."), [cuTexRefSetAddress2D](<group__CUDA__TEXREF__DEPRECATED.html#group__CUDA__TEXREF__DEPRECATED_1gbdec8983628f68bcde5db4b4c3f90851> "Binds an address as a 2D texture reference."), [cuTexRefSetAddressMode](<group__CUDA__TEXREF__DEPRECATED.html#group__CUDA__TEXREF__DEPRECATED_1ga45732a5c4ec291c0682fffcbaa6d393> "Sets the addressing mode for a texture reference."), [cuTexRefSetArray](<group__CUDA__TEXREF__DEPRECATED.html#group__CUDA__TEXREF__DEPRECATED_1gac3a34b4b10983433865fdadb83b9118> "Binds an array as a texture reference."), [cuTexRefSetFlags](<group__CUDA__TEXREF__DEPRECATED.html#group__CUDA__TEXREF__DEPRECATED_1g9d4816a6561e1d09e0eef9f9c0cdbfa2> "Sets the flags for a texture reference."), [cuTexRefSetFormat](<group__CUDA__TEXREF__DEPRECATED.html#group__CUDA__TEXREF__DEPRECATED_1g2d57eabbd5ef6780307c008b0f4ce83d> "Sets the format for a texture reference."), [cuTexRefGetAddress](<group__CUDA__TEXREF__DEPRECATED.html#group__CUDA__TEXREF__DEPRECATED_1g56a175420c7fef8e547a66bc79671488> "Gets the address associated with a texture reference."), [cuTexRefGetAddressMode](<group__CUDA__TEXREF__DEPRECATED.html#group__CUDA__TEXREF__DEPRECATED_1ga41ceb7f8a452d59ae7e874b1c8e0c67> "Gets the addressing mode used by a texture reference."), [cuTexRefGetArray](<group__CUDA__TEXREF__DEPRECATED.html#group__CUDA__TEXREF__DEPRECATED_1g7f74aff0d999af6613dfc9aff3a21087> "Gets the array bound to a texture reference."), [cuTexRefGetFilterMode](<group__CUDA__TEXREF__DEPRECATED.html#group__CUDA__TEXREF__DEPRECATED_1g941748b72fe9c6f9767be38b8d02c95d> "Gets the filter-mode used by a texture reference."), [cuTexRefGetFlags](<group__CUDA__TEXREF__DEPRECATED.html#group__CUDA__TEXREF__DEPRECATED_1g0eb1b87656d661c4fbd4ddbbc0dd7b94> "Gets the flags used by a texture reference."), [cuTexRefGetFormat](<group__CUDA__TEXREF__DEPRECATED.html#group__CUDA__TEXREF__DEPRECATED_1g0453d286f81825e1d503d651f8b079d8> "Gets the format used by a texture reference.")

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuTexRefSetFlags ( [CUtexref](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gec1e8eb9dc48ad748765d1fcc020d6b5>)Â hTexRef, unsigned int Â Flags )


Sets the flags for a texture reference.

######  Parameters

`hTexRef`
    \- Texture reference
`Flags`
    \- Optional flags to set

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_DEINITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9acf52f132faf29b473cdda6061f0f44a>), [CUDA_ERROR_NOT_INITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e98feb999f0af99b4a25ab26b3866f4df8>), [CUDA_ERROR_INVALID_CONTEXT](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a484e9af32c1e9893ff21f0e0191a12d>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>)

###### [Deprecated](<deprecated.html#deprecated__deprecated_1_deprecated000034>)

###### Description

Specifies optional flags via `Flags` to specify the behavior of data returned through the texture reference `hTexRef`. The valid flags are:

  * [CU_TRSF_READ_AS_INTEGER](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g6d2387c1b5dd5bc98f5b4c51cefdf41e>), which suppresses the default behavior of having the texture promote integer data to floating point data in the range [0, 1]. Note that texture with 32-bit integer format would not be promoted, regardless of whether or not this flag is specified;

  * [CU_TRSF_NORMALIZED_COORDINATES](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g7a19eb49fd506ecded6e8f314298d486>), which suppresses the default behavior of having the texture coordinates range from [0, Dim) where Dim is the width or height of the CUDA array. Instead, the texture coordinates [0, 1.0) reference the entire breadth of the array dimension;

  * [CU_TRSF_DISABLE_TRILINEAR_OPTIMIZATION](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g9512d7fa0ed8a2da30ef6f4ccc61fa4f>), which disables any trilinear filtering optimizations. Trilinear optimizations improve texture filtering performance by allowing bilinear filtering on textures in scenarios where it can closely approximate the expected results.


**See also:**

[cuTexRefSetAddress](<group__CUDA__TEXREF__DEPRECATED.html#group__CUDA__TEXREF__DEPRECATED_1ga6e288992f58e7a6e3350614bc9e813b> "Binds an address as a texture reference."), [cuTexRefSetAddress2D](<group__CUDA__TEXREF__DEPRECATED.html#group__CUDA__TEXREF__DEPRECATED_1gbdec8983628f68bcde5db4b4c3f90851> "Binds an address as a 2D texture reference."), [cuTexRefSetAddressMode](<group__CUDA__TEXREF__DEPRECATED.html#group__CUDA__TEXREF__DEPRECATED_1ga45732a5c4ec291c0682fffcbaa6d393> "Sets the addressing mode for a texture reference."), [cuTexRefSetArray](<group__CUDA__TEXREF__DEPRECATED.html#group__CUDA__TEXREF__DEPRECATED_1gac3a34b4b10983433865fdadb83b9118> "Binds an array as a texture reference."), [cuTexRefSetFilterMode](<group__CUDA__TEXREF__DEPRECATED.html#group__CUDA__TEXREF__DEPRECATED_1g93819286c48db39afc253c0f10358d2e> "Sets the filtering mode for a texture reference."), [cuTexRefSetFormat](<group__CUDA__TEXREF__DEPRECATED.html#group__CUDA__TEXREF__DEPRECATED_1g2d57eabbd5ef6780307c008b0f4ce83d> "Sets the format for a texture reference."), [cuTexRefGetAddress](<group__CUDA__TEXREF__DEPRECATED.html#group__CUDA__TEXREF__DEPRECATED_1g56a175420c7fef8e547a66bc79671488> "Gets the address associated with a texture reference."), [cuTexRefGetAddressMode](<group__CUDA__TEXREF__DEPRECATED.html#group__CUDA__TEXREF__DEPRECATED_1ga41ceb7f8a452d59ae7e874b1c8e0c67> "Gets the addressing mode used by a texture reference."), [cuTexRefGetArray](<group__CUDA__TEXREF__DEPRECATED.html#group__CUDA__TEXREF__DEPRECATED_1g7f74aff0d999af6613dfc9aff3a21087> "Gets the array bound to a texture reference."), [cuTexRefGetFilterMode](<group__CUDA__TEXREF__DEPRECATED.html#group__CUDA__TEXREF__DEPRECATED_1g941748b72fe9c6f9767be38b8d02c95d> "Gets the filter-mode used by a texture reference."), [cuTexRefGetFlags](<group__CUDA__TEXREF__DEPRECATED.html#group__CUDA__TEXREF__DEPRECATED_1g0eb1b87656d661c4fbd4ddbbc0dd7b94> "Gets the flags used by a texture reference."), [cuTexRefGetFormat](<group__CUDA__TEXREF__DEPRECATED.html#group__CUDA__TEXREF__DEPRECATED_1g0453d286f81825e1d503d651f8b079d8> "Gets the format used by a texture reference.")

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuTexRefSetFormat ( [CUtexref](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gec1e8eb9dc48ad748765d1fcc020d6b5>)Â hTexRef, [CUarray_format](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g9b009d9a6aa4c5765c8a00289b6068f9>)Â fmt, int Â NumPackedComponents )


Sets the format for a texture reference.

######  Parameters

`hTexRef`
    \- Texture reference
`fmt`
    \- Format to set
`NumPackedComponents`
    \- Number of components per array element

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_DEINITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9acf52f132faf29b473cdda6061f0f44a>), [CUDA_ERROR_NOT_INITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e98feb999f0af99b4a25ab26b3866f4df8>), [CUDA_ERROR_INVALID_CONTEXT](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a484e9af32c1e9893ff21f0e0191a12d>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>)

###### [Deprecated](<deprecated.html#deprecated__deprecated_1_deprecated000026>)

###### Description

Specifies the format of the data to be read by the texture reference `hTexRef`. `fmt` and `NumPackedComponents` are exactly analogous to the Format and NumChannels members of the CUDA_ARRAY_DESCRIPTOR structure: They specify the format of each component and the number of components per array element.

**See also:**

[cuTexRefSetAddress](<group__CUDA__TEXREF__DEPRECATED.html#group__CUDA__TEXREF__DEPRECATED_1ga6e288992f58e7a6e3350614bc9e813b> "Binds an address as a texture reference."), [cuTexRefSetAddress2D](<group__CUDA__TEXREF__DEPRECATED.html#group__CUDA__TEXREF__DEPRECATED_1gbdec8983628f68bcde5db4b4c3f90851> "Binds an address as a 2D texture reference."), [cuTexRefSetAddressMode](<group__CUDA__TEXREF__DEPRECATED.html#group__CUDA__TEXREF__DEPRECATED_1ga45732a5c4ec291c0682fffcbaa6d393> "Sets the addressing mode for a texture reference."), [cuTexRefSetArray](<group__CUDA__TEXREF__DEPRECATED.html#group__CUDA__TEXREF__DEPRECATED_1gac3a34b4b10983433865fdadb83b9118> "Binds an array as a texture reference."), [cuTexRefSetFilterMode](<group__CUDA__TEXREF__DEPRECATED.html#group__CUDA__TEXREF__DEPRECATED_1g93819286c48db39afc253c0f10358d2e> "Sets the filtering mode for a texture reference."), [cuTexRefSetFlags](<group__CUDA__TEXREF__DEPRECATED.html#group__CUDA__TEXREF__DEPRECATED_1g9d4816a6561e1d09e0eef9f9c0cdbfa2> "Sets the flags for a texture reference."), [cuTexRefGetAddress](<group__CUDA__TEXREF__DEPRECATED.html#group__CUDA__TEXREF__DEPRECATED_1g56a175420c7fef8e547a66bc79671488> "Gets the address associated with a texture reference."), [cuTexRefGetAddressMode](<group__CUDA__TEXREF__DEPRECATED.html#group__CUDA__TEXREF__DEPRECATED_1ga41ceb7f8a452d59ae7e874b1c8e0c67> "Gets the addressing mode used by a texture reference."), [cuTexRefGetArray](<group__CUDA__TEXREF__DEPRECATED.html#group__CUDA__TEXREF__DEPRECATED_1g7f74aff0d999af6613dfc9aff3a21087> "Gets the array bound to a texture reference."), [cuTexRefGetFilterMode](<group__CUDA__TEXREF__DEPRECATED.html#group__CUDA__TEXREF__DEPRECATED_1g941748b72fe9c6f9767be38b8d02c95d> "Gets the filter-mode used by a texture reference."), [cuTexRefGetFlags](<group__CUDA__TEXREF__DEPRECATED.html#group__CUDA__TEXREF__DEPRECATED_1g0eb1b87656d661c4fbd4ddbbc0dd7b94> "Gets the flags used by a texture reference."), [cuTexRefGetFormat](<group__CUDA__TEXREF__DEPRECATED.html#group__CUDA__TEXREF__DEPRECATED_1g0453d286f81825e1d503d651f8b079d8> "Gets the format used by a texture reference."), [cudaCreateChannelDesc](<../cuda-runtime-api/group__CUDART__HIGHLEVEL.html#group__CUDART__HIGHLEVEL_1g655725c27d8ffe75accb9b531ecf2d15>)

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuTexRefSetMaxAnisotropy ( [CUtexref](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gec1e8eb9dc48ad748765d1fcc020d6b5>)Â hTexRef, unsigned int Â maxAniso )


Sets the maximum anisotropy for a texture reference.

######  Parameters

`hTexRef`
    \- Texture reference
`maxAniso`
    \- Maximum anisotropy

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_DEINITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9acf52f132faf29b473cdda6061f0f44a>), [CUDA_ERROR_NOT_INITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e98feb999f0af99b4a25ab26b3866f4df8>), [CUDA_ERROR_INVALID_CONTEXT](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a484e9af32c1e9893ff21f0e0191a12d>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>)

###### [Deprecated](<deprecated.html#deprecated__deprecated_1_deprecated000032>)

###### Description

Specifies the maximum anisotropy `maxAniso` to be used when reading memory through the texture reference `hTexRef`.

Note that this call has no effect if `hTexRef` is bound to linear memory.

**See also:**

[cuTexRefSetAddress](<group__CUDA__TEXREF__DEPRECATED.html#group__CUDA__TEXREF__DEPRECATED_1ga6e288992f58e7a6e3350614bc9e813b> "Binds an address as a texture reference."), [cuTexRefSetAddress2D](<group__CUDA__TEXREF__DEPRECATED.html#group__CUDA__TEXREF__DEPRECATED_1gbdec8983628f68bcde5db4b4c3f90851> "Binds an address as a 2D texture reference."), [cuTexRefSetAddressMode](<group__CUDA__TEXREF__DEPRECATED.html#group__CUDA__TEXREF__DEPRECATED_1ga45732a5c4ec291c0682fffcbaa6d393> "Sets the addressing mode for a texture reference."), [cuTexRefSetArray](<group__CUDA__TEXREF__DEPRECATED.html#group__CUDA__TEXREF__DEPRECATED_1gac3a34b4b10983433865fdadb83b9118> "Binds an array as a texture reference."), [cuTexRefSetFlags](<group__CUDA__TEXREF__DEPRECATED.html#group__CUDA__TEXREF__DEPRECATED_1g9d4816a6561e1d09e0eef9f9c0cdbfa2> "Sets the flags for a texture reference."), [cuTexRefSetFormat](<group__CUDA__TEXREF__DEPRECATED.html#group__CUDA__TEXREF__DEPRECATED_1g2d57eabbd5ef6780307c008b0f4ce83d> "Sets the format for a texture reference."), [cuTexRefGetAddress](<group__CUDA__TEXREF__DEPRECATED.html#group__CUDA__TEXREF__DEPRECATED_1g56a175420c7fef8e547a66bc79671488> "Gets the address associated with a texture reference."), [cuTexRefGetAddressMode](<group__CUDA__TEXREF__DEPRECATED.html#group__CUDA__TEXREF__DEPRECATED_1ga41ceb7f8a452d59ae7e874b1c8e0c67> "Gets the addressing mode used by a texture reference."), [cuTexRefGetArray](<group__CUDA__TEXREF__DEPRECATED.html#group__CUDA__TEXREF__DEPRECATED_1g7f74aff0d999af6613dfc9aff3a21087> "Gets the array bound to a texture reference."), [cuTexRefGetFilterMode](<group__CUDA__TEXREF__DEPRECATED.html#group__CUDA__TEXREF__DEPRECATED_1g941748b72fe9c6f9767be38b8d02c95d> "Gets the filter-mode used by a texture reference."), [cuTexRefGetFlags](<group__CUDA__TEXREF__DEPRECATED.html#group__CUDA__TEXREF__DEPRECATED_1g0eb1b87656d661c4fbd4ddbbc0dd7b94> "Gets the flags used by a texture reference."), [cuTexRefGetFormat](<group__CUDA__TEXREF__DEPRECATED.html#group__CUDA__TEXREF__DEPRECATED_1g0453d286f81825e1d503d651f8b079d8> "Gets the format used by a texture reference.")

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuTexRefSetMipmapFilterMode ( [CUtexref](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gec1e8eb9dc48ad748765d1fcc020d6b5>)Â hTexRef, [CUfilter_mode](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g4fb799d90872f1d6cd074b4349f37c2a>)Â fm )


Sets the mipmap filtering mode for a texture reference.

######  Parameters

`hTexRef`
    \- Texture reference
`fm`
    \- Filtering mode to set

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_DEINITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9acf52f132faf29b473cdda6061f0f44a>), [CUDA_ERROR_NOT_INITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e98feb999f0af99b4a25ab26b3866f4df8>), [CUDA_ERROR_INVALID_CONTEXT](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a484e9af32c1e9893ff21f0e0191a12d>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>)

###### [Deprecated](<deprecated.html#deprecated__deprecated_1_deprecated000029>)

###### Description

Specifies the mipmap filtering mode `fm` to be used when reading memory through the texture reference `hTexRef`. CUfilter_mode_enum is defined as:


    â   typedef enum CUfilter_mode_enum {
                [CU_TR_FILTER_MODE_POINT](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg4fb799d90872f1d6cd074b4349f37c2ae1e747d9e41685f6b6a5b85baf43e60d>) = 0,
                [CU_TR_FILTER_MODE_LINEAR](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg4fb799d90872f1d6cd074b4349f37c2a517adfbd8a0e09592378d77ba2d922d8>) = 1
             } [CUfilter_mode](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g4fb799d90872f1d6cd074b4349f37c2a>);

Note that this call has no effect if `hTexRef` is not bound to a mipmapped array.

**See also:**

[cuTexRefSetAddress](<group__CUDA__TEXREF__DEPRECATED.html#group__CUDA__TEXREF__DEPRECATED_1ga6e288992f58e7a6e3350614bc9e813b> "Binds an address as a texture reference."), [cuTexRefSetAddress2D](<group__CUDA__TEXREF__DEPRECATED.html#group__CUDA__TEXREF__DEPRECATED_1gbdec8983628f68bcde5db4b4c3f90851> "Binds an address as a 2D texture reference."), [cuTexRefSetAddressMode](<group__CUDA__TEXREF__DEPRECATED.html#group__CUDA__TEXREF__DEPRECATED_1ga45732a5c4ec291c0682fffcbaa6d393> "Sets the addressing mode for a texture reference."), [cuTexRefSetArray](<group__CUDA__TEXREF__DEPRECATED.html#group__CUDA__TEXREF__DEPRECATED_1gac3a34b4b10983433865fdadb83b9118> "Binds an array as a texture reference."), [cuTexRefSetFlags](<group__CUDA__TEXREF__DEPRECATED.html#group__CUDA__TEXREF__DEPRECATED_1g9d4816a6561e1d09e0eef9f9c0cdbfa2> "Sets the flags for a texture reference."), [cuTexRefSetFormat](<group__CUDA__TEXREF__DEPRECATED.html#group__CUDA__TEXREF__DEPRECATED_1g2d57eabbd5ef6780307c008b0f4ce83d> "Sets the format for a texture reference."), [cuTexRefGetAddress](<group__CUDA__TEXREF__DEPRECATED.html#group__CUDA__TEXREF__DEPRECATED_1g56a175420c7fef8e547a66bc79671488> "Gets the address associated with a texture reference."), [cuTexRefGetAddressMode](<group__CUDA__TEXREF__DEPRECATED.html#group__CUDA__TEXREF__DEPRECATED_1ga41ceb7f8a452d59ae7e874b1c8e0c67> "Gets the addressing mode used by a texture reference."), [cuTexRefGetArray](<group__CUDA__TEXREF__DEPRECATED.html#group__CUDA__TEXREF__DEPRECATED_1g7f74aff0d999af6613dfc9aff3a21087> "Gets the array bound to a texture reference."), [cuTexRefGetFilterMode](<group__CUDA__TEXREF__DEPRECATED.html#group__CUDA__TEXREF__DEPRECATED_1g941748b72fe9c6f9767be38b8d02c95d> "Gets the filter-mode used by a texture reference."), [cuTexRefGetFlags](<group__CUDA__TEXREF__DEPRECATED.html#group__CUDA__TEXREF__DEPRECATED_1g0eb1b87656d661c4fbd4ddbbc0dd7b94> "Gets the flags used by a texture reference."), [cuTexRefGetFormat](<group__CUDA__TEXREF__DEPRECATED.html#group__CUDA__TEXREF__DEPRECATED_1g0453d286f81825e1d503d651f8b079d8> "Gets the format used by a texture reference.")

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuTexRefSetMipmapLevelBias ( [CUtexref](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gec1e8eb9dc48ad748765d1fcc020d6b5>)Â hTexRef, float Â bias )


Sets the mipmap level bias for a texture reference.

######  Parameters

`hTexRef`
    \- Texture reference
`bias`
    \- Mipmap level bias

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_DEINITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9acf52f132faf29b473cdda6061f0f44a>), [CUDA_ERROR_NOT_INITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e98feb999f0af99b4a25ab26b3866f4df8>), [CUDA_ERROR_INVALID_CONTEXT](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a484e9af32c1e9893ff21f0e0191a12d>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>)

###### [Deprecated](<deprecated.html#deprecated__deprecated_1_deprecated000030>)

###### Description

Specifies the mipmap level bias `bias` to be added to the specified mipmap level when reading memory through the texture reference `hTexRef`.

Note that this call has no effect if `hTexRef` is not bound to a mipmapped array.

**See also:**

[cuTexRefSetAddress](<group__CUDA__TEXREF__DEPRECATED.html#group__CUDA__TEXREF__DEPRECATED_1ga6e288992f58e7a6e3350614bc9e813b> "Binds an address as a texture reference."), [cuTexRefSetAddress2D](<group__CUDA__TEXREF__DEPRECATED.html#group__CUDA__TEXREF__DEPRECATED_1gbdec8983628f68bcde5db4b4c3f90851> "Binds an address as a 2D texture reference."), [cuTexRefSetAddressMode](<group__CUDA__TEXREF__DEPRECATED.html#group__CUDA__TEXREF__DEPRECATED_1ga45732a5c4ec291c0682fffcbaa6d393> "Sets the addressing mode for a texture reference."), [cuTexRefSetArray](<group__CUDA__TEXREF__DEPRECATED.html#group__CUDA__TEXREF__DEPRECATED_1gac3a34b4b10983433865fdadb83b9118> "Binds an array as a texture reference."), [cuTexRefSetFlags](<group__CUDA__TEXREF__DEPRECATED.html#group__CUDA__TEXREF__DEPRECATED_1g9d4816a6561e1d09e0eef9f9c0cdbfa2> "Sets the flags for a texture reference."), [cuTexRefSetFormat](<group__CUDA__TEXREF__DEPRECATED.html#group__CUDA__TEXREF__DEPRECATED_1g2d57eabbd5ef6780307c008b0f4ce83d> "Sets the format for a texture reference."), [cuTexRefGetAddress](<group__CUDA__TEXREF__DEPRECATED.html#group__CUDA__TEXREF__DEPRECATED_1g56a175420c7fef8e547a66bc79671488> "Gets the address associated with a texture reference."), [cuTexRefGetAddressMode](<group__CUDA__TEXREF__DEPRECATED.html#group__CUDA__TEXREF__DEPRECATED_1ga41ceb7f8a452d59ae7e874b1c8e0c67> "Gets the addressing mode used by a texture reference."), [cuTexRefGetArray](<group__CUDA__TEXREF__DEPRECATED.html#group__CUDA__TEXREF__DEPRECATED_1g7f74aff0d999af6613dfc9aff3a21087> "Gets the array bound to a texture reference."), [cuTexRefGetFilterMode](<group__CUDA__TEXREF__DEPRECATED.html#group__CUDA__TEXREF__DEPRECATED_1g941748b72fe9c6f9767be38b8d02c95d> "Gets the filter-mode used by a texture reference."), [cuTexRefGetFlags](<group__CUDA__TEXREF__DEPRECATED.html#group__CUDA__TEXREF__DEPRECATED_1g0eb1b87656d661c4fbd4ddbbc0dd7b94> "Gets the flags used by a texture reference."), [cuTexRefGetFormat](<group__CUDA__TEXREF__DEPRECATED.html#group__CUDA__TEXREF__DEPRECATED_1g0453d286f81825e1d503d651f8b079d8> "Gets the format used by a texture reference.")

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuTexRefSetMipmapLevelClamp ( [CUtexref](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gec1e8eb9dc48ad748765d1fcc020d6b5>)Â hTexRef, float Â minMipmapLevelClamp, float Â maxMipmapLevelClamp )


Sets the mipmap min/max mipmap level clamps for a texture reference.

######  Parameters

`hTexRef`
    \- Texture reference
`minMipmapLevelClamp`
    \- Mipmap min level clamp
`maxMipmapLevelClamp`
    \- Mipmap max level clamp

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_DEINITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9acf52f132faf29b473cdda6061f0f44a>), [CUDA_ERROR_NOT_INITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e98feb999f0af99b4a25ab26b3866f4df8>), [CUDA_ERROR_INVALID_CONTEXT](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a484e9af32c1e9893ff21f0e0191a12d>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>)

###### [Deprecated](<deprecated.html#deprecated__deprecated_1_deprecated000031>)

###### Description

Specifies the min/max mipmap level clamps, `minMipmapLevelClamp` and `maxMipmapLevelClamp` respectively, to be used when reading memory through the texture reference `hTexRef`.

Note that this call has no effect if `hTexRef` is not bound to a mipmapped array.

**See also:**

[cuTexRefSetAddress](<group__CUDA__TEXREF__DEPRECATED.html#group__CUDA__TEXREF__DEPRECATED_1ga6e288992f58e7a6e3350614bc9e813b> "Binds an address as a texture reference."), [cuTexRefSetAddress2D](<group__CUDA__TEXREF__DEPRECATED.html#group__CUDA__TEXREF__DEPRECATED_1gbdec8983628f68bcde5db4b4c3f90851> "Binds an address as a 2D texture reference."), [cuTexRefSetAddressMode](<group__CUDA__TEXREF__DEPRECATED.html#group__CUDA__TEXREF__DEPRECATED_1ga45732a5c4ec291c0682fffcbaa6d393> "Sets the addressing mode for a texture reference."), [cuTexRefSetArray](<group__CUDA__TEXREF__DEPRECATED.html#group__CUDA__TEXREF__DEPRECATED_1gac3a34b4b10983433865fdadb83b9118> "Binds an array as a texture reference."), [cuTexRefSetFlags](<group__CUDA__TEXREF__DEPRECATED.html#group__CUDA__TEXREF__DEPRECATED_1g9d4816a6561e1d09e0eef9f9c0cdbfa2> "Sets the flags for a texture reference."), [cuTexRefSetFormat](<group__CUDA__TEXREF__DEPRECATED.html#group__CUDA__TEXREF__DEPRECATED_1g2d57eabbd5ef6780307c008b0f4ce83d> "Sets the format for a texture reference."), [cuTexRefGetAddress](<group__CUDA__TEXREF__DEPRECATED.html#group__CUDA__TEXREF__DEPRECATED_1g56a175420c7fef8e547a66bc79671488> "Gets the address associated with a texture reference."), [cuTexRefGetAddressMode](<group__CUDA__TEXREF__DEPRECATED.html#group__CUDA__TEXREF__DEPRECATED_1ga41ceb7f8a452d59ae7e874b1c8e0c67> "Gets the addressing mode used by a texture reference."), [cuTexRefGetArray](<group__CUDA__TEXREF__DEPRECATED.html#group__CUDA__TEXREF__DEPRECATED_1g7f74aff0d999af6613dfc9aff3a21087> "Gets the array bound to a texture reference."), [cuTexRefGetFilterMode](<group__CUDA__TEXREF__DEPRECATED.html#group__CUDA__TEXREF__DEPRECATED_1g941748b72fe9c6f9767be38b8d02c95d> "Gets the filter-mode used by a texture reference."), [cuTexRefGetFlags](<group__CUDA__TEXREF__DEPRECATED.html#group__CUDA__TEXREF__DEPRECATED_1g0eb1b87656d661c4fbd4ddbbc0dd7b94> "Gets the flags used by a texture reference."), [cuTexRefGetFormat](<group__CUDA__TEXREF__DEPRECATED.html#group__CUDA__TEXREF__DEPRECATED_1g0453d286f81825e1d503d651f8b079d8> "Gets the format used by a texture reference.")

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuTexRefSetMipmappedArray ( [CUtexref](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gec1e8eb9dc48ad748765d1fcc020d6b5>)Â hTexRef, [CUmipmappedArray](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g96db856ab3d2940fb694ce4501d9b583>)Â hMipmappedArray, unsigned int Â Flags )


Binds a mipmapped array to a texture reference.

######  Parameters

`hTexRef`
    \- Texture reference to bind
`hMipmappedArray`
    \- Mipmapped array to bind
`Flags`
    \- Options (must be [CU_TRSA_OVERRIDE_FORMAT](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gf9f0c76f9c215b3bdeca06456bec3e68>))

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_DEINITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9acf52f132faf29b473cdda6061f0f44a>), [CUDA_ERROR_NOT_INITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e98feb999f0af99b4a25ab26b3866f4df8>), [CUDA_ERROR_INVALID_CONTEXT](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a484e9af32c1e9893ff21f0e0191a12d>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>)

###### [Deprecated](<deprecated.html#deprecated__deprecated_1_deprecated000023>)

###### Description

Binds the CUDA mipmapped array `hMipmappedArray` to the texture reference `hTexRef`. Any previous address or CUDA array state associated with the texture reference is superseded by this function. `Flags` must be set to [CU_TRSA_OVERRIDE_FORMAT](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gf9f0c76f9c215b3bdeca06456bec3e68>). Any CUDA array previously bound to `hTexRef` is unbound.

**See also:**

[cuTexRefSetAddress](<group__CUDA__TEXREF__DEPRECATED.html#group__CUDA__TEXREF__DEPRECATED_1ga6e288992f58e7a6e3350614bc9e813b> "Binds an address as a texture reference."), [cuTexRefSetAddress2D](<group__CUDA__TEXREF__DEPRECATED.html#group__CUDA__TEXREF__DEPRECATED_1gbdec8983628f68bcde5db4b4c3f90851> "Binds an address as a 2D texture reference."), [cuTexRefSetAddressMode](<group__CUDA__TEXREF__DEPRECATED.html#group__CUDA__TEXREF__DEPRECATED_1ga45732a5c4ec291c0682fffcbaa6d393> "Sets the addressing mode for a texture reference."), [cuTexRefSetFilterMode](<group__CUDA__TEXREF__DEPRECATED.html#group__CUDA__TEXREF__DEPRECATED_1g93819286c48db39afc253c0f10358d2e> "Sets the filtering mode for a texture reference."), [cuTexRefSetFlags](<group__CUDA__TEXREF__DEPRECATED.html#group__CUDA__TEXREF__DEPRECATED_1g9d4816a6561e1d09e0eef9f9c0cdbfa2> "Sets the flags for a texture reference."), [cuTexRefSetFormat](<group__CUDA__TEXREF__DEPRECATED.html#group__CUDA__TEXREF__DEPRECATED_1g2d57eabbd5ef6780307c008b0f4ce83d> "Sets the format for a texture reference."), [cuTexRefGetAddress](<group__CUDA__TEXREF__DEPRECATED.html#group__CUDA__TEXREF__DEPRECATED_1g56a175420c7fef8e547a66bc79671488> "Gets the address associated with a texture reference."), [cuTexRefGetAddressMode](<group__CUDA__TEXREF__DEPRECATED.html#group__CUDA__TEXREF__DEPRECATED_1ga41ceb7f8a452d59ae7e874b1c8e0c67> "Gets the addressing mode used by a texture reference."), [cuTexRefGetArray](<group__CUDA__TEXREF__DEPRECATED.html#group__CUDA__TEXREF__DEPRECATED_1g7f74aff0d999af6613dfc9aff3a21087> "Gets the array bound to a texture reference."), [cuTexRefGetFilterMode](<group__CUDA__TEXREF__DEPRECATED.html#group__CUDA__TEXREF__DEPRECATED_1g941748b72fe9c6f9767be38b8d02c95d> "Gets the filter-mode used by a texture reference."), [cuTexRefGetFlags](<group__CUDA__TEXREF__DEPRECATED.html#group__CUDA__TEXREF__DEPRECATED_1g0eb1b87656d661c4fbd4ddbbc0dd7b94> "Gets the flags used by a texture reference."), [cuTexRefGetFormat](<group__CUDA__TEXREF__DEPRECATED.html#group__CUDA__TEXREF__DEPRECATED_1g0453d286f81825e1d503d651f8b079d8> "Gets the format used by a texture reference.")

* * *


---

# Surface Reference Management

Failed to fetch documentation.


---

# Surface Reference (Deprecated)

## 6.27.Â Surface Reference Management [DEPRECATED]

This section describes the surface reference management functions of the low-level CUDA driver application programming interface.

### Functions

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuSurfRefGetArray](<#group__CUDA__SURFREF__DEPRECATED_1g9e46d47dce3ff21a0c6485c8613e391c>) ( [CUarray](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gd550651524a56766b60f10f0e7628042>)*Â phArray, [CUsurfref](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g7b99472b414f10b2c04dd2530dc7ea76>)Â hSurfRef )
     Passes back the CUDA array bound to a surface reference.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuSurfRefSetArray](<#group__CUDA__SURFREF__DEPRECATED_1g68abcde159fa897b1dfb23387926dd66>) ( [CUsurfref](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g7b99472b414f10b2c04dd2530dc7ea76>)Â hSurfRef, [CUarray](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gd550651524a56766b60f10f0e7628042>)Â hArray, unsigned int Â Flags )
     Sets the CUDA array for a surface reference.

### Functions

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuSurfRefGetArray ( [CUarray](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gd550651524a56766b60f10f0e7628042>)*Â phArray, [CUsurfref](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g7b99472b414f10b2c04dd2530dc7ea76>)Â hSurfRef )


Passes back the CUDA array bound to a surface reference.

######  Parameters

`phArray`
    \- Surface reference handle
`hSurfRef`
    \- Surface reference handle

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_DEINITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9acf52f132faf29b473cdda6061f0f44a>), [CUDA_ERROR_NOT_INITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e98feb999f0af99b4a25ab26b3866f4df8>), [CUDA_ERROR_INVALID_CONTEXT](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a484e9af32c1e9893ff21f0e0191a12d>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>)

###### [Deprecated](<deprecated.html#deprecated__deprecated_1_deprecated000050>)

###### Description

Returns in `*phArray` the CUDA array bound to the surface reference `hSurfRef`, or returns [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>) if the surface reference is not bound to any CUDA array.

**See also:**

[cuModuleGetSurfRef](<group__CUDA__MODULE__DEPRECATED.html#group__CUDA__MODULE__DEPRECATED_1g3c9cccfdfa65d6cf492b7ce1b93a4596> "Returns a handle to a surface reference."), [cuSurfRefSetArray](<group__CUDA__SURFREF__DEPRECATED.html#group__CUDA__SURFREF__DEPRECATED_1g68abcde159fa897b1dfb23387926dd66> "Sets the CUDA array for a surface reference.")

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuSurfRefSetArray ( [CUsurfref](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g7b99472b414f10b2c04dd2530dc7ea76>)Â hSurfRef, [CUarray](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gd550651524a56766b60f10f0e7628042>)Â hArray, unsigned int Â Flags )


Sets the CUDA array for a surface reference.

######  Parameters

`hSurfRef`
    \- Surface reference handle
`hArray`
    \- CUDA array handle
`Flags`
    \- set to 0

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_DEINITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9acf52f132faf29b473cdda6061f0f44a>), [CUDA_ERROR_NOT_INITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e98feb999f0af99b4a25ab26b3866f4df8>), [CUDA_ERROR_INVALID_CONTEXT](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a484e9af32c1e9893ff21f0e0191a12d>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>)

###### [Deprecated](<deprecated.html#deprecated__deprecated_1_deprecated000049>)

###### Description

Sets the CUDA array `hArray` to be read and written by the surface reference `hSurfRef`. Any previous CUDA array state associated with the surface reference is superseded by this function. `Flags` must be set to 0. The [CUDA_ARRAY3D_SURFACE_LDST](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g7287c43cacf1ed05865d6bcad1a23cd9>) flag must have been set for the CUDA array. Any CUDA array previously bound to `hSurfRef` is unbound.

**See also:**

[cuModuleGetSurfRef](<group__CUDA__MODULE__DEPRECATED.html#group__CUDA__MODULE__DEPRECATED_1g3c9cccfdfa65d6cf492b7ce1b93a4596> "Returns a handle to a surface reference."), [cuSurfRefGetArray](<group__CUDA__SURFREF__DEPRECATED.html#group__CUDA__SURFREF__DEPRECATED_1g9e46d47dce3ff21a0c6485c8613e391c> "Passes back the CUDA array bound to a surface reference.")

* * *


---

# Texture Object Management

## 6.28.Â Texture Object Management

This section describes the texture object management functions of the low-level CUDA driver application programming interface. The texture object API is only supported on devices of compute capability 3.0 or higher.

### Functions

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuTexObjectCreate](<#group__CUDA__TEXOBJECT_1g1f6dd0f9cbf56db725b1f45aa0a7218a>) ( [CUtexObject](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g65fb6720dea73d56db0b4d4974be052d>)*Â pTexObject, const [CUDA_RESOURCE_DESC](<structCUDA__RESOURCE__DESC__v1.html#structCUDA__RESOURCE__DESC__v1>)*Â pResDesc, const [CUDA_TEXTURE_DESC](<structCUDA__TEXTURE__DESC__v1.html#structCUDA__TEXTURE__DESC__v1>)*Â pTexDesc, const [CUDA_RESOURCE_VIEW_DESC](<structCUDA__RESOURCE__VIEW__DESC__v1.html#structCUDA__RESOURCE__VIEW__DESC__v1>)*Â pResViewDesc )
     Creates a texture object.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuTexObjectDestroy](<#group__CUDA__TEXOBJECT_1gcd522ba5e2d1852aff8c0388f66247fd>) ( [CUtexObject](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g65fb6720dea73d56db0b4d4974be052d>)Â texObject )
     Destroys a texture object.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuTexObjectGetResourceDesc](<#group__CUDA__TEXOBJECT_1g0cc8eb2fa1e584d2b04d631586d0921f>) ( [CUDA_RESOURCE_DESC](<structCUDA__RESOURCE__DESC__v1.html#structCUDA__RESOURCE__DESC__v1>)*Â pResDesc, [CUtexObject](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g65fb6720dea73d56db0b4d4974be052d>)Â texObject )
     Returns a texture object's resource descriptor.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuTexObjectGetResourceViewDesc](<#group__CUDA__TEXOBJECT_1g185fa4c933a1c3a7b6aebe3e4291a37b>) ( [CUDA_RESOURCE_VIEW_DESC](<structCUDA__RESOURCE__VIEW__DESC__v1.html#structCUDA__RESOURCE__VIEW__DESC__v1>)*Â pResViewDesc, [CUtexObject](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g65fb6720dea73d56db0b4d4974be052d>)Â texObject )
     Returns a texture object's resource view descriptor.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuTexObjectGetTextureDesc](<#group__CUDA__TEXOBJECT_1g688de37b844df7313c8fce30fc912645>) ( [CUDA_TEXTURE_DESC](<structCUDA__TEXTURE__DESC__v1.html#structCUDA__TEXTURE__DESC__v1>)*Â pTexDesc, [CUtexObject](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g65fb6720dea73d56db0b4d4974be052d>)Â texObject )
     Returns a texture object's texture descriptor.

### Functions

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuTexObjectCreate ( [CUtexObject](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g65fb6720dea73d56db0b4d4974be052d>)*Â pTexObject, const [CUDA_RESOURCE_DESC](<structCUDA__RESOURCE__DESC__v1.html#structCUDA__RESOURCE__DESC__v1>)*Â pResDesc, const [CUDA_TEXTURE_DESC](<structCUDA__TEXTURE__DESC__v1.html#structCUDA__TEXTURE__DESC__v1>)*Â pTexDesc, const [CUDA_RESOURCE_VIEW_DESC](<structCUDA__RESOURCE__VIEW__DESC__v1.html#structCUDA__RESOURCE__VIEW__DESC__v1>)*Â pResViewDesc )


Creates a texture object.

######  Parameters

`pTexObject`
    \- Texture object to create
`pResDesc`
    \- Resource descriptor
`pTexDesc`
    \- Texture descriptor
`pResViewDesc`
    \- Resource view descriptor

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_DEINITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9acf52f132faf29b473cdda6061f0f44a>), [CUDA_ERROR_NOT_INITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e98feb999f0af99b4a25ab26b3866f4df8>), [CUDA_ERROR_INVALID_CONTEXT](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a484e9af32c1e9893ff21f0e0191a12d>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>)

###### Description

Creates a texture object and returns it in `pTexObject`. `pResDesc` describes the data to texture from. `pTexDesc` describes how the data should be sampled. `pResViewDesc` is an optional argument that specifies an alternate format for the data described by `pResDesc`, and also describes the subresource region to restrict access to when texturing. `pResViewDesc` can only be specified if the type of resource is a CUDA array or a CUDA mipmapped array not in a block compressed format.

Texture objects are only supported on devices of compute capability 3.0 or higher. Additionally, a texture object is an opaque value, and, as such, should only be accessed through CUDA API calls.

The CUDA_RESOURCE_DESC structure is defined as:


    â        typedef struct CUDA_RESOURCE_DESC_st
                  {
                      [CUresourcetype](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g9f0a76c9f6be437e75c8310aea5280f6>) resType;

                      union {
                          struct {
                              [CUarray](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gd550651524a56766b60f10f0e7628042>) hArray;
                          } array;
                          struct {
                              [CUmipmappedArray](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g96db856ab3d2940fb694ce4501d9b583>) hMipmappedArray;
                          } mipmap;
                          struct {
                              [CUdeviceptr](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g183f7b0d8ad008ea2a5fd552537ace4e>) devPtr;
                              [CUarray_format](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g9b009d9a6aa4c5765c8a00289b6068f9>) format;
                              unsigned int numChannels;
                              size_t sizeInBytes;
                          } linear;
                          struct {
                              [CUdeviceptr](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g183f7b0d8ad008ea2a5fd552537ace4e>) devPtr;
                              [CUarray_format](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g9b009d9a6aa4c5765c8a00289b6068f9>) format;
                              unsigned int numChannels;
                              size_t width;
                              size_t height;
                              size_t pitchInBytes;
                          } pitch2D;
                      } res;

                      unsigned int flags;
                  } [CUDA_RESOURCE_DESC](<structCUDA__RESOURCE__DESC__v1.html#structCUDA__RESOURCE__DESC__v1>);

where:

  * [CUDA_RESOURCE_DESC::resType](<structCUDA__RESOURCE__DESC__v1.html#structCUDA__RESOURCE__DESC__v1_1fe341889f4a57165e7acc0efcfc38b64>) specifies the type of resource to texture from. CUresourceType is defined as:

        â        typedef enum CUresourcetype_enum {
                          [CU_RESOURCE_TYPE_ARRAY](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg9f0a76c9f6be437e75c8310aea5280f68171f299e8447a926051e13d613d77b1>)           = 0x00,
                          [CU_RESOURCE_TYPE_MIPMAPPED_ARRAY](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg9f0a76c9f6be437e75c8310aea5280f642868e220af0309016ec733e37db7f24>) = 0x01,
                          [CU_RESOURCE_TYPE_LINEAR](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg9f0a76c9f6be437e75c8310aea5280f6ba58dadf78cb83742b2a0afe39256f87>)          = 0x02,
                          [CU_RESOURCE_TYPE_PITCH2D](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg9f0a76c9f6be437e75c8310aea5280f62ba314f961b37dd487278b6894070dea>)         = 0x03
                      } [CUresourcetype](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g9f0a76c9f6be437e75c8310aea5280f6>);


If [CUDA_RESOURCE_DESC::resType](<structCUDA__RESOURCE__DESC__v1.html#structCUDA__RESOURCE__DESC__v1_1fe341889f4a57165e7acc0efcfc38b64>) is set to [CU_RESOURCE_TYPE_ARRAY](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg9f0a76c9f6be437e75c8310aea5280f68171f299e8447a926051e13d613d77b1>), CUDA_RESOURCE_DESC::res::array::hArray must be set to a valid CUDA array handle.

If [CUDA_RESOURCE_DESC::resType](<structCUDA__RESOURCE__DESC__v1.html#structCUDA__RESOURCE__DESC__v1_1fe341889f4a57165e7acc0efcfc38b64>) is set to [CU_RESOURCE_TYPE_MIPMAPPED_ARRAY](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg9f0a76c9f6be437e75c8310aea5280f642868e220af0309016ec733e37db7f24>), CUDA_RESOURCE_DESC::res::mipmap::hMipmappedArray must be set to a valid CUDA mipmapped array handle.

If [CUDA_RESOURCE_DESC::resType](<structCUDA__RESOURCE__DESC__v1.html#structCUDA__RESOURCE__DESC__v1_1fe341889f4a57165e7acc0efcfc38b64>) is set to [CU_RESOURCE_TYPE_LINEAR](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg9f0a76c9f6be437e75c8310aea5280f6ba58dadf78cb83742b2a0afe39256f87>), CUDA_RESOURCE_DESC::res::linear::devPtr must be set to a valid device pointer, that is aligned to [CU_DEVICE_ATTRIBUTE_TEXTURE_ALIGNMENT](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gge12b8a782bebe21b1ac0091bf9f4e2a39531a2b5f533e749109e9e0189f38196>). CUDA_RESOURCE_DESC::res::linear::format and CUDA_RESOURCE_DESC::res::linear::numChannels describe the format of each component and the number of components per array element. CUDA_RESOURCE_DESC::res::linear::sizeInBytes specifies the size of the array in bytes. The total number of elements in the linear address range cannot exceed [CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE1D_LINEAR_WIDTH](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gge12b8a782bebe21b1ac0091bf9f4e2a3335584a4bc5128e2a5ae9a4417f5b758>). The number of elements is computed as (sizeInBytes / (sizeof(format) * numChannels)).

If [CUDA_RESOURCE_DESC::resType](<structCUDA__RESOURCE__DESC__v1.html#structCUDA__RESOURCE__DESC__v1_1fe341889f4a57165e7acc0efcfc38b64>) is set to [CU_RESOURCE_TYPE_PITCH2D](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg9f0a76c9f6be437e75c8310aea5280f62ba314f961b37dd487278b6894070dea>), CUDA_RESOURCE_DESC::res::pitch2D::devPtr must be set to a valid device pointer, that is aligned to [CU_DEVICE_ATTRIBUTE_TEXTURE_ALIGNMENT](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gge12b8a782bebe21b1ac0091bf9f4e2a39531a2b5f533e749109e9e0189f38196>). CUDA_RESOURCE_DESC::res::pitch2D::format and CUDA_RESOURCE_DESC::res::pitch2D::numChannels describe the format of each component and the number of components per array element. CUDA_RESOURCE_DESC::res::pitch2D::width and CUDA_RESOURCE_DESC::res::pitch2D::height specify the width and height of the array in elements, and cannot exceed [CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_LINEAR_WIDTH](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gge12b8a782bebe21b1ac0091bf9f4e2a3afe638125896be2c465876a4955d699e>) and [CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_LINEAR_HEIGHT](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gge12b8a782bebe21b1ac0091bf9f4e2a3ff1c959cba47edce2374f66f161489c4>) respectively. CUDA_RESOURCE_DESC::res::pitch2D::pitchInBytes specifies the pitch between two rows in bytes and has to be aligned to [CU_DEVICE_ATTRIBUTE_TEXTURE_PITCH_ALIGNMENT](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gge12b8a782bebe21b1ac0091bf9f4e2a3551f1067be9a6187d75da5fcda7960d0>). Pitch cannot exceed [CU_DEVICE_ATTRIBUTE_MAXIMUM_TEXTURE2D_LINEAR_PITCH](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gge12b8a782bebe21b1ac0091bf9f4e2a3ad66050d059c337dd9635bfb7574f3d7>).

  * flags must be set to zero.


The CUDA_TEXTURE_DESC struct is defined as


    â        typedef struct CUDA_TEXTURE_DESC_st {
                      [CUaddress_mode](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc925457ee7128d6251071f6ff7608887>) addressMode[3];
                      [CUfilter_mode](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g4fb799d90872f1d6cd074b4349f37c2a>) filterMode;
                      unsigned int flags;
                      unsigned int maxAnisotropy;
                      [CUfilter_mode](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g4fb799d90872f1d6cd074b4349f37c2a>) mipmapFilterMode;
                      float mipmapLevelBias;
                      float minMipmapLevelClamp;
                      float maxMipmapLevelClamp;
                  } [CUDA_TEXTURE_DESC](<structCUDA__TEXTURE__DESC__v1.html#structCUDA__TEXTURE__DESC__v1>);

where

  * [CUDA_TEXTURE_DESC::addressMode](<structCUDA__TEXTURE__DESC__v1.html#structCUDA__TEXTURE__DESC__v1_1aeb3f6fa73835433a7700b80eea8d49b>) specifies the addressing mode for each dimension of the texture data. [CUaddress_mode](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc925457ee7128d6251071f6ff7608887>) is defined as:

        â        typedef enum CUaddress_mode_enum {
                          [CU_TR_ADDRESS_MODE_WRAP](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc925457ee7128d6251071f6ff760888787d43274db1dfed07818895b04197fcb>) = 0,
                          [CU_TR_ADDRESS_MODE_CLAMP](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc925457ee7128d6251071f6ff76088878ed20ebe21592443f61ecc06d61f32f4>) = 1,
                          [CU_TR_ADDRESS_MODE_MIRROR](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc925457ee7128d6251071f6ff76088872490f71f92668604bd10d49d77d198b8>) = 2,
                          [CU_TR_ADDRESS_MODE_BORDER](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc925457ee7128d6251071f6ff7608887ccee8c7882028f0865e8a2e542524fa4>) = 3
                      } [CUaddress_mode](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc925457ee7128d6251071f6ff7608887>);

This is ignored if [CUDA_RESOURCE_DESC::resType](<structCUDA__RESOURCE__DESC__v1.html#structCUDA__RESOURCE__DESC__v1_1fe341889f4a57165e7acc0efcfc38b64>) is [CU_RESOURCE_TYPE_LINEAR](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg9f0a76c9f6be437e75c8310aea5280f6ba58dadf78cb83742b2a0afe39256f87>). Also, if the flag, [CU_TRSF_NORMALIZED_COORDINATES](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g7a19eb49fd506ecded6e8f314298d486>) is not set, the only supported address mode is [CU_TR_ADDRESS_MODE_CLAMP](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc925457ee7128d6251071f6ff76088878ed20ebe21592443f61ecc06d61f32f4>).


  * [CUDA_TEXTURE_DESC::filterMode](<structCUDA__TEXTURE__DESC__v1.html#structCUDA__TEXTURE__DESC__v1_182e92599f2f13422d8cc6cfe947e6b17>) specifies the filtering mode to be used when fetching from the texture. CUfilter_mode is defined as:

        â        typedef enum CUfilter_mode_enum {
                          [CU_TR_FILTER_MODE_POINT](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg4fb799d90872f1d6cd074b4349f37c2ae1e747d9e41685f6b6a5b85baf43e60d>) = 0,
                          [CU_TR_FILTER_MODE_LINEAR](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg4fb799d90872f1d6cd074b4349f37c2a517adfbd8a0e09592378d77ba2d922d8>) = 1
                      } [CUfilter_mode](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g4fb799d90872f1d6cd074b4349f37c2a>);

This is ignored if [CUDA_RESOURCE_DESC::resType](<structCUDA__RESOURCE__DESC__v1.html#structCUDA__RESOURCE__DESC__v1_1fe341889f4a57165e7acc0efcfc38b64>) is [CU_RESOURCE_TYPE_LINEAR](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg9f0a76c9f6be437e75c8310aea5280f6ba58dadf78cb83742b2a0afe39256f87>).


  * [CUDA_TEXTURE_DESC::flags](<structCUDA__TEXTURE__DESC__v1.html#structCUDA__TEXTURE__DESC__v1_1f50575c45ea8767561db54f4e785cabd>) can be any combination of the following:
    * [CU_TRSF_READ_AS_INTEGER](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g6d2387c1b5dd5bc98f5b4c51cefdf41e>), which suppresses the default behavior of having the texture promote integer data to floating point data in the range [0, 1]. Note that texture with 32-bit integer format would not be promoted, regardless of whether or not this flag is specified.

    * [CU_TRSF_NORMALIZED_COORDINATES](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g7a19eb49fd506ecded6e8f314298d486>), which suppresses the default behavior of having the texture coordinates range from [0, Dim) where Dim is the width or height of the CUDA array. Instead, the texture coordinates [0, 1.0) reference the entire breadth of the array dimension; Note that for CUDA mipmapped arrays, this flag has to be set.

    * [CU_TRSF_DISABLE_TRILINEAR_OPTIMIZATION](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g9512d7fa0ed8a2da30ef6f4ccc61fa4f>), which disables any trilinear filtering optimizations. Trilinear optimizations improve texture filtering performance by allowing bilinear filtering on textures in scenarios where it can closely approximate the expected results.

    * [CU_TRSF_SEAMLESS_CUBEMAP](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g8517a99047de21e19986531ad3958e22>), which enables seamless cube map filtering. This flag can only be specified if the underlying resource is a CUDA array or a CUDA mipmapped array that was created with the flag [CUDA_ARRAY3D_CUBEMAP](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gfce9ad9aa3df839571b84b47febfb7ae>). When seamless cube map filtering is enabled, texture address modes specified by [CUDA_TEXTURE_DESC::addressMode](<structCUDA__TEXTURE__DESC__v1.html#structCUDA__TEXTURE__DESC__v1_1aeb3f6fa73835433a7700b80eea8d49b>) are ignored. Instead, if the [CUDA_TEXTURE_DESC::filterMode](<structCUDA__TEXTURE__DESC__v1.html#structCUDA__TEXTURE__DESC__v1_182e92599f2f13422d8cc6cfe947e6b17>) is set to [CU_TR_FILTER_MODE_POINT](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg4fb799d90872f1d6cd074b4349f37c2ae1e747d9e41685f6b6a5b85baf43e60d>) the address mode [CU_TR_ADDRESS_MODE_CLAMP](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc925457ee7128d6251071f6ff76088878ed20ebe21592443f61ecc06d61f32f4>) will be applied for all dimensions. If the [CUDA_TEXTURE_DESC::filterMode](<structCUDA__TEXTURE__DESC__v1.html#structCUDA__TEXTURE__DESC__v1_182e92599f2f13422d8cc6cfe947e6b17>) is set to [CU_TR_FILTER_MODE_LINEAR](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg4fb799d90872f1d6cd074b4349f37c2a517adfbd8a0e09592378d77ba2d922d8>) seamless cube map filtering will be performed when sampling along the cube face borders.


  * [CUDA_TEXTURE_DESC::maxAnisotropy](<structCUDA__TEXTURE__DESC__v1.html#structCUDA__TEXTURE__DESC__v1_139035372a07e031d233445673427f34a>) specifies the maximum anisotropy ratio to be used when doing anisotropic filtering. This value will be clamped to the range [1,16].


  * [CUDA_TEXTURE_DESC::mipmapFilterMode](<structCUDA__TEXTURE__DESC__v1.html#structCUDA__TEXTURE__DESC__v1_117333d832def1d97420ddd0bce8c73ce>) specifies the filter mode when the calculated mipmap level lies between two defined mipmap levels.


  * [CUDA_TEXTURE_DESC::mipmapLevelBias](<structCUDA__TEXTURE__DESC__v1.html#structCUDA__TEXTURE__DESC__v1_10b1c10e7f1eedc4a8ab547da5741ce2d>) specifies the offset to be applied to the calculated mipmap level.


  * [CUDA_TEXTURE_DESC::minMipmapLevelClamp](<structCUDA__TEXTURE__DESC__v1.html#structCUDA__TEXTURE__DESC__v1_1bf7da8359ccf52ba8afcd28c31b48be8>) specifies the lower end of the mipmap level range to clamp access to.


  * [CUDA_TEXTURE_DESC::maxMipmapLevelClamp](<structCUDA__TEXTURE__DESC__v1.html#structCUDA__TEXTURE__DESC__v1_1149eca11ac6059979a1754bffcc6c210>) specifies the upper end of the mipmap level range to clamp access to.


The CUDA_RESOURCE_VIEW_DESC struct is defined as


    â        typedef struct CUDA_RESOURCE_VIEW_DESC_st
                  {
                      [CUresourceViewFormat](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ge7db5e5fe7c197287e55f2e97289dfcf>) format;
                      size_t width;
                      size_t height;
                      size_t depth;
                      unsigned int firstMipmapLevel;
                      unsigned int lastMipmapLevel;
                      unsigned int firstLayer;
                      unsigned int lastLayer;
                  } [CUDA_RESOURCE_VIEW_DESC](<structCUDA__RESOURCE__VIEW__DESC__v1.html#structCUDA__RESOURCE__VIEW__DESC__v1>);

where:

  * [CUDA_RESOURCE_VIEW_DESC::format](<structCUDA__RESOURCE__VIEW__DESC__v1.html#structCUDA__RESOURCE__VIEW__DESC__v1_17ee307ae64bba468ea89bb502d3f8386>) specifies how the data contained in the CUDA array or CUDA mipmapped array should be interpreted. Note that this can incur a change in size of the texture data. If the resource view format is a block compressed format, then the underlying CUDA array or CUDA mipmapped array has to have a base of format [CU_AD_FORMAT_UNSIGNED_INT32](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg9b009d9a6aa4c5765c8a00289b6068f952b891ad5d4080db0fb2e23fe71614a0>). with 2 or 4 channels, depending on the block compressed format. For ex., BC1 and BC4 require the underlying CUDA array to have a format of [CU_AD_FORMAT_UNSIGNED_INT32](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg9b009d9a6aa4c5765c8a00289b6068f952b891ad5d4080db0fb2e23fe71614a0>) with 2 channels. The other BC formats require the underlying resource to have the same base format but with 4 channels.


  * [CUDA_RESOURCE_VIEW_DESC::width](<structCUDA__RESOURCE__VIEW__DESC__v1.html#structCUDA__RESOURCE__VIEW__DESC__v1_17a74f483b2af8a73d2a1876688926e63>) specifies the new width of the texture data. If the resource view format is a block compressed format, this value has to be 4 times the original width of the resource. For non block compressed formats, this value has to be equal to that of the original resource.


  * [CUDA_RESOURCE_VIEW_DESC::height](<structCUDA__RESOURCE__VIEW__DESC__v1.html#structCUDA__RESOURCE__VIEW__DESC__v1_1a2737a7f88568199ab94d7c3f696bed3>) specifies the new height of the texture data. If the resource view format is a block compressed format, this value has to be 4 times the original height of the resource. For non block compressed formats, this value has to be equal to that of the original resource.


  * [CUDA_RESOURCE_VIEW_DESC::depth](<structCUDA__RESOURCE__VIEW__DESC__v1.html#structCUDA__RESOURCE__VIEW__DESC__v1_164ca74e2623b821d8dfbbabbc5c839f6>) specifies the new depth of the texture data. This value has to be equal to that of the original resource.


  * [CUDA_RESOURCE_VIEW_DESC::firstMipmapLevel](<structCUDA__RESOURCE__VIEW__DESC__v1.html#structCUDA__RESOURCE__VIEW__DESC__v1_134105380b4498ef2a7b6f9898f983df3>) specifies the most detailed mipmap level. This will be the new mipmap level zero. For non-mipmapped resources, this value has to be zero.[CUDA_TEXTURE_DESC::minMipmapLevelClamp](<structCUDA__TEXTURE__DESC__v1.html#structCUDA__TEXTURE__DESC__v1_1bf7da8359ccf52ba8afcd28c31b48be8>) and [CUDA_TEXTURE_DESC::maxMipmapLevelClamp](<structCUDA__TEXTURE__DESC__v1.html#structCUDA__TEXTURE__DESC__v1_1149eca11ac6059979a1754bffcc6c210>) will be relative to this value. For ex., if the firstMipmapLevel is set to 2, and a minMipmapLevelClamp of 1.2 is specified, then the actual minimum mipmap level clamp will be 3.2.


  * [CUDA_RESOURCE_VIEW_DESC::lastMipmapLevel](<structCUDA__RESOURCE__VIEW__DESC__v1.html#structCUDA__RESOURCE__VIEW__DESC__v1_16e0dc4da9bcf7518fc66aee8f0dd928e>) specifies the least detailed mipmap level. For non-mipmapped resources, this value has to be zero.


  * [CUDA_RESOURCE_VIEW_DESC::firstLayer](<structCUDA__RESOURCE__VIEW__DESC__v1.html#structCUDA__RESOURCE__VIEW__DESC__v1_154262bb560a5c52aa73dfe97077334f9>) specifies the first layer index for layered textures. This will be the new layer zero. For non-layered resources, this value has to be zero.


  * [CUDA_RESOURCE_VIEW_DESC::lastLayer](<structCUDA__RESOURCE__VIEW__DESC__v1.html#structCUDA__RESOURCE__VIEW__DESC__v1_14f2845ad9438911320a33e3fb1017964>) specifies the last layer index for layered textures. For non-layered resources, this value has to be zero.


**See also:**

[cuTexObjectDestroy](<group__CUDA__TEXOBJECT.html#group__CUDA__TEXOBJECT_1gcd522ba5e2d1852aff8c0388f66247fd> "Destroys a texture object."), [cudaCreateTextureObject](<../cuda-runtime-api/group__CUDART__TEXTURE__OBJECT.html#group__CUDART__TEXTURE__OBJECT_1g16ac75814780c3a16e4c63869feb9ad3>)

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuTexObjectDestroy ( [CUtexObject](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g65fb6720dea73d56db0b4d4974be052d>)Â texObject )


Destroys a texture object.

######  Parameters

`texObject`
    \- Texture object to destroy

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_DEINITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9acf52f132faf29b473cdda6061f0f44a>), [CUDA_ERROR_NOT_INITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e98feb999f0af99b4a25ab26b3866f4df8>), [CUDA_ERROR_INVALID_CONTEXT](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a484e9af32c1e9893ff21f0e0191a12d>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>)

###### Description

Destroys the texture object specified by `texObject`.

**See also:**

[cuTexObjectCreate](<group__CUDA__TEXOBJECT.html#group__CUDA__TEXOBJECT_1g1f6dd0f9cbf56db725b1f45aa0a7218a> "Creates a texture object."), [cudaDestroyTextureObject](<../cuda-runtime-api/group__CUDART__TEXTURE__OBJECT.html#group__CUDART__TEXTURE__OBJECT_1g27be12e215f162cc877be94390da75bb>)

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuTexObjectGetResourceDesc ( [CUDA_RESOURCE_DESC](<structCUDA__RESOURCE__DESC__v1.html#structCUDA__RESOURCE__DESC__v1>)*Â pResDesc, [CUtexObject](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g65fb6720dea73d56db0b4d4974be052d>)Â texObject )


Returns a texture object's resource descriptor.

######  Parameters

`pResDesc`
    \- Resource descriptor
`texObject`
    \- Texture object

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_DEINITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9acf52f132faf29b473cdda6061f0f44a>), [CUDA_ERROR_NOT_INITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e98feb999f0af99b4a25ab26b3866f4df8>), [CUDA_ERROR_INVALID_CONTEXT](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a484e9af32c1e9893ff21f0e0191a12d>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>)

###### Description

Returns the resource descriptor for the texture object specified by `texObject`.

**See also:**

[cuTexObjectCreate](<group__CUDA__TEXOBJECT.html#group__CUDA__TEXOBJECT_1g1f6dd0f9cbf56db725b1f45aa0a7218a> "Creates a texture object."), [cudaGetTextureObjectResourceDesc](<../cuda-runtime-api/group__CUDART__TEXTURE__OBJECT.html#group__CUDART__TEXTURE__OBJECT_1g4ac6e3f033c356ecc4ab6fb85154f066>),

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuTexObjectGetResourceViewDesc ( [CUDA_RESOURCE_VIEW_DESC](<structCUDA__RESOURCE__VIEW__DESC__v1.html#structCUDA__RESOURCE__VIEW__DESC__v1>)*Â pResViewDesc, [CUtexObject](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g65fb6720dea73d56db0b4d4974be052d>)Â texObject )


Returns a texture object's resource view descriptor.

######  Parameters

`pResViewDesc`
    \- Resource view descriptor
`texObject`
    \- Texture object

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_DEINITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9acf52f132faf29b473cdda6061f0f44a>), [CUDA_ERROR_NOT_INITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e98feb999f0af99b4a25ab26b3866f4df8>), [CUDA_ERROR_INVALID_CONTEXT](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a484e9af32c1e9893ff21f0e0191a12d>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>)

###### Description

Returns the resource view descriptor for the texture object specified by `texObject`. If no resource view was set for `texObject`, the [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>) is returned.

**See also:**

[cuTexObjectCreate](<group__CUDA__TEXOBJECT.html#group__CUDA__TEXOBJECT_1g1f6dd0f9cbf56db725b1f45aa0a7218a> "Creates a texture object."), [cudaGetTextureObjectResourceViewDesc](<../cuda-runtime-api/group__CUDART__TEXTURE__OBJECT.html#group__CUDART__TEXTURE__OBJECT_1g0332bef8105771003c64d7f09d6163fe>)

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuTexObjectGetTextureDesc ( [CUDA_TEXTURE_DESC](<structCUDA__TEXTURE__DESC__v1.html#structCUDA__TEXTURE__DESC__v1>)*Â pTexDesc, [CUtexObject](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g65fb6720dea73d56db0b4d4974be052d>)Â texObject )


Returns a texture object's texture descriptor.

######  Parameters

`pTexDesc`
    \- Texture descriptor
`texObject`
    \- Texture object

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_DEINITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9acf52f132faf29b473cdda6061f0f44a>), [CUDA_ERROR_NOT_INITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e98feb999f0af99b4a25ab26b3866f4df8>), [CUDA_ERROR_INVALID_CONTEXT](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a484e9af32c1e9893ff21f0e0191a12d>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>)

###### Description

Returns the texture descriptor for the texture object specified by `texObject`.

**See also:**

[cuTexObjectCreate](<group__CUDA__TEXOBJECT.html#group__CUDA__TEXOBJECT_1g1f6dd0f9cbf56db725b1f45aa0a7218a> "Creates a texture object."), [cudaGetTextureObjectTextureDesc](<../cuda-runtime-api/group__CUDART__TEXTURE__OBJECT.html#group__CUDART__TEXTURE__OBJECT_1g152565714ff9dce6867b6099afc05e50>)

* * *


---

# Surface Object Management

## 6.29.Â Surface Object Management

This section describes the surface object management functions of the low-level CUDA driver application programming interface. The surface object API is only supported on devices of compute capability 3.0 or higher.

### Functions

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuSurfObjectCreate](<#group__CUDA__SURFOBJECT_1g6bc972c90c9590c9f720b2754e6d079d>) ( [CUsurfObject](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g4acc685a8412637d05668e30e984e220>)*Â pSurfObject, const [CUDA_RESOURCE_DESC](<structCUDA__RESOURCE__DESC__v1.html#structCUDA__RESOURCE__DESC__v1>)*Â pResDesc )
     Creates a surface object.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuSurfObjectDestroy](<#group__CUDA__SURFOBJECT_1g4c4ec48d203d1e0bb71750ddc4d7aef3>) ( [CUsurfObject](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g4acc685a8412637d05668e30e984e220>)Â surfObject )
     Destroys a surface object.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuSurfObjectGetResourceDesc](<#group__CUDA__SURFOBJECT_1g2472b7ea0b7e74600ed3d6c244b7ba21>) ( [CUDA_RESOURCE_DESC](<structCUDA__RESOURCE__DESC__v1.html#structCUDA__RESOURCE__DESC__v1>)*Â pResDesc, [CUsurfObject](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g4acc685a8412637d05668e30e984e220>)Â surfObject )
     Returns a surface object's resource descriptor.

### Functions

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuSurfObjectCreate ( [CUsurfObject](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g4acc685a8412637d05668e30e984e220>)*Â pSurfObject, const [CUDA_RESOURCE_DESC](<structCUDA__RESOURCE__DESC__v1.html#structCUDA__RESOURCE__DESC__v1>)*Â pResDesc )


Creates a surface object.

######  Parameters

`pSurfObject`
    \- Surface object to create
`pResDesc`
    \- Resource descriptor

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_DEINITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9acf52f132faf29b473cdda6061f0f44a>), [CUDA_ERROR_NOT_INITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e98feb999f0af99b4a25ab26b3866f4df8>), [CUDA_ERROR_INVALID_CONTEXT](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a484e9af32c1e9893ff21f0e0191a12d>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>)

###### Description

Creates a surface object and returns it in `pSurfObject`. `pResDesc` describes the data to perform surface load/stores on. [CUDA_RESOURCE_DESC::resType](<structCUDA__RESOURCE__DESC__v1.html#structCUDA__RESOURCE__DESC__v1_1fe341889f4a57165e7acc0efcfc38b64>) must be [CU_RESOURCE_TYPE_ARRAY](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg9f0a76c9f6be437e75c8310aea5280f68171f299e8447a926051e13d613d77b1>) and CUDA_RESOURCE_DESC::res::array::hArray must be set to a valid CUDA array handle. [CUDA_RESOURCE_DESC::flags](<structCUDA__RESOURCE__DESC__v1.html#structCUDA__RESOURCE__DESC__v1_1857d9251dec54700bd8cd071accc3bdf>) must be set to zero.

Surface objects are only supported on devices of compute capability 3.0 or higher. Additionally, a surface object is an opaque value, and, as such, should only be accessed through CUDA API calls.

**See also:**

[cuSurfObjectDestroy](<group__CUDA__SURFOBJECT.html#group__CUDA__SURFOBJECT_1g4c4ec48d203d1e0bb71750ddc4d7aef3> "Destroys a surface object."), [cudaCreateSurfaceObject](<../cuda-runtime-api/group__CUDART__SURFACE__OBJECT.html#group__CUDART__SURFACE__OBJECT_1g958899474ab2c5f40d233b524d6c5a01>)

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuSurfObjectDestroy ( [CUsurfObject](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g4acc685a8412637d05668e30e984e220>)Â surfObject )


Destroys a surface object.

######  Parameters

`surfObject`
    \- Surface object to destroy

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_DEINITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9acf52f132faf29b473cdda6061f0f44a>), [CUDA_ERROR_NOT_INITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e98feb999f0af99b4a25ab26b3866f4df8>), [CUDA_ERROR_INVALID_CONTEXT](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a484e9af32c1e9893ff21f0e0191a12d>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>)

###### Description

Destroys the surface object specified by `surfObject`.

**See also:**

[cuSurfObjectCreate](<group__CUDA__SURFOBJECT.html#group__CUDA__SURFOBJECT_1g6bc972c90c9590c9f720b2754e6d079d> "Creates a surface object."), [cudaDestroySurfaceObject](<../cuda-runtime-api/group__CUDART__SURFACE__OBJECT.html#group__CUDART__SURFACE__OBJECT_1g9fab66c3a39b9f8f52b718eea794ad60>)

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuSurfObjectGetResourceDesc ( [CUDA_RESOURCE_DESC](<structCUDA__RESOURCE__DESC__v1.html#structCUDA__RESOURCE__DESC__v1>)*Â pResDesc, [CUsurfObject](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g4acc685a8412637d05668e30e984e220>)Â surfObject )


Returns a surface object's resource descriptor.

######  Parameters

`pResDesc`
    \- Resource descriptor
`surfObject`
    \- Surface object

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_DEINITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9acf52f132faf29b473cdda6061f0f44a>), [CUDA_ERROR_NOT_INITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e98feb999f0af99b4a25ab26b3866f4df8>), [CUDA_ERROR_INVALID_CONTEXT](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a484e9af32c1e9893ff21f0e0191a12d>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>)

###### Description

Returns the resource descriptor for the surface object specified by `surfObject`.

**See also:**

[cuSurfObjectCreate](<group__CUDA__SURFOBJECT.html#group__CUDA__SURFOBJECT_1g6bc972c90c9590c9f720b2754e6d079d> "Creates a surface object."), [cudaGetSurfaceObjectResourceDesc](<../cuda-runtime-api/group__CUDART__SURFACE__OBJECT.html#group__CUDART__SURFACE__OBJECT_1gd7087318f73ae605645d6721d51486bd>)

* * *


---

# Tensor Map Object Management

## 6.30.Â Tensor Map Object Managment

This section describes the tensor map object management functions of the low-level CUDA driver application programming interface. The tensor core API is only supported on devices of compute capability 9.0 or higher.

### Functions

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuTensorMapEncodeIm2col](<#group__CUDA__TENSOR__MEMORY_1gb14d707a18d23fc0c3e22a67ceedc15a>) ( [CUtensorMap](<structCUtensorMap.html#structCUtensorMap>)*Â tensorMap, [CUtensorMapDataType](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g42bfc19a0751d7183ee94faf9d9e779d>)Â tensorDataType, cuuint32_tÂ tensorRank, void*Â globalAddress, const cuuint64_t*Â globalDim, const cuuint64_t*Â globalStrides, const int*Â pixelBoxLowerCorner, const int*Â pixelBoxUpperCorner, cuuint32_tÂ channelsPerPixel, cuuint32_tÂ pixelsPerColumn, const cuuint32_t*Â elementStrides, [CUtensorMapInterleave](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g4af9a09e04bb8fc817eeb7be1c5cea70>)Â interleave, [CUtensorMapSwizzle](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g0bc04417bd8ce2c64d204bc3cbc25b58>)Â swizzle, [CUtensorMapL2promotion](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ga054bf4ec364bd7bd00966a03cf51fb7>)Â l2Promotion, [CUtensorMapFloatOOBfill](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gde9161158bee466f4f92be353c52480e>)Â oobFill )
     Create a tensor map descriptor object representing im2col memory region.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuTensorMapEncodeIm2colWide](<#group__CUDA__TENSOR__MEMORY_1g6c1be81856c4e311f085e33a42403444>) ( [CUtensorMap](<structCUtensorMap.html#structCUtensorMap>)*Â tensorMap, [CUtensorMapDataType](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g42bfc19a0751d7183ee94faf9d9e779d>)Â tensorDataType, cuuint32_tÂ tensorRank, void*Â globalAddress, const cuuint64_t*Â globalDim, const cuuint64_t*Â globalStrides, int Â pixelBoxLowerCornerWidth, int Â pixelBoxUpperCornerWidth, cuuint32_tÂ channelsPerPixel, cuuint32_tÂ pixelsPerColumn, const cuuint32_t*Â elementStrides, [CUtensorMapInterleave](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g4af9a09e04bb8fc817eeb7be1c5cea70>)Â interleave, [CUtensorMapIm2ColWideMode](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g13a0a2e4907f0ec36e8180230644651b>)Â mode, [CUtensorMapSwizzle](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g0bc04417bd8ce2c64d204bc3cbc25b58>)Â swizzle, [CUtensorMapL2promotion](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ga054bf4ec364bd7bd00966a03cf51fb7>)Â l2Promotion, [CUtensorMapFloatOOBfill](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gde9161158bee466f4f92be353c52480e>)Â oobFill )
     Create a tensor map descriptor object representing im2col memory region, but where the elements are exclusively loaded along the W dimension.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuTensorMapEncodeTiled](<#group__CUDA__TENSOR__MEMORY_1ga7c7d2aaac9e49294304e755e6f341d7>) ( [CUtensorMap](<structCUtensorMap.html#structCUtensorMap>)*Â tensorMap, [CUtensorMapDataType](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g42bfc19a0751d7183ee94faf9d9e779d>)Â tensorDataType, cuuint32_tÂ tensorRank, void*Â globalAddress, const cuuint64_t*Â globalDim, const cuuint64_t*Â globalStrides, const cuuint32_t*Â boxDim, const cuuint32_t*Â elementStrides, [CUtensorMapInterleave](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g4af9a09e04bb8fc817eeb7be1c5cea70>)Â interleave, [CUtensorMapSwizzle](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g0bc04417bd8ce2c64d204bc3cbc25b58>)Â swizzle, [CUtensorMapL2promotion](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ga054bf4ec364bd7bd00966a03cf51fb7>)Â l2Promotion, [CUtensorMapFloatOOBfill](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gde9161158bee466f4f92be353c52480e>)Â oobFill )
     Create a tensor map descriptor object representing tiled memory region.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuTensorMapReplaceAddress](<#group__CUDA__TENSOR__MEMORY_1g8d54c0ff5c49b1b1a9baaac6fc796db3>) ( [CUtensorMap](<structCUtensorMap.html#structCUtensorMap>)*Â tensorMap, void*Â globalAddress )
     Modify an existing tensor map descriptor with an updated global address.

### Functions

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuTensorMapEncodeIm2col ( [CUtensorMap](<structCUtensorMap.html#structCUtensorMap>)*Â tensorMap, [CUtensorMapDataType](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g42bfc19a0751d7183ee94faf9d9e779d>)Â tensorDataType, cuuint32_tÂ tensorRank, void*Â globalAddress, const cuuint64_t*Â globalDim, const cuuint64_t*Â globalStrides, const int*Â pixelBoxLowerCorner, const int*Â pixelBoxUpperCorner, cuuint32_tÂ channelsPerPixel, cuuint32_tÂ pixelsPerColumn, const cuuint32_t*Â elementStrides, [CUtensorMapInterleave](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g4af9a09e04bb8fc817eeb7be1c5cea70>)Â interleave, [CUtensorMapSwizzle](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g0bc04417bd8ce2c64d204bc3cbc25b58>)Â swizzle, [CUtensorMapL2promotion](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ga054bf4ec364bd7bd00966a03cf51fb7>)Â l2Promotion, [CUtensorMapFloatOOBfill](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gde9161158bee466f4f92be353c52480e>)Â oobFill )


Create a tensor map descriptor object representing im2col memory region.

######  Parameters

`tensorMap`
    \- Tensor map object to create
`tensorDataType`
    \- Tensor data type
`tensorRank`
    \- Dimensionality of tensor; must be at least 3
`globalAddress`
    \- Starting address of memory region described by tensor
`globalDim`
    \- Array containing tensor size (number of elements) along each of the `tensorRank` dimensions
`globalStrides`
    \- Array containing stride size (in bytes) along each of the `tensorRank` \- 1 dimensions
`pixelBoxLowerCorner`
    \- Array containing DHW dimensions of lower box corner
`pixelBoxUpperCorner`
    \- Array containing DHW dimensions of upper box corner
`channelsPerPixel`
    \- Number of channels per pixel
`pixelsPerColumn`
    \- Number of pixels per column
`elementStrides`
    \- Array containing traversal stride in each of the `tensorRank` dimensions
`interleave`
    \- Type of interleaved layout the tensor addresses
`swizzle`
    \- Bank swizzling pattern inside shared memory
`l2Promotion`
    \- L2 promotion size
`oobFill`
    \- Indicate whether zero or special NaN constant will be used to fill out-of-bound elements

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_DEINITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9acf52f132faf29b473cdda6061f0f44a>), [CUDA_ERROR_NOT_INITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e98feb999f0af99b4a25ab26b3866f4df8>), [CUDA_ERROR_INVALID_CONTEXT](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a484e9af32c1e9893ff21f0e0191a12d>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>)

###### Description

Creates a descriptor for Tensor Memory Access (TMA) object specified by the parameters describing a im2col memory layout and returns it in `tensorMap`.

Tensor map objects are only supported on devices of compute capability 9.0 or higher. Additionally, a tensor map object is an opaque value, and, as such, should only be accessed through CUDA APIs and PTX.

The parameters passed are bound to the following requirements:

  * `tensorMap` address must be aligned to 64 bytes.


  * `tensorDataType` has to be an enum from [CUtensorMapDataType](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g42bfc19a0751d7183ee94faf9d9e779d>) which is defined as:

        â    typedef enum CUtensorMapDataType_enum {
                      CU_TENSOR_MAP_DATA_TYPE_UINT8 = 0,       // 1 byte
                      CU_TENSOR_MAP_DATA_TYPE_UINT16,          // 2 bytes
                      CU_TENSOR_MAP_DATA_TYPE_UINT32,          // 4 bytes
                      CU_TENSOR_MAP_DATA_TYPE_INT32,           // 4 bytes
                      CU_TENSOR_MAP_DATA_TYPE_UINT64,          // 8 bytes
                      CU_TENSOR_MAP_DATA_TYPE_INT64,           // 8 bytes
                      CU_TENSOR_MAP_DATA_TYPE_FLOAT16,         // 2 bytes
                      CU_TENSOR_MAP_DATA_TYPE_FLOAT32,         // 4 bytes
                      CU_TENSOR_MAP_DATA_TYPE_FLOAT64,         // 8 bytes
                      CU_TENSOR_MAP_DATA_TYPE_BFLOAT16,        // 2 bytes
                      CU_TENSOR_MAP_DATA_TYPE_FLOAT32_FTZ,     // 4 bytes
                      CU_TENSOR_MAP_DATA_TYPE_TFLOAT32,        // 4 bytes
                      CU_TENSOR_MAP_DATA_TYPE_TFLOAT32_FTZ     // 4 bytes
                      CU_TENSOR_MAP_DATA_TYPE_16U4_ALIGN8B,    // 4 bits
                      CU_TENSOR_MAP_DATA_TYPE_16U4_ALIGN16B,   // 4 bits
                      CU_TENSOR_MAP_DATA_TYPE_16U6_ALIGN16B    // 6 bits
                  } [CUtensorMapDataType](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g42bfc19a0751d7183ee94faf9d9e779d>);

CU_TENSOR_MAP_DATA_TYPE_16U4_ALIGN8B copies '16 x U4' packed values to memory aligned as 8 bytes. There are no gaps between packed values. CU_TENSOR_MAP_DATA_TYPE_16U4_ALIGN16B copies '16 x U4' packed values to memory aligned as 16 bytes. There are 8 byte gaps between every 8 byte chunk of packed values. CU_TENSOR_MAP_DATA_TYPE_16U6_ALIGN16B copies '16 x U6' packed values to memory aligned as 16 bytes. There are 4 byte gaps between every 12 byte chunk of packed values.


  * `tensorRank`, which specifies the number of tensor dimensions, must be 3, 4, or 5.


  * `globalAddress`, which specifies the starting address of the memory region described, must be 16 byte aligned. The following requirements need to also be met:
    * When `interleave` is CU_TENSOR_MAP_INTERLEAVE_32B, `globalAddress` must be 32 byte aligned.

    * When `tensorDataType` is CU_TENSOR_MAP_DATA_TYPE_16U6_ALIGN16B or CU_TENSOR_MAP_DATA_TYPE_16U4_ALIGN16B, `globalAddress` must be 32 byte aligned.


  * `globalDim` array, which specifies tensor size of each of the `tensorRank` dimensions, must be non-zero and less than or equal to 2^32. Additionally, the following requirements need to be met for the packed data types:
    * When `tensorDataType` is CU_TENSOR_MAP_DATA_TYPE_16U6_ALIGN16B or CU_TENSOR_MAP_DATA_TYPE_16U4_ALIGN16B, globalDim[0] must be a multiple of 128.

    * When `tensorDataType` is CU_TENSOR_MAP_DATA_TYPE_16U4_ALIGN8B, `globalDim`[0] must be a multiple of 2.

    * Dimension for the packed data types must reflect the number of individual U# values.


  * `globalStrides` array, which specifies tensor stride of each of the lower `tensorRank` \- 1 dimensions in bytes, must be a multiple of 16 and less than 2^40. Additionally, the following requirements need to be met:
    * When `interleave` is CU_TENSOR_MAP_INTERLEAVE_32B, the strides must be a multiple of 32.

    * When `tensorDataType` is CU_TENSOR_MAP_DATA_TYPE_16U6_ALIGN16B or CU_TENSOR_MAP_DATA_TYPE_16U4_ALIGN16B, the strides must be a multiple of 32. Each following dimension specified includes previous dimension stride:

          â    globalStrides[0] = globalDim[0] * elementSizeInBytes(tensorDataType) + padding[0];
                    for (i = 1; i < tensorRank - 1; i++)
                        globalStrides[i] = globalStrides[i â 1] * (globalDim[i] + padding[i]);
                        assert(globalStrides[i] >= globalDim[i]);


  * `pixelBoxLowerCorner` array specifies the coordinate offsets {D, H, W} of the bounding box from top/left/front corner. The number of offsets and their precision depend on the tensor dimensionality:
    * When `tensorRank` is 3, one signed offset within range [-32768, 32767] is supported.

    * When `tensorRank` is 4, two signed offsets each within range [-128, 127] are supported.

    * When `tensorRank` is 5, three offsets each within range [-16, 15] are supported.


  * `pixelBoxUpperCorner` array specifies the coordinate offsets {D, H, W} of the bounding box from bottom/right/back corner. The number of offsets and their precision depend on the tensor dimensionality:
    * When `tensorRank` is 3, one signed offset within range [-32768, 32767] is supported.

    * When `tensorRank` is 4, two signed offsets each within range [-128, 127] are supported.

    * When `tensorRank` is 5, three offsets each within range [-16, 15] are supported. The bounding box specified by `pixelBoxLowerCorner` and `pixelBoxUpperCorner` must have non-zero area.


  * `channelsPerPixel`, which specifies the number of elements which must be accessed along C dimension, must be less than or equal to 256. Additionally, when `tensorDataType` is CU_TENSOR_MAP_DATA_TYPE_16U6_ALIGN16B or CU_TENSOR_MAP_DATA_TYPE_16U4_ALIGN16B, `channelsPerPixel` must be 128.


  * `pixelsPerColumn`, which specifies the number of elements that must be accessed along the {N, D, H, W} dimensions, must be less than or equal to 1024.


  * `elementStrides` array, which specifies the iteration step along each of the `tensorRank` dimensions, must be non-zero and less than or equal to 8. Note that when `interleave` is CU_TENSOR_MAP_INTERLEAVE_NONE, the first element of this array is ignored since TMA doesnât support the stride for dimension zero. When all elements of the `elementStrides` array are one, `boxDim` specifies the number of elements to load. However, if `elementStrides`[i] is not equal to one for some `i`, then TMA loads ceil( `boxDim`[i] / `elementStrides`[i]) number of elements along i-th dimension. To load N elements along i-th dimension, `boxDim`[i] must be set to N * `elementStrides`[i].


  * `interleave` specifies the interleaved layout of type [CUtensorMapInterleave](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g4af9a09e04bb8fc817eeb7be1c5cea70>), which is defined as:

        â    typedef enum CUtensorMapInterleave_enum {
                      CU_TENSOR_MAP_INTERLEAVE_NONE = 0,
                      CU_TENSOR_MAP_INTERLEAVE_16B,
                      CU_TENSOR_MAP_INTERLEAVE_32B
                  } [CUtensorMapInterleave](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g4af9a09e04bb8fc817eeb7be1c5cea70>);

TMA supports interleaved layouts like NC/8HWC8 where C8 utilizes 16 bytes in memory assuming 2 byte per channel or NC/16HWC16 where C16 uses 32 bytes. When `interleave` is CU_TENSOR_MAP_INTERLEAVE_NONE and `swizzle` is not CU_TENSOR_MAP_SWIZZLE_NONE, the bounding box inner dimension (computed as `channelsPerPixel` multiplied by element size in bytes derived from `tensorDataType`) must be less than or equal to the swizzle size.
    * CU_TENSOR_MAP_SWIZZLE_32B requires the bounding box inner dimension to be <= 32.

    * CU_TENSOR_MAP_SWIZZLE_64B requires the bounding box inner dimension to be <= 64.

    * CU_TENSOR_MAP_SWIZZLE_128B* require the bounding box inner dimension to be <= 128. Additionally, `tensorDataType` of CU_TENSOR_MAP_DATA_TYPE_16U6_ALIGN16B requires `interleave` to be CU_TENSOR_MAP_INTERLEAVE_NONE.


  * `swizzle`, which specifies the shared memory bank swizzling pattern, has to be of type [CUtensorMapSwizzle](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g0bc04417bd8ce2c64d204bc3cbc25b58>) which is defined as:

        â    typedef enum CUtensorMapSwizzle_enum {
                      CU_TENSOR_MAP_SWIZZLE_NONE = 0,
                      CU_TENSOR_MAP_SWIZZLE_32B,                   // Swizzle 16B chunks within 32B  span
                      CU_TENSOR_MAP_SWIZZLE_64B,                   // Swizzle 16B chunks within 64B  span
                      CU_TENSOR_MAP_SWIZZLE_128B,                  // Swizzle 16B chunks within 128B span
                      CU_TENSOR_MAP_SWIZZLE_128B_ATOM_32B,         // Swizzle 32B chunks within 128B span
                      CU_TENSOR_MAP_SWIZZLE_128B_ATOM_32B_FLIP_8B, // Swizzle 32B chunks within 128B span, additionally swap lower 8B with upper 8B within each 16B for every alternate row
                      CU_TENSOR_MAP_SWIZZLE_128B_ATOM_64B          // Swizzle 64B chunks within 128B span
                  } [CUtensorMapSwizzle](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g0bc04417bd8ce2c64d204bc3cbc25b58>);

Data are organized in a specific order in global memory; however, this may not match the order in which the application accesses data in shared memory. This difference in data organization may cause bank conflicts when shared memory is accessed. In order to avoid this problem, data can be loaded to shared memory with shuffling across shared memory banks. When `interleave` is CU_TENSOR_MAP_INTERLEAVE_32B, `swizzle` must be CU_TENSOR_MAP_SWIZZLE_32B. Other interleave modes can have any swizzling pattern. When the `tensorDataType` is CU_TENSOR_MAP_DATA_TYPE_16U6_ALIGN16B, only the following swizzle modes are supported:
    * CU_TENSOR_MAP_SWIZZLE_NONE (Load & Store)

    * CU_TENSOR_MAP_SWIZZLE_128B (Load & Store)

    * CU_TENSOR_MAP_SWIZZLE_128B_ATOM_32B (Load & Store)

    * CU_TENSOR_MAP_SWIZZLE_128B_ATOM_64B (Store only) When the `tensorDataType` is CU_TENSOR_MAP_DATA_TYPE_16U4_ALIGN16B, only the following swizzle modes are supported:

    * CU_TENSOR_MAP_SWIZZLE_NONE (Load only)

    * CU_TENSOR_MAP_SWIZZLE_128B (Load only)

    * CU_TENSOR_MAP_SWIZZLE_128B_ATOM_32B (Load only)


  * `l2Promotion` specifies L2 fetch size which indicates the byte granularity at which L2 requests are filled from DRAM. It must be of type [CUtensorMapL2promotion](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ga054bf4ec364bd7bd00966a03cf51fb7>), which is defined as:

        â    typedef enum CUtensorMapL2promotion_enum {
                      CU_TENSOR_MAP_L2_PROMOTION_NONE = 0,
                      CU_TENSOR_MAP_L2_PROMOTION_L2_64B,
                      CU_TENSOR_MAP_L2_PROMOTION_L2_128B,
                      CU_TENSOR_MAP_L2_PROMOTION_L2_256B
                  } [CUtensorMapL2promotion](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ga054bf4ec364bd7bd00966a03cf51fb7>);


  * `oobFill`, which indicates whether zero or a special NaN constant should be used to fill out-of-bound elements, must be of type [CUtensorMapFloatOOBfill](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gde9161158bee466f4f92be353c52480e>) which is defined as:

        â    typedef enum CUtensorMapFloatOOBfill_enum {
                      CU_TENSOR_MAP_FLOAT_OOB_FILL_NONE = 0,
                      CU_TENSOR_MAP_FLOAT_OOB_FILL_NAN_REQUEST_ZERO_FMA
                  } [CUtensorMapFloatOOBfill](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gde9161158bee466f4f92be353c52480e>);

Note that CU_TENSOR_MAP_FLOAT_OOB_FILL_NAN_REQUEST_ZERO_FMA can only be used when `tensorDataType` represents a floating-point data type, and when `tensorDataType` is not CU_TENSOR_MAP_DATA_TYPE_16U4_ALIGN8B, CU_TENSOR_MAP_DATA_TYPE_16U4_ALIGN16B, and CU_TENSOR_MAP_DATA_TYPE_16U6_ALIGN16B.


**See also:**

[cuTensorMapEncodeTiled](<group__CUDA__TENSOR__MEMORY.html#group__CUDA__TENSOR__MEMORY_1ga7c7d2aaac9e49294304e755e6f341d7> "Create a tensor map descriptor object representing tiled memory region."), [cuTensorMapEncodeIm2colWide](<group__CUDA__TENSOR__MEMORY.html#group__CUDA__TENSOR__MEMORY_1g6c1be81856c4e311f085e33a42403444> "Create a tensor map descriptor object representing im2col memory region, but where the elements are exclusively loaded along the W dimension."), [cuTensorMapReplaceAddress](<group__CUDA__TENSOR__MEMORY.html#group__CUDA__TENSOR__MEMORY_1g8d54c0ff5c49b1b1a9baaac6fc796db3> "Modify an existing tensor map descriptor with an updated global address.")

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuTensorMapEncodeIm2colWide ( [CUtensorMap](<structCUtensorMap.html#structCUtensorMap>)*Â tensorMap, [CUtensorMapDataType](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g42bfc19a0751d7183ee94faf9d9e779d>)Â tensorDataType, cuuint32_tÂ tensorRank, void*Â globalAddress, const cuuint64_t*Â globalDim, const cuuint64_t*Â globalStrides, int Â pixelBoxLowerCornerWidth, int Â pixelBoxUpperCornerWidth, cuuint32_tÂ channelsPerPixel, cuuint32_tÂ pixelsPerColumn, const cuuint32_t*Â elementStrides, [CUtensorMapInterleave](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g4af9a09e04bb8fc817eeb7be1c5cea70>)Â interleave, [CUtensorMapIm2ColWideMode](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g13a0a2e4907f0ec36e8180230644651b>)Â mode, [CUtensorMapSwizzle](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g0bc04417bd8ce2c64d204bc3cbc25b58>)Â swizzle, [CUtensorMapL2promotion](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ga054bf4ec364bd7bd00966a03cf51fb7>)Â l2Promotion, [CUtensorMapFloatOOBfill](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gde9161158bee466f4f92be353c52480e>)Â oobFill )


Create a tensor map descriptor object representing im2col memory region, but where the elements are exclusively loaded along the W dimension.

######  Parameters

`tensorMap`
    \- Tensor map object to create
`tensorDataType`
    \- Tensor data type
`tensorRank`
    \- Dimensionality of tensor; must be at least 3
`globalAddress`
    \- Starting address of memory region described by tensor
`globalDim`
    \- Array containing tensor size (number of elements) along each of the `tensorRank` dimensions
`globalStrides`
    \- Array containing stride size (in bytes) along each of the `tensorRank` \- 1 dimensions
`pixelBoxLowerCornerWidth`
    \- Width offset of left box corner
`pixelBoxUpperCornerWidth`
    \- Width offset of right box corner
`channelsPerPixel`
    \- Number of channels per pixel
`pixelsPerColumn`
    \- Number of pixels per column
`elementStrides`
    \- Array containing traversal stride in each of the `tensorRank` dimensions
`interleave`
    \- Type of interleaved layout the tensor addresses
`mode`
    \- W or W128 mode
`swizzle`
    \- Bank swizzling pattern inside shared memory
`l2Promotion`
    \- L2 promotion size
`oobFill`
    \- Indicate whether zero or special NaN constant will be used to fill out-of-bound elements

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_DEINITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9acf52f132faf29b473cdda6061f0f44a>), [CUDA_ERROR_NOT_INITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e98feb999f0af99b4a25ab26b3866f4df8>), [CUDA_ERROR_INVALID_CONTEXT](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a484e9af32c1e9893ff21f0e0191a12d>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>)

###### Description

Creates a descriptor for Tensor Memory Access (TMA) object specified by the parameters describing a im2col memory layout and where the row is always loaded along the W dimensuin and returns it in `tensorMap`. This assumes the tensor layout in memory is either NDHWC, NHWC, or NWC.

This API is only supported on devices of compute capability 10.0 or higher. Additionally, a tensor map object is an opaque value, and, as such, should only be accessed through CUDA APIs and PTX.

The parameters passed are bound to the following requirements:

  * `tensorMap` address must be aligned to 64 bytes.


  * `tensorDataType` has to be an enum from [CUtensorMapDataType](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g42bfc19a0751d7183ee94faf9d9e779d>) which is defined as:

        â    typedef enum CUtensorMapDataType_enum {
                      CU_TENSOR_MAP_DATA_TYPE_UINT8 = 0,       // 1 byte
                      CU_TENSOR_MAP_DATA_TYPE_UINT16,          // 2 bytes
                      CU_TENSOR_MAP_DATA_TYPE_UINT32,          // 4 bytes
                      CU_TENSOR_MAP_DATA_TYPE_INT32,           // 4 bytes
                      CU_TENSOR_MAP_DATA_TYPE_UINT64,          // 8 bytes
                      CU_TENSOR_MAP_DATA_TYPE_INT64,           // 8 bytes
                      CU_TENSOR_MAP_DATA_TYPE_FLOAT16,         // 2 bytes
                      CU_TENSOR_MAP_DATA_TYPE_FLOAT32,         // 4 bytes
                      CU_TENSOR_MAP_DATA_TYPE_FLOAT64,         // 8 bytes
                      CU_TENSOR_MAP_DATA_TYPE_BFLOAT16,        // 2 bytes
                      CU_TENSOR_MAP_DATA_TYPE_FLOAT32_FTZ,     // 4 bytes
                      CU_TENSOR_MAP_DATA_TYPE_TFLOAT32,        // 4 bytes
                      CU_TENSOR_MAP_DATA_TYPE_TFLOAT32_FTZ     // 4 bytes
                      CU_TENSOR_MAP_DATA_TYPE_16U4_ALIGN8B,    // 4 bits
                      CU_TENSOR_MAP_DATA_TYPE_16U4_ALIGN16B,   // 4 bits
                      CU_TENSOR_MAP_DATA_TYPE_16U6_ALIGN16B    // 6 bits
                  } [CUtensorMapDataType](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g42bfc19a0751d7183ee94faf9d9e779d>);

CU_TENSOR_MAP_DATA_TYPE_16U4_ALIGN8B copies '16 x U4' packed values to memory aligned as 8 bytes. There are no gaps between packed values. CU_TENSOR_MAP_DATA_TYPE_16U4_ALIGN16B copies '16 x U4' packed values to memory aligned as 16 bytes. There are 8 byte gaps between every 8 byte chunk of packed values. CU_TENSOR_MAP_DATA_TYPE_16U6_ALIGN16B copies '16 x U6' packed values to memory aligned as 16 bytes. There are 4 byte gaps between every 12 byte chunk of packed values.


  * `tensorRank`, which specifies the number of tensor dimensions, must be 3, 4, or 5.


  * `globalAddress`, which specifies the starting address of the memory region described, must be 16 byte aligned. The following requirements need to also be met:
    * When `interleave` is CU_TENSOR_MAP_INTERLEAVE_32B, `globalAddress` must be 32 byte aligned.

    * When `tensorDataType` is CU_TENSOR_MAP_DATA_TYPE_16U6_ALIGN16B or CU_TENSOR_MAP_DATA_TYPE_16U4_ALIGN16B, `globalAddress` must be 32 byte aligned.


  * `globalDim` array, which specifies tensor size of each of the `tensorRank` dimensions, must be non-zero and less than or equal to 2^32. Additionally, the following requirements need to be met for the packed data types:
    * When `tensorDataType` is CU_TENSOR_MAP_DATA_TYPE_16U6_ALIGN16B or CU_TENSOR_MAP_DATA_TYPE_16U4_ALIGN16B, globalDim[0] must be a multiple of 128.

    * When `tensorDataType` is CU_TENSOR_MAP_DATA_TYPE_16U4_ALIGN8B, `globalDim`[0] must be a multiple of 2.

    * Dimension for the packed data types must reflect the number of individual U# values.


  * `globalStrides` array, which specifies tensor stride of each of the lower `tensorRank` \- 1 dimensions in bytes, must be a multiple of 16 and less than 2^40. Additionally, the following requirements need to be met:
    * When `interleave` is CU_TENSOR_MAP_INTERLEAVE_32B, the strides must be a multiple of 32.

    * When `tensorDataType` is CU_TENSOR_MAP_DATA_TYPE_16U6_ALIGN16B or CU_TENSOR_MAP_DATA_TYPE_16U4_ALIGN16B, the strides must be a multiple of 32. Each following dimension specified includes previous dimension stride:

          â    globalStrides[0] = globalDim[0] * elementSizeInBytes(tensorDataType) + padding[0];
                    for (i = 1; i < tensorRank - 1; i++)
                        globalStrides[i] = globalStrides[i â 1] * (globalDim[i] + padding[i]);
                        assert(globalStrides[i] >= globalDim[i]);


  * `pixelBoxLowerCornerWidth` specifies the coordinate offset W of the bounding box from left corner. The offset must be within range [-32768, 32767].


  * `pixelBoxUpperCornerWidth` specifies the coordinate offset W of the bounding box from right corner. The offset must be within range [-32768, 32767].


The bounding box specified by `pixelBoxLowerCornerWidth` and `pixelBoxUpperCornerWidth` must have non-zero area. Note that the size of the box along D and H dimensions is always equal to one.

  * `channelsPerPixel`, which specifies the number of elements which must be accessed along C dimension, must be less than or equal to 256. Additionally, when `tensorDataType` is CU_TENSOR_MAP_DATA_TYPE_16U6_ALIGN16B or CU_TENSOR_MAP_DATA_TYPE_16U4_ALIGN16B, `channelsPerPixel` must be 128.


  * `pixelsPerColumn`, which specifies the number of elements that must be accessed along the W dimension, must be less than or equal to 1024. This field is ignored when `mode` is CU_TENSOR_MAP_IM2COL_WIDE_MODE_W128.


  * `elementStrides` array, which specifies the iteration step along each of the `tensorRank` dimensions, must be non-zero and less than or equal to 8. Note that when `interleave` is CU_TENSOR_MAP_INTERLEAVE_NONE, the first element of this array is ignored since TMA doesnât support the stride for dimension zero. When all elements of the `elementStrides` array are one, `boxDim` specifies the number of elements to load. However, if `elementStrides`[i] is not equal to one for some `i`, then TMA loads ceil( `boxDim`[i] / `elementStrides`[i]) number of elements along i-th dimension. To load N elements along i-th dimension, `boxDim`[i] must be set to N * `elementStrides`[i].


  * `interleave` specifies the interleaved layout of type [CUtensorMapInterleave](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g4af9a09e04bb8fc817eeb7be1c5cea70>), which is defined as:

        â    typedef enum CUtensorMapInterleave_enum {
                      CU_TENSOR_MAP_INTERLEAVE_NONE = 0,
                      CU_TENSOR_MAP_INTERLEAVE_16B,
                      CU_TENSOR_MAP_INTERLEAVE_32B
                  } [CUtensorMapInterleave](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g4af9a09e04bb8fc817eeb7be1c5cea70>);

TMA supports interleaved layouts like NC/8HWC8 where C8 utilizes 16 bytes in memory assuming 2 byte per channel or NC/16HWC16 where C16 uses 32 bytes. When `interleave` is CU_TENSOR_MAP_INTERLEAVE_NONE, the bounding box inner dimension (computed as `channelsPerPixel` multiplied by element size in bytes derived from `tensorDataType`) must be less than or equal to the swizzle size.
    * CU_TENSOR_MAP_SWIZZLE_64B requires the bounding box inner dimension to be <= 64.

    * CU_TENSOR_MAP_SWIZZLE_128B* require the bounding box inner dimension to be <= 128. Additionally, `tensorDataType` of CU_TENSOR_MAP_DATA_TYPE_16U6_ALIGN16B requires `interleave` to be CU_TENSOR_MAP_INTERLEAVE_NONE.


  * `mode`, which describes loading of elements loaded along the W dimension, has to be one of the following [CUtensorMapIm2ColWideMode](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g13a0a2e4907f0ec36e8180230644651b>) types:

        â          CU_TENSOR_MAP_IM2COL_WIDE_MODE_W,
                        CU_TENSOR_MAP_IM2COL_WIDE_MODE_W128

CU_TENSOR_MAP_IM2COL_WIDE_MODE_W allows the number of elements loaded along the W dimension to be specified via the `pixelsPerColumn` field.


  * `swizzle`, which specifies the shared memory bank swizzling pattern, must be one of the following [CUtensorMapSwizzle](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g0bc04417bd8ce2c64d204bc3cbc25b58>) modes (other swizzle modes are not supported):

        â    typedef enum CUtensorMapSwizzle_enum {
                      CU_TENSOR_MAP_SWIZZLE_64B,                   // Swizzle 16B chunks within 64B  span
                      CU_TENSOR_MAP_SWIZZLE_128B,                  // Swizzle 16B chunks within 128B span
                      CU_TENSOR_MAP_SWIZZLE_128B_ATOM_32B,         // Swizzle 32B chunks within 128B span
                  } [CUtensorMapSwizzle](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g0bc04417bd8ce2c64d204bc3cbc25b58>);

Data are organized in a specific order in global memory; however, this may not match the order in which the application accesses data in shared memory. This difference in data organization may cause bank conflicts when shared memory is accessed. In order to avoid this problem, data can be loaded to shared memory with shuffling across shared memory banks. When the `tensorDataType` is CU_TENSOR_MAP_DATA_TYPE_16U6_ALIGN16B, only the following swizzle modes are supported:
    * CU_TENSOR_MAP_SWIZZLE_128B (Load & Store)

    * CU_TENSOR_MAP_SWIZZLE_128B_ATOM_32B (Load & Store) When the `tensorDataType` is CU_TENSOR_MAP_DATA_TYPE_16U4_ALIGN16B, only the following swizzle modes are supported:

    * CU_TENSOR_MAP_SWIZZLE_128B (Load only)

    * CU_TENSOR_MAP_SWIZZLE_128B_ATOM_32B (Load only)


  * `l2Promotion` specifies L2 fetch size which indicates the byte granularity at which L2 requests are filled from DRAM. It must be of type [CUtensorMapL2promotion](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ga054bf4ec364bd7bd00966a03cf51fb7>), which is defined as:

        â    typedef enum CUtensorMapL2promotion_enum {
                      CU_TENSOR_MAP_L2_PROMOTION_NONE = 0,
                      CU_TENSOR_MAP_L2_PROMOTION_L2_64B,
                      CU_TENSOR_MAP_L2_PROMOTION_L2_128B,
                      CU_TENSOR_MAP_L2_PROMOTION_L2_256B
                  } [CUtensorMapL2promotion](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ga054bf4ec364bd7bd00966a03cf51fb7>);


  * `oobFill`, which indicates whether zero or a special NaN constant should be used to fill out-of-bound elements, must be of type [CUtensorMapFloatOOBfill](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gde9161158bee466f4f92be353c52480e>) which is defined as:

        â    typedef enum CUtensorMapFloatOOBfill_enum {
                      CU_TENSOR_MAP_FLOAT_OOB_FILL_NONE = 0,
                      CU_TENSOR_MAP_FLOAT_OOB_FILL_NAN_REQUEST_ZERO_FMA
                  } [CUtensorMapFloatOOBfill](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gde9161158bee466f4f92be353c52480e>);

Note that CU_TENSOR_MAP_FLOAT_OOB_FILL_NAN_REQUEST_ZERO_FMA can only be used when `tensorDataType` represents a floating-point data type, and when `tensorDataType` is not CU_TENSOR_MAP_DATA_TYPE_16U4_ALIGN8B, CU_TENSOR_MAP_DATA_TYPE_16U4_ALIGN16B, and CU_TENSOR_MAP_DATA_TYPE_16U6_ALIGN16B.


**See also:**

[cuTensorMapEncodeTiled](<group__CUDA__TENSOR__MEMORY.html#group__CUDA__TENSOR__MEMORY_1ga7c7d2aaac9e49294304e755e6f341d7> "Create a tensor map descriptor object representing tiled memory region."), [cuTensorMapEncodeIm2col](<group__CUDA__TENSOR__MEMORY.html#group__CUDA__TENSOR__MEMORY_1gb14d707a18d23fc0c3e22a67ceedc15a> "Create a tensor map descriptor object representing im2col memory region."), [cuTensorMapReplaceAddress](<group__CUDA__TENSOR__MEMORY.html#group__CUDA__TENSOR__MEMORY_1g8d54c0ff5c49b1b1a9baaac6fc796db3> "Modify an existing tensor map descriptor with an updated global address.")

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuTensorMapEncodeTiled ( [CUtensorMap](<structCUtensorMap.html#structCUtensorMap>)*Â tensorMap, [CUtensorMapDataType](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g42bfc19a0751d7183ee94faf9d9e779d>)Â tensorDataType, cuuint32_tÂ tensorRank, void*Â globalAddress, const cuuint64_t*Â globalDim, const cuuint64_t*Â globalStrides, const cuuint32_t*Â boxDim, const cuuint32_t*Â elementStrides, [CUtensorMapInterleave](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g4af9a09e04bb8fc817eeb7be1c5cea70>)Â interleave, [CUtensorMapSwizzle](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g0bc04417bd8ce2c64d204bc3cbc25b58>)Â swizzle, [CUtensorMapL2promotion](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ga054bf4ec364bd7bd00966a03cf51fb7>)Â l2Promotion, [CUtensorMapFloatOOBfill](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gde9161158bee466f4f92be353c52480e>)Â oobFill )


Create a tensor map descriptor object representing tiled memory region.

######  Parameters

`tensorMap`
    \- Tensor map object to create
`tensorDataType`
    \- Tensor data type
`tensorRank`
    \- Dimensionality of tensor
`globalAddress`
    \- Starting address of memory region described by tensor
`globalDim`
    \- Array containing tensor size (number of elements) along each of the `tensorRank` dimensions
`globalStrides`
    \- Array containing stride size (in bytes) along each of the `tensorRank` \- 1 dimensions
`boxDim`
    \- Array containing traversal box size (number of elments) along each of the `tensorRank` dimensions. Specifies how many elements to be traversed along each tensor dimension.
`elementStrides`
    \- Array containing traversal stride in each of the `tensorRank` dimensions
`interleave`
    \- Type of interleaved layout the tensor addresses
`swizzle`
    \- Bank swizzling pattern inside shared memory
`l2Promotion`
    \- L2 promotion size
`oobFill`
    \- Indicate whether zero or special NaN constant must be used to fill out-of-bound elements

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_DEINITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9acf52f132faf29b473cdda6061f0f44a>), [CUDA_ERROR_NOT_INITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e98feb999f0af99b4a25ab26b3866f4df8>), [CUDA_ERROR_INVALID_CONTEXT](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a484e9af32c1e9893ff21f0e0191a12d>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>)

###### Description

Creates a descriptor for Tensor Memory Access (TMA) object specified by the parameters describing a tiled region and returns it in `tensorMap`.

Tensor map objects are only supported on devices of compute capability 9.0 or higher. Additionally, a tensor map object is an opaque value, and, as such, should only be accessed through CUDA APIs and PTX.

The parameters passed are bound to the following requirements:

  * `tensorMap` address must be aligned to 64 bytes.


  * `tensorDataType` has to be an enum from [CUtensorMapDataType](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g42bfc19a0751d7183ee94faf9d9e779d>) which is defined as:

        â    typedef enum CUtensorMapDataType_enum {
                      CU_TENSOR_MAP_DATA_TYPE_UINT8 = 0,       // 1 byte
                      CU_TENSOR_MAP_DATA_TYPE_UINT16,          // 2 bytes
                      CU_TENSOR_MAP_DATA_TYPE_UINT32,          // 4 bytes
                      CU_TENSOR_MAP_DATA_TYPE_INT32,           // 4 bytes
                      CU_TENSOR_MAP_DATA_TYPE_UINT64,          // 8 bytes
                      CU_TENSOR_MAP_DATA_TYPE_INT64,           // 8 bytes
                      CU_TENSOR_MAP_DATA_TYPE_FLOAT16,         // 2 bytes
                      CU_TENSOR_MAP_DATA_TYPE_FLOAT32,         // 4 bytes
                      CU_TENSOR_MAP_DATA_TYPE_FLOAT64,         // 8 bytes
                      CU_TENSOR_MAP_DATA_TYPE_BFLOAT16,        // 2 bytes
                      CU_TENSOR_MAP_DATA_TYPE_FLOAT32_FTZ,     // 4 bytes
                      CU_TENSOR_MAP_DATA_TYPE_TFLOAT32,        // 4 bytes
                      CU_TENSOR_MAP_DATA_TYPE_TFLOAT32_FTZ,    // 4 bytes
                      CU_TENSOR_MAP_DATA_TYPE_16U4_ALIGN8B,    // 4 bits
                      CU_TENSOR_MAP_DATA_TYPE_16U4_ALIGN16B,   // 4 bits
                      CU_TENSOR_MAP_DATA_TYPE_16U6_ALIGN16B    // 6 bits
                  } [CUtensorMapDataType](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g42bfc19a0751d7183ee94faf9d9e779d>);

CU_TENSOR_MAP_DATA_TYPE_16U4_ALIGN8B copies '16 x U4' packed values to memory aligned as 8 bytes. There are no gaps between packed values. CU_TENSOR_MAP_DATA_TYPE_16U4_ALIGN16B copies '16 x U4' packed values to memory aligned as 16 bytes. There are 8 byte gaps between every 8 byte chunk of packed values. CU_TENSOR_MAP_DATA_TYPE_16U6_ALIGN16B copies '16 x U6' packed values to memory aligned as 16 bytes. There are 4 byte gaps between every 12 byte chunk of packed values.


  * `tensorRank` must be non-zero and less than or equal to the maximum supported dimensionality of 5. If `interleave` is not CU_TENSOR_MAP_INTERLEAVE_NONE, then `tensorRank` must additionally be greater than or equal to 3.


  * `globalAddress`, which specifies the starting address of the memory region described, must be 16 byte aligned. The following requirements need to also be met:
    * When `interleave` is CU_TENSOR_MAP_INTERLEAVE_32B, `globalAddress` must be 32 byte aligned.

    * When `tensorDataType` is CU_TENSOR_MAP_DATA_TYPE_16U6_ALIGN16B or CU_TENSOR_MAP_DATA_TYPE_16U4_ALIGN16B, `globalAddress` must be 32 byte aligned.


  * `globalDim` array, which specifies tensor size of each of the `tensorRank` dimensions, must be non-zero and less than or equal to 2^32. Additionally, the following requirements need to be met for the packed data types:
    * When `tensorDataType` is CU_TENSOR_MAP_DATA_TYPE_16U6_ALIGN16B or CU_TENSOR_MAP_DATA_TYPE_16U4_ALIGN16B, globalDim[0] must be a multiple of 128.

    * When `tensorDataType` is CU_TENSOR_MAP_DATA_TYPE_16U4_ALIGN8B, `globalDim`[0] must be a multiple of 2.

    * Dimension for the packed data types must reflect the number of individual U# values.


  * `globalStrides` array, which specifies tensor stride of each of the lower `tensorRank` \- 1 dimensions in bytes, must be a multiple of 16 and less than 2^40. Additionally, the following requirements need to be met:
    * When `interleave` is CU_TENSOR_MAP_INTERLEAVE_32B, the strides must be a multiple of 32.

    * When `tensorDataType` is CU_TENSOR_MAP_DATA_TYPE_16U6_ALIGN16B or CU_TENSOR_MAP_DATA_TYPE_16U4_ALIGN16B, the strides must be a multiple of 32. Each following dimension specified includes previous dimension stride:

          â    globalStrides[0] = globalDim[0] * elementSizeInBytes(tensorDataType) + padding[0];
                    for (i = 1; i < tensorRank - 1; i++)
                        globalStrides[i] = globalStrides[i â 1] * (globalDim[i] + padding[i]);
                        assert(globalStrides[i] >= globalDim[i]);


  * `boxDim` array, which specifies number of elements to be traversed along each of the `tensorRank` dimensions, must be non-zero and less than or equal to 256. Additionally, the following requirements need to be met:
    * When `interleave` is CU_TENSOR_MAP_INTERLEAVE_NONE, { `boxDim`[0] * elementSizeInBytes( `tensorDataType` ) } must be a multiple of 16 bytes.

    * When `tensorDataType` is CU_TENSOR_MAP_DATA_TYPE_16U6_ALIGN16B or CU_TENSOR_MAP_DATA_TYPE_16U4_ALIGN16B, boxDim[0] must be 128.


  * `elementStrides` array, which specifies the iteration step along each of the `tensorRank` dimensions, must be non-zero and less than or equal to 8. Note that when `interleave` is CU_TENSOR_MAP_INTERLEAVE_NONE, the first element of this array is ignored since TMA doesnât support the stride for dimension zero. When all elements of `elementStrides` array is one, `boxDim` specifies the number of elements to load. However, if the `elementStrides`[i] is not equal to one, then TMA loads ceil( `boxDim`[i] / `elementStrides`[i]) number of elements along i-th dimension. To load N elements along i-th dimension, `boxDim`[i] must be set to N * `elementStrides`[i].


  * `interleave` specifies the interleaved layout of type [CUtensorMapInterleave](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g4af9a09e04bb8fc817eeb7be1c5cea70>), which is defined as:

        â    typedef enum CUtensorMapInterleave_enum {
                      CU_TENSOR_MAP_INTERLEAVE_NONE = 0,
                      CU_TENSOR_MAP_INTERLEAVE_16B,
                      CU_TENSOR_MAP_INTERLEAVE_32B
                  } [CUtensorMapInterleave](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g4af9a09e04bb8fc817eeb7be1c5cea70>);

TMA supports interleaved layouts like NC/8HWC8 where C8 utilizes 16 bytes in memory assuming 2 byte per channel or NC/16HWC16 where C16 uses 32 bytes. When `interleave` is CU_TENSOR_MAP_INTERLEAVE_NONE and `swizzle` is not CU_TENSOR_MAP_SWIZZLE_NONE, the bounding box inner dimension (computed as `boxDim`[0] multiplied by element size derived from `tensorDataType`) must be less than or equal to the swizzle size.
    * CU_TENSOR_MAP_SWIZZLE_32B requires the bounding box inner dimension to be <= 32.

    * CU_TENSOR_MAP_SWIZZLE_64B requires the bounding box inner dimension to be <= 64.

    * CU_TENSOR_MAP_SWIZZLE_128B* require the bounding box inner dimension to be <= 128. Additionally, `tensorDataType` of CU_TENSOR_MAP_DATA_TYPE_16U6_ALIGN16B requires `interleave` to be CU_TENSOR_MAP_INTERLEAVE_NONE.


  * `swizzle`, which specifies the shared memory bank swizzling pattern, has to be of type [CUtensorMapSwizzle](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g0bc04417bd8ce2c64d204bc3cbc25b58>) which is defined as:

        â    typedef enum CUtensorMapSwizzle_enum {
                      CU_TENSOR_MAP_SWIZZLE_NONE = 0,
                      CU_TENSOR_MAP_SWIZZLE_32B,                   // Swizzle 16B chunks within 32B  span
                      CU_TENSOR_MAP_SWIZZLE_64B,                   // Swizzle 16B chunks within 64B  span
                      CU_TENSOR_MAP_SWIZZLE_128B,                  // Swizzle 16B chunks within 128B span
                      CU_TENSOR_MAP_SWIZZLE_128B_ATOM_32B,         // Swizzle 32B chunks within 128B span
                      CU_TENSOR_MAP_SWIZZLE_128B_ATOM_32B_FLIP_8B, // Swizzle 32B chunks within 128B span, additionally swap lower 8B with upper 8B within each 16B for every alternate row
                      CU_TENSOR_MAP_SWIZZLE_128B_ATOM_64B          // Swizzle 64B chunks within 128B span
                  } [CUtensorMapSwizzle](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g0bc04417bd8ce2c64d204bc3cbc25b58>);

Data are organized in a specific order in global memory; however, this may not match the order in which the application accesses data in shared memory. This difference in data organization may cause bank conflicts when shared memory is accessed. In order to avoid this problem, data can be loaded to shared memory with shuffling across shared memory banks. When `interleave` is CU_TENSOR_MAP_INTERLEAVE_32B, `swizzle` must be CU_TENSOR_MAP_SWIZZLE_32B. Other interleave modes can have any swizzling pattern. When the `tensorDataType` is CU_TENSOR_MAP_DATA_TYPE_16U6_ALIGN16B, only the following swizzle modes are supported:
    * CU_TENSOR_MAP_SWIZZLE_NONE (Load & Store)

    * CU_TENSOR_MAP_SWIZZLE_128B (Load & Store)

    * CU_TENSOR_MAP_SWIZZLE_128B_ATOM_32B (Load & Store)

    * CU_TENSOR_MAP_SWIZZLE_128B_ATOM_64B (Store only) When the `tensorDataType` is CU_TENSOR_MAP_DATA_TYPE_16U4_ALIGN16B, only the following swizzle modes are supported:

    * CU_TENSOR_MAP_SWIZZLE_NONE (Load only)

    * CU_TENSOR_MAP_SWIZZLE_128B (Load only)

    * CU_TENSOR_MAP_SWIZZLE_128B_ATOM_32B (Load only)


  * `l2Promotion` specifies L2 fetch size which indicates the byte granurality at which L2 requests is filled from DRAM. It must be of type [CUtensorMapL2promotion](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ga054bf4ec364bd7bd00966a03cf51fb7>), which is defined as:

        â    typedef enum CUtensorMapL2promotion_enum {
                      CU_TENSOR_MAP_L2_PROMOTION_NONE = 0,
                      CU_TENSOR_MAP_L2_PROMOTION_L2_64B,
                      CU_TENSOR_MAP_L2_PROMOTION_L2_128B,
                      CU_TENSOR_MAP_L2_PROMOTION_L2_256B
                  } [CUtensorMapL2promotion](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ga054bf4ec364bd7bd00966a03cf51fb7>);


  * `oobFill`, which indicates whether zero or a special NaN constant should be used to fill out-of-bound elements, must be of type [CUtensorMapFloatOOBfill](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gde9161158bee466f4f92be353c52480e>) which is defined as:

        â    typedef enum CUtensorMapFloatOOBfill_enum {
                      CU_TENSOR_MAP_FLOAT_OOB_FILL_NONE = 0,
                      CU_TENSOR_MAP_FLOAT_OOB_FILL_NAN_REQUEST_ZERO_FMA
                  } [CUtensorMapFloatOOBfill](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gde9161158bee466f4f92be353c52480e>);

Note that CU_TENSOR_MAP_FLOAT_OOB_FILL_NAN_REQUEST_ZERO_FMA can only be used when `tensorDataType` represents a floating-point data type, and when `tensorDataType` is not CU_TENSOR_MAP_DATA_TYPE_16U4_ALIGN8B, CU_TENSOR_MAP_DATA_TYPE_16U4_ALIGN16B, and CU_TENSOR_MAP_DATA_TYPE_16U6_ALIGN16B.


**See also:**

[cuTensorMapEncodeIm2col](<group__CUDA__TENSOR__MEMORY.html#group__CUDA__TENSOR__MEMORY_1gb14d707a18d23fc0c3e22a67ceedc15a> "Create a tensor map descriptor object representing im2col memory region."), [cuTensorMapEncodeIm2colWide](<group__CUDA__TENSOR__MEMORY.html#group__CUDA__TENSOR__MEMORY_1g6c1be81856c4e311f085e33a42403444> "Create a tensor map descriptor object representing im2col memory region, but where the elements are exclusively loaded along the W dimension."), [cuTensorMapReplaceAddress](<group__CUDA__TENSOR__MEMORY.html#group__CUDA__TENSOR__MEMORY_1g8d54c0ff5c49b1b1a9baaac6fc796db3> "Modify an existing tensor map descriptor with an updated global address.")

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuTensorMapReplaceAddress ( [CUtensorMap](<structCUtensorMap.html#structCUtensorMap>)*Â tensorMap, void*Â globalAddress )


Modify an existing tensor map descriptor with an updated global address.

######  Parameters

`tensorMap`
    \- Tensor map object to modify
`globalAddress`
    \- Starting address of memory region described by tensor, must follow previous alignment requirements

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_DEINITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9acf52f132faf29b473cdda6061f0f44a>), [CUDA_ERROR_NOT_INITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e98feb999f0af99b4a25ab26b3866f4df8>), [CUDA_ERROR_INVALID_CONTEXT](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a484e9af32c1e9893ff21f0e0191a12d>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>)

###### Description

Modifies the descriptor for Tensor Memory Access (TMA) object passed in `tensorMap` with an updated `globalAddress`.

Tensor map objects are only supported on devices of compute capability 9.0 or higher. Additionally, a tensor map object is an opaque value, and, as such, should only be accessed through CUDA API calls.

**See also:**

[cuTensorMapEncodeTiled](<group__CUDA__TENSOR__MEMORY.html#group__CUDA__TENSOR__MEMORY_1ga7c7d2aaac9e49294304e755e6f341d7> "Create a tensor map descriptor object representing tiled memory region."), [cuTensorMapEncodeIm2col](<group__CUDA__TENSOR__MEMORY.html#group__CUDA__TENSOR__MEMORY_1gb14d707a18d23fc0c3e22a67ceedc15a> "Create a tensor map descriptor object representing im2col memory region."), [cuTensorMapEncodeIm2colWide](<group__CUDA__TENSOR__MEMORY.html#group__CUDA__TENSOR__MEMORY_1g6c1be81856c4e311f085e33a42403444> "Create a tensor map descriptor object representing im2col memory region, but where the elements are exclusively loaded along the W dimension.")

* * *


---

# Peer Context Memory Access

## 6.31.Â Peer Context Memory Access

This section describes the direct peer context memory access functions of the low-level CUDA driver application programming interface.

### Functions

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuCtxDisablePeerAccess](<#group__CUDA__PEER__ACCESS_1g5b4b6936ea868d4954ce4d841a3b4810>) ( [CUcontext](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gf9f5bd81658f866613785b3a0bb7d7d9>)Â peerContext )
     Disables direct access to memory allocations in a peer context and unregisters any registered allocations.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuCtxEnablePeerAccess](<#group__CUDA__PEER__ACCESS_1g0889ec6728e61c05ed359551d67b3f5a>) ( [CUcontext](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gf9f5bd81658f866613785b3a0bb7d7d9>)Â peerContext, unsigned int Â Flags )
     Enables direct access to memory allocations in a peer context.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuDeviceCanAccessPeer](<#group__CUDA__PEER__ACCESS_1g496bdaae1f632ebfb695b99d2c40f19e>) ( int*Â canAccessPeer, [CUdevice](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g41ca2a24a242b36ef2ca77330b5fb72a>)Â dev, [CUdevice](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g41ca2a24a242b36ef2ca77330b5fb72a>)Â peerDev )
     Queries if a device may directly access a peer device's memory.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuDeviceGetP2PAtomicCapabilities](<#group__CUDA__PEER__ACCESS_1gfd989876c8fd3291b520c0b561d5282d>) ( unsigned int*Â capabilities, const [CUatomicOperation *](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gfd7012de0abfe50cee089f3f00d6dcf3>)*Â operations, unsigned int Â count, [CUdevice](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g41ca2a24a242b36ef2ca77330b5fb72a>)Â srcDevice, [CUdevice](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g41ca2a24a242b36ef2ca77330b5fb72a>)Â dstDevice )
     Queries details about atomic operations supported between two devices.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuDeviceGetP2PAttribute](<#group__CUDA__PEER__ACCESS_1g4c55c60508f8eba4546b51f2ee545393>) ( int*Â value, [CUdevice_P2PAttribute](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g578d7cf687ce20f7e99468e8c14e22de>)Â attrib, [CUdevice](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g41ca2a24a242b36ef2ca77330b5fb72a>)Â srcDevice, [CUdevice](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g41ca2a24a242b36ef2ca77330b5fb72a>)Â dstDevice )
     Queries attributes of the link between two devices.

### Functions

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuCtxDisablePeerAccess ( [CUcontext](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gf9f5bd81658f866613785b3a0bb7d7d9>)Â peerContext )


Disables direct access to memory allocations in a peer context and unregisters any registered allocations.

######  Parameters

`peerContext`
    \- Peer context to disable direct access to

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_DEINITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9acf52f132faf29b473cdda6061f0f44a>), [CUDA_ERROR_NOT_INITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e98feb999f0af99b4a25ab26b3866f4df8>), [CUDA_ERROR_PEER_ACCESS_NOT_ENABLED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e95e985a1735204ae8455e9eec402d46c3>), [CUDA_ERROR_INVALID_CONTEXT](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a484e9af32c1e9893ff21f0e0191a12d>),

###### Description

Returns [CUDA_ERROR_PEER_ACCESS_NOT_ENABLED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e95e985a1735204ae8455e9eec402d46c3>) if direct peer access has not yet been enabled from `peerContext` to the current context.

Returns [CUDA_ERROR_INVALID_CONTEXT](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a484e9af32c1e9893ff21f0e0191a12d>) if there is no current context, or if `peerContext` is not a valid context.

Note:

Note that this function may also return error codes from previous, asynchronous launches.

**See also:**

[cuDeviceCanAccessPeer](<group__CUDA__PEER__ACCESS.html#group__CUDA__PEER__ACCESS_1g496bdaae1f632ebfb695b99d2c40f19e> "Queries if a device may directly access a peer device's memory."), [cuCtxEnablePeerAccess](<group__CUDA__PEER__ACCESS.html#group__CUDA__PEER__ACCESS_1g0889ec6728e61c05ed359551d67b3f5a> "Enables direct access to memory allocations in a peer context."), [cudaDeviceDisablePeerAccess](<../cuda-runtime-api/group__CUDART__PEER.html#group__CUDART__PEER_1g9663734ad02653207ad6836053bf572e>)

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuCtxEnablePeerAccess ( [CUcontext](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gf9f5bd81658f866613785b3a0bb7d7d9>)Â peerContext, unsigned int Â Flags )


Enables direct access to memory allocations in a peer context.

######  Parameters

`peerContext`
    \- Peer context to enable direct access to from the current context
`Flags`
    \- Reserved for future use and must be set to 0

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_DEINITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9acf52f132faf29b473cdda6061f0f44a>), [CUDA_ERROR_NOT_INITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e98feb999f0af99b4a25ab26b3866f4df8>), [CUDA_ERROR_PEER_ACCESS_ALREADY_ENABLED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e947c18606be796573aa2957402fa89a9c>), [CUDA_ERROR_TOO_MANY_PEERS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9168ef870793a31ef4cdd7cb6e279b34a>), [CUDA_ERROR_INVALID_CONTEXT](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a484e9af32c1e9893ff21f0e0191a12d>), [CUDA_ERROR_PEER_ACCESS_UNSUPPORTED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9d60abcaa3f2710f961db8c383bb95cae>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>)

###### Description

If both the current context and `peerContext` are on devices which support unified addressing (as may be queried using [CU_DEVICE_ATTRIBUTE_UNIFIED_ADDRESSING](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gge12b8a782bebe21b1ac0091bf9f4e2a3dc11dd6d9f149a7bae32499f2b802c0d>)) and same major compute capability, then on success all allocations from `peerContext` will immediately be accessible by the current context. See [Unified Addressing](<group__CUDA__UNIFIED.html#group__CUDA__UNIFIED>) for additional details.

Note that access granted by this call is unidirectional and that in order to access memory from the current context in `peerContext`, a separate symmetric call to [cuCtxEnablePeerAccess()](<group__CUDA__PEER__ACCESS.html#group__CUDA__PEER__ACCESS_1g0889ec6728e61c05ed359551d67b3f5a> "Enables direct access to memory allocations in a peer context.") is required.

Note that there are both device-wide and system-wide limitations per system configuration, as noted in the CUDA Programming Guide under the section "Peer-to-Peer Memory Access".

Returns [CUDA_ERROR_PEER_ACCESS_UNSUPPORTED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9d60abcaa3f2710f961db8c383bb95cae>) if [cuDeviceCanAccessPeer()](<group__CUDA__PEER__ACCESS.html#group__CUDA__PEER__ACCESS_1g496bdaae1f632ebfb695b99d2c40f19e> "Queries if a device may directly access a peer device's memory.") indicates that the [CUdevice](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g41ca2a24a242b36ef2ca77330b5fb72a>) of the current context cannot directly access memory from the [CUdevice](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g41ca2a24a242b36ef2ca77330b5fb72a>) of `peerContext`.

Returns [CUDA_ERROR_PEER_ACCESS_ALREADY_ENABLED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e947c18606be796573aa2957402fa89a9c>) if direct access of `peerContext` from the current context has already been enabled.

Returns [CUDA_ERROR_TOO_MANY_PEERS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9168ef870793a31ef4cdd7cb6e279b34a>) if direct peer access is not possible because hardware resources required for peer access have been exhausted.

Returns [CUDA_ERROR_INVALID_CONTEXT](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a484e9af32c1e9893ff21f0e0191a12d>) if there is no current context, `peerContext` is not a valid context, or if the current context is `peerContext`.

Returns [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>) if `Flags` is not 0.

Note:

Note that this function may also return error codes from previous, asynchronous launches.

**See also:**

[cuDeviceCanAccessPeer](<group__CUDA__PEER__ACCESS.html#group__CUDA__PEER__ACCESS_1g496bdaae1f632ebfb695b99d2c40f19e> "Queries if a device may directly access a peer device's memory."), [cuCtxDisablePeerAccess](<group__CUDA__PEER__ACCESS.html#group__CUDA__PEER__ACCESS_1g5b4b6936ea868d4954ce4d841a3b4810> "Disables direct access to memory allocations in a peer context and unregisters any registered allocations."), [cudaDeviceEnablePeerAccess](<../cuda-runtime-api/group__CUDART__PEER.html#group__CUDART__PEER_1g2b0adabf90db37e5cfddc92cbb2589f3>)

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuDeviceCanAccessPeer ( int*Â canAccessPeer, [CUdevice](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g41ca2a24a242b36ef2ca77330b5fb72a>)Â dev, [CUdevice](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g41ca2a24a242b36ef2ca77330b5fb72a>)Â peerDev )


Queries if a device may directly access a peer device's memory.

######  Parameters

`canAccessPeer`
    \- Returned access capability
`dev`
    \- Device from which allocations on `peerDev` are to be directly accessed.
`peerDev`
    \- Device on which the allocations to be directly accessed by `dev` reside.

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_DEINITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9acf52f132faf29b473cdda6061f0f44a>), [CUDA_ERROR_NOT_INITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e98feb999f0af99b4a25ab26b3866f4df8>), [CUDA_ERROR_INVALID_DEVICE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e96f047e7215788ca96c81af92a04bfb6c>)

###### Description

Returns in `*canAccessPeer` a value of 1 if contexts on `dev` are capable of directly accessing memory from contexts on `peerDev` and 0 otherwise. If direct access of `peerDev` from `dev` is possible, then access may be enabled on two specific contexts by calling [cuCtxEnablePeerAccess()](<group__CUDA__PEER__ACCESS.html#group__CUDA__PEER__ACCESS_1g0889ec6728e61c05ed359551d67b3f5a> "Enables direct access to memory allocations in a peer context.").

Note:

Note that this function may also return error codes from previous, asynchronous launches.

**See also:**

[cuCtxEnablePeerAccess](<group__CUDA__PEER__ACCESS.html#group__CUDA__PEER__ACCESS_1g0889ec6728e61c05ed359551d67b3f5a> "Enables direct access to memory allocations in a peer context."), [cuCtxDisablePeerAccess](<group__CUDA__PEER__ACCESS.html#group__CUDA__PEER__ACCESS_1g5b4b6936ea868d4954ce4d841a3b4810> "Disables direct access to memory allocations in a peer context and unregisters any registered allocations."), [cudaDeviceCanAccessPeer](<../cuda-runtime-api/group__CUDART__PEER.html#group__CUDART__PEER_1g4db0d04e44995d5c1c34be4ecc863f22>)

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuDeviceGetP2PAtomicCapabilities ( unsigned int*Â capabilities, const [CUatomicOperation *](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gfd7012de0abfe50cee089f3f00d6dcf3>)*Â operations, unsigned int Â count, [CUdevice](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g41ca2a24a242b36ef2ca77330b5fb72a>)Â srcDevice, [CUdevice](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g41ca2a24a242b36ef2ca77330b5fb72a>)Â dstDevice )


Queries details about atomic operations supported between two devices.

######  Parameters

`capabilities`
    \- Returned capability details of each requested operation
`operations`
    \- Requested operations
`count`
    \- Count of requested operations and size of capabilities
`srcDevice`
    \- The source device of the target link
`dstDevice`
    \- The destination device of the target link

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_INVALID_DEVICE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e96f047e7215788ca96c81af92a04bfb6c>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>)

###### Description

Returns in `*capabilities` the details about requested atomic `*operations` over the the link between `srcDevice` and `dstDevice`. The allocated size of `*operations` and `*capabilities` must be `count`.

For each [CUatomicOperation](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gfd7012de0abfe50cee089f3f00d6dcf3>) in `*operations`, the corresponding result in `*capabilities` will be a bitmask indicating which of [CUatomicOperationCapability](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gf8fbc0f84fd6461c5611b3935b26e22c>) the link supports natively.

Returns [CUDA_ERROR_INVALID_DEVICE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e96f047e7215788ca96c81af92a04bfb6c>) if `srcDevice` or `dstDevice` are not valid or if they represent the same device.

Returns [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>) if `*capabilities` or `*operations` is NULL, if `count` is 0, or if any of `*operations` is not valid.

Note:

Note that this function may also return error codes from previous, asynchronous launches.

**See also:**

[cuDeviceGetP2PAttribute](<group__CUDA__PEER__ACCESS.html#group__CUDA__PEER__ACCESS_1g4c55c60508f8eba4546b51f2ee545393> "Queries attributes of the link between two devices."), [cudaDeviceGetP2PAttribute](<../cuda-runtime-api/group__CUDART__DEVICE.html#group__CUDART__DEVICE_1gc63e5bf168e53b2daf71904eab048fa9>), [cudaDeviceGetP2PAtomicCapabilities](<../cuda-runtime-api/group__CUDART__DEVICE.html#group__CUDART__DEVICE_1ga608cadee2598ca942b362db73267c2b>)

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuDeviceGetP2PAttribute ( int*Â value, [CUdevice_P2PAttribute](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g578d7cf687ce20f7e99468e8c14e22de>)Â attrib, [CUdevice](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g41ca2a24a242b36ef2ca77330b5fb72a>)Â srcDevice, [CUdevice](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g41ca2a24a242b36ef2ca77330b5fb72a>)Â dstDevice )


Queries attributes of the link between two devices.

######  Parameters

`value`
    \- Returned value of the requested attribute
`attrib`
    \- The requested attribute of the link between `srcDevice` and `dstDevice`.
`srcDevice`
    \- The source device of the target link.
`dstDevice`
    \- The destination device of the target link.

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_DEINITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9acf52f132faf29b473cdda6061f0f44a>), [CUDA_ERROR_NOT_INITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e98feb999f0af99b4a25ab26b3866f4df8>), [CUDA_ERROR_INVALID_DEVICE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e96f047e7215788ca96c81af92a04bfb6c>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>)

###### Description

Returns in `*value` the value of the requested attribute `attrib` of the link between `srcDevice` and `dstDevice`. The supported attributes are:

  * [CU_DEVICE_P2P_ATTRIBUTE_PERFORMANCE_RANK](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg578d7cf687ce20f7e99468e8c14e22de193d16e6c0ee3a975c184b32586f9fdc>): A relative value indicating the performance of the link between two devices.

  * [CU_DEVICE_P2P_ATTRIBUTE_ACCESS_SUPPORTED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg578d7cf687ce20f7e99468e8c14e22dec7e28aec0cd03c462a49d00d1b145f46>) P2P: 1 if P2P Access is enable.

  * [CU_DEVICE_P2P_ATTRIBUTE_NATIVE_ATOMIC_SUPPORTED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg578d7cf687ce20f7e99468e8c14e22de810416263d10b9917ac99d35058d6236>): 1 if all CUDA-valid atomic operations over the link are supported.

  * [CU_DEVICE_P2P_ATTRIBUTE_CUDA_ARRAY_ACCESS_SUPPORTED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg578d7cf687ce20f7e99468e8c14e22de83a83eb1e8d535b6b8ecf00f509f4097>): 1 if cudaArray can be accessed over the link.

  * [CU_DEVICE_P2P_ATTRIBUTE_ONLY_PARTIAL_NATIVE_ATOMIC_SUPPORTED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg578d7cf687ce20f7e99468e8c14e22de4a3bdcbd230a998ee38f8ec70bd902a0>): 1 if some CUDA-valid atomic operations over the link are supported. Information about specific operations can be retrieved with [cuDeviceGetP2PAtomicCapabilities](<group__CUDA__PEER__ACCESS.html#group__CUDA__PEER__ACCESS_1gfd989876c8fd3291b520c0b561d5282d> "Queries details about atomic operations supported between two devices.").


Returns [CUDA_ERROR_INVALID_DEVICE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e96f047e7215788ca96c81af92a04bfb6c>) if `srcDevice` or `dstDevice` are not valid or if they represent the same device.

Returns [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>) if `attrib` is not valid or if `value` is a null pointer.

Note:

Note that this function may also return error codes from previous, asynchronous launches.

**See also:**

[cuCtxEnablePeerAccess](<group__CUDA__PEER__ACCESS.html#group__CUDA__PEER__ACCESS_1g0889ec6728e61c05ed359551d67b3f5a> "Enables direct access to memory allocations in a peer context."), [cuCtxDisablePeerAccess](<group__CUDA__PEER__ACCESS.html#group__CUDA__PEER__ACCESS_1g5b4b6936ea868d4954ce4d841a3b4810> "Disables direct access to memory allocations in a peer context and unregisters any registered allocations."), [cuDeviceCanAccessPeer](<group__CUDA__PEER__ACCESS.html#group__CUDA__PEER__ACCESS_1g496bdaae1f632ebfb695b99d2c40f19e> "Queries if a device may directly access a peer device's memory."), [cuDeviceGetP2PAtomicCapabilities](<group__CUDA__PEER__ACCESS.html#group__CUDA__PEER__ACCESS_1gfd989876c8fd3291b520c0b561d5282d> "Queries details about atomic operations supported between two devices."), [cudaDeviceGetP2PAttribute](<../cuda-runtime-api/group__CUDART__DEVICE.html#group__CUDART__DEVICE_1gc63e5bf168e53b2daf71904eab048fa9>)

* * *


---

# Graphics Interoperability

## 6.32.Â Graphics Interoperability

This section describes the graphics interoperability functions of the low-level CUDA driver application programming interface.

### Functions

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuGraphicsMapResources](<#group__CUDA__GRAPHICS_1gffcfd8e78d82cc4f6dd987e8bce4edb0>) ( unsigned int Â count, [CUgraphicsResource](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc0c4e1704647178d9c5ba3be46517dcd>)*Â resources, [CUstream](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gb946c7f02e09efd788a204718015d88a>)Â hStream )
     Map graphics resources for access by CUDA.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuGraphicsResourceGetMappedMipmappedArray](<#group__CUDA__GRAPHICS_1g37680bbe89c7fe5c613563eaab9d14c1>) ( [CUmipmappedArray](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g96db856ab3d2940fb694ce4501d9b583>)*Â pMipmappedArray, [CUgraphicsResource](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc0c4e1704647178d9c5ba3be46517dcd>)Â resource )
     Get a mipmapped array through which to access a mapped graphics resource.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuGraphicsResourceGetMappedPointer](<#group__CUDA__GRAPHICS_1g8a634cf4150d399f0018061580592457>) ( [CUdeviceptr](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g183f7b0d8ad008ea2a5fd552537ace4e>)*Â pDevPtr, size_t*Â pSize, [CUgraphicsResource](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc0c4e1704647178d9c5ba3be46517dcd>)Â resource )
     Get a device pointer through which to access a mapped graphics resource.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuGraphicsResourceSetMapFlags](<#group__CUDA__GRAPHICS_1gfe96aa7747f8b11d44a6fa6a851e1b39>) ( [CUgraphicsResource](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc0c4e1704647178d9c5ba3be46517dcd>)Â resource, unsigned int Â flags )
     Set usage flags for mapping a graphics resource.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuGraphicsSubResourceGetMappedArray](<#group__CUDA__GRAPHICS_1g61c55e987e54558cce547240d6123078>) ( [CUarray](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gd550651524a56766b60f10f0e7628042>)*Â pArray, [CUgraphicsResource](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc0c4e1704647178d9c5ba3be46517dcd>)Â resource, unsigned int Â arrayIndex, unsigned int Â mipLevel )
     Get an array through which to access a subresource of a mapped graphics resource.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuGraphicsUnmapResources](<#group__CUDA__GRAPHICS_1g8e9ff25d071375a0df1cb5aee924af32>) ( unsigned int Â count, [CUgraphicsResource](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc0c4e1704647178d9c5ba3be46517dcd>)*Â resources, [CUstream](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gb946c7f02e09efd788a204718015d88a>)Â hStream )
     Unmap graphics resources.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuGraphicsUnregisterResource](<#group__CUDA__GRAPHICS_1ga7e5e97b74eaa13dfa6582e853e4c96d>) ( [CUgraphicsResource](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc0c4e1704647178d9c5ba3be46517dcd>)Â resource )
     Unregisters a graphics resource for access by CUDA.

### Functions

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuGraphicsMapResources ( unsigned int Â count, [CUgraphicsResource](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc0c4e1704647178d9c5ba3be46517dcd>)*Â resources, [CUstream](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gb946c7f02e09efd788a204718015d88a>)Â hStream )


Map graphics resources for access by CUDA.

######  Parameters

`count`
    \- Number of resources to map
`resources`
    \- Resources to map for CUDA usage
`hStream`
    \- Stream with which to synchronize

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_DEINITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9acf52f132faf29b473cdda6061f0f44a>), [CUDA_ERROR_NOT_INITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e98feb999f0af99b4a25ab26b3866f4df8>), [CUDA_ERROR_INVALID_CONTEXT](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a484e9af32c1e9893ff21f0e0191a12d>), [CUDA_ERROR_INVALID_HANDLE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e90fd2e63260c6317ba943af0f7e4b8d21>), [CUDA_ERROR_ALREADY_MAPPED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9240bb253a699176d9f49ee2f2c91b61b>), [CUDA_ERROR_UNKNOWN](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9c5a6ab0245179d297f1fa56ed0097183>)

###### Description

Maps the `count` graphics resources in `resources` for access by CUDA.

The resources in `resources` may be accessed by CUDA until they are unmapped. The graphics API from which `resources` were registered should not access any resources while they are mapped by CUDA. If an application does so, the results are undefined.

This function provides the synchronization guarantee that any graphics calls issued before [cuGraphicsMapResources()](<group__CUDA__GRAPHICS.html#group__CUDA__GRAPHICS_1gffcfd8e78d82cc4f6dd987e8bce4edb0> "Map graphics resources for access by CUDA.") will complete before any subsequent CUDA work issued in `stream` begins.

If `resources` includes any duplicate entries then [CUDA_ERROR_INVALID_HANDLE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e90fd2e63260c6317ba943af0f7e4b8d21>) is returned. If any of `resources` are presently mapped for access by CUDA then [CUDA_ERROR_ALREADY_MAPPED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9240bb253a699176d9f49ee2f2c91b61b>) is returned.

Note:

  * This function uses standard [default stream](<stream-sync-behavior.html#stream-sync-behavior__default-stream>) semantics.

  * Note that this function may also return error codes from previous, asynchronous launches.


**See also:**

[cuGraphicsResourceGetMappedPointer](<group__CUDA__GRAPHICS.html#group__CUDA__GRAPHICS_1g8a634cf4150d399f0018061580592457> "Get a device pointer through which to access a mapped graphics resource."), [cuGraphicsSubResourceGetMappedArray](<group__CUDA__GRAPHICS.html#group__CUDA__GRAPHICS_1g61c55e987e54558cce547240d6123078> "Get an array through which to access a subresource of a mapped graphics resource."), [cuGraphicsUnmapResources](<group__CUDA__GRAPHICS.html#group__CUDA__GRAPHICS_1g8e9ff25d071375a0df1cb5aee924af32> "Unmap graphics resources."), [cudaGraphicsMapResources](<../cuda-runtime-api/group__CUDART__INTEROP.html#group__CUDART__INTEROP_1gad8fbe74d02adefb8e7efb4971ee6322>)

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuGraphicsResourceGetMappedMipmappedArray ( [CUmipmappedArray](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g96db856ab3d2940fb694ce4501d9b583>)*Â pMipmappedArray, [CUgraphicsResource](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc0c4e1704647178d9c5ba3be46517dcd>)Â resource )


Get a mipmapped array through which to access a mapped graphics resource.

######  Parameters

`pMipmappedArray`
    \- Returned mipmapped array through which `resource` may be accessed
`resource`
    \- Mapped resource to access

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_DEINITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9acf52f132faf29b473cdda6061f0f44a>), [CUDA_ERROR_NOT_INITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e98feb999f0af99b4a25ab26b3866f4df8>), [CUDA_ERROR_INVALID_CONTEXT](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a484e9af32c1e9893ff21f0e0191a12d>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>), [CUDA_ERROR_INVALID_HANDLE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e90fd2e63260c6317ba943af0f7e4b8d21>), [CUDA_ERROR_NOT_MAPPED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9e098433b926c9afdb6b6bdf191629447>), [CUDA_ERROR_NOT_MAPPED_AS_ARRAY](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9037f39ebe1bbd16d1b162f4456d507c5>)

###### Description

Returns in `*pMipmappedArray` a mipmapped array through which the mapped graphics resource `resource`. The value set in `*pMipmappedArray` may change every time that `resource` is mapped.

If `resource` is not a texture then it cannot be accessed via a mipmapped array and [CUDA_ERROR_NOT_MAPPED_AS_ARRAY](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9037f39ebe1bbd16d1b162f4456d507c5>) is returned. If `resource` is not mapped then [CUDA_ERROR_NOT_MAPPED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9e098433b926c9afdb6b6bdf191629447>) is returned.

Note:

Note that this function may also return error codes from previous, asynchronous launches.

**See also:**

[cuGraphicsResourceGetMappedPointer](<group__CUDA__GRAPHICS.html#group__CUDA__GRAPHICS_1g8a634cf4150d399f0018061580592457> "Get a device pointer through which to access a mapped graphics resource."), [cudaGraphicsResourceGetMappedMipmappedArray](<../cuda-runtime-api/group__CUDART__INTEROP.html#group__CUDART__INTEROP_1g84c3772d2ed06cda8c92bc43cdc893d0>)

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuGraphicsResourceGetMappedPointer ( [CUdeviceptr](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g183f7b0d8ad008ea2a5fd552537ace4e>)*Â pDevPtr, size_t*Â pSize, [CUgraphicsResource](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc0c4e1704647178d9c5ba3be46517dcd>)Â resource )


Get a device pointer through which to access a mapped graphics resource.

######  Parameters

`pDevPtr`
    \- Returned pointer through which `resource` may be accessed
`pSize`
    \- Returned size of the buffer accessible starting at `*pPointer`
`resource`
    \- Mapped resource to access

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_DEINITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9acf52f132faf29b473cdda6061f0f44a>), [CUDA_ERROR_NOT_INITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e98feb999f0af99b4a25ab26b3866f4df8>), [CUDA_ERROR_INVALID_CONTEXT](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a484e9af32c1e9893ff21f0e0191a12d>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>), [CUDA_ERROR_INVALID_HANDLE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e90fd2e63260c6317ba943af0f7e4b8d21>), [CUDA_ERROR_NOT_MAPPED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9e098433b926c9afdb6b6bdf191629447>), [CUDA_ERROR_NOT_MAPPED_AS_POINTER](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a7ceef277b14abcb140c4ffa72a37473>)

###### Description

Returns in `*pDevPtr` a pointer through which the mapped graphics resource `resource` may be accessed. Returns in `pSize` the size of the memory in bytes which may be accessed from that pointer. The value set in `pPointer` may change every time that `resource` is mapped.

If `resource` is not a buffer then it cannot be accessed via a pointer and [CUDA_ERROR_NOT_MAPPED_AS_POINTER](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a7ceef277b14abcb140c4ffa72a37473>) is returned. If `resource` is not mapped then [CUDA_ERROR_NOT_MAPPED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9e098433b926c9afdb6b6bdf191629447>) is returned. *

Note:

Note that this function may also return error codes from previous, asynchronous launches.

**See also:**

[cuGraphicsMapResources](<group__CUDA__GRAPHICS.html#group__CUDA__GRAPHICS_1gffcfd8e78d82cc4f6dd987e8bce4edb0> "Map graphics resources for access by CUDA."), [cuGraphicsSubResourceGetMappedArray](<group__CUDA__GRAPHICS.html#group__CUDA__GRAPHICS_1g61c55e987e54558cce547240d6123078> "Get an array through which to access a subresource of a mapped graphics resource."), [cudaGraphicsResourceGetMappedPointer](<../cuda-runtime-api/group__CUDART__INTEROP.html#group__CUDART__INTEROP_1ga36881081c8deb4df25c256158e1ac99>)

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuGraphicsResourceSetMapFlags ( [CUgraphicsResource](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc0c4e1704647178d9c5ba3be46517dcd>)Â resource, unsigned int Â flags )


Set usage flags for mapping a graphics resource.

######  Parameters

`resource`
    \- Registered resource to set flags for
`flags`
    \- Parameters for resource mapping

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_DEINITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9acf52f132faf29b473cdda6061f0f44a>), [CUDA_ERROR_NOT_INITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e98feb999f0af99b4a25ab26b3866f4df8>), [CUDA_ERROR_INVALID_CONTEXT](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a484e9af32c1e9893ff21f0e0191a12d>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>), [CUDA_ERROR_INVALID_HANDLE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e90fd2e63260c6317ba943af0f7e4b8d21>), [CUDA_ERROR_ALREADY_MAPPED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9240bb253a699176d9f49ee2f2c91b61b>)

###### Description

Set `flags` for mapping the graphics resource `resource`.

Changes to `flags` will take effect the next time `resource` is mapped. The `flags` argument may be any of the following:

  * CU_GRAPHICS_MAP_RESOURCE_FLAGS_NONE: Specifies no hints about how this resource will be used. It is therefore assumed that this resource will be read from and written to by CUDA kernels. This is the default value.

  * CU_GRAPHICS_MAP_RESOURCE_FLAGS_READONLY: Specifies that CUDA kernels which access this resource will not write to this resource.

  * CU_GRAPHICS_MAP_RESOURCE_FLAGS_WRITEDISCARD: Specifies that CUDA kernels which access this resource will not read from this resource and will write over the entire contents of the resource, so none of the data previously stored in the resource will be preserved.


If `resource` is presently mapped for access by CUDA then [CUDA_ERROR_ALREADY_MAPPED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9240bb253a699176d9f49ee2f2c91b61b>) is returned. If `flags` is not one of the above values then [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>) is returned.

Note:

Note that this function may also return error codes from previous, asynchronous launches.

**See also:**

[cuGraphicsMapResources](<group__CUDA__GRAPHICS.html#group__CUDA__GRAPHICS_1gffcfd8e78d82cc4f6dd987e8bce4edb0> "Map graphics resources for access by CUDA."), [cudaGraphicsResourceSetMapFlags](<../cuda-runtime-api/group__CUDART__INTEROP.html#group__CUDART__INTEROP_1g5f94a0043909fddc100ab5f0c2476b9f>)

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuGraphicsSubResourceGetMappedArray ( [CUarray](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gd550651524a56766b60f10f0e7628042>)*Â pArray, [CUgraphicsResource](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc0c4e1704647178d9c5ba3be46517dcd>)Â resource, unsigned int Â arrayIndex, unsigned int Â mipLevel )


Get an array through which to access a subresource of a mapped graphics resource.

######  Parameters

`pArray`
    \- Returned array through which a subresource of `resource` may be accessed
`resource`
    \- Mapped resource to access
`arrayIndex`
    \- Array index for array textures or cubemap face index as defined by [CUarray_cubemap_face](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g012fda14b50e7db8798a340627c4c330>) for cubemap textures for the subresource to access
`mipLevel`
    \- Mipmap level for the subresource to access

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_DEINITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9acf52f132faf29b473cdda6061f0f44a>), [CUDA_ERROR_NOT_INITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e98feb999f0af99b4a25ab26b3866f4df8>), [CUDA_ERROR_INVALID_CONTEXT](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a484e9af32c1e9893ff21f0e0191a12d>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>), [CUDA_ERROR_INVALID_HANDLE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e90fd2e63260c6317ba943af0f7e4b8d21>), [CUDA_ERROR_NOT_MAPPED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9e098433b926c9afdb6b6bdf191629447>), [CUDA_ERROR_NOT_MAPPED_AS_ARRAY](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9037f39ebe1bbd16d1b162f4456d507c5>)

###### Description

Returns in `*pArray` an array through which the subresource of the mapped graphics resource `resource` which corresponds to array index `arrayIndex` and mipmap level `mipLevel` may be accessed. The value set in `*pArray` may change every time that `resource` is mapped.

If `resource` is not a texture then it cannot be accessed via an array and [CUDA_ERROR_NOT_MAPPED_AS_ARRAY](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9037f39ebe1bbd16d1b162f4456d507c5>) is returned. If `arrayIndex` is not a valid array index for `resource` then [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>) is returned. If `mipLevel` is not a valid mipmap level for `resource` then [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>) is returned. If `resource` is not mapped then [CUDA_ERROR_NOT_MAPPED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9e098433b926c9afdb6b6bdf191629447>) is returned.

Note:

Note that this function may also return error codes from previous, asynchronous launches.

**See also:**

[cuGraphicsResourceGetMappedPointer](<group__CUDA__GRAPHICS.html#group__CUDA__GRAPHICS_1g8a634cf4150d399f0018061580592457> "Get a device pointer through which to access a mapped graphics resource."), [cudaGraphicsSubResourceGetMappedArray](<../cuda-runtime-api/group__CUDART__INTEROP.html#group__CUDART__INTEROP_1g0dd6b5f024dfdcff5c28a08ef9958031>)

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuGraphicsUnmapResources ( unsigned int Â count, [CUgraphicsResource](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc0c4e1704647178d9c5ba3be46517dcd>)*Â resources, [CUstream](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gb946c7f02e09efd788a204718015d88a>)Â hStream )


Unmap graphics resources.

######  Parameters

`count`
    \- Number of resources to unmap
`resources`
    \- Resources to unmap
`hStream`
    \- Stream with which to synchronize

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_DEINITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9acf52f132faf29b473cdda6061f0f44a>), [CUDA_ERROR_NOT_INITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e98feb999f0af99b4a25ab26b3866f4df8>), [CUDA_ERROR_INVALID_CONTEXT](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a484e9af32c1e9893ff21f0e0191a12d>), [CUDA_ERROR_INVALID_HANDLE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e90fd2e63260c6317ba943af0f7e4b8d21>), [CUDA_ERROR_NOT_MAPPED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9e098433b926c9afdb6b6bdf191629447>), [CUDA_ERROR_UNKNOWN](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9c5a6ab0245179d297f1fa56ed0097183>)

###### Description

Unmaps the `count` graphics resources in `resources`.

Once unmapped, the resources in `resources` may not be accessed by CUDA until they are mapped again.

This function provides the synchronization guarantee that any CUDA work issued in `stream` before [cuGraphicsUnmapResources()](<group__CUDA__GRAPHICS.html#group__CUDA__GRAPHICS_1g8e9ff25d071375a0df1cb5aee924af32> "Unmap graphics resources.") will complete before any subsequently issued graphics work begins.

If `resources` includes any duplicate entries then [CUDA_ERROR_INVALID_HANDLE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e90fd2e63260c6317ba943af0f7e4b8d21>) is returned. If any of `resources` are not presently mapped for access by CUDA then [CUDA_ERROR_NOT_MAPPED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9e098433b926c9afdb6b6bdf191629447>) is returned.

Note:

  * This function uses standard [default stream](<stream-sync-behavior.html#stream-sync-behavior__default-stream>) semantics.

  * Note that this function may also return error codes from previous, asynchronous launches.


**See also:**

[cuGraphicsMapResources](<group__CUDA__GRAPHICS.html#group__CUDA__GRAPHICS_1gffcfd8e78d82cc4f6dd987e8bce4edb0> "Map graphics resources for access by CUDA."), [cudaGraphicsUnmapResources](<../cuda-runtime-api/group__CUDART__INTEROP.html#group__CUDART__INTEROP_1g11988ab4431b11ddb7cbde7aedb60491>)

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuGraphicsUnregisterResource ( [CUgraphicsResource](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc0c4e1704647178d9c5ba3be46517dcd>)Â resource )


Unregisters a graphics resource for access by CUDA.

######  Parameters

`resource`
    \- Resource to unregister

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_DEINITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9acf52f132faf29b473cdda6061f0f44a>), [CUDA_ERROR_NOT_INITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e98feb999f0af99b4a25ab26b3866f4df8>), [CUDA_ERROR_INVALID_CONTEXT](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a484e9af32c1e9893ff21f0e0191a12d>), [CUDA_ERROR_INVALID_HANDLE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e90fd2e63260c6317ba943af0f7e4b8d21>), [CUDA_ERROR_UNKNOWN](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9c5a6ab0245179d297f1fa56ed0097183>)

###### Description

Unregisters the graphics resource `resource` so it is not accessible by CUDA unless registered again.

If `resource` is invalid then [CUDA_ERROR_INVALID_HANDLE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e90fd2e63260c6317ba943af0f7e4b8d21>) is returned.

Note:

Note that this function may also return error codes from previous, asynchronous launches.

**See also:**

[cuGraphicsD3D9RegisterResource](<group__CUDA__D3D9.html#group__CUDA__D3D9_1g391835e0d3c5a34bdba99840157194bf> "Register a Direct3D 9 resource for access by CUDA."), [cuGraphicsD3D10RegisterResource](<group__CUDA__D3D10.html#group__CUDA__D3D10_1g87fb2a189c27c4b63538d23f53b2c8e6> "Register a Direct3D 10 resource for access by CUDA."), [cuGraphicsD3D11RegisterResource](<group__CUDA__D3D11.html#group__CUDA__D3D11_1g4c02792aa87c3acc255b9de15b0509da> "Register a Direct3D 11 resource for access by CUDA."), [cuGraphicsGLRegisterBuffer](<group__CUDA__GL.html#group__CUDA__GL_1gd530f66cc9ab43a31a98527e75f343a0> "Registers an OpenGL buffer object."), [cuGraphicsGLRegisterImage](<group__CUDA__GL.html#group__CUDA__GL_1g52c3a36c4c92611b6fcf0662b2f74e40> "Register an OpenGL texture or renderbuffer object."), [cudaGraphicsUnregisterResource](<../cuda-runtime-api/group__CUDART__INTEROP.html#group__CUDART__INTEROP_1gc65d1f2900086747de1e57301d709940>)

* * *


---

# OpenGL Interoperability

## 6.40.Â OpenGL Interoperability

This section describes the OpenGL interoperability functions of the low-level CUDA driver application programming interface. Note that mapping of OpenGL resources is performed with the graphics API agnostic, resource mapping interface described in [Graphics Interoperability](<group__CUDA__GRAPHICS.html#group__CUDA__GRAPHICS>).

### Modules

Â

[OpenGL Interoperability [DEPRECATED]](<group__CUDA__GL__DEPRECATED.html#group__CUDA__GL__DEPRECATED>)

     [](<group__CUDA__GL__DEPRECATED.html#group__CUDA__GL__DEPRECATED>)

### Enumerations

enumÂ [CUGLDeviceList](<#group__CUDA__GL_1g7676f0c02ef846176f6ef26accbb9e3b>)


### Functions

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuGLGetDevices](<#group__CUDA__GL_1g98bb15525b04d2f6a817c21e07d8b7cd>) ( unsigned int*Â pCudaDeviceCount, [CUdevice](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g41ca2a24a242b36ef2ca77330b5fb72a>)*Â pCudaDevices, unsigned int Â cudaDeviceCount, [CUGLDeviceList](<group__CUDA__GL.html#group__CUDA__GL_1g7676f0c02ef846176f6ef26accbb9e3b>)Â deviceList )
     Gets the CUDA devices associated with the current OpenGL context.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuGraphicsGLRegisterBuffer](<#group__CUDA__GL_1gd530f66cc9ab43a31a98527e75f343a0>) ( [CUgraphicsResource](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc0c4e1704647178d9c5ba3be46517dcd>)*Â pCudaResource, GLuintÂ buffer, unsigned int Â Flags )
     Registers an OpenGL buffer object.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuGraphicsGLRegisterImage](<#group__CUDA__GL_1g52c3a36c4c92611b6fcf0662b2f74e40>) ( [CUgraphicsResource](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc0c4e1704647178d9c5ba3be46517dcd>)*Â pCudaResource, GLuintÂ image, GLenumÂ target, unsigned int Â Flags )
     Register an OpenGL texture or renderbuffer object.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuWGLGetDevice](<#group__CUDA__GL_1g21ff8296192dc38dff42ba3346078282>) ( [CUdevice](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g41ca2a24a242b36ef2ca77330b5fb72a>)*Â pDevice, HGPUNVÂ hGpu )
     Gets the CUDA device associated with hGpu.

### Enumerations

enum CUGLDeviceList


CUDA devices corresponding to an OpenGL device

######  Values

CU_GL_DEVICE_LIST_ALL = 0x01
    The CUDA devices for all GPUs used by the current OpenGL context
CU_GL_DEVICE_LIST_CURRENT_FRAME = 0x02
    The CUDA devices for the GPUs used by the current OpenGL context in its currently rendering frame
CU_GL_DEVICE_LIST_NEXT_FRAME = 0x03
    The CUDA devices for the GPUs to be used by the current OpenGL context in the next frame

### Functions

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuGLGetDevices ( unsigned int*Â pCudaDeviceCount, [CUdevice](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g41ca2a24a242b36ef2ca77330b5fb72a>)*Â pCudaDevices, unsigned int Â cudaDeviceCount, [CUGLDeviceList](<group__CUDA__GL.html#group__CUDA__GL_1g7676f0c02ef846176f6ef26accbb9e3b>)Â deviceList )


Gets the CUDA devices associated with the current OpenGL context.

######  Parameters

`pCudaDeviceCount`
    \- Returned number of CUDA devices.
`pCudaDevices`
    \- Returned CUDA devices.
`cudaDeviceCount`
    \- The size of the output device array pCudaDevices.
`deviceList`
    \- The set of devices to return.

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_NO_DEVICE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9761bea84083d384d4fb88d51d972aada>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>), [CUDA_ERROR_INVALID_CONTEXT](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a484e9af32c1e9893ff21f0e0191a12d>), [CUDA_ERROR_INVALID_GRAPHICS_CONTEXT](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e98667df54ca7b35fa911703978a679839>), [CUDA_ERROR_OPERATING_SYSTEM](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9c849a151611f6e2ed1b3ae923f79ef3c>)

###### Description

Returns in `*pCudaDeviceCount` the number of CUDA-compatible devices corresponding to the current OpenGL context. Also returns in `*pCudaDevices` at most cudaDeviceCount of the CUDA-compatible devices corresponding to the current OpenGL context. If any of the GPUs being used by the current OpenGL context are not CUDA capable then the call will return CUDA_ERROR_NO_DEVICE.

The `deviceList` argument may be any of the following:

  * [CU_GL_DEVICE_LIST_ALL](<group__CUDA__GL.html#group__CUDA__GL_1gg7676f0c02ef846176f6ef26accbb9e3b43d2b311a54ae5c914c264e8395c3164>): Query all devices used by the current OpenGL context.

  * [CU_GL_DEVICE_LIST_CURRENT_FRAME](<group__CUDA__GL.html#group__CUDA__GL_1gg7676f0c02ef846176f6ef26accbb9e3bdc48f515019afdc0a78cd366871b0fe1>): Query the devices used by the current OpenGL context to render the current frame (in SLI).

  * [CU_GL_DEVICE_LIST_NEXT_FRAME](<group__CUDA__GL.html#group__CUDA__GL_1gg7676f0c02ef846176f6ef26accbb9e3b9d6d52b3167bd1d144eb08db8b60325a>): Query the devices used by the current OpenGL context to render the next frame (in SLI). Note that this is a prediction, it can't be guaranteed that this is correct in all cases.


Note:

Note that this function may also return error codes from previous, asynchronous launches.

**See also:**

[cuWGLGetDevice](<group__CUDA__GL.html#group__CUDA__GL_1g21ff8296192dc38dff42ba3346078282> "Gets the CUDA device associated with hGpu."), [cudaGLGetDevices](<../cuda-runtime-api/group__CUDART__OPENGL.html#group__CUDART__OPENGL_1g3471ecaa5b827c94f2c55ab51fde1751>)

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuGraphicsGLRegisterBuffer ( [CUgraphicsResource](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc0c4e1704647178d9c5ba3be46517dcd>)*Â pCudaResource, GLuintÂ buffer, unsigned int Â Flags )


Registers an OpenGL buffer object.

######  Parameters

`pCudaResource`
    \- Pointer to the returned object handle
`buffer`
    \- name of buffer object to be registered
`Flags`
    \- Register flags

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_INVALID_HANDLE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e90fd2e63260c6317ba943af0f7e4b8d21>), [CUDA_ERROR_ALREADY_MAPPED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9240bb253a699176d9f49ee2f2c91b61b>), [CUDA_ERROR_INVALID_CONTEXT](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a484e9af32c1e9893ff21f0e0191a12d>), [CUDA_ERROR_OPERATING_SYSTEM](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9c849a151611f6e2ed1b3ae923f79ef3c>)

###### Description

Registers the buffer object specified by `buffer` for access by CUDA. A handle to the registered object is returned as `pCudaResource`. The register flags `Flags` specify the intended usage, as follows:

  * CU_GRAPHICS_REGISTER_FLAGS_NONE: Specifies no hints about how this resource will be used. It is therefore assumed that this resource will be read from and written to by CUDA. This is the default value.

  * CU_GRAPHICS_REGISTER_FLAGS_READ_ONLY: Specifies that CUDA will not write to this resource.

  * CU_GRAPHICS_REGISTER_FLAGS_WRITE_DISCARD: Specifies that CUDA will not read from this resource and will write over the entire contents of the resource, so none of the data previously stored in the resource will be preserved.


Note:

Note that this function may also return error codes from previous, asynchronous launches.

**See also:**

[cuGraphicsUnregisterResource](<group__CUDA__GRAPHICS.html#group__CUDA__GRAPHICS_1ga7e5e97b74eaa13dfa6582e853e4c96d> "Unregisters a graphics resource for access by CUDA."), [cuGraphicsMapResources](<group__CUDA__GRAPHICS.html#group__CUDA__GRAPHICS_1gffcfd8e78d82cc4f6dd987e8bce4edb0> "Map graphics resources for access by CUDA."), [cuGraphicsResourceGetMappedPointer](<group__CUDA__GRAPHICS.html#group__CUDA__GRAPHICS_1g8a634cf4150d399f0018061580592457> "Get a device pointer through which to access a mapped graphics resource."), [cudaGraphicsGLRegisterBuffer](<../cuda-runtime-api/group__CUDART__OPENGL.html#group__CUDART__OPENGL_1g0fd33bea77ca7b1e69d1619caf44214b>)

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuGraphicsGLRegisterImage ( [CUgraphicsResource](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc0c4e1704647178d9c5ba3be46517dcd>)*Â pCudaResource, GLuintÂ image, GLenumÂ target, unsigned int Â Flags )


Register an OpenGL texture or renderbuffer object.

######  Parameters

`pCudaResource`
    \- Pointer to the returned object handle
`image`
    \- name of texture or renderbuffer object to be registered
`target`
    \- Identifies the type of object specified by `image`
`Flags`
    \- Register flags

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_INVALID_HANDLE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e90fd2e63260c6317ba943af0f7e4b8d21>), [CUDA_ERROR_ALREADY_MAPPED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9240bb253a699176d9f49ee2f2c91b61b>), [CUDA_ERROR_INVALID_CONTEXT](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a484e9af32c1e9893ff21f0e0191a12d>), [CUDA_ERROR_OPERATING_SYSTEM](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9c849a151611f6e2ed1b3ae923f79ef3c>)

###### Description

Registers the texture or renderbuffer object specified by `image` for access by CUDA. A handle to the registered object is returned as `pCudaResource`.

`target` must match the type of the object, and must be one of GL_TEXTURE_2D, GL_TEXTURE_RECTANGLE, GL_TEXTURE_CUBE_MAP, GL_TEXTURE_3D, GL_TEXTURE_2D_ARRAY, or GL_RENDERBUFFER.

The register flags `Flags` specify the intended usage, as follows:

  * CU_GRAPHICS_REGISTER_FLAGS_NONE: Specifies no hints about how this resource will be used. It is therefore assumed that this resource will be read from and written to by CUDA. This is the default value.

  * CU_GRAPHICS_REGISTER_FLAGS_READ_ONLY: Specifies that CUDA will not write to this resource.

  * CU_GRAPHICS_REGISTER_FLAGS_WRITE_DISCARD: Specifies that CUDA will not read from this resource and will write over the entire contents of the resource, so none of the data previously stored in the resource will be preserved.

  * CU_GRAPHICS_REGISTER_FLAGS_SURFACE_LDST: Specifies that CUDA will bind this resource to a surface reference.

  * CU_GRAPHICS_REGISTER_FLAGS_TEXTURE_GATHER: Specifies that CUDA will perform texture gather operations on this resource.


The following image formats are supported. For brevity's sake, the list is abbreviated. For ex., {GL_R, GL_RG} X {8, 16} would expand to the following 4 formats {GL_R8, GL_R16, GL_RG8, GL_RG16} :

  * GL_RED, GL_RG, GL_RGBA, GL_LUMINANCE, GL_ALPHA, GL_LUMINANCE_ALPHA, GL_INTENSITY

  * {GL_R, GL_RG, GL_RGBA} X {8, 16, 16F, 32F, 8UI, 16UI, 32UI, 8I, 16I, 32I}

  * {GL_LUMINANCE, GL_ALPHA, GL_LUMINANCE_ALPHA, GL_INTENSITY} X {8, 16, 16F_ARB, 32F_ARB, 8UI_EXT, 16UI_EXT, 32UI_EXT, 8I_EXT, 16I_EXT, 32I_EXT}


The following image classes are currently disallowed:

  * Textures with borders

  * Multisampled renderbuffers


Note:

Note that this function may also return error codes from previous, asynchronous launches.

**See also:**

[cuGraphicsUnregisterResource](<group__CUDA__GRAPHICS.html#group__CUDA__GRAPHICS_1ga7e5e97b74eaa13dfa6582e853e4c96d> "Unregisters a graphics resource for access by CUDA."), [cuGraphicsMapResources](<group__CUDA__GRAPHICS.html#group__CUDA__GRAPHICS_1gffcfd8e78d82cc4f6dd987e8bce4edb0> "Map graphics resources for access by CUDA."), [cuGraphicsSubResourceGetMappedArray](<group__CUDA__GRAPHICS.html#group__CUDA__GRAPHICS_1g61c55e987e54558cce547240d6123078> "Get an array through which to access a subresource of a mapped graphics resource."), [cudaGraphicsGLRegisterImage](<../cuda-runtime-api/group__CUDART__OPENGL.html#group__CUDART__OPENGL_1g80d12187ae7590807c7676697d9fe03d>)

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuWGLGetDevice ( [CUdevice](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g41ca2a24a242b36ef2ca77330b5fb72a>)*Â pDevice, HGPUNVÂ hGpu )


Gets the CUDA device associated with hGpu.

######  Parameters

`pDevice`
    \- Device associated with hGpu
`hGpu`
    \- Handle to a GPU, as queried via WGL_NV_gpu_affinity()

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_DEINITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9acf52f132faf29b473cdda6061f0f44a>), [CUDA_ERROR_NOT_INITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e98feb999f0af99b4a25ab26b3866f4df8>), [CUDA_ERROR_INVALID_CONTEXT](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a484e9af32c1e9893ff21f0e0191a12d>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>)

###### Description

Returns in `*pDevice` the CUDA device associated with a `hGpu`, if applicable.

Note:

Note that this function may also return error codes from previous, asynchronous launches.

**See also:**

[cuGLMapBufferObject](<group__CUDA__GL__DEPRECATED.html#group__CUDA__GL__DEPRECATED_1g68f705554e3630cabea768a7621689ee> "Maps an OpenGL buffer object."), [cuGLRegisterBufferObject](<group__CUDA__GL__DEPRECATED.html#group__CUDA__GL__DEPRECATED_1gaeba53543521eec9ad519bf3fa5574c0> "Registers an OpenGL buffer object."), [cuGLUnmapBufferObject](<group__CUDA__GL__DEPRECATED.html#group__CUDA__GL__DEPRECATED_1g83c72b84acd61fbdab204000b6daea0d> "Unmaps an OpenGL buffer object."), [cuGLUnregisterBufferObject](<group__CUDA__GL__DEPRECATED.html#group__CUDA__GL__DEPRECATED_1g5564309322313e2e5df222647227f3a6> "Unregister an OpenGL buffer object."), [cuGLUnmapBufferObjectAsync](<group__CUDA__GL__DEPRECATED.html#group__CUDA__GL__DEPRECATED_1g901b90f8543042cf59f51b99a0c96f3b> "Unmaps an OpenGL buffer object."), [cuGLSetBufferObjectMapFlags](<group__CUDA__GL__DEPRECATED.html#group__CUDA__GL__DEPRECATED_1gb04334f5028a5ad24640949164bd5cc9> "Set the map flags for an OpenGL buffer object."), [cudaWGLGetDevice](<../cuda-runtime-api/group__CUDART__OPENGL.html#group__CUDART__OPENGL_1gcbad4f3a7ed30ee479322f9923a05a2c>)

### OpenGL Interoperability [DEPRECATED]

* * *


---

# OpenGL Interoperability (Deprecated)

## 6.40.1.Â OpenGL Interoperability [DEPRECATED]

## [[OpenGL Interoperability](<group__CUDA__GL.html#group__CUDA__GL>)]

This section describes deprecated OpenGL interoperability functionality.

### Enumerations

enumÂ [CUGLmap_flags](<#group__CUDA__GL__DEPRECATED_1gd0d7e6d08165785f7f801feef8a71c9a>)


### Functions

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuGLCtxCreate](<#group__CUDA__GL__DEPRECATED_1g931f6d260d7db412b37497cb4b2fdf5d>) ( [CUcontext](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gf9f5bd81658f866613785b3a0bb7d7d9>)*Â pCtx, unsigned int Â Flags, [CUdevice](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g41ca2a24a242b36ef2ca77330b5fb72a>)Â device )
     Create a CUDA context for interoperability with OpenGL.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuGLInit](<#group__CUDA__GL__DEPRECATED_1g393d6b6cc9bc93185c45bb6c3ec87fe9>) ( void )
     Initializes OpenGL interoperability.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuGLMapBufferObject](<#group__CUDA__GL__DEPRECATED_1g68f705554e3630cabea768a7621689ee>) ( [CUdeviceptr](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g183f7b0d8ad008ea2a5fd552537ace4e>)*Â dptr, size_t*Â size, GLuintÂ buffer )
     Maps an OpenGL buffer object.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuGLMapBufferObjectAsync](<#group__CUDA__GL__DEPRECATED_1gc309e0c027b9fba9a65ba533ec5f834e>) ( [CUdeviceptr](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g183f7b0d8ad008ea2a5fd552537ace4e>)*Â dptr, size_t*Â size, GLuintÂ buffer, [CUstream](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gb946c7f02e09efd788a204718015d88a>)Â hStream )
     Maps an OpenGL buffer object.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuGLRegisterBufferObject](<#group__CUDA__GL__DEPRECATED_1gaeba53543521eec9ad519bf3fa5574c0>) ( GLuintÂ buffer )
     Registers an OpenGL buffer object.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuGLSetBufferObjectMapFlags](<#group__CUDA__GL__DEPRECATED_1gb04334f5028a5ad24640949164bd5cc9>) ( GLuintÂ buffer, unsigned int Â Flags )
     Set the map flags for an OpenGL buffer object.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuGLUnmapBufferObject](<#group__CUDA__GL__DEPRECATED_1g83c72b84acd61fbdab204000b6daea0d>) ( GLuintÂ buffer )
     Unmaps an OpenGL buffer object.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuGLUnmapBufferObjectAsync](<#group__CUDA__GL__DEPRECATED_1g901b90f8543042cf59f51b99a0c96f3b>) ( GLuintÂ buffer, [CUstream](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gb946c7f02e09efd788a204718015d88a>)Â hStream )
     Unmaps an OpenGL buffer object.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuGLUnregisterBufferObject](<#group__CUDA__GL__DEPRECATED_1g5564309322313e2e5df222647227f3a6>) ( GLuintÂ buffer )
     Unregister an OpenGL buffer object.

### Enumerations

enum CUGLmap_flags


Flags to map or unmap a resource

######  Values

CU_GL_MAP_RESOURCE_FLAGS_NONE = 0x00

CU_GL_MAP_RESOURCE_FLAGS_READ_ONLY = 0x01

CU_GL_MAP_RESOURCE_FLAGS_WRITE_DISCARD = 0x02


### Functions

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuGLCtxCreate ( [CUcontext](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gf9f5bd81658f866613785b3a0bb7d7d9>)*Â pCtx, unsigned int Â Flags, [CUdevice](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g41ca2a24a242b36ef2ca77330b5fb72a>)Â device )


Create a CUDA context for interoperability with OpenGL.

######  Parameters

`pCtx`
    \- Returned CUDA context
`Flags`
    \- Options for CUDA context creation
`device`
    \- Device on which to create the context

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_DEINITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9acf52f132faf29b473cdda6061f0f44a>), [CUDA_ERROR_NOT_INITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e98feb999f0af99b4a25ab26b3866f4df8>), [CUDA_ERROR_INVALID_CONTEXT](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a484e9af32c1e9893ff21f0e0191a12d>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>), [CUDA_ERROR_OUT_OF_MEMORY](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9264c50688ed110e8476b591befe60c02>)

###### [Deprecated](<deprecated.html#deprecated__deprecated_1_deprecated000071>)

This function is deprecated as of Cuda 5.0.

###### Description

This function is deprecated and should no longer be used. It is no longer necessary to associate a CUDA context with an OpenGL context in order to achieve maximum interoperability performance.

Note:

Note that this function may also return error codes from previous, asynchronous launches.

**See also:**

[cuCtxCreate](<group__CUDA__CTX.html#group__CUDA__CTX_1g77e9fb578caefca5ed15b4acebf35265> "Create a CUDA context."), [cuGLInit](<group__CUDA__GL__DEPRECATED.html#group__CUDA__GL__DEPRECATED_1g393d6b6cc9bc93185c45bb6c3ec87fe9> "Initializes OpenGL interoperability."), [cuGLMapBufferObject](<group__CUDA__GL__DEPRECATED.html#group__CUDA__GL__DEPRECATED_1g68f705554e3630cabea768a7621689ee> "Maps an OpenGL buffer object."), [cuGLRegisterBufferObject](<group__CUDA__GL__DEPRECATED.html#group__CUDA__GL__DEPRECATED_1gaeba53543521eec9ad519bf3fa5574c0> "Registers an OpenGL buffer object."), [cuGLUnmapBufferObject](<group__CUDA__GL__DEPRECATED.html#group__CUDA__GL__DEPRECATED_1g83c72b84acd61fbdab204000b6daea0d> "Unmaps an OpenGL buffer object."), [cuGLUnregisterBufferObject](<group__CUDA__GL__DEPRECATED.html#group__CUDA__GL__DEPRECATED_1g5564309322313e2e5df222647227f3a6> "Unregister an OpenGL buffer object."), [cuGLMapBufferObjectAsync](<group__CUDA__GL__DEPRECATED.html#group__CUDA__GL__DEPRECATED_1gc309e0c027b9fba9a65ba533ec5f834e> "Maps an OpenGL buffer object."), [cuGLUnmapBufferObjectAsync](<group__CUDA__GL__DEPRECATED.html#group__CUDA__GL__DEPRECATED_1g901b90f8543042cf59f51b99a0c96f3b> "Unmaps an OpenGL buffer object."), [cuGLSetBufferObjectMapFlags](<group__CUDA__GL__DEPRECATED.html#group__CUDA__GL__DEPRECATED_1gb04334f5028a5ad24640949164bd5cc9> "Set the map flags for an OpenGL buffer object."), [cuWGLGetDevice](<group__CUDA__GL.html#group__CUDA__GL_1g21ff8296192dc38dff42ba3346078282> "Gets the CUDA device associated with hGpu.")

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuGLInit ( void )


Initializes OpenGL interoperability.

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_DEINITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9acf52f132faf29b473cdda6061f0f44a>), [CUDA_ERROR_NOT_INITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e98feb999f0af99b4a25ab26b3866f4df8>), [CUDA_ERROR_INVALID_CONTEXT](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a484e9af32c1e9893ff21f0e0191a12d>), [CUDA_ERROR_UNKNOWN](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9c5a6ab0245179d297f1fa56ed0097183>)

###### [Deprecated](<deprecated.html#deprecated__deprecated_1_deprecated000072>)

This function is deprecated as of Cuda 3.0.

###### Description

Initializes OpenGL interoperability. This function is deprecated and calling it is no longer required. It may fail if the needed OpenGL driver facilities are not available.

Note:

Note that this function may also return error codes from previous, asynchronous launches.

**See also:**

[cuGLMapBufferObject](<group__CUDA__GL__DEPRECATED.html#group__CUDA__GL__DEPRECATED_1g68f705554e3630cabea768a7621689ee> "Maps an OpenGL buffer object."), [cuGLRegisterBufferObject](<group__CUDA__GL__DEPRECATED.html#group__CUDA__GL__DEPRECATED_1gaeba53543521eec9ad519bf3fa5574c0> "Registers an OpenGL buffer object."), [cuGLUnmapBufferObject](<group__CUDA__GL__DEPRECATED.html#group__CUDA__GL__DEPRECATED_1g83c72b84acd61fbdab204000b6daea0d> "Unmaps an OpenGL buffer object."), [cuGLUnregisterBufferObject](<group__CUDA__GL__DEPRECATED.html#group__CUDA__GL__DEPRECATED_1g5564309322313e2e5df222647227f3a6> "Unregister an OpenGL buffer object."), [cuGLMapBufferObjectAsync](<group__CUDA__GL__DEPRECATED.html#group__CUDA__GL__DEPRECATED_1gc309e0c027b9fba9a65ba533ec5f834e> "Maps an OpenGL buffer object."), [cuGLUnmapBufferObjectAsync](<group__CUDA__GL__DEPRECATED.html#group__CUDA__GL__DEPRECATED_1g901b90f8543042cf59f51b99a0c96f3b> "Unmaps an OpenGL buffer object."), [cuGLSetBufferObjectMapFlags](<group__CUDA__GL__DEPRECATED.html#group__CUDA__GL__DEPRECATED_1gb04334f5028a5ad24640949164bd5cc9> "Set the map flags for an OpenGL buffer object."), [cuWGLGetDevice](<group__CUDA__GL.html#group__CUDA__GL_1g21ff8296192dc38dff42ba3346078282> "Gets the CUDA device associated with hGpu.")

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuGLMapBufferObject ( [CUdeviceptr](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g183f7b0d8ad008ea2a5fd552537ace4e>)*Â dptr, size_t*Â size, GLuintÂ buffer )


Maps an OpenGL buffer object.

######  Parameters

`dptr`
    \- Returned mapped base pointer
`size`
    \- Returned size of mapping
`buffer`
    \- The name of the buffer object to map

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_DEINITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9acf52f132faf29b473cdda6061f0f44a>), [CUDA_ERROR_NOT_INITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e98feb999f0af99b4a25ab26b3866f4df8>), [CUDA_ERROR_INVALID_CONTEXT](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a484e9af32c1e9893ff21f0e0191a12d>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>), [CUDA_ERROR_MAP_FAILED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9b9a95891afee8e479ca2e89595b51a2f>)

###### [Deprecated](<deprecated.html#deprecated__deprecated_1_deprecated000074>)

This function is deprecated as of Cuda 3.0.

###### Description

Maps the buffer object specified by `buffer` into the address space of the current CUDA context and returns in `*dptr` and `*size` the base pointer and size of the resulting mapping.

There must be a valid OpenGL context bound to the current thread when this function is called. This must be the same context, or a member of the same shareGroup, as the context that was bound when the buffer was registered.

All streams in the current CUDA context are synchronized with the current GL context.

Note:

Note that this function may also return error codes from previous, asynchronous launches.

**See also:**

[cuGraphicsMapResources](<group__CUDA__GRAPHICS.html#group__CUDA__GRAPHICS_1gffcfd8e78d82cc4f6dd987e8bce4edb0> "Map graphics resources for access by CUDA.")

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuGLMapBufferObjectAsync ( [CUdeviceptr](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g183f7b0d8ad008ea2a5fd552537ace4e>)*Â dptr, size_t*Â size, GLuintÂ buffer, [CUstream](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gb946c7f02e09efd788a204718015d88a>)Â hStream )


Maps an OpenGL buffer object.

######  Parameters

`dptr`
    \- Returned mapped base pointer
`size`
    \- Returned size of mapping
`buffer`
    \- The name of the buffer object to map
`hStream`
    \- Stream to synchronize

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_DEINITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9acf52f132faf29b473cdda6061f0f44a>), [CUDA_ERROR_NOT_INITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e98feb999f0af99b4a25ab26b3866f4df8>), [CUDA_ERROR_INVALID_CONTEXT](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a484e9af32c1e9893ff21f0e0191a12d>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>), [CUDA_ERROR_MAP_FAILED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9b9a95891afee8e479ca2e89595b51a2f>)

###### [Deprecated](<deprecated.html#deprecated__deprecated_1_deprecated000078>)

This function is deprecated as of Cuda 3.0.

###### Description

Maps the buffer object specified by `buffer` into the address space of the current CUDA context and returns in `*dptr` and `*size` the base pointer and size of the resulting mapping.

There must be a valid OpenGL context bound to the current thread when this function is called. This must be the same context, or a member of the same shareGroup, as the context that was bound when the buffer was registered.

Stream `hStream` in the current CUDA context is synchronized with the current GL context.

Note:

Note that this function may also return error codes from previous, asynchronous launches.

**See also:**

[cuGraphicsMapResources](<group__CUDA__GRAPHICS.html#group__CUDA__GRAPHICS_1gffcfd8e78d82cc4f6dd987e8bce4edb0> "Map graphics resources for access by CUDA.")

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuGLRegisterBufferObject ( GLuintÂ buffer )


Registers an OpenGL buffer object.

######  Parameters

`buffer`
    \- The name of the buffer object to register.

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_DEINITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9acf52f132faf29b473cdda6061f0f44a>), [CUDA_ERROR_NOT_INITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e98feb999f0af99b4a25ab26b3866f4df8>), [CUDA_ERROR_INVALID_CONTEXT](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a484e9af32c1e9893ff21f0e0191a12d>), [CUDA_ERROR_ALREADY_MAPPED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9240bb253a699176d9f49ee2f2c91b61b>)

###### [Deprecated](<deprecated.html#deprecated__deprecated_1_deprecated000073>)

This function is deprecated as of Cuda 3.0.

###### Description

Registers the buffer object specified by `buffer` for access by CUDA. This function must be called before CUDA can map the buffer object. There must be a valid OpenGL context bound to the current thread when this function is called, and the buffer name is resolved by that context.

Note:

Note that this function may also return error codes from previous, asynchronous launches.

**See also:**

[cuGraphicsGLRegisterBuffer](<group__CUDA__GL.html#group__CUDA__GL_1gd530f66cc9ab43a31a98527e75f343a0> "Registers an OpenGL buffer object.")

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuGLSetBufferObjectMapFlags ( GLuintÂ buffer, unsigned int Â Flags )


Set the map flags for an OpenGL buffer object.

######  Parameters

`buffer`
    \- Buffer object to unmap
`Flags`
    \- Map flags

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_NOT_INITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e98feb999f0af99b4a25ab26b3866f4df8>), [CUDA_ERROR_INVALID_HANDLE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e90fd2e63260c6317ba943af0f7e4b8d21>), [CUDA_ERROR_ALREADY_MAPPED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9240bb253a699176d9f49ee2f2c91b61b>), [CUDA_ERROR_INVALID_CONTEXT](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a484e9af32c1e9893ff21f0e0191a12d>),

###### [Deprecated](<deprecated.html#deprecated__deprecated_1_deprecated000077>)

This function is deprecated as of Cuda 3.0.

###### Description

Sets the map flags for the buffer object specified by `buffer`.

Changes to `Flags` will take effect the next time `buffer` is mapped. The `Flags` argument may be any of the following:

  * CU_GL_MAP_RESOURCE_FLAGS_NONE: Specifies no hints about how this resource will be used. It is therefore assumed that this resource will be read from and written to by CUDA kernels. This is the default value.

  * CU_GL_MAP_RESOURCE_FLAGS_READ_ONLY: Specifies that CUDA kernels which access this resource will not write to this resource.

  * CU_GL_MAP_RESOURCE_FLAGS_WRITE_DISCARD: Specifies that CUDA kernels which access this resource will not read from this resource and will write over the entire contents of the resource, so none of the data previously stored in the resource will be preserved.


If `buffer` has not been registered for use with CUDA, then [CUDA_ERROR_INVALID_HANDLE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e90fd2e63260c6317ba943af0f7e4b8d21>) is returned. If `buffer` is presently mapped for access by CUDA, then [CUDA_ERROR_ALREADY_MAPPED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9240bb253a699176d9f49ee2f2c91b61b>) is returned.

There must be a valid OpenGL context bound to the current thread when this function is called. This must be the same context, or a member of the same shareGroup, as the context that was bound when the buffer was registered.

Note:

Note that this function may also return error codes from previous, asynchronous launches.

**See also:**

[cuGraphicsResourceSetMapFlags](<group__CUDA__GRAPHICS.html#group__CUDA__GRAPHICS_1gfe96aa7747f8b11d44a6fa6a851e1b39> "Set usage flags for mapping a graphics resource.")

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuGLUnmapBufferObject ( GLuintÂ buffer )


Unmaps an OpenGL buffer object.

######  Parameters

`buffer`
    \- Buffer object to unmap

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_DEINITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9acf52f132faf29b473cdda6061f0f44a>), [CUDA_ERROR_NOT_INITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e98feb999f0af99b4a25ab26b3866f4df8>), [CUDA_ERROR_INVALID_CONTEXT](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a484e9af32c1e9893ff21f0e0191a12d>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>)

###### [Deprecated](<deprecated.html#deprecated__deprecated_1_deprecated000075>)

This function is deprecated as of Cuda 3.0.

###### Description

Unmaps the buffer object specified by `buffer` for access by CUDA.

There must be a valid OpenGL context bound to the current thread when this function is called. This must be the same context, or a member of the same shareGroup, as the context that was bound when the buffer was registered.

All streams in the current CUDA context are synchronized with the current GL context.

Note:

Note that this function may also return error codes from previous, asynchronous launches.

**See also:**

[cuGraphicsUnmapResources](<group__CUDA__GRAPHICS.html#group__CUDA__GRAPHICS_1g8e9ff25d071375a0df1cb5aee924af32> "Unmap graphics resources.")

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuGLUnmapBufferObjectAsync ( GLuintÂ buffer, [CUstream](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gb946c7f02e09efd788a204718015d88a>)Â hStream )


Unmaps an OpenGL buffer object.

######  Parameters

`buffer`
    \- Name of the buffer object to unmap
`hStream`
    \- Stream to synchronize

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_DEINITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9acf52f132faf29b473cdda6061f0f44a>), [CUDA_ERROR_NOT_INITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e98feb999f0af99b4a25ab26b3866f4df8>), [CUDA_ERROR_INVALID_CONTEXT](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a484e9af32c1e9893ff21f0e0191a12d>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>)

###### [Deprecated](<deprecated.html#deprecated__deprecated_1_deprecated000079>)

This function is deprecated as of Cuda 3.0.

###### Description

Unmaps the buffer object specified by `buffer` for access by CUDA.

There must be a valid OpenGL context bound to the current thread when this function is called. This must be the same context, or a member of the same shareGroup, as the context that was bound when the buffer was registered.

Stream `hStream` in the current CUDA context is synchronized with the current GL context.

Note:

Note that this function may also return error codes from previous, asynchronous launches.

**See also:**

[cuGraphicsUnmapResources](<group__CUDA__GRAPHICS.html#group__CUDA__GRAPHICS_1g8e9ff25d071375a0df1cb5aee924af32> "Unmap graphics resources.")

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuGLUnregisterBufferObject ( GLuintÂ buffer )


Unregister an OpenGL buffer object.

######  Parameters

`buffer`
    \- Name of the buffer object to unregister

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_DEINITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9acf52f132faf29b473cdda6061f0f44a>), [CUDA_ERROR_NOT_INITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e98feb999f0af99b4a25ab26b3866f4df8>), [CUDA_ERROR_INVALID_CONTEXT](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a484e9af32c1e9893ff21f0e0191a12d>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>)

###### [Deprecated](<deprecated.html#deprecated__deprecated_1_deprecated000076>)

This function is deprecated as of Cuda 3.0.

###### Description

Unregisters the buffer object specified by `buffer`. This releases any resources associated with the registered buffer. After this call, the buffer may no longer be mapped for access by CUDA.

There must be a valid OpenGL context bound to the current thread when this function is called. This must be the same context, or a member of the same shareGroup, as the context that was bound when the buffer was registered.

Note:

Note that this function may also return error codes from previous, asynchronous launches.

**See also:**

[cuGraphicsUnregisterResource](<group__CUDA__GRAPHICS.html#group__CUDA__GRAPHICS_1ga7e5e97b74eaa13dfa6582e853e4c96d> "Unregisters a graphics resource for access by CUDA.")

* * *


---

# Direct3D 9 Interoperability

## 6.41.Â Direct3D 9 Interoperability

This section describes the Direct3D 9 interoperability functions of the low-level CUDA driver application programming interface. Note that mapping of Direct3D 9 resources is performed with the graphics API agnostic, resource mapping interface described in [Graphics Interoperability](<group__CUDA__GRAPHICS.html#group__CUDA__GRAPHICS>).

### Modules

Â

[Direct3D 9 Interoperability [DEPRECATED]](<group__CUDA__D3D9__DEPRECATED.html#group__CUDA__D3D9__DEPRECATED>)

     [](<group__CUDA__D3D9__DEPRECATED.html#group__CUDA__D3D9__DEPRECATED>)

### Enumerations

enumÂ [CUd3d9DeviceList](<#group__CUDA__D3D9_1g2cf4b668539659fec0dba41bcc999f6d>)


### Functions

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuD3D9CtxCreate](<#group__CUDA__D3D9_1gab201a2284d11b00cdb4d6bba492e520>) ( [CUcontext](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gf9f5bd81658f866613785b3a0bb7d7d9>)*Â pCtx, [CUdevice](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g41ca2a24a242b36ef2ca77330b5fb72a>)*Â pCudaDevice, unsigned int Â Flags, IDirect3DDevice9*Â pD3DDevice )
     Create a CUDA context for interoperability with Direct3D 9.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuD3D9CtxCreateOnDevice](<#group__CUDA__D3D9_1gcaca5329caf0c0253a5a944ecc958742>) ( [CUcontext](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gf9f5bd81658f866613785b3a0bb7d7d9>)*Â pCtx, unsigned int Â flags, IDirect3DDevice9*Â pD3DDevice, [CUdevice](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g41ca2a24a242b36ef2ca77330b5fb72a>)Â cudaDevice )
     Create a CUDA context for interoperability with Direct3D 9.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuD3D9GetDevice](<#group__CUDA__D3D9_1ge293c667e76dafaaf47ce64d0bd91c4d>) ( [CUdevice](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g41ca2a24a242b36ef2ca77330b5fb72a>)*Â pCudaDevice, const char*Â pszAdapterName )
     Gets the CUDA device corresponding to a display adapter.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuD3D9GetDevices](<#group__CUDA__D3D9_1g2c53ac0b20c57738fa497d1f8992f7ad>) ( unsigned int*Â pCudaDeviceCount, [CUdevice](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g41ca2a24a242b36ef2ca77330b5fb72a>)*Â pCudaDevices, unsigned int Â cudaDeviceCount, IDirect3DDevice9*Â pD3D9Device, [CUd3d9DeviceList](<group__CUDA__D3D9.html#group__CUDA__D3D9_1g2cf4b668539659fec0dba41bcc999f6d>)Â deviceList )
     Gets the CUDA devices corresponding to a Direct3D 9 device.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuD3D9GetDirect3DDevice](<#group__CUDA__D3D9_1g439e074e2b46156f859c40ddaaf3d3fb>) ( IDirect3DDevice9**Â ppD3DDevice )
     Get the Direct3D 9 device against which the current CUDA context was created.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuGraphicsD3D9RegisterResource](<#group__CUDA__D3D9_1g391835e0d3c5a34bdba99840157194bf>) ( [CUgraphicsResource](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc0c4e1704647178d9c5ba3be46517dcd>)*Â pCudaResource, IDirect3DResource9*Â pD3DResource, unsigned int Â Flags )
     Register a Direct3D 9 resource for access by CUDA.

### Enumerations

enum CUd3d9DeviceList


CUDA devices corresponding to a D3D9 device

######  Values

CU_D3D9_DEVICE_LIST_ALL = 0x01
    The CUDA devices for all GPUs used by a D3D9 device
CU_D3D9_DEVICE_LIST_CURRENT_FRAME = 0x02
    The CUDA devices for the GPUs used by a D3D9 device in its currently rendering frame
CU_D3D9_DEVICE_LIST_NEXT_FRAME = 0x03
    The CUDA devices for the GPUs to be used by a D3D9 device in the next frame

### Functions

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuD3D9CtxCreate ( [CUcontext](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gf9f5bd81658f866613785b3a0bb7d7d9>)*Â pCtx, [CUdevice](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g41ca2a24a242b36ef2ca77330b5fb72a>)*Â pCudaDevice, unsigned int Â Flags, IDirect3DDevice9*Â pD3DDevice )


Create a CUDA context for interoperability with Direct3D 9.

######  Parameters

`pCtx`
    \- Returned newly created CUDA context
`pCudaDevice`
    \- Returned pointer to the device on which the context was created
`Flags`
    \- Context creation flags (see [cuCtxCreate()](<group__CUDA__CTX.html#group__CUDA__CTX_1g77e9fb578caefca5ed15b4acebf35265> "Create a CUDA context.") for details)
`pD3DDevice`
    \- Direct3D device to create interoperability context with

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_DEINITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9acf52f132faf29b473cdda6061f0f44a>), [CUDA_ERROR_NOT_INITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e98feb999f0af99b4a25ab26b3866f4df8>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>), [CUDA_ERROR_OUT_OF_MEMORY](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9264c50688ed110e8476b591befe60c02>), [CUDA_ERROR_UNKNOWN](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9c5a6ab0245179d297f1fa56ed0097183>)

###### Description

Creates a new CUDA context, enables interoperability for that context with the Direct3D device `pD3DDevice`, and associates the created CUDA context with the calling thread. The created [CUcontext](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gf9f5bd81658f866613785b3a0bb7d7d9>) will be returned in `*pCtx`. Direct3D resources from this device may be registered and mapped through the lifetime of this CUDA context. If `pCudaDevice` is non-NULL then the [CUdevice](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g41ca2a24a242b36ef2ca77330b5fb72a>) on which this CUDA context was created will be returned in `*pCudaDevice`.

On success, this call will increase the internal reference count on `pD3DDevice`. This reference count will be decremented upon destruction of this context through [cuCtxDestroy()](<group__CUDA__CTX.html#group__CUDA__CTX_1g27a365aebb0eb548166309f58a1e8b8e> "Destroy a CUDA context."). This context will cease to function if `pD3DDevice` is destroyed or encounters an error.

Note that this function is never required for correct functionality. Use of this function will result in accelerated interoperability only when the operating system is Windows Vista or Windows 7, and the device `pD3DDdevice` is not an IDirect3DDevice9Ex. In all other circumstances, this function is not necessary.

Note:

Note that this function may also return error codes from previous, asynchronous launches.

**See also:**

[cuD3D9GetDevice](<group__CUDA__D3D9.html#group__CUDA__D3D9_1ge293c667e76dafaaf47ce64d0bd91c4d> "Gets the CUDA device corresponding to a display adapter."), [cuGraphicsD3D9RegisterResource](<group__CUDA__D3D9.html#group__CUDA__D3D9_1g391835e0d3c5a34bdba99840157194bf> "Register a Direct3D 9 resource for access by CUDA.")

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuD3D9CtxCreateOnDevice ( [CUcontext](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gf9f5bd81658f866613785b3a0bb7d7d9>)*Â pCtx, unsigned int Â flags, IDirect3DDevice9*Â pD3DDevice, [CUdevice](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g41ca2a24a242b36ef2ca77330b5fb72a>)Â cudaDevice )


Create a CUDA context for interoperability with Direct3D 9.

######  Parameters

`pCtx`
    \- Returned newly created CUDA context
`flags`
    \- Context creation flags (see [cuCtxCreate()](<group__CUDA__CTX.html#group__CUDA__CTX_1g77e9fb578caefca5ed15b4acebf35265> "Create a CUDA context.") for details)
`pD3DDevice`
    \- Direct3D device to create interoperability context with
`cudaDevice`
    \- The CUDA device on which to create the context. This device must be among the devices returned when querying CU_D3D9_DEVICES_ALL from [cuD3D9GetDevices](<group__CUDA__D3D9.html#group__CUDA__D3D9_1g2c53ac0b20c57738fa497d1f8992f7ad> "Gets the CUDA devices corresponding to a Direct3D 9 device.").

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_DEINITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9acf52f132faf29b473cdda6061f0f44a>), [CUDA_ERROR_NOT_INITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e98feb999f0af99b4a25ab26b3866f4df8>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>), [CUDA_ERROR_OUT_OF_MEMORY](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9264c50688ed110e8476b591befe60c02>), [CUDA_ERROR_UNKNOWN](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9c5a6ab0245179d297f1fa56ed0097183>)

###### Description

Creates a new CUDA context, enables interoperability for that context with the Direct3D device `pD3DDevice`, and associates the created CUDA context with the calling thread. The created [CUcontext](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gf9f5bd81658f866613785b3a0bb7d7d9>) will be returned in `*pCtx`. Direct3D resources from this device may be registered and mapped through the lifetime of this CUDA context.

On success, this call will increase the internal reference count on `pD3DDevice`. This reference count will be decremented upon destruction of this context through [cuCtxDestroy()](<group__CUDA__CTX.html#group__CUDA__CTX_1g27a365aebb0eb548166309f58a1e8b8e> "Destroy a CUDA context."). This context will cease to function if `pD3DDevice` is destroyed or encounters an error.

Note that this function is never required for correct functionality. Use of this function will result in accelerated interoperability only when the operating system is Windows Vista or Windows 7, and the device `pD3DDdevice` is not an IDirect3DDevice9Ex. In all other circumstances, this function is not necessary.

Note:

Note that this function may also return error codes from previous, asynchronous launches.

**See also:**

[cuD3D9GetDevices](<group__CUDA__D3D9.html#group__CUDA__D3D9_1g2c53ac0b20c57738fa497d1f8992f7ad> "Gets the CUDA devices corresponding to a Direct3D 9 device."), [cuGraphicsD3D9RegisterResource](<group__CUDA__D3D9.html#group__CUDA__D3D9_1g391835e0d3c5a34bdba99840157194bf> "Register a Direct3D 9 resource for access by CUDA.")

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuD3D9GetDevice ( [CUdevice](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g41ca2a24a242b36ef2ca77330b5fb72a>)*Â pCudaDevice, const char*Â pszAdapterName )


Gets the CUDA device corresponding to a display adapter.

######  Parameters

`pCudaDevice`
    \- Returned CUDA device corresponding to pszAdapterName
`pszAdapterName`
    \- Adapter name to query for device

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_DEINITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9acf52f132faf29b473cdda6061f0f44a>), [CUDA_ERROR_NOT_INITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e98feb999f0af99b4a25ab26b3866f4df8>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>), [CUDA_ERROR_NOT_FOUND](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9af1cadbeb21d3a78115ca211ba44c053>), [CUDA_ERROR_UNKNOWN](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9c5a6ab0245179d297f1fa56ed0097183>)

###### Description

Returns in `*pCudaDevice` the CUDA-compatible device corresponding to the adapter name `pszAdapterName` obtained from EnumDisplayDevices() or IDirect3D9::GetAdapterIdentifier().

If no device on the adapter with name `pszAdapterName` is CUDA-compatible, then the call will fail.

Note:

Note that this function may also return error codes from previous, asynchronous launches.

**See also:**

[cuD3D9CtxCreate](<group__CUDA__D3D9.html#group__CUDA__D3D9_1gab201a2284d11b00cdb4d6bba492e520> "Create a CUDA context for interoperability with Direct3D 9."), [cudaD3D9GetDevice](<../cuda-runtime-api/group__CUDART__D3D9.html#group__CUDART__D3D9_1gcd070306b3ce6540a3bc309d415f19b2>)

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuD3D9GetDevices ( unsigned int*Â pCudaDeviceCount, [CUdevice](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g41ca2a24a242b36ef2ca77330b5fb72a>)*Â pCudaDevices, unsigned int Â cudaDeviceCount, IDirect3DDevice9*Â pD3D9Device, [CUd3d9DeviceList](<group__CUDA__D3D9.html#group__CUDA__D3D9_1g2cf4b668539659fec0dba41bcc999f6d>)Â deviceList )


Gets the CUDA devices corresponding to a Direct3D 9 device.

######  Parameters

`pCudaDeviceCount`
    \- Returned number of CUDA devices corresponding to `pD3D9Device`
`pCudaDevices`
    \- Returned CUDA devices corresponding to `pD3D9Device`
`cudaDeviceCount`
    \- The size of the output device array `pCudaDevices`
`pD3D9Device`
    \- Direct3D 9 device to query for CUDA devices
`deviceList`
    \- The set of devices to return. This set may be [CU_D3D9_DEVICE_LIST_ALL](<group__CUDA__D3D9.html#group__CUDA__D3D9_1gg2cf4b668539659fec0dba41bcc999f6d7d126d9cf1514d7c41b38cf84113a4dd>) for all devices, [CU_D3D9_DEVICE_LIST_CURRENT_FRAME](<group__CUDA__D3D9.html#group__CUDA__D3D9_1gg2cf4b668539659fec0dba41bcc999f6df8bd68d9d5a86fbf3c9e60ab2e607e41>) for the devices used to render the current frame (in SLI), or [CU_D3D9_DEVICE_LIST_NEXT_FRAME](<group__CUDA__D3D9.html#group__CUDA__D3D9_1gg2cf4b668539659fec0dba41bcc999f6d111afda57f25cc5c51a02078ca0530f2>) for the devices used to render the next frame (in SLI).

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_DEINITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9acf52f132faf29b473cdda6061f0f44a>), [CUDA_ERROR_NOT_INITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e98feb999f0af99b4a25ab26b3866f4df8>), [CUDA_ERROR_NO_DEVICE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9761bea84083d384d4fb88d51d972aada>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>), [CUDA_ERROR_NOT_FOUND](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9af1cadbeb21d3a78115ca211ba44c053>), [CUDA_ERROR_UNKNOWN](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9c5a6ab0245179d297f1fa56ed0097183>)

###### Description

Returns in `*pCudaDeviceCount` the number of CUDA-compatible device corresponding to the Direct3D 9 device `pD3D9Device`. Also returns in `*pCudaDevices` at most `cudaDeviceCount` of the CUDA-compatible devices corresponding to the Direct3D 9 device `pD3D9Device`.

If any of the GPUs being used to render `pDevice` are not CUDA capable then the call will return [CUDA_ERROR_NO_DEVICE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9761bea84083d384d4fb88d51d972aada>).

Note:

Note that this function may also return error codes from previous, asynchronous launches.

**See also:**

[cuD3D9CtxCreate](<group__CUDA__D3D9.html#group__CUDA__D3D9_1gab201a2284d11b00cdb4d6bba492e520> "Create a CUDA context for interoperability with Direct3D 9."), [cudaD3D9GetDevices](<../cuda-runtime-api/group__CUDART__D3D9.html#group__CUDART__D3D9_1g113d44c4c588818e27de685a58412736>)

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuD3D9GetDirect3DDevice ( IDirect3DDevice9**Â ppD3DDevice )


Get the Direct3D 9 device against which the current CUDA context was created.

######  Parameters

`ppD3DDevice`
    \- Returned Direct3D device corresponding to CUDA context

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_DEINITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9acf52f132faf29b473cdda6061f0f44a>), [CUDA_ERROR_NOT_INITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e98feb999f0af99b4a25ab26b3866f4df8>), [CUDA_ERROR_INVALID_CONTEXT](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a484e9af32c1e9893ff21f0e0191a12d>)[CUDA_ERROR_INVALID_GRAPHICS_CONTEXT](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e98667df54ca7b35fa911703978a679839>)

###### Description

Returns in `*ppD3DDevice` the Direct3D device against which this CUDA context was created in [cuD3D9CtxCreate()](<group__CUDA__D3D9.html#group__CUDA__D3D9_1gab201a2284d11b00cdb4d6bba492e520> "Create a CUDA context for interoperability with Direct3D 9.").

Note:

Note that this function may also return error codes from previous, asynchronous launches.

**See also:**

[cuD3D9GetDevice](<group__CUDA__D3D9.html#group__CUDA__D3D9_1ge293c667e76dafaaf47ce64d0bd91c4d> "Gets the CUDA device corresponding to a display adapter."), [cudaD3D9GetDirect3DDevice](<../cuda-runtime-api/group__CUDART__D3D9.html#group__CUDART__D3D9_1g911fe6061c4e0015abf8124ac8e07582>)

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuGraphicsD3D9RegisterResource ( [CUgraphicsResource](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc0c4e1704647178d9c5ba3be46517dcd>)*Â pCudaResource, IDirect3DResource9*Â pD3DResource, unsigned int Â Flags )


Register a Direct3D 9 resource for access by CUDA.

######  Parameters

`pCudaResource`
    \- Returned graphics resource handle
`pD3DResource`
    \- Direct3D resource to register
`Flags`
    \- Parameters for resource registration

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_DEINITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9acf52f132faf29b473cdda6061f0f44a>), [CUDA_ERROR_NOT_INITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e98feb999f0af99b4a25ab26b3866f4df8>), [CUDA_ERROR_INVALID_CONTEXT](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a484e9af32c1e9893ff21f0e0191a12d>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>), [CUDA_ERROR_INVALID_HANDLE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e90fd2e63260c6317ba943af0f7e4b8d21>), [CUDA_ERROR_OUT_OF_MEMORY](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9264c50688ed110e8476b591befe60c02>), [CUDA_ERROR_UNKNOWN](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9c5a6ab0245179d297f1fa56ed0097183>)

###### Description

Registers the Direct3D 9 resource `pD3DResource` for access by CUDA and returns a CUDA handle to `pD3Dresource` in `pCudaResource`. The handle returned in `pCudaResource` may be used to map and unmap this resource until it is unregistered. On success this call will increase the internal reference count on `pD3DResource`. This reference count will be decremented when this resource is unregistered through [cuGraphicsUnregisterResource()](<group__CUDA__GRAPHICS.html#group__CUDA__GRAPHICS_1ga7e5e97b74eaa13dfa6582e853e4c96d> "Unregisters a graphics resource for access by CUDA.").

This call is potentially high-overhead and should not be called every frame in interactive applications.

The type of `pD3DResource` must be one of the following.

  * IDirect3DVertexBuffer9: may be accessed through a device pointer

  * IDirect3DIndexBuffer9: may be accessed through a device pointer

  * IDirect3DSurface9: may be accessed through an array. Only stand-alone objects of type IDirect3DSurface9 may be explicitly shared. In particular, individual mipmap levels and faces of cube maps may not be registered directly. To access individual surfaces associated with a texture, one must register the base texture object.

  * IDirect3DBaseTexture9: individual surfaces on this texture may be accessed through an array.


The `Flags` argument may be used to specify additional parameters at register time. The valid values for this parameter are

  * CU_GRAPHICS_REGISTER_FLAGS_NONE: Specifies no hints about how this resource will be used.

  * CU_GRAPHICS_REGISTER_FLAGS_SURFACE_LDST: Specifies that CUDA will bind this resource to a surface reference.

  * CU_GRAPHICS_REGISTER_FLAGS_TEXTURE_GATHER: Specifies that CUDA will perform texture gather operations on this resource.


Not all Direct3D resources of the above types may be used for interoperability with CUDA. The following are some limitations.

  * The primary rendertarget may not be registered with CUDA.

  * Resources allocated as shared may not be registered with CUDA.

  * Textures which are not of a format which is 1, 2, or 4 channels of 8, 16, or 32-bit integer or floating-point data cannot be shared.

  * Surfaces of depth or stencil formats cannot be shared.


A complete list of supported formats is as follows:

  * D3DFMT_L8

  * D3DFMT_L16

  * D3DFMT_A8R8G8B8

  * D3DFMT_X8R8G8B8

  * D3DFMT_G16R16

  * D3DFMT_A8B8G8R8

  * D3DFMT_A8

  * D3DFMT_A8L8

  * D3DFMT_Q8W8V8U8

  * D3DFMT_V16U16

  * D3DFMT_A16B16G16R16F

  * D3DFMT_A16B16G16R16

  * D3DFMT_R32F

  * D3DFMT_G16R16F

  * D3DFMT_A32B32G32R32F

  * D3DFMT_G32R32F

  * D3DFMT_R16F


If Direct3D interoperability is not initialized for this context using [cuD3D9CtxCreate](<group__CUDA__D3D9.html#group__CUDA__D3D9_1gab201a2284d11b00cdb4d6bba492e520> "Create a CUDA context for interoperability with Direct3D 9.") then [CUDA_ERROR_INVALID_CONTEXT](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a484e9af32c1e9893ff21f0e0191a12d>) is returned. If `pD3DResource` is of incorrect type or is already registered then [CUDA_ERROR_INVALID_HANDLE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e90fd2e63260c6317ba943af0f7e4b8d21>) is returned. If `pD3DResource` cannot be registered then [CUDA_ERROR_UNKNOWN](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9c5a6ab0245179d297f1fa56ed0097183>) is returned. If `Flags` is not one of the above specified value then [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>) is returned.

Note:

Note that this function may also return error codes from previous, asynchronous launches.

**See also:**

[cuD3D9CtxCreate](<group__CUDA__D3D9.html#group__CUDA__D3D9_1gab201a2284d11b00cdb4d6bba492e520> "Create a CUDA context for interoperability with Direct3D 9."), [cuGraphicsUnregisterResource](<group__CUDA__GRAPHICS.html#group__CUDA__GRAPHICS_1ga7e5e97b74eaa13dfa6582e853e4c96d> "Unregisters a graphics resource for access by CUDA."), [cuGraphicsMapResources](<group__CUDA__GRAPHICS.html#group__CUDA__GRAPHICS_1gffcfd8e78d82cc4f6dd987e8bce4edb0> "Map graphics resources for access by CUDA."), [cuGraphicsSubResourceGetMappedArray](<group__CUDA__GRAPHICS.html#group__CUDA__GRAPHICS_1g61c55e987e54558cce547240d6123078> "Get an array through which to access a subresource of a mapped graphics resource."), [cuGraphicsResourceGetMappedPointer](<group__CUDA__GRAPHICS.html#group__CUDA__GRAPHICS_1g8a634cf4150d399f0018061580592457> "Get a device pointer through which to access a mapped graphics resource."), [cudaGraphicsD3D9RegisterResource](<../cuda-runtime-api/group__CUDART__D3D9.html#group__CUDART__D3D9_1gab5efa8a8882a6e0ee99717a434730b0>)

### Direct3D 9 Interoperability [DEPRECATED]

* * *


---

# Direct3D 9 (Deprecated)

## 6.41.1.Â Direct3D 9 Interoperability [DEPRECATED]

## [[Direct3D 9 Interoperability](<group__CUDA__D3D9.html#group__CUDA__D3D9>)]

This section describes deprecated Direct3D 9 interoperability functionality.

### Enumerations

enumÂ [CUd3d9map_flags](<#group__CUDA__D3D9__DEPRECATED_1ge689aa9141452e4048257aabe606d6bc>)

enumÂ [CUd3d9register_flags](<#group__CUDA__D3D9__DEPRECATED_1g8300da18582a2d6b981e74b2348e4f77>)


### Functions

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuD3D9MapResources](<#group__CUDA__D3D9__DEPRECATED_1g092c45dd723d9881c7c95b2fdbecb5d8>) ( unsigned int Â count, IDirect3DResource9**Â ppResource )
     Map Direct3D resources for access by CUDA.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuD3D9RegisterResource](<#group__CUDA__D3D9__DEPRECATED_1g2797f46baff62444656115eae9c8e1de>) ( IDirect3DResource9*Â pResource, unsigned int Â Flags )
     Register a Direct3D resource for access by CUDA.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuD3D9ResourceGetMappedArray](<#group__CUDA__D3D9__DEPRECATED_1g23597dfa283062869d6e62e0c3c03d91>) ( [CUarray](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gd550651524a56766b60f10f0e7628042>)*Â pArray, IDirect3DResource9*Â pResource, unsigned int Â Face, unsigned int Â Level )
     Get an array through which to access a subresource of a Direct3D resource which has been mapped for access by CUDA.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuD3D9ResourceGetMappedPitch](<#group__CUDA__D3D9__DEPRECATED_1g22273146dd5681ccfc473bd9ef82f9f2>) ( size_t*Â pPitch, size_t*Â pPitchSlice, IDirect3DResource9*Â pResource, unsigned int Â Face, unsigned int Â Level )
     Get the pitch of a subresource of a Direct3D resource which has been mapped for access by CUDA.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuD3D9ResourceGetMappedPointer](<#group__CUDA__D3D9__DEPRECATED_1g7fb080fc9497d1f25fe1e3a226c56bdc>) ( [CUdeviceptr](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g183f7b0d8ad008ea2a5fd552537ace4e>)*Â pDevPtr, IDirect3DResource9*Â pResource, unsigned int Â Face, unsigned int Â Level )
     Get the pointer through which to access a subresource of a Direct3D resource which has been mapped for access by CUDA.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuD3D9ResourceGetMappedSize](<#group__CUDA__D3D9__DEPRECATED_1g84dbbbfc3cbb9260e22fea8f632c40ac>) ( size_t*Â pSize, IDirect3DResource9*Â pResource, unsigned int Â Face, unsigned int Â Level )
     Get the size of a subresource of a Direct3D resource which has been mapped for access by CUDA.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuD3D9ResourceGetSurfaceDimensions](<#group__CUDA__D3D9__DEPRECATED_1gdf64c251f6fdc73869b7ccdf34befb1c>) ( size_t*Â pWidth, size_t*Â pHeight, size_t*Â pDepth, IDirect3DResource9*Â pResource, unsigned int Â Face, unsigned int Â Level )
     Get the dimensions of a registered surface.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuD3D9ResourceSetMapFlags](<#group__CUDA__D3D9__DEPRECATED_1gbb78cc5147eaed89e0a9b86dbf2d7408>) ( IDirect3DResource9*Â pResource, unsigned int Â Flags )
     Set usage flags for mapping a Direct3D resource.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuD3D9UnmapResources](<#group__CUDA__D3D9__DEPRECATED_1gb985949a449e21274dd346c538619afe>) ( unsigned int Â count, IDirect3DResource9**Â ppResource )
     Unmaps Direct3D resources.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuD3D9UnregisterResource](<#group__CUDA__D3D9__DEPRECATED_1g4889264b5a904f2dcb0f739ee67c4ce6>) ( IDirect3DResource9*Â pResource )
     Unregister a Direct3D resource.

### Enumerations

enum CUd3d9map_flags


Flags to map or unmap a resource

######  Values

CU_D3D9_MAPRESOURCE_FLAGS_NONE = 0x00

CU_D3D9_MAPRESOURCE_FLAGS_READONLY = 0x01

CU_D3D9_MAPRESOURCE_FLAGS_WRITEDISCARD = 0x02


enum CUd3d9register_flags


Flags to register a resource

######  Values

CU_D3D9_REGISTER_FLAGS_NONE = 0x00

CU_D3D9_REGISTER_FLAGS_ARRAY = 0x01


### Functions

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuD3D9MapResources ( unsigned int Â count, IDirect3DResource9**Â ppResource )


Map Direct3D resources for access by CUDA.

######  Parameters

`count`
    \- Number of resources in ppResource
`ppResource`
    \- Resources to map for CUDA usage

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_DEINITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9acf52f132faf29b473cdda6061f0f44a>), [CUDA_ERROR_NOT_INITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e98feb999f0af99b4a25ab26b3866f4df8>), [CUDA_ERROR_INVALID_CONTEXT](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a484e9af32c1e9893ff21f0e0191a12d>), [CUDA_ERROR_INVALID_HANDLE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e90fd2e63260c6317ba943af0f7e4b8d21>), [CUDA_ERROR_ALREADY_MAPPED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9240bb253a699176d9f49ee2f2c91b61b>), [CUDA_ERROR_UNKNOWN](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9c5a6ab0245179d297f1fa56ed0097183>)

###### [Deprecated](<deprecated.html#deprecated__deprecated_1_deprecated000082>)

This function is deprecated as of CUDA 3.0.

###### Description

Maps the `count` Direct3D resources in `ppResource` for access by CUDA.

The resources in `ppResource` may be accessed in CUDA kernels until they are unmapped. Direct3D should not access any resources while they are mapped by CUDA. If an application does so the results are undefined.

This function provides the synchronization guarantee that any Direct3D calls issued before [cuD3D9MapResources()](<group__CUDA__D3D9__DEPRECATED.html#group__CUDA__D3D9__DEPRECATED_1g092c45dd723d9881c7c95b2fdbecb5d8> "Map Direct3D resources for access by CUDA.") will complete before any CUDA kernels issued after [cuD3D9MapResources()](<group__CUDA__D3D9__DEPRECATED.html#group__CUDA__D3D9__DEPRECATED_1g092c45dd723d9881c7c95b2fdbecb5d8> "Map Direct3D resources for access by CUDA.") begin.

If any of `ppResource` have not been registered for use with CUDA or if `ppResource` contains any duplicate entries, then [CUDA_ERROR_INVALID_HANDLE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e90fd2e63260c6317ba943af0f7e4b8d21>) is returned. If any of `ppResource` are presently mapped for access by CUDA, then [CUDA_ERROR_ALREADY_MAPPED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9240bb253a699176d9f49ee2f2c91b61b>) is returned.

Note:

Note that this function may also return error codes from previous, asynchronous launches.

**See also:**

[cuGraphicsMapResources](<group__CUDA__GRAPHICS.html#group__CUDA__GRAPHICS_1gffcfd8e78d82cc4f6dd987e8bce4edb0> "Map graphics resources for access by CUDA.")

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuD3D9RegisterResource ( IDirect3DResource9*Â pResource, unsigned int Â Flags )


Register a Direct3D resource for access by CUDA.

######  Parameters

`pResource`
    \- Resource to register for CUDA access
`Flags`
    \- Flags for resource registration

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_DEINITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9acf52f132faf29b473cdda6061f0f44a>), [CUDA_ERROR_NOT_INITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e98feb999f0af99b4a25ab26b3866f4df8>), [CUDA_ERROR_INVALID_CONTEXT](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a484e9af32c1e9893ff21f0e0191a12d>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>), [CUDA_ERROR_INVALID_HANDLE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e90fd2e63260c6317ba943af0f7e4b8d21>), [CUDA_ERROR_OUT_OF_MEMORY](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9264c50688ed110e8476b591befe60c02>), [CUDA_ERROR_UNKNOWN](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9c5a6ab0245179d297f1fa56ed0097183>)

###### [Deprecated](<deprecated.html#deprecated__deprecated_1_deprecated000080>)

This function is deprecated as of CUDA 3.0.

###### Description

Registers the Direct3D resource `pResource` for access by CUDA.

If this call is successful, then the application will be able to map and unmap this resource until it is unregistered through [cuD3D9UnregisterResource()](<group__CUDA__D3D9__DEPRECATED.html#group__CUDA__D3D9__DEPRECATED_1g4889264b5a904f2dcb0f739ee67c4ce6> "Unregister a Direct3D resource."). Also on success, this call will increase the internal reference count on `pResource`. This reference count will be decremented when this resource is unregistered through [cuD3D9UnregisterResource()](<group__CUDA__D3D9__DEPRECATED.html#group__CUDA__D3D9__DEPRECATED_1g4889264b5a904f2dcb0f739ee67c4ce6> "Unregister a Direct3D resource.").

This call is potentially high-overhead and should not be called every frame in interactive applications.

The type of `pResource` must be one of the following.

  * IDirect3DVertexBuffer9: Cannot be used with `Flags` set to CU_D3D9_REGISTER_FLAGS_ARRAY.

  * IDirect3DIndexBuffer9: Cannot be used with `Flags` set to CU_D3D9_REGISTER_FLAGS_ARRAY.

  * IDirect3DSurface9: Only stand-alone objects of type IDirect3DSurface9 may be explicitly shared. In particular, individual mipmap levels and faces of cube maps may not be registered directly. To access individual surfaces associated with a texture, one must register the base texture object. For restrictions on the `Flags` parameter, see type IDirect3DBaseTexture9.

  * IDirect3DBaseTexture9: When a texture is registered, all surfaces associated with the all mipmap levels of all faces of the texture will be accessible to CUDA.


The `Flags` argument specifies the mechanism through which CUDA will access the Direct3D resource. The following values are allowed.

  * CU_D3D9_REGISTER_FLAGS_NONE: Specifies that CUDA will access this resource through a [CUdeviceptr](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g183f7b0d8ad008ea2a5fd552537ace4e>). The pointer, size, and (for textures), pitch for each subresource of this allocation may be queried through [cuD3D9ResourceGetMappedPointer()](<group__CUDA__D3D9__DEPRECATED.html#group__CUDA__D3D9__DEPRECATED_1g7fb080fc9497d1f25fe1e3a226c56bdc> "Get the pointer through which to access a subresource of a Direct3D resource which has been mapped for access by CUDA."), [cuD3D9ResourceGetMappedSize()](<group__CUDA__D3D9__DEPRECATED.html#group__CUDA__D3D9__DEPRECATED_1g84dbbbfc3cbb9260e22fea8f632c40ac> "Get the size of a subresource of a Direct3D resource which has been mapped for access by CUDA."), and [cuD3D9ResourceGetMappedPitch()](<group__CUDA__D3D9__DEPRECATED.html#group__CUDA__D3D9__DEPRECATED_1g22273146dd5681ccfc473bd9ef82f9f2> "Get the pitch of a subresource of a Direct3D resource which has been mapped for access by CUDA.") respectively. This option is valid for all resource types.

  * CU_D3D9_REGISTER_FLAGS_ARRAY: Specifies that CUDA will access this resource through a [CUarray](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gd550651524a56766b60f10f0e7628042>) queried on a sub-resource basis through [cuD3D9ResourceGetMappedArray()](<group__CUDA__D3D9__DEPRECATED.html#group__CUDA__D3D9__DEPRECATED_1g23597dfa283062869d6e62e0c3c03d91> "Get an array through which to access a subresource of a Direct3D resource which has been mapped for access by CUDA."). This option is only valid for resources of type IDirect3DSurface9 and subtypes of IDirect3DBaseTexture9.


Not all Direct3D resources of the above types may be used for interoperability with CUDA. The following are some limitations.

  * The primary rendertarget may not be registered with CUDA.

  * Resources allocated as shared may not be registered with CUDA.

  * Any resources allocated in D3DPOOL_SYSTEMMEM or D3DPOOL_MANAGED may not be registered with CUDA.

  * Textures which are not of a format which is 1, 2, or 4 channels of 8, 16, or 32-bit integer or floating-point data cannot be shared.

  * Surfaces of depth or stencil formats cannot be shared.


If Direct3D interoperability is not initialized on this context, then [CUDA_ERROR_INVALID_CONTEXT](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a484e9af32c1e9893ff21f0e0191a12d>) is returned. If `pResource` is of incorrect type (e.g. is a non-stand-alone IDirect3DSurface9) or is already registered, then [CUDA_ERROR_INVALID_HANDLE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e90fd2e63260c6317ba943af0f7e4b8d21>) is returned. If `pResource` cannot be registered then [CUDA_ERROR_UNKNOWN](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9c5a6ab0245179d297f1fa56ed0097183>) is returned.

Note:

Note that this function may also return error codes from previous, asynchronous launches.

**See also:**

[cuGraphicsD3D9RegisterResource](<group__CUDA__D3D9.html#group__CUDA__D3D9_1g391835e0d3c5a34bdba99840157194bf> "Register a Direct3D 9 resource for access by CUDA.")

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuD3D9ResourceGetMappedArray ( [CUarray](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gd550651524a56766b60f10f0e7628042>)*Â pArray, IDirect3DResource9*Â pResource, unsigned int Â Face, unsigned int Â Level )


Get an array through which to access a subresource of a Direct3D resource which has been mapped for access by CUDA.

######  Parameters

`pArray`
    \- Returned array corresponding to subresource
`pResource`
    \- Mapped resource to access
`Face`
    \- Face of resource to access
`Level`
    \- Level of resource to access

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_DEINITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9acf52f132faf29b473cdda6061f0f44a>), [CUDA_ERROR_NOT_INITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e98feb999f0af99b4a25ab26b3866f4df8>), [CUDA_ERROR_INVALID_CONTEXT](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a484e9af32c1e9893ff21f0e0191a12d>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>), [CUDA_ERROR_INVALID_HANDLE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e90fd2e63260c6317ba943af0f7e4b8d21>), [CUDA_ERROR_NOT_MAPPED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9e098433b926c9afdb6b6bdf191629447>)

###### [Deprecated](<deprecated.html#deprecated__deprecated_1_deprecated000086>)

This function is deprecated as of CUDA 3.0.

###### Description

Returns in `*pArray` an array through which the subresource of the mapped Direct3D resource `pResource` which corresponds to `Face` and `Level` may be accessed. The value set in `pArray` may change every time that `pResource` is mapped.

If `pResource` is not registered then [CUDA_ERROR_INVALID_HANDLE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e90fd2e63260c6317ba943af0f7e4b8d21>) is returned. If `pResource` was not registered with usage flags CU_D3D9_REGISTER_FLAGS_ARRAY then [CUDA_ERROR_INVALID_HANDLE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e90fd2e63260c6317ba943af0f7e4b8d21>) is returned. If `pResource` is not mapped then [CUDA_ERROR_NOT_MAPPED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9e098433b926c9afdb6b6bdf191629447>) is returned.

For usage requirements of `Face` and `Level` parameters, see [cuD3D9ResourceGetMappedPointer()](<group__CUDA__D3D9__DEPRECATED.html#group__CUDA__D3D9__DEPRECATED_1g7fb080fc9497d1f25fe1e3a226c56bdc> "Get the pointer through which to access a subresource of a Direct3D resource which has been mapped for access by CUDA.").

Note:

Note that this function may also return error codes from previous, asynchronous launches.

**See also:**

[cuGraphicsSubResourceGetMappedArray](<group__CUDA__GRAPHICS.html#group__CUDA__GRAPHICS_1g61c55e987e54558cce547240d6123078> "Get an array through which to access a subresource of a mapped graphics resource.")

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuD3D9ResourceGetMappedPitch ( size_t*Â pPitch, size_t*Â pPitchSlice, IDirect3DResource9*Â pResource, unsigned int Â Face, unsigned int Â Level )


Get the pitch of a subresource of a Direct3D resource which has been mapped for access by CUDA.

######  Parameters

`pPitch`
    \- Returned pitch of subresource
`pPitchSlice`
    \- Returned Z-slice pitch of subresource
`pResource`
    \- Mapped resource to access
`Face`
    \- Face of resource to access
`Level`
    \- Level of resource to access

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_DEINITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9acf52f132faf29b473cdda6061f0f44a>), [CUDA_ERROR_NOT_INITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e98feb999f0af99b4a25ab26b3866f4df8>), [CUDA_ERROR_INVALID_CONTEXT](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a484e9af32c1e9893ff21f0e0191a12d>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>), [CUDA_ERROR_INVALID_HANDLE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e90fd2e63260c6317ba943af0f7e4b8d21>), [CUDA_ERROR_NOT_MAPPED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9e098433b926c9afdb6b6bdf191629447>)

###### [Deprecated](<deprecated.html#deprecated__deprecated_1_deprecated000089>)

This function is deprecated as of CUDA 3.0.

###### Description

Returns in `*pPitch` and `*pPitchSlice` the pitch and Z-slice pitch of the subresource of the mapped Direct3D resource `pResource`, which corresponds to `Face` and `Level`. The values set in `pPitch` and `pPitchSlice` may change every time that `pResource` is mapped.

The pitch and Z-slice pitch values may be used to compute the location of a sample on a surface as follows.

For a 2D surface, the byte offset of the sample at position **x** , **y** from the base pointer of the surface is:

**y** * **pitch** \+ (**bytes per pixel**) * **x**

For a 3D surface, the byte offset of the sample at position **x** , **y** , **z** from the base pointer of the surface is:

**z*** **slicePitch** \+ **y** * **pitch** \+ (**bytes per pixel**) * **x**

Both parameters `pPitch` and `pPitchSlice` are optional and may be set to NULL.

If `pResource` is not of type IDirect3DBaseTexture9 or one of its sub-types or if `pResource` has not been registered for use with CUDA, then [cudaErrorInvalidResourceHandle](<../cuda-runtime-api/group__CUDART__TYPES.html#group__CUDART__TYPES_1gg3f51e3575c2178246db0a94a430e0038c4673247aee4d1ab8d07871f376e0273>) is returned. If `pResource` was not registered with usage flags CU_D3D9_REGISTER_FLAGS_NONE, then [CUDA_ERROR_INVALID_HANDLE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e90fd2e63260c6317ba943af0f7e4b8d21>) is returned. If `pResource` is not mapped for access by CUDA then [CUDA_ERROR_NOT_MAPPED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9e098433b926c9afdb6b6bdf191629447>) is returned.

For usage requirements of `Face` and `Level` parameters, see [cuD3D9ResourceGetMappedPointer()](<group__CUDA__D3D9__DEPRECATED.html#group__CUDA__D3D9__DEPRECATED_1g7fb080fc9497d1f25fe1e3a226c56bdc> "Get the pointer through which to access a subresource of a Direct3D resource which has been mapped for access by CUDA.").

Note:

Note that this function may also return error codes from previous, asynchronous launches.

**See also:**

[cuGraphicsSubResourceGetMappedArray](<group__CUDA__GRAPHICS.html#group__CUDA__GRAPHICS_1g61c55e987e54558cce547240d6123078> "Get an array through which to access a subresource of a mapped graphics resource.")

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuD3D9ResourceGetMappedPointer ( [CUdeviceptr](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g183f7b0d8ad008ea2a5fd552537ace4e>)*Â pDevPtr, IDirect3DResource9*Â pResource, unsigned int Â Face, unsigned int Â Level )


Get the pointer through which to access a subresource of a Direct3D resource which has been mapped for access by CUDA.

######  Parameters

`pDevPtr`
    \- Returned pointer corresponding to subresource
`pResource`
    \- Mapped resource to access
`Face`
    \- Face of resource to access
`Level`
    \- Level of resource to access

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_DEINITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9acf52f132faf29b473cdda6061f0f44a>), [CUDA_ERROR_NOT_INITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e98feb999f0af99b4a25ab26b3866f4df8>), [CUDA_ERROR_INVALID_CONTEXT](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a484e9af32c1e9893ff21f0e0191a12d>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>), [CUDA_ERROR_INVALID_HANDLE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e90fd2e63260c6317ba943af0f7e4b8d21>), [CUDA_ERROR_NOT_MAPPED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9e098433b926c9afdb6b6bdf191629447>)

###### [Deprecated](<deprecated.html#deprecated__deprecated_1_deprecated000087>)

This function is deprecated as of CUDA 3.0.

###### Description

Returns in `*pDevPtr` the base pointer of the subresource of the mapped Direct3D resource `pResource`, which corresponds to `Face` and `Level`. The value set in `pDevPtr` may change every time that `pResource` is mapped.

If `pResource` is not registered, then [CUDA_ERROR_INVALID_HANDLE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e90fd2e63260c6317ba943af0f7e4b8d21>) is returned. If `pResource` was not registered with usage flags CU_D3D9_REGISTER_FLAGS_NONE, then [CUDA_ERROR_INVALID_HANDLE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e90fd2e63260c6317ba943af0f7e4b8d21>) is returned. If `pResource` is not mapped, then [CUDA_ERROR_NOT_MAPPED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9e098433b926c9afdb6b6bdf191629447>) is returned.

If `pResource` is of type IDirect3DCubeTexture9, then `Face` must one of the values enumerated by type D3DCUBEMAP_FACES. For all other types `Face` must be 0. If `Face` is invalid, then [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>) is returned.

If `pResource` is of type IDirect3DBaseTexture9, then `Level` must correspond to a valid mipmap level. At present only mipmap level 0 is supported. For all other types `Level` must be 0. If `Level` is invalid, then [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>) is returned.

Note:

Note that this function may also return error codes from previous, asynchronous launches.

**See also:**

[cuGraphicsResourceGetMappedPointer](<group__CUDA__GRAPHICS.html#group__CUDA__GRAPHICS_1g8a634cf4150d399f0018061580592457> "Get a device pointer through which to access a mapped graphics resource.")

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuD3D9ResourceGetMappedSize ( size_t*Â pSize, IDirect3DResource9*Â pResource, unsigned int Â Face, unsigned int Â Level )


Get the size of a subresource of a Direct3D resource which has been mapped for access by CUDA.

######  Parameters

`pSize`
    \- Returned size of subresource
`pResource`
    \- Mapped resource to access
`Face`
    \- Face of resource to access
`Level`
    \- Level of resource to access

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_DEINITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9acf52f132faf29b473cdda6061f0f44a>), [CUDA_ERROR_NOT_INITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e98feb999f0af99b4a25ab26b3866f4df8>), [CUDA_ERROR_INVALID_CONTEXT](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a484e9af32c1e9893ff21f0e0191a12d>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>), [CUDA_ERROR_INVALID_HANDLE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e90fd2e63260c6317ba943af0f7e4b8d21>), [CUDA_ERROR_NOT_MAPPED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9e098433b926c9afdb6b6bdf191629447>)

###### [Deprecated](<deprecated.html#deprecated__deprecated_1_deprecated000088>)

This function is deprecated as of CUDA 3.0.

###### Description

Returns in `*pSize` the size of the subresource of the mapped Direct3D resource `pResource`, which corresponds to `Face` and `Level`. The value set in `pSize` may change every time that `pResource` is mapped.

If `pResource` has not been registered for use with CUDA, then [CUDA_ERROR_INVALID_HANDLE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e90fd2e63260c6317ba943af0f7e4b8d21>) is returned. If `pResource` was not registered with usage flags CU_D3D9_REGISTER_FLAGS_NONE, then [CUDA_ERROR_INVALID_HANDLE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e90fd2e63260c6317ba943af0f7e4b8d21>) is returned. If `pResource` is not mapped for access by CUDA, then [CUDA_ERROR_NOT_MAPPED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9e098433b926c9afdb6b6bdf191629447>) is returned.

For usage requirements of `Face` and `Level` parameters, see [cuD3D9ResourceGetMappedPointer](<group__CUDA__D3D9__DEPRECATED.html#group__CUDA__D3D9__DEPRECATED_1g7fb080fc9497d1f25fe1e3a226c56bdc> "Get the pointer through which to access a subresource of a Direct3D resource which has been mapped for access by CUDA.").

Note:

Note that this function may also return error codes from previous, asynchronous launches.

**See also:**

[cuGraphicsResourceGetMappedPointer](<group__CUDA__GRAPHICS.html#group__CUDA__GRAPHICS_1g8a634cf4150d399f0018061580592457> "Get a device pointer through which to access a mapped graphics resource.")

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuD3D9ResourceGetSurfaceDimensions ( size_t*Â pWidth, size_t*Â pHeight, size_t*Â pDepth, IDirect3DResource9*Â pResource, unsigned int Â Face, unsigned int Â Level )


Get the dimensions of a registered surface.

######  Parameters

`pWidth`
    \- Returned width of surface
`pHeight`
    \- Returned height of surface
`pDepth`
    \- Returned depth of surface
`pResource`
    \- Registered resource to access
`Face`
    \- Face of resource to access
`Level`
    \- Level of resource to access

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_DEINITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9acf52f132faf29b473cdda6061f0f44a>), [CUDA_ERROR_NOT_INITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e98feb999f0af99b4a25ab26b3866f4df8>), [CUDA_ERROR_INVALID_CONTEXT](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a484e9af32c1e9893ff21f0e0191a12d>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>), [CUDA_ERROR_INVALID_HANDLE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e90fd2e63260c6317ba943af0f7e4b8d21>)

###### [Deprecated](<deprecated.html#deprecated__deprecated_1_deprecated000085>)

This function is deprecated as of CUDA 3.0.

###### Description

Returns in `*pWidth`, `*pHeight`, and `*pDepth` the dimensions of the subresource of the mapped Direct3D resource `pResource`, which corresponds to `Face` and `Level`.

Because anti-aliased surfaces may have multiple samples per pixel, it is possible that the dimensions of a resource will be an integer factor larger than the dimensions reported by the Direct3D runtime.

The parameters `pWidth`, `pHeight`, and `pDepth` are optional. For 2D surfaces, the value returned in `*pDepth` will be 0.

If `pResource` is not of type IDirect3DBaseTexture9 or IDirect3DSurface9 or if `pResource` has not been registered for use with CUDA, then [CUDA_ERROR_INVALID_HANDLE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e90fd2e63260c6317ba943af0f7e4b8d21>) is returned.

For usage requirements of `Face` and `Level` parameters, see [cuD3D9ResourceGetMappedPointer()](<group__CUDA__D3D9__DEPRECATED.html#group__CUDA__D3D9__DEPRECATED_1g7fb080fc9497d1f25fe1e3a226c56bdc> "Get the pointer through which to access a subresource of a Direct3D resource which has been mapped for access by CUDA.").

Note:

Note that this function may also return error codes from previous, asynchronous launches.

**See also:**

[cuGraphicsSubResourceGetMappedArray](<group__CUDA__GRAPHICS.html#group__CUDA__GRAPHICS_1g61c55e987e54558cce547240d6123078> "Get an array through which to access a subresource of a mapped graphics resource.")

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuD3D9ResourceSetMapFlags ( IDirect3DResource9*Â pResource, unsigned int Â Flags )


Set usage flags for mapping a Direct3D resource.

######  Parameters

`pResource`
    \- Registered resource to set flags for
`Flags`
    \- Parameters for resource mapping

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_DEINITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9acf52f132faf29b473cdda6061f0f44a>), [CUDA_ERROR_NOT_INITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e98feb999f0af99b4a25ab26b3866f4df8>), [CUDA_ERROR_INVALID_CONTEXT](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a484e9af32c1e9893ff21f0e0191a12d>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>), [CUDA_ERROR_INVALID_HANDLE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e90fd2e63260c6317ba943af0f7e4b8d21>), [CUDA_ERROR_ALREADY_MAPPED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9240bb253a699176d9f49ee2f2c91b61b>)

###### [Deprecated](<deprecated.html#deprecated__deprecated_1_deprecated000084>)

This function is deprecated as of Cuda 3.0.

###### Description

Set `Flags` for mapping the Direct3D resource `pResource`.

Changes to `Flags` will take effect the next time `pResource` is mapped. The `Flags` argument may be any of the following:

  * CU_D3D9_MAPRESOURCE_FLAGS_NONE: Specifies no hints about how this resource will be used. It is therefore assumed that this resource will be read from and written to by CUDA kernels. This is the default value.

  * CU_D3D9_MAPRESOURCE_FLAGS_READONLY: Specifies that CUDA kernels which access this resource will not write to this resource.

  * CU_D3D9_MAPRESOURCE_FLAGS_WRITEDISCARD: Specifies that CUDA kernels which access this resource will not read from this resource and will write over the entire contents of the resource, so none of the data previously stored in the resource will be preserved.


If `pResource` has not been registered for use with CUDA, then [CUDA_ERROR_INVALID_HANDLE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e90fd2e63260c6317ba943af0f7e4b8d21>) is returned. If `pResource` is presently mapped for access by CUDA, then [CUDA_ERROR_ALREADY_MAPPED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9240bb253a699176d9f49ee2f2c91b61b>) is returned.

Note:

Note that this function may also return error codes from previous, asynchronous launches.

**See also:**

[cuGraphicsResourceSetMapFlags](<group__CUDA__GRAPHICS.html#group__CUDA__GRAPHICS_1gfe96aa7747f8b11d44a6fa6a851e1b39> "Set usage flags for mapping a graphics resource.")

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuD3D9UnmapResources ( unsigned int Â count, IDirect3DResource9**Â ppResource )


Unmaps Direct3D resources.

######  Parameters

`count`
    \- Number of resources to unmap for CUDA
`ppResource`
    \- Resources to unmap for CUDA

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_DEINITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9acf52f132faf29b473cdda6061f0f44a>), [CUDA_ERROR_NOT_INITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e98feb999f0af99b4a25ab26b3866f4df8>), [CUDA_ERROR_INVALID_CONTEXT](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a484e9af32c1e9893ff21f0e0191a12d>), [CUDA_ERROR_INVALID_HANDLE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e90fd2e63260c6317ba943af0f7e4b8d21>), [CUDA_ERROR_NOT_MAPPED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9e098433b926c9afdb6b6bdf191629447>), [CUDA_ERROR_UNKNOWN](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9c5a6ab0245179d297f1fa56ed0097183>)

###### [Deprecated](<deprecated.html#deprecated__deprecated_1_deprecated000083>)

This function is deprecated as of CUDA 3.0.

###### Description

Unmaps the `count` Direct3D resources in `ppResource`.

This function provides the synchronization guarantee that any CUDA kernels issued before [cuD3D9UnmapResources()](<group__CUDA__D3D9__DEPRECATED.html#group__CUDA__D3D9__DEPRECATED_1gb985949a449e21274dd346c538619afe> "Unmaps Direct3D resources.") will complete before any Direct3D calls issued after [cuD3D9UnmapResources()](<group__CUDA__D3D9__DEPRECATED.html#group__CUDA__D3D9__DEPRECATED_1gb985949a449e21274dd346c538619afe> "Unmaps Direct3D resources.") begin.

If any of `ppResource` have not been registered for use with CUDA or if `ppResource` contains any duplicate entries, then [CUDA_ERROR_INVALID_HANDLE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e90fd2e63260c6317ba943af0f7e4b8d21>) is returned. If any of `ppResource` are not presently mapped for access by CUDA, then [CUDA_ERROR_NOT_MAPPED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9e098433b926c9afdb6b6bdf191629447>) is returned.

Note:

Note that this function may also return error codes from previous, asynchronous launches.

**See also:**

[cuGraphicsUnmapResources](<group__CUDA__GRAPHICS.html#group__CUDA__GRAPHICS_1g8e9ff25d071375a0df1cb5aee924af32> "Unmap graphics resources.")

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuD3D9UnregisterResource ( IDirect3DResource9*Â pResource )


Unregister a Direct3D resource.

######  Parameters

`pResource`
    \- Resource to unregister

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_DEINITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9acf52f132faf29b473cdda6061f0f44a>), [CUDA_ERROR_NOT_INITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e98feb999f0af99b4a25ab26b3866f4df8>), [CUDA_ERROR_INVALID_CONTEXT](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a484e9af32c1e9893ff21f0e0191a12d>), [CUDA_ERROR_INVALID_HANDLE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e90fd2e63260c6317ba943af0f7e4b8d21>), [CUDA_ERROR_UNKNOWN](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9c5a6ab0245179d297f1fa56ed0097183>)

###### [Deprecated](<deprecated.html#deprecated__deprecated_1_deprecated000081>)

This function is deprecated as of CUDA 3.0.

###### Description

Unregisters the Direct3D resource `pResource` so it is not accessible by CUDA unless registered again.

If `pResource` is not registered, then [CUDA_ERROR_INVALID_HANDLE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e90fd2e63260c6317ba943af0f7e4b8d21>) is returned.

Note:

Note that this function may also return error codes from previous, asynchronous launches.

**See also:**

[cuGraphicsUnregisterResource](<group__CUDA__GRAPHICS.html#group__CUDA__GRAPHICS_1ga7e5e97b74eaa13dfa6582e853e4c96d> "Unregisters a graphics resource for access by CUDA.")

* * *


---

# Direct3D 10 Interoperability

## 6.42.Â Direct3D 10 Interoperability

This section describes the Direct3D 10 interoperability functions of the low-level CUDA driver application programming interface. Note that mapping of Direct3D 10 resources is performed with the graphics API agnostic, resource mapping interface described in [Graphics Interoperability](<group__CUDA__GRAPHICS.html#group__CUDA__GRAPHICS>).

### Modules

Â

[Direct3D 10 Interoperability [DEPRECATED]](<group__CUDA__D3D10__DEPRECATED.html#group__CUDA__D3D10__DEPRECATED>)

     [](<group__CUDA__D3D10__DEPRECATED.html#group__CUDA__D3D10__DEPRECATED>)

### Enumerations

enumÂ [CUd3d10DeviceList](<#group__CUDA__D3D10_1g6c6dadb6de5493a111271be299f62b99>)


### Functions

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuD3D10GetDevice](<#group__CUDA__D3D10_1g98e0c9dcac9771d45112053045e0c34f>) ( [CUdevice](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g41ca2a24a242b36ef2ca77330b5fb72a>)*Â pCudaDevice, IDXGIAdapter*Â pAdapter )
     Gets the CUDA device corresponding to a display adapter.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuD3D10GetDevices](<#group__CUDA__D3D10_1gdcc33dea972d5b834f45a0acefe5fe77>) ( unsigned int*Â pCudaDeviceCount, [CUdevice](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g41ca2a24a242b36ef2ca77330b5fb72a>)*Â pCudaDevices, unsigned int Â cudaDeviceCount, ID3D10Device*Â pD3D10Device, [CUd3d10DeviceList](<group__CUDA__D3D10.html#group__CUDA__D3D10_1g6c6dadb6de5493a111271be299f62b99>)Â deviceList )
     Gets the CUDA devices corresponding to a Direct3D 10 device.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuGraphicsD3D10RegisterResource](<#group__CUDA__D3D10_1g87fb2a189c27c4b63538d23f53b2c8e6>) ( [CUgraphicsResource](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc0c4e1704647178d9c5ba3be46517dcd>)*Â pCudaResource, ID3D10Resource*Â pD3DResource, unsigned int Â Flags )
     Register a Direct3D 10 resource for access by CUDA.

### Enumerations

enum CUd3d10DeviceList


CUDA devices corresponding to a D3D10 device

######  Values

CU_D3D10_DEVICE_LIST_ALL = 0x01
    The CUDA devices for all GPUs used by a D3D10 device
CU_D3D10_DEVICE_LIST_CURRENT_FRAME = 0x02
    The CUDA devices for the GPUs used by a D3D10 device in its currently rendering frame
CU_D3D10_DEVICE_LIST_NEXT_FRAME = 0x03
    The CUDA devices for the GPUs to be used by a D3D10 device in the next frame

### Functions

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuD3D10GetDevice ( [CUdevice](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g41ca2a24a242b36ef2ca77330b5fb72a>)*Â pCudaDevice, IDXGIAdapter*Â pAdapter )


Gets the CUDA device corresponding to a display adapter.

######  Parameters

`pCudaDevice`
    \- Returned CUDA device corresponding to `pAdapter`
`pAdapter`
    \- Adapter to query for CUDA device

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_DEINITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9acf52f132faf29b473cdda6061f0f44a>), [CUDA_ERROR_NOT_INITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e98feb999f0af99b4a25ab26b3866f4df8>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>), [CUDA_ERROR_NOT_FOUND](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9af1cadbeb21d3a78115ca211ba44c053>), [CUDA_ERROR_UNKNOWN](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9c5a6ab0245179d297f1fa56ed0097183>)

###### Description

Returns in `*pCudaDevice` the CUDA-compatible device corresponding to the adapter `pAdapter` obtained from IDXGIFactory::EnumAdapters.

If no device on `pAdapter` is CUDA-compatible then the call will fail.

Note:

Note that this function may also return error codes from previous, asynchronous launches.

**See also:**

[cuD3D10GetDevices](<group__CUDA__D3D10.html#group__CUDA__D3D10_1gdcc33dea972d5b834f45a0acefe5fe77> "Gets the CUDA devices corresponding to a Direct3D 10 device."), [cudaD3D10GetDevice](<../cuda-runtime-api/group__CUDART__D3D10.html#group__CUDART__D3D10_1g9c053ca39e9c4a3dfcc65326db155fa6>)

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuD3D10GetDevices ( unsigned int*Â pCudaDeviceCount, [CUdevice](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g41ca2a24a242b36ef2ca77330b5fb72a>)*Â pCudaDevices, unsigned int Â cudaDeviceCount, ID3D10Device*Â pD3D10Device, [CUd3d10DeviceList](<group__CUDA__D3D10.html#group__CUDA__D3D10_1g6c6dadb6de5493a111271be299f62b99>)Â deviceList )


Gets the CUDA devices corresponding to a Direct3D 10 device.

######  Parameters

`pCudaDeviceCount`
    \- Returned number of CUDA devices corresponding to `pD3D10Device`
`pCudaDevices`
    \- Returned CUDA devices corresponding to `pD3D10Device`
`cudaDeviceCount`
    \- The size of the output device array `pCudaDevices`
`pD3D10Device`
    \- Direct3D 10 device to query for CUDA devices
`deviceList`
    \- The set of devices to return. This set may be [CU_D3D10_DEVICE_LIST_ALL](<group__CUDA__D3D10.html#group__CUDA__D3D10_1gg6c6dadb6de5493a111271be299f62b99245d88858362d72f1e235d99895cb2f4>) for all devices, [CU_D3D10_DEVICE_LIST_CURRENT_FRAME](<group__CUDA__D3D10.html#group__CUDA__D3D10_1gg6c6dadb6de5493a111271be299f62b9955e91512320c16f4334e3607a10ae61d>) for the devices used to render the current frame (in SLI), or [CU_D3D10_DEVICE_LIST_NEXT_FRAME](<group__CUDA__D3D10.html#group__CUDA__D3D10_1gg6c6dadb6de5493a111271be299f62b99049f702f1ca930b270efbb55b4b0093c>) for the devices used to render the next frame (in SLI).

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_DEINITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9acf52f132faf29b473cdda6061f0f44a>), [CUDA_ERROR_NOT_INITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e98feb999f0af99b4a25ab26b3866f4df8>), [CUDA_ERROR_NO_DEVICE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9761bea84083d384d4fb88d51d972aada>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>), [CUDA_ERROR_NOT_FOUND](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9af1cadbeb21d3a78115ca211ba44c053>), [CUDA_ERROR_UNKNOWN](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9c5a6ab0245179d297f1fa56ed0097183>)

###### Description

Returns in `*pCudaDeviceCount` the number of CUDA-compatible device corresponding to the Direct3D 10 device `pD3D10Device`. Also returns in `*pCudaDevices` at most `cudaDeviceCount` of the CUDA-compatible devices corresponding to the Direct3D 10 device `pD3D10Device`.

If any of the GPUs being used to render `pDevice` are not CUDA capable then the call will return [CUDA_ERROR_NO_DEVICE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9761bea84083d384d4fb88d51d972aada>).

Note:

Note that this function may also return error codes from previous, asynchronous launches.

**See also:**

[cuD3D10GetDevice](<group__CUDA__D3D10.html#group__CUDA__D3D10_1g98e0c9dcac9771d45112053045e0c34f> "Gets the CUDA device corresponding to a display adapter."), [cudaD3D10GetDevices](<../cuda-runtime-api/group__CUDART__D3D10.html#group__CUDART__D3D10_1g70ccbdf2ed995cb7182eb97c6780996d>)

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuGraphicsD3D10RegisterResource ( [CUgraphicsResource](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc0c4e1704647178d9c5ba3be46517dcd>)*Â pCudaResource, ID3D10Resource*Â pD3DResource, unsigned int Â Flags )


Register a Direct3D 10 resource for access by CUDA.

######  Parameters

`pCudaResource`
    \- Returned graphics resource handle
`pD3DResource`
    \- Direct3D resource to register
`Flags`
    \- Parameters for resource registration

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_DEINITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9acf52f132faf29b473cdda6061f0f44a>), [CUDA_ERROR_NOT_INITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e98feb999f0af99b4a25ab26b3866f4df8>), [CUDA_ERROR_INVALID_CONTEXT](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a484e9af32c1e9893ff21f0e0191a12d>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>), [CUDA_ERROR_INVALID_HANDLE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e90fd2e63260c6317ba943af0f7e4b8d21>), [CUDA_ERROR_OUT_OF_MEMORY](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9264c50688ed110e8476b591befe60c02>), [CUDA_ERROR_UNKNOWN](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9c5a6ab0245179d297f1fa56ed0097183>)

###### Description

Registers the Direct3D 10 resource `pD3DResource` for access by CUDA and returns a CUDA handle to `pD3Dresource` in `pCudaResource`. The handle returned in `pCudaResource` may be used to map and unmap this resource until it is unregistered. On success this call will increase the internal reference count on `pD3DResource`. This reference count will be decremented when this resource is unregistered through [cuGraphicsUnregisterResource()](<group__CUDA__GRAPHICS.html#group__CUDA__GRAPHICS_1ga7e5e97b74eaa13dfa6582e853e4c96d> "Unregisters a graphics resource for access by CUDA.").

This call is potentially high-overhead and should not be called every frame in interactive applications.

The type of `pD3DResource` must be one of the following.

  * ID3D10Buffer: may be accessed through a device pointer.

  * ID3D10Texture1D: individual subresources of the texture may be accessed via arrays

  * ID3D10Texture2D: individual subresources of the texture may be accessed via arrays

  * ID3D10Texture3D: individual subresources of the texture may be accessed via arrays


The `Flags` argument may be used to specify additional parameters at register time. The valid values for this parameter are

  * CU_GRAPHICS_REGISTER_FLAGS_NONE: Specifies no hints about how this resource will be used.

  * CU_GRAPHICS_REGISTER_FLAGS_SURFACE_LDST: Specifies that CUDA will bind this resource to a surface reference.

  * CU_GRAPHICS_REGISTER_FLAGS_TEXTURE_GATHER: Specifies that CUDA will perform texture gather operations on this resource.


Not all Direct3D resources of the above types may be used for interoperability with CUDA. The following are some limitations.

  * The primary rendertarget may not be registered with CUDA.

  * Textures which are not of a format which is 1, 2, or 4 channels of 8, 16, or 32-bit integer or floating-point data cannot be shared.

  * Surfaces of depth or stencil formats cannot be shared.


A complete list of supported DXGI formats is as follows. For compactness the notation A_{B,C,D} represents A_B, A_C, and A_D.

  * DXGI_FORMAT_A8_UNORM

  * DXGI_FORMAT_B8G8R8A8_UNORM

  * DXGI_FORMAT_B8G8R8X8_UNORM

  * DXGI_FORMAT_R16_FLOAT

  * DXGI_FORMAT_R16G16B16A16_{FLOAT,SINT,SNORM,UINT,UNORM}

  * DXGI_FORMAT_R16G16_{FLOAT,SINT,SNORM,UINT,UNORM}

  * DXGI_FORMAT_R16_{SINT,SNORM,UINT,UNORM}

  * DXGI_FORMAT_R32_FLOAT

  * DXGI_FORMAT_R32G32B32A32_{FLOAT,SINT,UINT}

  * DXGI_FORMAT_R32G32_{FLOAT,SINT,UINT}

  * DXGI_FORMAT_R32_{SINT,UINT}

  * DXGI_FORMAT_R8G8B8A8_{SINT,SNORM,UINT,UNORM,UNORM_SRGB}

  * DXGI_FORMAT_R8G8_{SINT,SNORM,UINT,UNORM}

  * DXGI_FORMAT_R8_{SINT,SNORM,UINT,UNORM}


If `pD3DResource` is of incorrect type or is already registered then [CUDA_ERROR_INVALID_HANDLE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e90fd2e63260c6317ba943af0f7e4b8d21>) is returned. If `pD3DResource` cannot be registered then [CUDA_ERROR_UNKNOWN](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9c5a6ab0245179d297f1fa56ed0097183>) is returned. If `Flags` is not one of the above specified value then [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>) is returned.

Note:

Note that this function may also return error codes from previous, asynchronous launches.

**See also:**

[cuGraphicsUnregisterResource](<group__CUDA__GRAPHICS.html#group__CUDA__GRAPHICS_1ga7e5e97b74eaa13dfa6582e853e4c96d> "Unregisters a graphics resource for access by CUDA."), [cuGraphicsMapResources](<group__CUDA__GRAPHICS.html#group__CUDA__GRAPHICS_1gffcfd8e78d82cc4f6dd987e8bce4edb0> "Map graphics resources for access by CUDA."), [cuGraphicsSubResourceGetMappedArray](<group__CUDA__GRAPHICS.html#group__CUDA__GRAPHICS_1g61c55e987e54558cce547240d6123078> "Get an array through which to access a subresource of a mapped graphics resource."), [cuGraphicsResourceGetMappedPointer](<group__CUDA__GRAPHICS.html#group__CUDA__GRAPHICS_1g8a634cf4150d399f0018061580592457> "Get a device pointer through which to access a mapped graphics resource."), [cudaGraphicsD3D10RegisterResource](<../cuda-runtime-api/group__CUDART__D3D10.html#group__CUDART__D3D10_1g438731f7af2b799fb757910be6cff62b>)

### Direct3D 10 Interoperability [DEPRECATED]

* * *


---

# Direct3D 10 (Deprecated)

## 6.42.1.Â Direct3D 10 Interoperability [DEPRECATED]

## [[Direct3D 10 Interoperability](<group__CUDA__D3D10.html#group__CUDA__D3D10>)]

This section describes deprecated Direct3D 10 interoperability functionality.

### Enumerations

enumÂ [CUD3D10map_flags](<#group__CUDA__D3D10__DEPRECATED_1g74452bd2ef8d2515e627a4b54ca44394>)

enumÂ [CUD3D10register_flags](<#group__CUDA__D3D10__DEPRECATED_1gbad99be7f2d194fda482bae2c34286ad>)


### Functions

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuD3D10CtxCreate](<#group__CUDA__D3D10__DEPRECATED_1gceb8ac9cabf2dae3f6185be772e36e95>) ( [CUcontext](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gf9f5bd81658f866613785b3a0bb7d7d9>)*Â pCtx, [CUdevice](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g41ca2a24a242b36ef2ca77330b5fb72a>)*Â pCudaDevice, unsigned int Â Flags, ID3D10Device*Â pD3DDevice )
     Create a CUDA context for interoperability with Direct3D 10.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuD3D10CtxCreateOnDevice](<#group__CUDA__D3D10__DEPRECATED_1gcac8d5f82332089f34fee44831477ae4>) ( [CUcontext](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gf9f5bd81658f866613785b3a0bb7d7d9>)*Â pCtx, unsigned int Â flags, ID3D10Device*Â pD3DDevice, [CUdevice](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g41ca2a24a242b36ef2ca77330b5fb72a>)Â cudaDevice )
     Create a CUDA context for interoperability with Direct3D 10.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuD3D10GetDirect3DDevice](<#group__CUDA__D3D10__DEPRECATED_1ga3b842b3a35adab2fec4febb44ed6251>) ( ID3D10Device**Â ppD3DDevice )
     Get the Direct3D 10 device against which the current CUDA context was created.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuD3D10MapResources](<#group__CUDA__D3D10__DEPRECATED_1g5c8ecc921f0830b3163a0f32ccd7511d>) ( unsigned int Â count, ID3D10Resource**Â ppResources )
     Map Direct3D resources for access by CUDA.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuD3D10RegisterResource](<#group__CUDA__D3D10__DEPRECATED_1g476a6f370797a72d0238898e5d3e93ce>) ( ID3D10Resource*Â pResource, unsigned int Â Flags )
     Register a Direct3D resource for access by CUDA.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuD3D10ResourceGetMappedArray](<#group__CUDA__D3D10__DEPRECATED_1ge10b1c832c2f8ac54cf72aa1dca8ad0f>) ( [CUarray](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gd550651524a56766b60f10f0e7628042>)*Â pArray, ID3D10Resource*Â pResource, unsigned int Â SubResource )
     Get an array through which to access a subresource of a Direct3D resource which has been mapped for access by CUDA.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuD3D10ResourceGetMappedPitch](<#group__CUDA__D3D10__DEPRECATED_1ga5c9af1165e0f783a123f4ae8ceb3379>) ( size_t*Â pPitch, size_t*Â pPitchSlice, ID3D10Resource*Â pResource, unsigned int Â SubResource )
     Get the pitch of a subresource of a Direct3D resource which has been mapped for access by CUDA.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuD3D10ResourceGetMappedPointer](<#group__CUDA__D3D10__DEPRECATED_1ged2d8b89638fb2355e1ba2d7b92e0ff1>) ( [CUdeviceptr](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g183f7b0d8ad008ea2a5fd552537ace4e>)*Â pDevPtr, ID3D10Resource*Â pResource, unsigned int Â SubResource )
     Get a pointer through which to access a subresource of a Direct3D resource which has been mapped for access by CUDA.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuD3D10ResourceGetMappedSize](<#group__CUDA__D3D10__DEPRECATED_1g1c0069e431c8f95fd85fd3379cf7cb0e>) ( size_t*Â pSize, ID3D10Resource*Â pResource, unsigned int Â SubResource )
     Get the size of a subresource of a Direct3D resource which has been mapped for access by CUDA.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuD3D10ResourceGetSurfaceDimensions](<#group__CUDA__D3D10__DEPRECATED_1g7795faffd5e58e04f277263d310278fe>) ( size_t*Â pWidth, size_t*Â pHeight, size_t*Â pDepth, ID3D10Resource*Â pResource, unsigned int Â SubResource )
     Get the dimensions of a registered surface.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuD3D10ResourceSetMapFlags](<#group__CUDA__D3D10__DEPRECATED_1gcbfee49e43deebbcde1deea91d8e48fa>) ( ID3D10Resource*Â pResource, unsigned int Â Flags )
     Set usage flags for mapping a Direct3D resource.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuD3D10UnmapResources](<#group__CUDA__D3D10__DEPRECATED_1gbe4c93d0d53f16e843c035b2dd144a46>) ( unsigned int Â count, ID3D10Resource**Â ppResources )
     Unmap Direct3D resources.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuD3D10UnregisterResource](<#group__CUDA__D3D10__DEPRECATED_1gb4bb733df68b54424ac0b575e113e4ca>) ( ID3D10Resource*Â pResource )
     Unregister a Direct3D resource.

### Enumerations

enum CUD3D10map_flags


Flags to map or unmap a resource

######  Values

CU_D3D10_MAPRESOURCE_FLAGS_NONE = 0x00

CU_D3D10_MAPRESOURCE_FLAGS_READONLY = 0x01

CU_D3D10_MAPRESOURCE_FLAGS_WRITEDISCARD = 0x02


enum CUD3D10register_flags


Flags to register a resource

######  Values

CU_D3D10_REGISTER_FLAGS_NONE = 0x00

CU_D3D10_REGISTER_FLAGS_ARRAY = 0x01


### Functions

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuD3D10CtxCreate ( [CUcontext](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gf9f5bd81658f866613785b3a0bb7d7d9>)*Â pCtx, [CUdevice](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g41ca2a24a242b36ef2ca77330b5fb72a>)*Â pCudaDevice, unsigned int Â Flags, ID3D10Device*Â pD3DDevice )


Create a CUDA context for interoperability with Direct3D 10.

######  Parameters

`pCtx`
    \- Returned newly created CUDA context
`pCudaDevice`
    \- Returned pointer to the device on which the context was created
`Flags`
    \- Context creation flags (see [cuCtxCreate()](<group__CUDA__CTX.html#group__CUDA__CTX_1g77e9fb578caefca5ed15b4acebf35265> "Create a CUDA context.") for details)
`pD3DDevice`
    \- Direct3D device to create interoperability context with

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_DEINITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9acf52f132faf29b473cdda6061f0f44a>), [CUDA_ERROR_NOT_INITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e98feb999f0af99b4a25ab26b3866f4df8>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>), [CUDA_ERROR_OUT_OF_MEMORY](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9264c50688ed110e8476b591befe60c02>), [CUDA_ERROR_UNKNOWN](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9c5a6ab0245179d297f1fa56ed0097183>)

###### [Deprecated](<deprecated.html#deprecated__deprecated_1_deprecated000090>)

This function is deprecated as of CUDA 5.0.

###### Description

This function is deprecated and should no longer be used. It is no longer necessary to associate a CUDA context with a D3D10 device in order to achieve maximum interoperability performance.

Note:

Note that this function may also return error codes from previous, asynchronous launches.

**See also:**

[cuD3D10GetDevice](<group__CUDA__D3D10.html#group__CUDA__D3D10_1g98e0c9dcac9771d45112053045e0c34f> "Gets the CUDA device corresponding to a display adapter."), [cuGraphicsD3D10RegisterResource](<group__CUDA__D3D10.html#group__CUDA__D3D10_1g87fb2a189c27c4b63538d23f53b2c8e6> "Register a Direct3D 10 resource for access by CUDA.")

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuD3D10CtxCreateOnDevice ( [CUcontext](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gf9f5bd81658f866613785b3a0bb7d7d9>)*Â pCtx, unsigned int Â flags, ID3D10Device*Â pD3DDevice, [CUdevice](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g41ca2a24a242b36ef2ca77330b5fb72a>)Â cudaDevice )


Create a CUDA context for interoperability with Direct3D 10.

######  Parameters

`pCtx`
    \- Returned newly created CUDA context
`flags`
    \- Context creation flags (see [cuCtxCreate()](<group__CUDA__CTX.html#group__CUDA__CTX_1g77e9fb578caefca5ed15b4acebf35265> "Create a CUDA context.") for details)
`pD3DDevice`
    \- Direct3D device to create interoperability context with
`cudaDevice`
    \- The CUDA device on which to create the context. This device must be among the devices returned when querying CU_D3D10_DEVICES_ALL from [cuD3D10GetDevices](<group__CUDA__D3D10.html#group__CUDA__D3D10_1gdcc33dea972d5b834f45a0acefe5fe77> "Gets the CUDA devices corresponding to a Direct3D 10 device.").

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_DEINITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9acf52f132faf29b473cdda6061f0f44a>), [CUDA_ERROR_NOT_INITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e98feb999f0af99b4a25ab26b3866f4df8>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>), [CUDA_ERROR_OUT_OF_MEMORY](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9264c50688ed110e8476b591befe60c02>), [CUDA_ERROR_UNKNOWN](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9c5a6ab0245179d297f1fa56ed0097183>)

###### [Deprecated](<deprecated.html#deprecated__deprecated_1_deprecated000091>)

This function is deprecated as of CUDA 5.0.

###### Description

This function is deprecated and should no longer be used. It is no longer necessary to associate a CUDA context with a D3D10 device in order to achieve maximum interoperability performance.

Note:

Note that this function may also return error codes from previous, asynchronous launches.

**See also:**

[cuD3D10GetDevices](<group__CUDA__D3D10.html#group__CUDA__D3D10_1gdcc33dea972d5b834f45a0acefe5fe77> "Gets the CUDA devices corresponding to a Direct3D 10 device."), [cuGraphicsD3D10RegisterResource](<group__CUDA__D3D10.html#group__CUDA__D3D10_1g87fb2a189c27c4b63538d23f53b2c8e6> "Register a Direct3D 10 resource for access by CUDA.")

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuD3D10GetDirect3DDevice ( ID3D10Device**Â ppD3DDevice )


Get the Direct3D 10 device against which the current CUDA context was created.

######  Parameters

`ppD3DDevice`
    \- Returned Direct3D device corresponding to CUDA context

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_DEINITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9acf52f132faf29b473cdda6061f0f44a>), [CUDA_ERROR_NOT_INITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e98feb999f0af99b4a25ab26b3866f4df8>), [CUDA_ERROR_INVALID_CONTEXT](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a484e9af32c1e9893ff21f0e0191a12d>)

###### [Deprecated](<deprecated.html#deprecated__deprecated_1_deprecated000092>)

This function is deprecated as of CUDA 5.0.

###### Description

This function is deprecated and should no longer be used. It is no longer necessary to associate a CUDA context with a D3D10 device in order to achieve maximum interoperability performance.

Note:

Note that this function may also return error codes from previous, asynchronous launches.

**See also:**

[cuD3D10GetDevice](<group__CUDA__D3D10.html#group__CUDA__D3D10_1g98e0c9dcac9771d45112053045e0c34f> "Gets the CUDA device corresponding to a display adapter.")

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuD3D10MapResources ( unsigned int Â count, ID3D10Resource**Â ppResources )


Map Direct3D resources for access by CUDA.

######  Parameters

`count`
    \- Number of resources to map for CUDA
`ppResources`
    \- Resources to map for CUDA

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_DEINITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9acf52f132faf29b473cdda6061f0f44a>), [CUDA_ERROR_NOT_INITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e98feb999f0af99b4a25ab26b3866f4df8>), [CUDA_ERROR_INVALID_CONTEXT](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a484e9af32c1e9893ff21f0e0191a12d>), [CUDA_ERROR_INVALID_HANDLE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e90fd2e63260c6317ba943af0f7e4b8d21>), [CUDA_ERROR_ALREADY_MAPPED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9240bb253a699176d9f49ee2f2c91b61b>), [CUDA_ERROR_UNKNOWN](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9c5a6ab0245179d297f1fa56ed0097183>)

###### [Deprecated](<deprecated.html#deprecated__deprecated_1_deprecated000095>)

This function is deprecated as of CUDA 3.0.

###### Description

Maps the `count` Direct3D resources in `ppResources` for access by CUDA.

The resources in `ppResources` may be accessed in CUDA kernels until they are unmapped. Direct3D should not access any resources while they are mapped by CUDA. If an application does so, the results are undefined.

This function provides the synchronization guarantee that any Direct3D calls issued before [cuD3D10MapResources()](<group__CUDA__D3D10__DEPRECATED.html#group__CUDA__D3D10__DEPRECATED_1g5c8ecc921f0830b3163a0f32ccd7511d> "Map Direct3D resources for access by CUDA.") will complete before any CUDA kernels issued after [cuD3D10MapResources()](<group__CUDA__D3D10__DEPRECATED.html#group__CUDA__D3D10__DEPRECATED_1g5c8ecc921f0830b3163a0f32ccd7511d> "Map Direct3D resources for access by CUDA.") begin.

If any of `ppResources` have not been registered for use with CUDA or if `ppResources` contains any duplicate entries, then [CUDA_ERROR_INVALID_HANDLE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e90fd2e63260c6317ba943af0f7e4b8d21>) is returned. If any of `ppResources` are presently mapped for access by CUDA, then [CUDA_ERROR_ALREADY_MAPPED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9240bb253a699176d9f49ee2f2c91b61b>) is returned.

Note:

Note that this function may also return error codes from previous, asynchronous launches.

**See also:**

[cuGraphicsMapResources](<group__CUDA__GRAPHICS.html#group__CUDA__GRAPHICS_1gffcfd8e78d82cc4f6dd987e8bce4edb0> "Map graphics resources for access by CUDA.")

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuD3D10RegisterResource ( ID3D10Resource*Â pResource, unsigned int Â Flags )


Register a Direct3D resource for access by CUDA.

######  Parameters

`pResource`
    \- Resource to register
`Flags`
    \- Parameters for resource registration

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_DEINITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9acf52f132faf29b473cdda6061f0f44a>), [CUDA_ERROR_NOT_INITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e98feb999f0af99b4a25ab26b3866f4df8>), [CUDA_ERROR_INVALID_CONTEXT](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a484e9af32c1e9893ff21f0e0191a12d>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>), [CUDA_ERROR_INVALID_HANDLE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e90fd2e63260c6317ba943af0f7e4b8d21>), [CUDA_ERROR_OUT_OF_MEMORY](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9264c50688ed110e8476b591befe60c02>), [CUDA_ERROR_UNKNOWN](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9c5a6ab0245179d297f1fa56ed0097183>)

###### [Deprecated](<deprecated.html#deprecated__deprecated_1_deprecated000093>)

This function is deprecated as of CUDA 3.0.

###### Description

Registers the Direct3D resource `pResource` for access by CUDA.

If this call is successful, then the application will be able to map and unmap this resource until it is unregistered through [cuD3D10UnregisterResource()](<group__CUDA__D3D10__DEPRECATED.html#group__CUDA__D3D10__DEPRECATED_1gb4bb733df68b54424ac0b575e113e4ca> "Unregister a Direct3D resource."). Also on success, this call will increase the internal reference count on `pResource`. This reference count will be decremented when this resource is unregistered through [cuD3D10UnregisterResource()](<group__CUDA__D3D10__DEPRECATED.html#group__CUDA__D3D10__DEPRECATED_1gb4bb733df68b54424ac0b575e113e4ca> "Unregister a Direct3D resource.").

This call is potentially high-overhead and should not be called every frame in interactive applications.

The type of `pResource` must be one of the following.

  * ID3D10Buffer: Cannot be used with `Flags` set to CU_D3D10_REGISTER_FLAGS_ARRAY.

  * ID3D10Texture1D: No restrictions.

  * ID3D10Texture2D: No restrictions.

  * ID3D10Texture3D: No restrictions.


The `Flags` argument specifies the mechanism through which CUDA will access the Direct3D resource. The following values are allowed.

  * CU_D3D10_REGISTER_FLAGS_NONE: Specifies that CUDA will access this resource through a [CUdeviceptr](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g183f7b0d8ad008ea2a5fd552537ace4e>). The pointer, size, and (for textures), pitch for each subresource of this allocation may be queried through [cuD3D10ResourceGetMappedPointer()](<group__CUDA__D3D10__DEPRECATED.html#group__CUDA__D3D10__DEPRECATED_1ged2d8b89638fb2355e1ba2d7b92e0ff1> "Get a pointer through which to access a subresource of a Direct3D resource which has been mapped for access by CUDA."), [cuD3D10ResourceGetMappedSize()](<group__CUDA__D3D10__DEPRECATED.html#group__CUDA__D3D10__DEPRECATED_1g1c0069e431c8f95fd85fd3379cf7cb0e> "Get the size of a subresource of a Direct3D resource which has been mapped for access by CUDA."), and [cuD3D10ResourceGetMappedPitch()](<group__CUDA__D3D10__DEPRECATED.html#group__CUDA__D3D10__DEPRECATED_1ga5c9af1165e0f783a123f4ae8ceb3379> "Get the pitch of a subresource of a Direct3D resource which has been mapped for access by CUDA.") respectively. This option is valid for all resource types.

  * CU_D3D10_REGISTER_FLAGS_ARRAY: Specifies that CUDA will access this resource through a [CUarray](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gd550651524a56766b60f10f0e7628042>) queried on a sub-resource basis through [cuD3D10ResourceGetMappedArray()](<group__CUDA__D3D10__DEPRECATED.html#group__CUDA__D3D10__DEPRECATED_1ge10b1c832c2f8ac54cf72aa1dca8ad0f> "Get an array through which to access a subresource of a Direct3D resource which has been mapped for access by CUDA."). This option is only valid for resources of type ID3D10Texture1D, ID3D10Texture2D, and ID3D10Texture3D.


Not all Direct3D resources of the above types may be used for interoperability with CUDA. The following are some limitations.

  * The primary rendertarget may not be registered with CUDA.

  * Resources allocated as shared may not be registered with CUDA.

  * Textures which are not of a format which is 1, 2, or 4 channels of 8, 16, or 32-bit integer or floating-point data cannot be shared.

  * Surfaces of depth or stencil formats cannot be shared.


If Direct3D interoperability is not initialized on this context then [CUDA_ERROR_INVALID_CONTEXT](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a484e9af32c1e9893ff21f0e0191a12d>) is returned. If `pResource` is of incorrect type or is already registered, then [CUDA_ERROR_INVALID_HANDLE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e90fd2e63260c6317ba943af0f7e4b8d21>) is returned. If `pResource` cannot be registered, then [CUDA_ERROR_UNKNOWN](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9c5a6ab0245179d297f1fa56ed0097183>) is returned.

Note:

Note that this function may also return error codes from previous, asynchronous launches.

**See also:**

[cuGraphicsD3D10RegisterResource](<group__CUDA__D3D10.html#group__CUDA__D3D10_1g87fb2a189c27c4b63538d23f53b2c8e6> "Register a Direct3D 10 resource for access by CUDA.")

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuD3D10ResourceGetMappedArray ( [CUarray](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gd550651524a56766b60f10f0e7628042>)*Â pArray, ID3D10Resource*Â pResource, unsigned int Â SubResource )


Get an array through which to access a subresource of a Direct3D resource which has been mapped for access by CUDA.

######  Parameters

`pArray`
    \- Returned array corresponding to subresource
`pResource`
    \- Mapped resource to access
`SubResource`
    \- Subresource of pResource to access

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_DEINITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9acf52f132faf29b473cdda6061f0f44a>), [CUDA_ERROR_NOT_INITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e98feb999f0af99b4a25ab26b3866f4df8>), [CUDA_ERROR_INVALID_CONTEXT](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a484e9af32c1e9893ff21f0e0191a12d>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>), [CUDA_ERROR_INVALID_HANDLE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e90fd2e63260c6317ba943af0f7e4b8d21>), [CUDA_ERROR_NOT_MAPPED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9e098433b926c9afdb6b6bdf191629447>)

###### [Deprecated](<deprecated.html#deprecated__deprecated_1_deprecated000098>)

This function is deprecated as of CUDA 3.0.

###### Description

Returns in `*pArray` an array through which the subresource of the mapped Direct3D resource `pResource`, which corresponds to `SubResource` may be accessed. The value set in `pArray` may change every time that `pResource` is mapped.

If `pResource` is not registered, then [CUDA_ERROR_INVALID_HANDLE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e90fd2e63260c6317ba943af0f7e4b8d21>) is returned. If `pResource` was not registered with usage flags CU_D3D10_REGISTER_FLAGS_ARRAY, then [CUDA_ERROR_INVALID_HANDLE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e90fd2e63260c6317ba943af0f7e4b8d21>) is returned. If `pResource` is not mapped, then [CUDA_ERROR_NOT_MAPPED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9e098433b926c9afdb6b6bdf191629447>) is returned.

For usage requirements of the `SubResource` parameter, see [cuD3D10ResourceGetMappedPointer()](<group__CUDA__D3D10__DEPRECATED.html#group__CUDA__D3D10__DEPRECATED_1ged2d8b89638fb2355e1ba2d7b92e0ff1> "Get a pointer through which to access a subresource of a Direct3D resource which has been mapped for access by CUDA.").

Note:

Note that this function may also return error codes from previous, asynchronous launches.

**See also:**

[cuGraphicsSubResourceGetMappedArray](<group__CUDA__GRAPHICS.html#group__CUDA__GRAPHICS_1g61c55e987e54558cce547240d6123078> "Get an array through which to access a subresource of a mapped graphics resource.")

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuD3D10ResourceGetMappedPitch ( size_t*Â pPitch, size_t*Â pPitchSlice, ID3D10Resource*Â pResource, unsigned int Â SubResource )


Get the pitch of a subresource of a Direct3D resource which has been mapped for access by CUDA.

######  Parameters

`pPitch`
    \- Returned pitch of subresource
`pPitchSlice`
    \- Returned Z-slice pitch of subresource
`pResource`
    \- Mapped resource to access
`SubResource`
    \- Subresource of pResource to access

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_DEINITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9acf52f132faf29b473cdda6061f0f44a>), [CUDA_ERROR_NOT_INITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e98feb999f0af99b4a25ab26b3866f4df8>), [CUDA_ERROR_INVALID_CONTEXT](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a484e9af32c1e9893ff21f0e0191a12d>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>), [CUDA_ERROR_INVALID_HANDLE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e90fd2e63260c6317ba943af0f7e4b8d21>), [CUDA_ERROR_NOT_MAPPED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9e098433b926c9afdb6b6bdf191629447>)

###### [Deprecated](<deprecated.html#deprecated__deprecated_1_deprecated000101>)

This function is deprecated as of CUDA 3.0.

###### Description

Returns in `*pPitch` and `*pPitchSlice` the pitch and Z-slice pitch of the subresource of the mapped Direct3D resource `pResource`, which corresponds to `SubResource`. The values set in `pPitch` and `pPitchSlice` may change every time that `pResource` is mapped.

The pitch and Z-slice pitch values may be used to compute the location of a sample on a surface as follows.

For a 2D surface, the byte offset of the sample at position **x** , **y** from the base pointer of the surface is:

**y** * **pitch** \+ (**bytes per pixel**) * **x**

For a 3D surface, the byte offset of the sample at position **x** , **y** , **z** from the base pointer of the surface is:

**z*** **slicePitch** \+ **y** * **pitch** \+ (**bytes per pixel**) * **x**

Both parameters `pPitch` and `pPitchSlice` are optional and may be set to NULL.

If `pResource` is not of type IDirect3DBaseTexture10 or one of its sub-types or if `pResource` has not been registered for use with CUDA, then [CUDA_ERROR_INVALID_HANDLE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e90fd2e63260c6317ba943af0f7e4b8d21>) is returned. If `pResource` was not registered with usage flags CU_D3D10_REGISTER_FLAGS_NONE, then [CUDA_ERROR_INVALID_HANDLE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e90fd2e63260c6317ba943af0f7e4b8d21>) is returned. If `pResource` is not mapped for access by CUDA, then [CUDA_ERROR_NOT_MAPPED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9e098433b926c9afdb6b6bdf191629447>) is returned.

For usage requirements of the `SubResource` parameter, see [cuD3D10ResourceGetMappedPointer()](<group__CUDA__D3D10__DEPRECATED.html#group__CUDA__D3D10__DEPRECATED_1ged2d8b89638fb2355e1ba2d7b92e0ff1> "Get a pointer through which to access a subresource of a Direct3D resource which has been mapped for access by CUDA.").

Note:

Note that this function may also return error codes from previous, asynchronous launches.

**See also:**

[cuGraphicsSubResourceGetMappedArray](<group__CUDA__GRAPHICS.html#group__CUDA__GRAPHICS_1g61c55e987e54558cce547240d6123078> "Get an array through which to access a subresource of a mapped graphics resource.")

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuD3D10ResourceGetMappedPointer ( [CUdeviceptr](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g183f7b0d8ad008ea2a5fd552537ace4e>)*Â pDevPtr, ID3D10Resource*Â pResource, unsigned int Â SubResource )


Get a pointer through which to access a subresource of a Direct3D resource which has been mapped for access by CUDA.

######  Parameters

`pDevPtr`
    \- Returned pointer corresponding to subresource
`pResource`
    \- Mapped resource to access
`SubResource`
    \- Subresource of pResource to access

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_DEINITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9acf52f132faf29b473cdda6061f0f44a>), [CUDA_ERROR_NOT_INITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e98feb999f0af99b4a25ab26b3866f4df8>), [CUDA_ERROR_INVALID_CONTEXT](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a484e9af32c1e9893ff21f0e0191a12d>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>), [CUDA_ERROR_INVALID_HANDLE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e90fd2e63260c6317ba943af0f7e4b8d21>), [CUDA_ERROR_NOT_MAPPED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9e098433b926c9afdb6b6bdf191629447>)

###### [Deprecated](<deprecated.html#deprecated__deprecated_1_deprecated000099>)

This function is deprecated as of CUDA 3.0.

###### Description

Returns in `*pDevPtr` the base pointer of the subresource of the mapped Direct3D resource `pResource`, which corresponds to `SubResource`. The value set in `pDevPtr` may change every time that `pResource` is mapped.

If `pResource` is not registered, then [CUDA_ERROR_INVALID_HANDLE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e90fd2e63260c6317ba943af0f7e4b8d21>) is returned. If `pResource` was not registered with usage flags CU_D3D10_REGISTER_FLAGS_NONE, then [CUDA_ERROR_INVALID_HANDLE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e90fd2e63260c6317ba943af0f7e4b8d21>) is returned. If `pResource` is not mapped, then [CUDA_ERROR_NOT_MAPPED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9e098433b926c9afdb6b6bdf191629447>) is returned.

If `pResource` is of type ID3D10Buffer, then `SubResource` must be 0. If `pResource` is of any other type, then the value of `SubResource` must come from the subresource calculation in D3D10CalcSubResource().

Note:

Note that this function may also return error codes from previous, asynchronous launches.

**See also:**

[cuGraphicsResourceGetMappedPointer](<group__CUDA__GRAPHICS.html#group__CUDA__GRAPHICS_1g8a634cf4150d399f0018061580592457> "Get a device pointer through which to access a mapped graphics resource.")

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuD3D10ResourceGetMappedSize ( size_t*Â pSize, ID3D10Resource*Â pResource, unsigned int Â SubResource )


Get the size of a subresource of a Direct3D resource which has been mapped for access by CUDA.

######  Parameters

`pSize`
    \- Returned size of subresource
`pResource`
    \- Mapped resource to access
`SubResource`
    \- Subresource of pResource to access

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_DEINITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9acf52f132faf29b473cdda6061f0f44a>), [CUDA_ERROR_NOT_INITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e98feb999f0af99b4a25ab26b3866f4df8>), [CUDA_ERROR_INVALID_CONTEXT](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a484e9af32c1e9893ff21f0e0191a12d>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>), [CUDA_ERROR_INVALID_HANDLE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e90fd2e63260c6317ba943af0f7e4b8d21>), [CUDA_ERROR_NOT_MAPPED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9e098433b926c9afdb6b6bdf191629447>)

###### [Deprecated](<deprecated.html#deprecated__deprecated_1_deprecated000100>)

This function is deprecated as of CUDA 3.0.

###### Description

Returns in `*pSize` the size of the subresource of the mapped Direct3D resource `pResource`, which corresponds to `SubResource`. The value set in `pSize` may change every time that `pResource` is mapped.

If `pResource` has not been registered for use with CUDA, then [CUDA_ERROR_INVALID_HANDLE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e90fd2e63260c6317ba943af0f7e4b8d21>) is returned. If `pResource` was not registered with usage flags CU_D3D10_REGISTER_FLAGS_NONE, then [CUDA_ERROR_INVALID_HANDLE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e90fd2e63260c6317ba943af0f7e4b8d21>) is returned. If `pResource` is not mapped for access by CUDA, then [CUDA_ERROR_NOT_MAPPED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9e098433b926c9afdb6b6bdf191629447>) is returned.

For usage requirements of the `SubResource` parameter, see [cuD3D10ResourceGetMappedPointer()](<group__CUDA__D3D10__DEPRECATED.html#group__CUDA__D3D10__DEPRECATED_1ged2d8b89638fb2355e1ba2d7b92e0ff1> "Get a pointer through which to access a subresource of a Direct3D resource which has been mapped for access by CUDA.").

Note:

Note that this function may also return error codes from previous, asynchronous launches.

**See also:**

[cuGraphicsResourceGetMappedPointer](<group__CUDA__GRAPHICS.html#group__CUDA__GRAPHICS_1g8a634cf4150d399f0018061580592457> "Get a device pointer through which to access a mapped graphics resource.")

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuD3D10ResourceGetSurfaceDimensions ( size_t*Â pWidth, size_t*Â pHeight, size_t*Â pDepth, ID3D10Resource*Â pResource, unsigned int Â SubResource )


Get the dimensions of a registered surface.

######  Parameters

`pWidth`
    \- Returned width of surface
`pHeight`
    \- Returned height of surface
`pDepth`
    \- Returned depth of surface
`pResource`
    \- Registered resource to access
`SubResource`
    \- Subresource of pResource to access

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_DEINITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9acf52f132faf29b473cdda6061f0f44a>), [CUDA_ERROR_NOT_INITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e98feb999f0af99b4a25ab26b3866f4df8>), [CUDA_ERROR_INVALID_CONTEXT](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a484e9af32c1e9893ff21f0e0191a12d>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>), [CUDA_ERROR_INVALID_HANDLE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e90fd2e63260c6317ba943af0f7e4b8d21>)

###### [Deprecated](<deprecated.html#deprecated__deprecated_1_deprecated000102>)

This function is deprecated as of CUDA 3.0.

###### Description

Returns in `*pWidth`, `*pHeight`, and `*pDepth` the dimensions of the subresource of the mapped Direct3D resource `pResource`, which corresponds to `SubResource`.

Because anti-aliased surfaces may have multiple samples per pixel, it is possible that the dimensions of a resource will be an integer factor larger than the dimensions reported by the Direct3D runtime.

The parameters `pWidth`, `pHeight`, and `pDepth` are optional. For 2D surfaces, the value returned in `*pDepth` will be 0.

If `pResource` is not of type IDirect3DBaseTexture10 or IDirect3DSurface10 or if `pResource` has not been registered for use with CUDA, then [CUDA_ERROR_INVALID_HANDLE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e90fd2e63260c6317ba943af0f7e4b8d21>) is returned.

For usage requirements of the `SubResource` parameter, see [cuD3D10ResourceGetMappedPointer()](<group__CUDA__D3D10__DEPRECATED.html#group__CUDA__D3D10__DEPRECATED_1ged2d8b89638fb2355e1ba2d7b92e0ff1> "Get a pointer through which to access a subresource of a Direct3D resource which has been mapped for access by CUDA.").

Note:

Note that this function may also return error codes from previous, asynchronous launches.

**See also:**

[cuGraphicsSubResourceGetMappedArray](<group__CUDA__GRAPHICS.html#group__CUDA__GRAPHICS_1g61c55e987e54558cce547240d6123078> "Get an array through which to access a subresource of a mapped graphics resource.")

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuD3D10ResourceSetMapFlags ( ID3D10Resource*Â pResource, unsigned int Â Flags )


Set usage flags for mapping a Direct3D resource.

######  Parameters

`pResource`
    \- Registered resource to set flags for
`Flags`
    \- Parameters for resource mapping

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_DEINITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9acf52f132faf29b473cdda6061f0f44a>), [CUDA_ERROR_NOT_INITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e98feb999f0af99b4a25ab26b3866f4df8>), [CUDA_ERROR_INVALID_CONTEXT](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a484e9af32c1e9893ff21f0e0191a12d>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>), [CUDA_ERROR_INVALID_HANDLE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e90fd2e63260c6317ba943af0f7e4b8d21>), [CUDA_ERROR_ALREADY_MAPPED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9240bb253a699176d9f49ee2f2c91b61b>)

###### [Deprecated](<deprecated.html#deprecated__deprecated_1_deprecated000097>)

This function is deprecated as of CUDA 3.0.

###### Description

Set flags for mapping the Direct3D resource `pResource`.

Changes to flags will take effect the next time `pResource` is mapped. The `Flags` argument may be any of the following.

  * CU_D3D10_MAPRESOURCE_FLAGS_NONE: Specifies no hints about how this resource will be used. It is therefore assumed that this resource will be read from and written to by CUDA kernels. This is the default value.

  * CU_D3D10_MAPRESOURCE_FLAGS_READONLY: Specifies that CUDA kernels which access this resource will not write to this resource.

  * CU_D3D10_MAPRESOURCE_FLAGS_WRITEDISCARD: Specifies that CUDA kernels which access this resource will not read from this resource and will write over the entire contents of the resource, so none of the data previously stored in the resource will be preserved.


If `pResource` has not been registered for use with CUDA, then [CUDA_ERROR_INVALID_HANDLE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e90fd2e63260c6317ba943af0f7e4b8d21>) is returned. If `pResource` is presently mapped for access by CUDA then [CUDA_ERROR_ALREADY_MAPPED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9240bb253a699176d9f49ee2f2c91b61b>) is returned.

Note:

Note that this function may also return error codes from previous, asynchronous launches.

**See also:**

[cuGraphicsResourceSetMapFlags](<group__CUDA__GRAPHICS.html#group__CUDA__GRAPHICS_1gfe96aa7747f8b11d44a6fa6a851e1b39> "Set usage flags for mapping a graphics resource.")

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuD3D10UnmapResources ( unsigned int Â count, ID3D10Resource**Â ppResources )


Unmap Direct3D resources.

######  Parameters

`count`
    \- Number of resources to unmap for CUDA
`ppResources`
    \- Resources to unmap for CUDA

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_DEINITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9acf52f132faf29b473cdda6061f0f44a>), [CUDA_ERROR_NOT_INITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e98feb999f0af99b4a25ab26b3866f4df8>), [CUDA_ERROR_INVALID_CONTEXT](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a484e9af32c1e9893ff21f0e0191a12d>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>), [CUDA_ERROR_INVALID_HANDLE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e90fd2e63260c6317ba943af0f7e4b8d21>), [CUDA_ERROR_NOT_MAPPED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9e098433b926c9afdb6b6bdf191629447>), [CUDA_ERROR_UNKNOWN](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9c5a6ab0245179d297f1fa56ed0097183>)

###### [Deprecated](<deprecated.html#deprecated__deprecated_1_deprecated000096>)

This function is deprecated as of CUDA 3.0.

###### Description

Unmaps the `count` Direct3D resources in `ppResources`.

This function provides the synchronization guarantee that any CUDA kernels issued before [cuD3D10UnmapResources()](<group__CUDA__D3D10__DEPRECATED.html#group__CUDA__D3D10__DEPRECATED_1gbe4c93d0d53f16e843c035b2dd144a46> "Unmap Direct3D resources.") will complete before any Direct3D calls issued after [cuD3D10UnmapResources()](<group__CUDA__D3D10__DEPRECATED.html#group__CUDA__D3D10__DEPRECATED_1gbe4c93d0d53f16e843c035b2dd144a46> "Unmap Direct3D resources.") begin.

If any of `ppResources` have not been registered for use with CUDA or if `ppResources` contains any duplicate entries, then [CUDA_ERROR_INVALID_HANDLE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e90fd2e63260c6317ba943af0f7e4b8d21>) is returned. If any of `ppResources` are not presently mapped for access by CUDA, then [CUDA_ERROR_NOT_MAPPED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9e098433b926c9afdb6b6bdf191629447>) is returned.

Note:

Note that this function may also return error codes from previous, asynchronous launches.

**See also:**

[cuGraphicsUnmapResources](<group__CUDA__GRAPHICS.html#group__CUDA__GRAPHICS_1g8e9ff25d071375a0df1cb5aee924af32> "Unmap graphics resources.")

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuD3D10UnregisterResource ( ID3D10Resource*Â pResource )


Unregister a Direct3D resource.

######  Parameters

`pResource`
    \- Resources to unregister

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_DEINITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9acf52f132faf29b473cdda6061f0f44a>), [CUDA_ERROR_NOT_INITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e98feb999f0af99b4a25ab26b3866f4df8>), [CUDA_ERROR_INVALID_CONTEXT](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a484e9af32c1e9893ff21f0e0191a12d>), [CUDA_ERROR_INVALID_HANDLE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e90fd2e63260c6317ba943af0f7e4b8d21>), [CUDA_ERROR_UNKNOWN](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9c5a6ab0245179d297f1fa56ed0097183>)

###### [Deprecated](<deprecated.html#deprecated__deprecated_1_deprecated000094>)

This function is deprecated as of CUDA 3.0.

###### Description

Unregisters the Direct3D resource `pResource` so it is not accessible by CUDA unless registered again.

If `pResource` is not registered, then [CUDA_ERROR_INVALID_HANDLE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e90fd2e63260c6317ba943af0f7e4b8d21>) is returned.

Note:

Note that this function may also return error codes from previous, asynchronous launches.

**See also:**

[cuGraphicsUnregisterResource](<group__CUDA__GRAPHICS.html#group__CUDA__GRAPHICS_1ga7e5e97b74eaa13dfa6582e853e4c96d> "Unregisters a graphics resource for access by CUDA.")

* * *


---

# Direct3D 11 Interoperability

## 6.43.Â Direct3D 11 Interoperability

This section describes the Direct3D 11 interoperability functions of the low-level CUDA driver application programming interface. Note that mapping of Direct3D 11 resources is performed with the graphics API agnostic, resource mapping interface described in [Graphics Interoperability](<group__CUDA__GRAPHICS.html#group__CUDA__GRAPHICS>).

### Modules

Â

[Direct3D 11 Interoperability [DEPRECATED]](<group__CUDA__D3D11__DEPRECATED.html#group__CUDA__D3D11__DEPRECATED>)

     [](<group__CUDA__D3D11__DEPRECATED.html#group__CUDA__D3D11__DEPRECATED>)

### Enumerations

enumÂ [CUd3d11DeviceList](<#group__CUDA__D3D11_1gf590094e914ab0d2c6a5385711496500>)


### Functions

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuD3D11GetDevice](<#group__CUDA__D3D11_1ga1f1648cdf3bd5aef7a55af6dc1f42cd>) ( [CUdevice](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g41ca2a24a242b36ef2ca77330b5fb72a>)*Â pCudaDevice, IDXGIAdapter*Â pAdapter )
     Gets the CUDA device corresponding to a display adapter.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuD3D11GetDevices](<#group__CUDA__D3D11_1g7fca109b0dba2050b58f6bac627ff441>) ( unsigned int*Â pCudaDeviceCount, [CUdevice](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g41ca2a24a242b36ef2ca77330b5fb72a>)*Â pCudaDevices, unsigned int Â cudaDeviceCount, ID3D11Device*Â pD3D11Device, [CUd3d11DeviceList](<group__CUDA__D3D11.html#group__CUDA__D3D11_1gf590094e914ab0d2c6a5385711496500>)Â deviceList )
     Gets the CUDA devices corresponding to a Direct3D 11 device.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuGraphicsD3D11RegisterResource](<#group__CUDA__D3D11_1g4c02792aa87c3acc255b9de15b0509da>) ( [CUgraphicsResource](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc0c4e1704647178d9c5ba3be46517dcd>)*Â pCudaResource, ID3D11Resource*Â pD3DResource, unsigned int Â Flags )
     Register a Direct3D 11 resource for access by CUDA.

### Enumerations

enum CUd3d11DeviceList


CUDA devices corresponding to a D3D11 device

######  Values

CU_D3D11_DEVICE_LIST_ALL = 0x01
    The CUDA devices for all GPUs used by a D3D11 device
CU_D3D11_DEVICE_LIST_CURRENT_FRAME = 0x02
    The CUDA devices for the GPUs used by a D3D11 device in its currently rendering frame
CU_D3D11_DEVICE_LIST_NEXT_FRAME = 0x03
    The CUDA devices for the GPUs to be used by a D3D11 device in the next frame

### Functions

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuD3D11GetDevice ( [CUdevice](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g41ca2a24a242b36ef2ca77330b5fb72a>)*Â pCudaDevice, IDXGIAdapter*Â pAdapter )


Gets the CUDA device corresponding to a display adapter.

######  Parameters

`pCudaDevice`
    \- Returned CUDA device corresponding to `pAdapter`
`pAdapter`
    \- Adapter to query for CUDA device

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_DEINITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9acf52f132faf29b473cdda6061f0f44a>), [CUDA_ERROR_NOT_INITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e98feb999f0af99b4a25ab26b3866f4df8>), [CUDA_ERROR_NO_DEVICE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9761bea84083d384d4fb88d51d972aada>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>), [CUDA_ERROR_NOT_FOUND](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9af1cadbeb21d3a78115ca211ba44c053>), [CUDA_ERROR_UNKNOWN](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9c5a6ab0245179d297f1fa56ed0097183>)

###### Description

Returns in `*pCudaDevice` the CUDA-compatible device corresponding to the adapter `pAdapter` obtained from IDXGIFactory::EnumAdapters.

If no device on `pAdapter` is CUDA-compatible the call will return [CUDA_ERROR_NO_DEVICE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9761bea84083d384d4fb88d51d972aada>).

Note:

Note that this function may also return error codes from previous, asynchronous launches.

**See also:**

[cuD3D11GetDevices](<group__CUDA__D3D11.html#group__CUDA__D3D11_1g7fca109b0dba2050b58f6bac627ff441> "Gets the CUDA devices corresponding to a Direct3D 11 device."), [cudaD3D11GetDevice](<../cuda-runtime-api/group__CUDART__D3D11.html#group__CUDART__D3D11_1gcf0568f3809489723b70f1c5e614d346>)

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuD3D11GetDevices ( unsigned int*Â pCudaDeviceCount, [CUdevice](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g41ca2a24a242b36ef2ca77330b5fb72a>)*Â pCudaDevices, unsigned int Â cudaDeviceCount, ID3D11Device*Â pD3D11Device, [CUd3d11DeviceList](<group__CUDA__D3D11.html#group__CUDA__D3D11_1gf590094e914ab0d2c6a5385711496500>)Â deviceList )


Gets the CUDA devices corresponding to a Direct3D 11 device.

######  Parameters

`pCudaDeviceCount`
    \- Returned number of CUDA devices corresponding to `pD3D11Device`
`pCudaDevices`
    \- Returned CUDA devices corresponding to `pD3D11Device`
`cudaDeviceCount`
    \- The size of the output device array `pCudaDevices`
`pD3D11Device`
    \- Direct3D 11 device to query for CUDA devices
`deviceList`
    \- The set of devices to return. This set may be [CU_D3D11_DEVICE_LIST_ALL](<group__CUDA__D3D11.html#group__CUDA__D3D11_1ggf590094e914ab0d2c6a5385711496500f6d10bf4ca0a08ec3a8638799a42f06d>) for all devices, [CU_D3D11_DEVICE_LIST_CURRENT_FRAME](<group__CUDA__D3D11.html#group__CUDA__D3D11_1ggf590094e914ab0d2c6a5385711496500cf10944d19f95ddebf5e2a56b3313bb2>) for the devices used to render the current frame (in SLI), or [CU_D3D11_DEVICE_LIST_NEXT_FRAME](<group__CUDA__D3D11.html#group__CUDA__D3D11_1ggf590094e914ab0d2c6a53857114965006f90591f1e5804a28848a8ce6654d986>) for the devices used to render the next frame (in SLI).

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_DEINITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9acf52f132faf29b473cdda6061f0f44a>), [CUDA_ERROR_NOT_INITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e98feb999f0af99b4a25ab26b3866f4df8>), [CUDA_ERROR_NO_DEVICE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9761bea84083d384d4fb88d51d972aada>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>), [CUDA_ERROR_NOT_FOUND](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9af1cadbeb21d3a78115ca211ba44c053>), [CUDA_ERROR_UNKNOWN](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9c5a6ab0245179d297f1fa56ed0097183>)

###### Description

Returns in `*pCudaDeviceCount` the number of CUDA-compatible device corresponding to the Direct3D 11 device `pD3D11Device`. Also returns in `*pCudaDevices` at most `cudaDeviceCount` of the CUDA-compatible devices corresponding to the Direct3D 11 device `pD3D11Device`.

If any of the GPUs being used to render `pDevice` are not CUDA capable then the call will return [CUDA_ERROR_NO_DEVICE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9761bea84083d384d4fb88d51d972aada>).

Note:

Note that this function may also return error codes from previous, asynchronous launches.

**See also:**

[cuD3D11GetDevice](<group__CUDA__D3D11.html#group__CUDA__D3D11_1ga1f1648cdf3bd5aef7a55af6dc1f42cd> "Gets the CUDA device corresponding to a display adapter."), [cudaD3D11GetDevices](<../cuda-runtime-api/group__CUDART__D3D11.html#group__CUDART__D3D11_1gd928ba905f56d69fd91a2145f15d3590>)

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuGraphicsD3D11RegisterResource ( [CUgraphicsResource](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc0c4e1704647178d9c5ba3be46517dcd>)*Â pCudaResource, ID3D11Resource*Â pD3DResource, unsigned int Â Flags )


Register a Direct3D 11 resource for access by CUDA.

######  Parameters

`pCudaResource`
    \- Returned graphics resource handle
`pD3DResource`
    \- Direct3D resource to register
`Flags`
    \- Parameters for resource registration

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_DEINITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9acf52f132faf29b473cdda6061f0f44a>), [CUDA_ERROR_NOT_INITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e98feb999f0af99b4a25ab26b3866f4df8>), [CUDA_ERROR_INVALID_CONTEXT](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a484e9af32c1e9893ff21f0e0191a12d>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>), [CUDA_ERROR_INVALID_HANDLE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e90fd2e63260c6317ba943af0f7e4b8d21>), [CUDA_ERROR_OUT_OF_MEMORY](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9264c50688ed110e8476b591befe60c02>), [CUDA_ERROR_UNKNOWN](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9c5a6ab0245179d297f1fa56ed0097183>)

###### Description

Registers the Direct3D 11 resource `pD3DResource` for access by CUDA and returns a CUDA handle to `pD3Dresource` in `pCudaResource`. The handle returned in `pCudaResource` may be used to map and unmap this resource until it is unregistered. On success this call will increase the internal reference count on `pD3DResource`. This reference count will be decremented when this resource is unregistered through [cuGraphicsUnregisterResource()](<group__CUDA__GRAPHICS.html#group__CUDA__GRAPHICS_1ga7e5e97b74eaa13dfa6582e853e4c96d> "Unregisters a graphics resource for access by CUDA.").

This call is potentially high-overhead and should not be called every frame in interactive applications.

The type of `pD3DResource` must be one of the following.

  * ID3D11Buffer: may be accessed through a device pointer.

  * ID3D11Texture1D: individual subresources of the texture may be accessed via arrays

  * ID3D11Texture2D: individual subresources of the texture may be accessed via arrays

  * ID3D11Texture3D: individual subresources of the texture may be accessed via arrays


The `Flags` argument may be used to specify additional parameters at register time. The valid values for this parameter are

  * CU_GRAPHICS_REGISTER_FLAGS_NONE: Specifies no hints about how this resource will be used.

  * CU_GRAPHICS_REGISTER_FLAGS_SURFACE_LDST: Specifies that CUDA will bind this resource to a surface reference.

  * CU_GRAPHICS_REGISTER_FLAGS_TEXTURE_GATHER: Specifies that CUDA will perform texture gather operations on this resource.


Not all Direct3D resources of the above types may be used for interoperability with CUDA. The following are some limitations.

  * The primary rendertarget may not be registered with CUDA.

  * Textures which are not of a format which is 1, 2, or 4 channels of 8, 16, or 32-bit integer or floating-point data cannot be shared.

  * Surfaces of depth or stencil formats cannot be shared.


A complete list of supported DXGI formats is as follows. For compactness the notation A_{B,C,D} represents A_B, A_C, and A_D.

  * DXGI_FORMAT_A8_UNORM

  * DXGI_FORMAT_B8G8R8A8_UNORM

  * DXGI_FORMAT_B8G8R8X8_UNORM

  * DXGI_FORMAT_R16_FLOAT

  * DXGI_FORMAT_R16G16B16A16_{FLOAT,SINT,SNORM,UINT,UNORM}

  * DXGI_FORMAT_R16G16_{FLOAT,SINT,SNORM,UINT,UNORM}

  * DXGI_FORMAT_R16_{SINT,SNORM,UINT,UNORM}

  * DXGI_FORMAT_R32_FLOAT

  * DXGI_FORMAT_R32G32B32A32_{FLOAT,SINT,UINT}

  * DXGI_FORMAT_R32G32_{FLOAT,SINT,UINT}

  * DXGI_FORMAT_R32_{SINT,UINT}

  * DXGI_FORMAT_R8G8B8A8_{SINT,SNORM,UINT,UNORM,UNORM_SRGB}

  * DXGI_FORMAT_R8G8_{SINT,SNORM,UINT,UNORM}

  * DXGI_FORMAT_R8_{SINT,SNORM,UINT,UNORM}


If `pD3DResource` is of incorrect type or is already registered then [CUDA_ERROR_INVALID_HANDLE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e90fd2e63260c6317ba943af0f7e4b8d21>) is returned. If `pD3DResource` cannot be registered then [CUDA_ERROR_UNKNOWN](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9c5a6ab0245179d297f1fa56ed0097183>) is returned. If `Flags` is not one of the above specified value then [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>) is returned.

Note:

Note that this function may also return error codes from previous, asynchronous launches.

**See also:**

[cuGraphicsUnregisterResource](<group__CUDA__GRAPHICS.html#group__CUDA__GRAPHICS_1ga7e5e97b74eaa13dfa6582e853e4c96d> "Unregisters a graphics resource for access by CUDA."), [cuGraphicsMapResources](<group__CUDA__GRAPHICS.html#group__CUDA__GRAPHICS_1gffcfd8e78d82cc4f6dd987e8bce4edb0> "Map graphics resources for access by CUDA."), [cuGraphicsSubResourceGetMappedArray](<group__CUDA__GRAPHICS.html#group__CUDA__GRAPHICS_1g61c55e987e54558cce547240d6123078> "Get an array through which to access a subresource of a mapped graphics resource."), [cuGraphicsResourceGetMappedPointer](<group__CUDA__GRAPHICS.html#group__CUDA__GRAPHICS_1g8a634cf4150d399f0018061580592457> "Get a device pointer through which to access a mapped graphics resource."), [cudaGraphicsD3D11RegisterResource](<../cuda-runtime-api/group__CUDART__D3D11.html#group__CUDART__D3D11_1g85d07753780643584b8febab0370623b>)

### Direct3D 11 Interoperability [DEPRECATED]

* * *


---

# Direct3D 11 (Deprecated)

## 6.43.1.Â Direct3D 11 Interoperability [DEPRECATED]

## [[Direct3D 11 Interoperability](<group__CUDA__D3D11.html#group__CUDA__D3D11>)]

This section describes deprecated Direct3D 11 interoperability functionality.

### Functions

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuD3D11CtxCreate](<#group__CUDA__D3D11__DEPRECATED_1gc81ef881bbd18ff5527f37e8a76fd761>) ( [CUcontext](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gf9f5bd81658f866613785b3a0bb7d7d9>)*Â pCtx, [CUdevice](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g41ca2a24a242b36ef2ca77330b5fb72a>)*Â pCudaDevice, unsigned int Â Flags, ID3D11Device*Â pD3DDevice )
     Create a CUDA context for interoperability with Direct3D 11.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuD3D11CtxCreateOnDevice](<#group__CUDA__D3D11__DEPRECATED_1g9f5d54aa09837416a552b16d52479a02>) ( [CUcontext](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gf9f5bd81658f866613785b3a0bb7d7d9>)*Â pCtx, unsigned int Â flags, ID3D11Device*Â pD3DDevice, [CUdevice](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g41ca2a24a242b36ef2ca77330b5fb72a>)Â cudaDevice )
     Create a CUDA context for interoperability with Direct3D 11.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuD3D11GetDirect3DDevice](<#group__CUDA__D3D11__DEPRECATED_1g0b929512b51e56cfef54f2616bd33ed8>) ( ID3D11Device**Â ppD3DDevice )
     Get the Direct3D 11 device against which the current CUDA context was created.

### Functions

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuD3D11CtxCreate ( [CUcontext](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gf9f5bd81658f866613785b3a0bb7d7d9>)*Â pCtx, [CUdevice](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g41ca2a24a242b36ef2ca77330b5fb72a>)*Â pCudaDevice, unsigned int Â Flags, ID3D11Device*Â pD3DDevice )


Create a CUDA context for interoperability with Direct3D 11.

######  Parameters

`pCtx`
    \- Returned newly created CUDA context
`pCudaDevice`
    \- Returned pointer to the device on which the context was created
`Flags`
    \- Context creation flags (see [cuCtxCreate()](<group__CUDA__CTX.html#group__CUDA__CTX_1g77e9fb578caefca5ed15b4acebf35265> "Create a CUDA context.") for details)
`pD3DDevice`
    \- Direct3D device to create interoperability context with

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_DEINITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9acf52f132faf29b473cdda6061f0f44a>), [CUDA_ERROR_NOT_INITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e98feb999f0af99b4a25ab26b3866f4df8>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>), [CUDA_ERROR_OUT_OF_MEMORY](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9264c50688ed110e8476b591befe60c02>), [CUDA_ERROR_UNKNOWN](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9c5a6ab0245179d297f1fa56ed0097183>)

###### [Deprecated](<deprecated.html#deprecated__deprecated_1_deprecated000103>)

This function is deprecated as of CUDA 5.0.

###### Description

This function is deprecated and should no longer be used. It is no longer necessary to associate a CUDA context with a D3D11 device in order to achieve maximum interoperability performance.

Note:

Note that this function may also return error codes from previous, asynchronous launches.

**See also:**

[cuD3D11GetDevice](<group__CUDA__D3D11.html#group__CUDA__D3D11_1ga1f1648cdf3bd5aef7a55af6dc1f42cd> "Gets the CUDA device corresponding to a display adapter."), [cuGraphicsD3D11RegisterResource](<group__CUDA__D3D11.html#group__CUDA__D3D11_1g4c02792aa87c3acc255b9de15b0509da> "Register a Direct3D 11 resource for access by CUDA.")

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuD3D11CtxCreateOnDevice ( [CUcontext](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gf9f5bd81658f866613785b3a0bb7d7d9>)*Â pCtx, unsigned int Â flags, ID3D11Device*Â pD3DDevice, [CUdevice](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g41ca2a24a242b36ef2ca77330b5fb72a>)Â cudaDevice )


Create a CUDA context for interoperability with Direct3D 11.

######  Parameters

`pCtx`
    \- Returned newly created CUDA context
`flags`
    \- Context creation flags (see [cuCtxCreate()](<group__CUDA__CTX.html#group__CUDA__CTX_1g77e9fb578caefca5ed15b4acebf35265> "Create a CUDA context.") for details)
`pD3DDevice`
    \- Direct3D device to create interoperability context with
`cudaDevice`
    \- The CUDA device on which to create the context. This device must be among the devices returned when querying CU_D3D11_DEVICES_ALL from [cuD3D11GetDevices](<group__CUDA__D3D11.html#group__CUDA__D3D11_1g7fca109b0dba2050b58f6bac627ff441> "Gets the CUDA devices corresponding to a Direct3D 11 device.").

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_DEINITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9acf52f132faf29b473cdda6061f0f44a>), [CUDA_ERROR_NOT_INITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e98feb999f0af99b4a25ab26b3866f4df8>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>), [CUDA_ERROR_OUT_OF_MEMORY](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9264c50688ed110e8476b591befe60c02>), [CUDA_ERROR_UNKNOWN](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9c5a6ab0245179d297f1fa56ed0097183>)

###### [Deprecated](<deprecated.html#deprecated__deprecated_1_deprecated000104>)

This function is deprecated as of CUDA 5.0.

###### Description

This function is deprecated and should no longer be used. It is no longer necessary to associate a CUDA context with a D3D11 device in order to achieve maximum interoperability performance.

Note:

Note that this function may also return error codes from previous, asynchronous launches.

**See also:**

[cuD3D11GetDevices](<group__CUDA__D3D11.html#group__CUDA__D3D11_1g7fca109b0dba2050b58f6bac627ff441> "Gets the CUDA devices corresponding to a Direct3D 11 device."), [cuGraphicsD3D11RegisterResource](<group__CUDA__D3D11.html#group__CUDA__D3D11_1g4c02792aa87c3acc255b9de15b0509da> "Register a Direct3D 11 resource for access by CUDA.")

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuD3D11GetDirect3DDevice ( ID3D11Device**Â ppD3DDevice )


Get the Direct3D 11 device against which the current CUDA context was created.

######  Parameters

`ppD3DDevice`
    \- Returned Direct3D device corresponding to CUDA context

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_DEINITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9acf52f132faf29b473cdda6061f0f44a>), [CUDA_ERROR_NOT_INITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e98feb999f0af99b4a25ab26b3866f4df8>), [CUDA_ERROR_INVALID_CONTEXT](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a484e9af32c1e9893ff21f0e0191a12d>)

###### [Deprecated](<deprecated.html#deprecated__deprecated_1_deprecated000105>)

This function is deprecated as of CUDA 5.0.

###### Description

This function is deprecated and should no longer be used. It is no longer necessary to associate a CUDA context with a D3D11 device in order to achieve maximum interoperability performance.

Note:

Note that this function may also return error codes from previous, asynchronous launches.

**See also:**

[cuD3D11GetDevice](<group__CUDA__D3D11.html#group__CUDA__D3D11_1ga1f1648cdf3bd5aef7a55af6dc1f42cd> "Gets the CUDA device corresponding to a display adapter.")

* * *


---

# VDPAU Interoperability

## 6.44.Â VDPAU Interoperability

This section describes the VDPAU interoperability functions of the low-level CUDA driver application programming interface.

### Functions

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuGraphicsVDPAURegisterOutputSurface](<#group__CUDA__VDPAU_1g54874c7f771e51f27292a562c92cee28>) ( [CUgraphicsResource](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc0c4e1704647178d9c5ba3be46517dcd>)*Â pCudaResource, VdpOutputSurfaceÂ vdpSurface, unsigned int Â flags )
     Registers a VDPAU VdpOutputSurface object.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuGraphicsVDPAURegisterVideoSurface](<#group__CUDA__VDPAU_1ga5e00ff2d3ff2f8b680a69f3bc5cd891>) ( [CUgraphicsResource](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc0c4e1704647178d9c5ba3be46517dcd>)*Â pCudaResource, VdpVideoSurfaceÂ vdpSurface, unsigned int Â flags )
     Registers a VDPAU VdpVideoSurface object.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuVDPAUCtxCreate](<#group__CUDA__VDPAU_1gbfca4396947b5f194901c279cc6973d4>) ( [CUcontext](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gf9f5bd81658f866613785b3a0bb7d7d9>)*Â pCtx, unsigned int Â flags, [CUdevice](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g41ca2a24a242b36ef2ca77330b5fb72a>)Â device, VdpDeviceÂ vdpDevice, VdpGetProcAddress*Â vdpGetProcAddress )
     Create a CUDA context for interoperability with VDPAU.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuVDPAUGetDevice](<#group__CUDA__VDPAU_1g0cce87525545da2cf1e84e007d5fe230>) ( [CUdevice](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g41ca2a24a242b36ef2ca77330b5fb72a>)*Â pDevice, VdpDeviceÂ vdpDevice, VdpGetProcAddress*Â vdpGetProcAddress )
     Gets the CUDA device associated with a VDPAU device.

### Functions

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuGraphicsVDPAURegisterOutputSurface ( [CUgraphicsResource](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc0c4e1704647178d9c5ba3be46517dcd>)*Â pCudaResource, VdpOutputSurfaceÂ vdpSurface, unsigned int Â flags )


Registers a VDPAU VdpOutputSurface object.

######  Parameters

`pCudaResource`
    \- Pointer to the returned object handle
`vdpSurface`
    \- The VdpOutputSurface to be registered
`flags`
    \- Map flags

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_INVALID_HANDLE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e90fd2e63260c6317ba943af0f7e4b8d21>), [CUDA_ERROR_ALREADY_MAPPED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9240bb253a699176d9f49ee2f2c91b61b>), [CUDA_ERROR_INVALID_CONTEXT](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a484e9af32c1e9893ff21f0e0191a12d>),

###### Description

Registers the VdpOutputSurface specified by `vdpSurface` for access by CUDA. A handle to the registered object is returned as `pCudaResource`. The surface's intended usage is specified using `flags`, as follows:

  * CU_GRAPHICS_MAP_RESOURCE_FLAGS_NONE: Specifies no hints about how this resource will be used. It is therefore assumed that this resource will be read from and written to by CUDA. This is the default value.

  * CU_GRAPHICS_MAP_RESOURCE_FLAGS_READ_ONLY: Specifies that CUDA will not write to this resource.

  * CU_GRAPHICS_MAP_RESOURCE_FLAGS_WRITE_DISCARD: Specifies that CUDA will not read from this resource and will write over the entire contents of the resource, so none of the data previously stored in the resource will be preserved.


The VdpOutputSurface is presented as an array of subresources that may be accessed using pointers returned by [cuGraphicsSubResourceGetMappedArray](<group__CUDA__GRAPHICS.html#group__CUDA__GRAPHICS_1g61c55e987e54558cce547240d6123078> "Get an array through which to access a subresource of a mapped graphics resource."). The exact number of valid `arrayIndex` values depends on the VDPAU surface format. The mapping is shown in the table below. `mipLevel` must be 0.

Note:

Note that this function may also return error codes from previous, asynchronous launches.

**See also:**

[cuCtxCreate](<group__CUDA__CTX.html#group__CUDA__CTX_1g77e9fb578caefca5ed15b4acebf35265> "Create a CUDA context."), [cuVDPAUCtxCreate](<group__CUDA__VDPAU.html#group__CUDA__VDPAU_1gbfca4396947b5f194901c279cc6973d4> "Create a CUDA context for interoperability with VDPAU."), [cuGraphicsVDPAURegisterVideoSurface](<group__CUDA__VDPAU.html#group__CUDA__VDPAU_1ga5e00ff2d3ff2f8b680a69f3bc5cd891> "Registers a VDPAU VdpVideoSurface object."), [cuGraphicsUnregisterResource](<group__CUDA__GRAPHICS.html#group__CUDA__GRAPHICS_1ga7e5e97b74eaa13dfa6582e853e4c96d> "Unregisters a graphics resource for access by CUDA."), [cuGraphicsResourceSetMapFlags](<group__CUDA__GRAPHICS.html#group__CUDA__GRAPHICS_1gfe96aa7747f8b11d44a6fa6a851e1b39> "Set usage flags for mapping a graphics resource."), [cuGraphicsMapResources](<group__CUDA__GRAPHICS.html#group__CUDA__GRAPHICS_1gffcfd8e78d82cc4f6dd987e8bce4edb0> "Map graphics resources for access by CUDA."), [cuGraphicsUnmapResources](<group__CUDA__GRAPHICS.html#group__CUDA__GRAPHICS_1g8e9ff25d071375a0df1cb5aee924af32> "Unmap graphics resources."), [cuGraphicsSubResourceGetMappedArray](<group__CUDA__GRAPHICS.html#group__CUDA__GRAPHICS_1g61c55e987e54558cce547240d6123078> "Get an array through which to access a subresource of a mapped graphics resource."), [cuVDPAUGetDevice](<group__CUDA__VDPAU.html#group__CUDA__VDPAU_1g0cce87525545da2cf1e84e007d5fe230> "Gets the CUDA device associated with a VDPAU device."), [cudaGraphicsVDPAURegisterOutputSurface](<../cuda-runtime-api/group__CUDART__VDPAU.html#group__CUDART__VDPAU_1gda9802a968253275d1d79f54debf5f6e>)

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuGraphicsVDPAURegisterVideoSurface ( [CUgraphicsResource](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc0c4e1704647178d9c5ba3be46517dcd>)*Â pCudaResource, VdpVideoSurfaceÂ vdpSurface, unsigned int Â flags )


Registers a VDPAU VdpVideoSurface object.

######  Parameters

`pCudaResource`
    \- Pointer to the returned object handle
`vdpSurface`
    \- The VdpVideoSurface to be registered
`flags`
    \- Map flags

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_INVALID_HANDLE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e90fd2e63260c6317ba943af0f7e4b8d21>), [CUDA_ERROR_ALREADY_MAPPED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9240bb253a699176d9f49ee2f2c91b61b>), [CUDA_ERROR_INVALID_CONTEXT](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a484e9af32c1e9893ff21f0e0191a12d>),

###### Description

Registers the VdpVideoSurface specified by `vdpSurface` for access by CUDA. A handle to the registered object is returned as `pCudaResource`. The surface's intended usage is specified using `flags`, as follows:

  * CU_GRAPHICS_MAP_RESOURCE_FLAGS_NONE: Specifies no hints about how this resource will be used. It is therefore assumed that this resource will be read from and written to by CUDA. This is the default value.

  * CU_GRAPHICS_MAP_RESOURCE_FLAGS_READ_ONLY: Specifies that CUDA will not write to this resource.

  * CU_GRAPHICS_MAP_RESOURCE_FLAGS_WRITE_DISCARD: Specifies that CUDA will not read from this resource and will write over the entire contents of the resource, so none of the data previously stored in the resource will be preserved.


The VdpVideoSurface is presented as an array of subresources that may be accessed using pointers returned by [cuGraphicsSubResourceGetMappedArray](<group__CUDA__GRAPHICS.html#group__CUDA__GRAPHICS_1g61c55e987e54558cce547240d6123078> "Get an array through which to access a subresource of a mapped graphics resource."). The exact number of valid `arrayIndex` values depends on the VDPAU surface format. The mapping is shown in the table below. `mipLevel` must be 0.

Note:

Note that this function may also return error codes from previous, asynchronous launches.

**See also:**

[cuCtxCreate](<group__CUDA__CTX.html#group__CUDA__CTX_1g77e9fb578caefca5ed15b4acebf35265> "Create a CUDA context."), [cuVDPAUCtxCreate](<group__CUDA__VDPAU.html#group__CUDA__VDPAU_1gbfca4396947b5f194901c279cc6973d4> "Create a CUDA context for interoperability with VDPAU."), [cuGraphicsVDPAURegisterOutputSurface](<group__CUDA__VDPAU.html#group__CUDA__VDPAU_1g54874c7f771e51f27292a562c92cee28> "Registers a VDPAU VdpOutputSurface object."), [cuGraphicsUnregisterResource](<group__CUDA__GRAPHICS.html#group__CUDA__GRAPHICS_1ga7e5e97b74eaa13dfa6582e853e4c96d> "Unregisters a graphics resource for access by CUDA."), [cuGraphicsResourceSetMapFlags](<group__CUDA__GRAPHICS.html#group__CUDA__GRAPHICS_1gfe96aa7747f8b11d44a6fa6a851e1b39> "Set usage flags for mapping a graphics resource."), [cuGraphicsMapResources](<group__CUDA__GRAPHICS.html#group__CUDA__GRAPHICS_1gffcfd8e78d82cc4f6dd987e8bce4edb0> "Map graphics resources for access by CUDA."), [cuGraphicsUnmapResources](<group__CUDA__GRAPHICS.html#group__CUDA__GRAPHICS_1g8e9ff25d071375a0df1cb5aee924af32> "Unmap graphics resources."), [cuGraphicsSubResourceGetMappedArray](<group__CUDA__GRAPHICS.html#group__CUDA__GRAPHICS_1g61c55e987e54558cce547240d6123078> "Get an array through which to access a subresource of a mapped graphics resource."), [cuVDPAUGetDevice](<group__CUDA__VDPAU.html#group__CUDA__VDPAU_1g0cce87525545da2cf1e84e007d5fe230> "Gets the CUDA device associated with a VDPAU device."), [cudaGraphicsVDPAURegisterVideoSurface](<../cuda-runtime-api/group__CUDART__VDPAU.html#group__CUDART__VDPAU_1g0cd4adc9fe3f324927c1719b29ec12fb>)

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuVDPAUCtxCreate ( [CUcontext](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gf9f5bd81658f866613785b3a0bb7d7d9>)*Â pCtx, unsigned int Â flags, [CUdevice](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g41ca2a24a242b36ef2ca77330b5fb72a>)Â device, VdpDeviceÂ vdpDevice, VdpGetProcAddress*Â vdpGetProcAddress )


Create a CUDA context for interoperability with VDPAU.

######  Parameters

`pCtx`
    \- Returned CUDA context
`flags`
    \- Options for CUDA context creation
`device`
    \- Device on which to create the context
`vdpDevice`
    \- The VdpDevice to interop with
`vdpGetProcAddress`
    \- VDPAU's VdpGetProcAddress function pointer

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_DEINITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9acf52f132faf29b473cdda6061f0f44a>), [CUDA_ERROR_NOT_INITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e98feb999f0af99b4a25ab26b3866f4df8>), [CUDA_ERROR_INVALID_CONTEXT](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a484e9af32c1e9893ff21f0e0191a12d>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>), [CUDA_ERROR_OUT_OF_MEMORY](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9264c50688ed110e8476b591befe60c02>)

###### Description

Creates a new CUDA context, initializes VDPAU interoperability, and associates the CUDA context with the calling thread. It must be called before performing any other VDPAU interoperability operations. It may fail if the needed VDPAU driver facilities are not available. For usage of the `flags` parameter, see [cuCtxCreate()](<group__CUDA__CTX.html#group__CUDA__CTX_1g77e9fb578caefca5ed15b4acebf35265> "Create a CUDA context.").

Note:

Note that this function may also return error codes from previous, asynchronous launches.

**See also:**

[cuCtxCreate](<group__CUDA__CTX.html#group__CUDA__CTX_1g77e9fb578caefca5ed15b4acebf35265> "Create a CUDA context."), [cuGraphicsVDPAURegisterVideoSurface](<group__CUDA__VDPAU.html#group__CUDA__VDPAU_1ga5e00ff2d3ff2f8b680a69f3bc5cd891> "Registers a VDPAU VdpVideoSurface object."), [cuGraphicsVDPAURegisterOutputSurface](<group__CUDA__VDPAU.html#group__CUDA__VDPAU_1g54874c7f771e51f27292a562c92cee28> "Registers a VDPAU VdpOutputSurface object."), [cuGraphicsUnregisterResource](<group__CUDA__GRAPHICS.html#group__CUDA__GRAPHICS_1ga7e5e97b74eaa13dfa6582e853e4c96d> "Unregisters a graphics resource for access by CUDA."), [cuGraphicsResourceSetMapFlags](<group__CUDA__GRAPHICS.html#group__CUDA__GRAPHICS_1gfe96aa7747f8b11d44a6fa6a851e1b39> "Set usage flags for mapping a graphics resource."), [cuGraphicsMapResources](<group__CUDA__GRAPHICS.html#group__CUDA__GRAPHICS_1gffcfd8e78d82cc4f6dd987e8bce4edb0> "Map graphics resources for access by CUDA."), [cuGraphicsUnmapResources](<group__CUDA__GRAPHICS.html#group__CUDA__GRAPHICS_1g8e9ff25d071375a0df1cb5aee924af32> "Unmap graphics resources."), [cuGraphicsSubResourceGetMappedArray](<group__CUDA__GRAPHICS.html#group__CUDA__GRAPHICS_1g61c55e987e54558cce547240d6123078> "Get an array through which to access a subresource of a mapped graphics resource."), [cuVDPAUGetDevice](<group__CUDA__VDPAU.html#group__CUDA__VDPAU_1g0cce87525545da2cf1e84e007d5fe230> "Gets the CUDA device associated with a VDPAU device.")

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuVDPAUGetDevice ( [CUdevice](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g41ca2a24a242b36ef2ca77330b5fb72a>)*Â pDevice, VdpDeviceÂ vdpDevice, VdpGetProcAddress*Â vdpGetProcAddress )


Gets the CUDA device associated with a VDPAU device.

######  Parameters

`pDevice`
    \- Device associated with vdpDevice
`vdpDevice`
    \- A VdpDevice handle
`vdpGetProcAddress`
    \- VDPAU's VdpGetProcAddress function pointer

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_DEINITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9acf52f132faf29b473cdda6061f0f44a>), [CUDA_ERROR_NOT_INITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e98feb999f0af99b4a25ab26b3866f4df8>), [CUDA_ERROR_INVALID_CONTEXT](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a484e9af32c1e9893ff21f0e0191a12d>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>)

###### Description

Returns in `*pDevice` the CUDA device associated with a `vdpDevice`, if applicable.

Note:

Note that this function may also return error codes from previous, asynchronous launches.

**See also:**

[cuCtxCreate](<group__CUDA__CTX.html#group__CUDA__CTX_1g77e9fb578caefca5ed15b4acebf35265> "Create a CUDA context."), [cuVDPAUCtxCreate](<group__CUDA__VDPAU.html#group__CUDA__VDPAU_1gbfca4396947b5f194901c279cc6973d4> "Create a CUDA context for interoperability with VDPAU."), [cuGraphicsVDPAURegisterVideoSurface](<group__CUDA__VDPAU.html#group__CUDA__VDPAU_1ga5e00ff2d3ff2f8b680a69f3bc5cd891> "Registers a VDPAU VdpVideoSurface object."), [cuGraphicsVDPAURegisterOutputSurface](<group__CUDA__VDPAU.html#group__CUDA__VDPAU_1g54874c7f771e51f27292a562c92cee28> "Registers a VDPAU VdpOutputSurface object."), [cuGraphicsUnregisterResource](<group__CUDA__GRAPHICS.html#group__CUDA__GRAPHICS_1ga7e5e97b74eaa13dfa6582e853e4c96d> "Unregisters a graphics resource for access by CUDA."), [cuGraphicsResourceSetMapFlags](<group__CUDA__GRAPHICS.html#group__CUDA__GRAPHICS_1gfe96aa7747f8b11d44a6fa6a851e1b39> "Set usage flags for mapping a graphics resource."), [cuGraphicsMapResources](<group__CUDA__GRAPHICS.html#group__CUDA__GRAPHICS_1gffcfd8e78d82cc4f6dd987e8bce4edb0> "Map graphics resources for access by CUDA."), [cuGraphicsUnmapResources](<group__CUDA__GRAPHICS.html#group__CUDA__GRAPHICS_1g8e9ff25d071375a0df1cb5aee924af32> "Unmap graphics resources."), [cuGraphicsSubResourceGetMappedArray](<group__CUDA__GRAPHICS.html#group__CUDA__GRAPHICS_1g61c55e987e54558cce547240d6123078> "Get an array through which to access a subresource of a mapped graphics resource."), [cudaVDPAUGetDevice](<../cuda-runtime-api/group__CUDART__VDPAU.html#group__CUDART__VDPAU_1g242a0ba3eef80229ac3702e05f9eb1d9>)

* * *


---

# EGL Interoperability

## 6.45.Â EGL Interoperability

This section describes the EGL interoperability functions of the low-level CUDA driver application programming interface.

### Functions

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuEGLStreamConsumerAcquireFrame](<#group__CUDA__EGL_1g10507a0acb74a90136caacb363a3c6a7>) ( [CUeglStreamConnection](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g60c595264697050bc2bb8e00cf5f86e7>)*Â conn, [CUgraphicsResource](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc0c4e1704647178d9c5ba3be46517dcd>)*Â pCudaResource, [CUstream](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gb946c7f02e09efd788a204718015d88a>)*Â pStream, unsigned int Â timeout )
     Acquire an image frame from the EGLStream with CUDA as a consumer.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuEGLStreamConsumerConnect](<#group__CUDA__EGL_1g3f59b85a292d59c19c8b64b8ade8a658>) ( [CUeglStreamConnection](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g60c595264697050bc2bb8e00cf5f86e7>)*Â conn, EGLStreamKHRÂ stream )
     Connect CUDA to EGLStream as a consumer.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuEGLStreamConsumerConnectWithFlags](<#group__CUDA__EGL_1g7be3b064ea600a7bac4906e5d61ba4b7>) ( [CUeglStreamConnection](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g60c595264697050bc2bb8e00cf5f86e7>)*Â conn, EGLStreamKHRÂ stream, unsigned int Â flags )
     Connect CUDA to EGLStream as a consumer with given flags.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuEGLStreamConsumerDisconnect](<#group__CUDA__EGL_1g3ab15cff9be3b25447714101ecda6a61>) ( [CUeglStreamConnection](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g60c595264697050bc2bb8e00cf5f86e7>)*Â conn )
     Disconnect CUDA as a consumer to EGLStream .
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuEGLStreamConsumerReleaseFrame](<#group__CUDA__EGL_1g4dadfefc718210e91c8f44f6a8e4b233>) ( [CUeglStreamConnection](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g60c595264697050bc2bb8e00cf5f86e7>)*Â conn, [CUgraphicsResource](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc0c4e1704647178d9c5ba3be46517dcd>)Â pCudaResource, [CUstream](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gb946c7f02e09efd788a204718015d88a>)*Â pStream )
     Releases the last frame acquired from the EGLStream.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuEGLStreamProducerConnect](<#group__CUDA__EGL_1g5d181803d994a06f1bf9b05f52757bef>) ( [CUeglStreamConnection](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g60c595264697050bc2bb8e00cf5f86e7>)*Â conn, EGLStreamKHRÂ stream, EGLintÂ width, EGLintÂ height )
     Connect CUDA to EGLStream as a producer.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuEGLStreamProducerDisconnect](<#group__CUDA__EGL_1gbdc9664bfb17dd3fa1e0a3ca68a8cafd>) ( [CUeglStreamConnection](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g60c595264697050bc2bb8e00cf5f86e7>)*Â conn )
     Disconnect CUDA as a producer to EGLStream .
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuEGLStreamProducerPresentFrame](<#group__CUDA__EGL_1g60dcaadeabcbaedb4a271d529306687b>) ( [CUeglStreamConnection](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g60c595264697050bc2bb8e00cf5f86e7>)*Â conn, [CUeglFrame](<structCUeglFrame__v1.html#structCUeglFrame__v1>)Â eglframe, [CUstream](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gb946c7f02e09efd788a204718015d88a>)*Â pStream )
     Present a CUDA eglFrame to the EGLStream with CUDA as a producer.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuEGLStreamProducerReturnFrame](<#group__CUDA__EGL_1g70c84d9d01f343fc07cd632f9cfc3a06>) ( [CUeglStreamConnection](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g60c595264697050bc2bb8e00cf5f86e7>)*Â conn, [CUeglFrame](<structCUeglFrame__v1.html#structCUeglFrame__v1>)*Â eglframe, [CUstream](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gb946c7f02e09efd788a204718015d88a>)*Â pStream )
     Return the CUDA eglFrame to the EGLStream released by the consumer.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuEventCreateFromEGLSync](<#group__CUDA__EGL_1gc1f625de07ffc410973fcc9709e36342>) ( [CUevent](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g6d740185cf0953636d4ae37f68d7559b>)*Â phEvent, EGLSyncKHRÂ eglSync, unsigned int Â flags )
     Creates an event from EGLSync object.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuGraphicsEGLRegisterImage](<#group__CUDA__EGL_1g9f9b026d175238be6f6e79048d6879c5>) ( [CUgraphicsResource](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc0c4e1704647178d9c5ba3be46517dcd>)*Â pCudaResource, EGLImageKHRÂ image, unsigned int Â flags )
     Registers an EGL image.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuGraphicsResourceGetMappedEglFrame](<#group__CUDA__EGL_1ge1e57193ad1dbf554af60d5b2d096ede>) ( [CUeglFrame](<structCUeglFrame__v1.html#structCUeglFrame__v1>)*Â eglFrame, [CUgraphicsResource](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc0c4e1704647178d9c5ba3be46517dcd>)Â resource, unsigned int Â index, unsigned int Â mipLevel )
     Get an eglFrame through which to access a registered EGL graphics resource.

### Functions

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuEGLStreamConsumerAcquireFrame ( [CUeglStreamConnection](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g60c595264697050bc2bb8e00cf5f86e7>)*Â conn, [CUgraphicsResource](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc0c4e1704647178d9c5ba3be46517dcd>)*Â pCudaResource, [CUstream](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gb946c7f02e09efd788a204718015d88a>)*Â pStream, unsigned int Â timeout )


Acquire an image frame from the EGLStream with CUDA as a consumer.

######  Parameters

`conn`
    \- Connection on which to acquire
`pCudaResource`
    \- CUDA resource on which the stream frame will be mapped for use.
`pStream`
    \- CUDA stream for synchronization and any data migrations implied by [CUeglResourceLocationFlags](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gf2804cd7cda3b8716c31ba620f644cd3>).
`timeout`
    \- Desired timeout in usec for a new frame to be acquired. If set as [CUDA_EGL_INFINITE_TIMEOUT](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g71b9a58998751468a873848efd699af3>), acquire waits infinitely. After timeout occurs CUDA consumer tries to acquire an old frame if available and EGL_SUPPORT_REUSE_NV flag is set.

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_INVALID_HANDLE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e90fd2e63260c6317ba943af0f7e4b8d21>), [CUDA_ERROR_LAUNCH_TIMEOUT](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e965460d83f63575af9805ca59f8f19d74>),

###### Description

Acquire an image frame from EGLStreamKHR. This API can also acquire an old frame presented by the producer unless explicitly disabled by setting EGL_SUPPORT_REUSE_NV flag to EGL_FALSE during stream initialization. By default, EGLStream is created with this flag set to EGL_TRUE. [cuGraphicsResourceGetMappedEglFrame](<group__CUDA__EGL.html#group__CUDA__EGL_1ge1e57193ad1dbf554af60d5b2d096ede> "Get an eglFrame through which to access a registered EGL graphics resource.") can be called on `pCudaResource` to get CUeglFrame.

**See also:**

[cuEGLStreamConsumerConnect](<group__CUDA__EGL.html#group__CUDA__EGL_1g3f59b85a292d59c19c8b64b8ade8a658> "Connect CUDA to EGLStream as a consumer."), [cuEGLStreamConsumerDisconnect](<group__CUDA__EGL.html#group__CUDA__EGL_1g3ab15cff9be3b25447714101ecda6a61> "Disconnect CUDA as a consumer to EGLStream ."), [cuEGLStreamConsumerAcquireFrame](<group__CUDA__EGL.html#group__CUDA__EGL_1g10507a0acb74a90136caacb363a3c6a7> "Acquire an image frame from the EGLStream with CUDA as a consumer."), [cuEGLStreamConsumerReleaseFrame](<group__CUDA__EGL.html#group__CUDA__EGL_1g4dadfefc718210e91c8f44f6a8e4b233> "Releases the last frame acquired from the EGLStream."), [cudaEGLStreamConsumerAcquireFrame](<../cuda-runtime-api/group__CUDART__EGL.html#group__CUDART__EGL_1g83dd1bfea48c093d3f0b247754970f58>)

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuEGLStreamConsumerConnect ( [CUeglStreamConnection](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g60c595264697050bc2bb8e00cf5f86e7>)*Â conn, EGLStreamKHRÂ stream )


Connect CUDA to EGLStream as a consumer.

######  Parameters

`conn`
    \- Pointer to the returned connection handle
`stream`
    \- EGLStreamKHR handle

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_INVALID_HANDLE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e90fd2e63260c6317ba943af0f7e4b8d21>), [CUDA_ERROR_INVALID_CONTEXT](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a484e9af32c1e9893ff21f0e0191a12d>),

###### Description

Connect CUDA as a consumer to EGLStreamKHR specified by `stream`.

The EGLStreamKHR is an EGL object that transfers a sequence of image frames from one API to another.

**See also:**

[cuEGLStreamConsumerConnect](<group__CUDA__EGL.html#group__CUDA__EGL_1g3f59b85a292d59c19c8b64b8ade8a658> "Connect CUDA to EGLStream as a consumer."), [cuEGLStreamConsumerDisconnect](<group__CUDA__EGL.html#group__CUDA__EGL_1g3ab15cff9be3b25447714101ecda6a61> "Disconnect CUDA as a consumer to EGLStream ."), [cuEGLStreamConsumerAcquireFrame](<group__CUDA__EGL.html#group__CUDA__EGL_1g10507a0acb74a90136caacb363a3c6a7> "Acquire an image frame from the EGLStream with CUDA as a consumer."), [cuEGLStreamConsumerReleaseFrame](<group__CUDA__EGL.html#group__CUDA__EGL_1g4dadfefc718210e91c8f44f6a8e4b233> "Releases the last frame acquired from the EGLStream."), [cudaEGLStreamConsumerConnect](<../cuda-runtime-api/group__CUDART__EGL.html#group__CUDART__EGL_1g7993b0e3802420547e3f403549be65a1>)

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuEGLStreamConsumerConnectWithFlags ( [CUeglStreamConnection](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g60c595264697050bc2bb8e00cf5f86e7>)*Â conn, EGLStreamKHRÂ stream, unsigned int Â flags )


Connect CUDA to EGLStream as a consumer with given flags.

######  Parameters

`conn`
    \- Pointer to the returned connection handle
`stream`
    \- EGLStreamKHR handle
`flags`
    \- Flags denote intended location - system or video.

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_INVALID_HANDLE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e90fd2e63260c6317ba943af0f7e4b8d21>), [CUDA_ERROR_INVALID_CONTEXT](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a484e9af32c1e9893ff21f0e0191a12d>),

###### Description

Connect CUDA as a consumer to EGLStreamKHR specified by `stream` with specified `flags` defined by CUeglResourceLocationFlags.

The flags specify whether the consumer wants to access frames from system memory or video memory. Default is [CU_EGL_RESOURCE_LOCATION_VIDMEM](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggf2804cd7cda3b8716c31ba620f644cd3115dedc3b0a393b00d2c38d996daeedc>).

**See also:**

[cuEGLStreamConsumerConnect](<group__CUDA__EGL.html#group__CUDA__EGL_1g3f59b85a292d59c19c8b64b8ade8a658> "Connect CUDA to EGLStream as a consumer."), [cuEGLStreamConsumerDisconnect](<group__CUDA__EGL.html#group__CUDA__EGL_1g3ab15cff9be3b25447714101ecda6a61> "Disconnect CUDA as a consumer to EGLStream ."), [cuEGLStreamConsumerAcquireFrame](<group__CUDA__EGL.html#group__CUDA__EGL_1g10507a0acb74a90136caacb363a3c6a7> "Acquire an image frame from the EGLStream with CUDA as a consumer."), [cuEGLStreamConsumerReleaseFrame](<group__CUDA__EGL.html#group__CUDA__EGL_1g4dadfefc718210e91c8f44f6a8e4b233> "Releases the last frame acquired from the EGLStream."), [cudaEGLStreamConsumerConnectWithFlags](<../cuda-runtime-api/group__CUDART__EGL.html#group__CUDART__EGL_1g4e2d79eb6bcb9eca4f6e3f13eb3f7fc3>)

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuEGLStreamConsumerDisconnect ( [CUeglStreamConnection](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g60c595264697050bc2bb8e00cf5f86e7>)*Â conn )


Disconnect CUDA as a consumer to EGLStream .

######  Parameters

`conn`
    \- Conection to disconnect.

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_INVALID_HANDLE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e90fd2e63260c6317ba943af0f7e4b8d21>), [CUDA_ERROR_INVALID_CONTEXT](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a484e9af32c1e9893ff21f0e0191a12d>),

###### Description

Disconnect CUDA as a consumer to EGLStreamKHR.

**See also:**

[cuEGLStreamConsumerConnect](<group__CUDA__EGL.html#group__CUDA__EGL_1g3f59b85a292d59c19c8b64b8ade8a658> "Connect CUDA to EGLStream as a consumer."), [cuEGLStreamConsumerDisconnect](<group__CUDA__EGL.html#group__CUDA__EGL_1g3ab15cff9be3b25447714101ecda6a61> "Disconnect CUDA as a consumer to EGLStream ."), [cuEGLStreamConsumerAcquireFrame](<group__CUDA__EGL.html#group__CUDA__EGL_1g10507a0acb74a90136caacb363a3c6a7> "Acquire an image frame from the EGLStream with CUDA as a consumer."), [cuEGLStreamConsumerReleaseFrame](<group__CUDA__EGL.html#group__CUDA__EGL_1g4dadfefc718210e91c8f44f6a8e4b233> "Releases the last frame acquired from the EGLStream."), [cudaEGLStreamConsumerDisconnect](<../cuda-runtime-api/group__CUDART__EGL.html#group__CUDART__EGL_1gb2ef252e72ad2419506f3cf305753c6a>)

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuEGLStreamConsumerReleaseFrame ( [CUeglStreamConnection](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g60c595264697050bc2bb8e00cf5f86e7>)*Â conn, [CUgraphicsResource](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc0c4e1704647178d9c5ba3be46517dcd>)Â pCudaResource, [CUstream](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gb946c7f02e09efd788a204718015d88a>)*Â pStream )


Releases the last frame acquired from the EGLStream.

######  Parameters

`conn`
    \- Connection on which to release
`pCudaResource`
    \- CUDA resource whose corresponding frame is to be released
`pStream`
    \- CUDA stream on which release will be done.

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_INVALID_HANDLE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e90fd2e63260c6317ba943af0f7e4b8d21>),

###### Description

Release the acquired image frame specified by `pCudaResource` to EGLStreamKHR. If EGL_SUPPORT_REUSE_NV flag is set to EGL_TRUE, at the time of EGL creation this API doesn't release the last frame acquired on the EGLStream. By default, EGLStream is created with this flag set to EGL_TRUE.

**See also:**

[cuEGLStreamConsumerConnect](<group__CUDA__EGL.html#group__CUDA__EGL_1g3f59b85a292d59c19c8b64b8ade8a658> "Connect CUDA to EGLStream as a consumer."), [cuEGLStreamConsumerDisconnect](<group__CUDA__EGL.html#group__CUDA__EGL_1g3ab15cff9be3b25447714101ecda6a61> "Disconnect CUDA as a consumer to EGLStream ."), [cuEGLStreamConsumerAcquireFrame](<group__CUDA__EGL.html#group__CUDA__EGL_1g10507a0acb74a90136caacb363a3c6a7> "Acquire an image frame from the EGLStream with CUDA as a consumer."), [cuEGLStreamConsumerReleaseFrame](<group__CUDA__EGL.html#group__CUDA__EGL_1g4dadfefc718210e91c8f44f6a8e4b233> "Releases the last frame acquired from the EGLStream."), [cudaEGLStreamConsumerReleaseFrame](<../cuda-runtime-api/group__CUDART__EGL.html#group__CUDART__EGL_1g51b3df89a3e0eb8baad7449674797467>)

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuEGLStreamProducerConnect ( [CUeglStreamConnection](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g60c595264697050bc2bb8e00cf5f86e7>)*Â conn, EGLStreamKHRÂ stream, EGLintÂ width, EGLintÂ height )


Connect CUDA to EGLStream as a producer.

######  Parameters

`conn`
    \- Pointer to the returned connection handle
`stream`
    \- EGLStreamKHR handle
`width`
    \- width of the image to be submitted to the stream
`height`
    \- height of the image to be submitted to the stream

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_INVALID_HANDLE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e90fd2e63260c6317ba943af0f7e4b8d21>), [CUDA_ERROR_INVALID_CONTEXT](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a484e9af32c1e9893ff21f0e0191a12d>),

###### Description

Connect CUDA as a producer to EGLStreamKHR specified by `stream`.

The EGLStreamKHR is an EGL object that transfers a sequence of image frames from one API to another.

**See also:**

[cuEGLStreamProducerConnect](<group__CUDA__EGL.html#group__CUDA__EGL_1g5d181803d994a06f1bf9b05f52757bef> "Connect CUDA to EGLStream as a producer."), [cuEGLStreamProducerDisconnect](<group__CUDA__EGL.html#group__CUDA__EGL_1gbdc9664bfb17dd3fa1e0a3ca68a8cafd> "Disconnect CUDA as a producer to EGLStream ."), [cuEGLStreamProducerPresentFrame](<group__CUDA__EGL.html#group__CUDA__EGL_1g60dcaadeabcbaedb4a271d529306687b> "Present a CUDA eglFrame to the EGLStream with CUDA as a producer."), [cudaEGLStreamProducerConnect](<../cuda-runtime-api/group__CUDART__EGL.html#group__CUDART__EGL_1gf35966d50689874614985f688a888c03>)

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuEGLStreamProducerDisconnect ( [CUeglStreamConnection](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g60c595264697050bc2bb8e00cf5f86e7>)*Â conn )


Disconnect CUDA as a producer to EGLStream .

######  Parameters

`conn`
    \- Conection to disconnect.

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_INVALID_HANDLE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e90fd2e63260c6317ba943af0f7e4b8d21>), [CUDA_ERROR_INVALID_CONTEXT](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a484e9af32c1e9893ff21f0e0191a12d>),

###### Description

Disconnect CUDA as a producer to EGLStreamKHR.

**See also:**

[cuEGLStreamProducerConnect](<group__CUDA__EGL.html#group__CUDA__EGL_1g5d181803d994a06f1bf9b05f52757bef> "Connect CUDA to EGLStream as a producer."), [cuEGLStreamProducerDisconnect](<group__CUDA__EGL.html#group__CUDA__EGL_1gbdc9664bfb17dd3fa1e0a3ca68a8cafd> "Disconnect CUDA as a producer to EGLStream ."), [cuEGLStreamProducerPresentFrame](<group__CUDA__EGL.html#group__CUDA__EGL_1g60dcaadeabcbaedb4a271d529306687b> "Present a CUDA eglFrame to the EGLStream with CUDA as a producer."), [cudaEGLStreamProducerDisconnect](<../cuda-runtime-api/group__CUDART__EGL.html#group__CUDART__EGL_1g381335525d81342c29c0b62cc4f64dc9>)

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuEGLStreamProducerPresentFrame ( [CUeglStreamConnection](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g60c595264697050bc2bb8e00cf5f86e7>)*Â conn, [CUeglFrame](<structCUeglFrame__v1.html#structCUeglFrame__v1>)Â eglframe, [CUstream](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gb946c7f02e09efd788a204718015d88a>)*Â pStream )


Present a CUDA eglFrame to the EGLStream with CUDA as a producer.

######  Parameters

`conn`
    \- Connection on which to present the CUDA array
`eglframe`
    \- CUDA Eglstream Proucer Frame handle to be sent to the consumer over EglStream.
`pStream`
    \- CUDA stream on which to present the frame.

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_INVALID_HANDLE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e90fd2e63260c6317ba943af0f7e4b8d21>),

###### Description

When a frame is presented by the producer, it gets associated with the EGLStream and thus it is illegal to free the frame before the producer is disconnected. If a frame is freed and reused it may lead to undefined behavior.

If producer and consumer are on different GPUs (iGPU and dGPU) then frametype [CU_EGL_FRAME_TYPE_ARRAY](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggec3f4a4e1a5785b1aa0fcc209cd47c38c02019e2bb4a56d31db30925d567d101>) is not supported. [CU_EGL_FRAME_TYPE_PITCH](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggec3f4a4e1a5785b1aa0fcc209cd47c38fc6cb007c686d8cad86705005c55bf33>) can be used for such cross-device applications.

The CUeglFrame is defined as:


    â typedef struct CUeglFrame_st {
               union {
                   [CUarray](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gd550651524a56766b60f10f0e7628042>) pArray[[MAX_PLANES](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g4269718bae6e29c6059d666ec76df24b>)];
                   void*   pPitch[[MAX_PLANES](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g4269718bae6e29c6059d666ec76df24b>)];
               } frame;
               unsigned int width;
               unsigned int height;
               unsigned int depth;
               unsigned int pitch;
               unsigned int planeCount;
               unsigned int numChannels;
               [CUeglFrameType](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gec3f4a4e1a5785b1aa0fcc209cd47c38>) frameType;
               [CUeglColorFormat](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g38337000e43e400e77ad36c7e197a9f2>) eglColorFormat;
               [CUarray_format](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g9b009d9a6aa4c5765c8a00289b6068f9>) cuFormat;
           } [CUeglFrame](<structCUeglFrame__v1.html#structCUeglFrame__v1>);

For CUeglFrame of type [CU_EGL_FRAME_TYPE_PITCH](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggec3f4a4e1a5785b1aa0fcc209cd47c38fc6cb007c686d8cad86705005c55bf33>), the application may present sub-region of a memory allocation. In that case, the pitched pointer will specify the start address of the sub-region in the allocation and corresponding CUeglFrame fields will specify the dimensions of the sub-region.

**See also:**

[cuEGLStreamProducerConnect](<group__CUDA__EGL.html#group__CUDA__EGL_1g5d181803d994a06f1bf9b05f52757bef> "Connect CUDA to EGLStream as a producer."), [cuEGLStreamProducerDisconnect](<group__CUDA__EGL.html#group__CUDA__EGL_1gbdc9664bfb17dd3fa1e0a3ca68a8cafd> "Disconnect CUDA as a producer to EGLStream ."), [cuEGLStreamProducerReturnFrame](<group__CUDA__EGL.html#group__CUDA__EGL_1g70c84d9d01f343fc07cd632f9cfc3a06> "Return the CUDA eglFrame to the EGLStream released by the consumer."), [cudaEGLStreamProducerPresentFrame](<../cuda-runtime-api/group__CUDART__EGL.html#group__CUDART__EGL_1g5c84a3778586dda401df00052ae5753b>)

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuEGLStreamProducerReturnFrame ( [CUeglStreamConnection](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g60c595264697050bc2bb8e00cf5f86e7>)*Â conn, [CUeglFrame](<structCUeglFrame__v1.html#structCUeglFrame__v1>)*Â eglframe, [CUstream](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gb946c7f02e09efd788a204718015d88a>)*Â pStream )


Return the CUDA eglFrame to the EGLStream released by the consumer.

######  Parameters

`conn`
    \- Connection on which to return
`eglframe`
    \- CUDA Eglstream Proucer Frame handle returned from the consumer over EglStream.
`pStream`
    \- CUDA stream on which to return the frame.

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_INVALID_HANDLE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e90fd2e63260c6317ba943af0f7e4b8d21>), [CUDA_ERROR_LAUNCH_TIMEOUT](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e965460d83f63575af9805ca59f8f19d74>)

###### Description

This API can potentially return CUDA_ERROR_LAUNCH_TIMEOUT if the consumer has not returned a frame to EGL stream. If timeout is returned the application can retry.

**See also:**

[cuEGLStreamProducerConnect](<group__CUDA__EGL.html#group__CUDA__EGL_1g5d181803d994a06f1bf9b05f52757bef> "Connect CUDA to EGLStream as a producer."), [cuEGLStreamProducerDisconnect](<group__CUDA__EGL.html#group__CUDA__EGL_1gbdc9664bfb17dd3fa1e0a3ca68a8cafd> "Disconnect CUDA as a producer to EGLStream ."), [cuEGLStreamProducerPresentFrame](<group__CUDA__EGL.html#group__CUDA__EGL_1g60dcaadeabcbaedb4a271d529306687b> "Present a CUDA eglFrame to the EGLStream with CUDA as a producer."), [cudaEGLStreamProducerReturnFrame](<../cuda-runtime-api/group__CUDART__EGL.html#group__CUDART__EGL_1g631d1080365d32a35a19b87584725748>)

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuEventCreateFromEGLSync ( [CUevent](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g6d740185cf0953636d4ae37f68d7559b>)*Â phEvent, EGLSyncKHRÂ eglSync, unsigned int Â flags )


Creates an event from EGLSync object.

######  Parameters

`phEvent`
    \- Returns newly created event
`eglSync`
    \- Opaque handle to EGLSync object
`flags`
    \- Event creation flags

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_DEINITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9acf52f132faf29b473cdda6061f0f44a>), [CUDA_ERROR_NOT_INITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e98feb999f0af99b4a25ab26b3866f4df8>), [CUDA_ERROR_INVALID_CONTEXT](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a484e9af32c1e9893ff21f0e0191a12d>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>), [CUDA_ERROR_OUT_OF_MEMORY](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9264c50688ed110e8476b591befe60c02>)

###### Description

Creates an event *phEvent from an EGLSyncKHR eglSync with the flags specified via `flags`. Valid flags include:

  * [CU_EVENT_DEFAULT](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg5ae04079c671c8e659a3a27c7b23f629e22adf5df73b0d43c6374a12ebee1333>): Default event creation flag.

  * [CU_EVENT_BLOCKING_SYNC](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg5ae04079c671c8e659a3a27c7b23f6296813b3b31fdb737133124f3c35044362>): Specifies that the created event should use blocking synchronization. A CPU thread that uses [cuEventSynchronize()](<group__CUDA__EVENT.html#group__CUDA__EVENT_1g9e520d34e51af7f5375610bca4add99c> "Waits for an event to complete.") to wait on an event created with this flag will block until the event has actually been completed.


Once the `eglSync` gets destroyed, [cuEventDestroy](<group__CUDA__EVENT.html#group__CUDA__EVENT_1g593ec73a8ec5a5fc031311d3e4dca1ef> "Destroys an event.") is the only API that can be invoked on the event.

[cuEventRecord](<group__CUDA__EVENT.html#group__CUDA__EVENT_1g95424d3be52c4eb95d83861b70fb89d1> "Records an event.") and TimingData are not supported for events created from EGLSync.

The EGLSyncKHR is an opaque handle to an EGL sync object. typedef void* EGLSyncKHR

**See also:**

[cuEventQuery](<group__CUDA__EVENT.html#group__CUDA__EVENT_1g6f0704d755066b0ee705749ae911deef> "Queries an event's status."), [cuEventSynchronize](<group__CUDA__EVENT.html#group__CUDA__EVENT_1g9e520d34e51af7f5375610bca4add99c> "Waits for an event to complete."), [cuEventDestroy](<group__CUDA__EVENT.html#group__CUDA__EVENT_1g593ec73a8ec5a5fc031311d3e4dca1ef> "Destroys an event.")

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuGraphicsEGLRegisterImage ( [CUgraphicsResource](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc0c4e1704647178d9c5ba3be46517dcd>)*Â pCudaResource, EGLImageKHRÂ image, unsigned int Â flags )


Registers an EGL image.

######  Parameters

`pCudaResource`
    \- Pointer to the returned object handle
`image`
    \- An EGLImageKHR image which can be used to create target resource.
`flags`
    \- Map flags

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_INVALID_HANDLE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e90fd2e63260c6317ba943af0f7e4b8d21>), [CUDA_ERROR_ALREADY_MAPPED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9240bb253a699176d9f49ee2f2c91b61b>), [CUDA_ERROR_INVALID_CONTEXT](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a484e9af32c1e9893ff21f0e0191a12d>),

###### Description

Registers the EGLImageKHR specified by `image` for access by CUDA. A handle to the registered object is returned as `pCudaResource`. Additional Mapping/Unmapping is not required for the registered resource and [cuGraphicsResourceGetMappedEglFrame](<group__CUDA__EGL.html#group__CUDA__EGL_1ge1e57193ad1dbf554af60d5b2d096ede> "Get an eglFrame through which to access a registered EGL graphics resource.") can be directly called on the `pCudaResource`.

The application will be responsible for synchronizing access to shared objects. The application must ensure that any pending operation which access the objects have completed before passing control to CUDA. This may be accomplished by issuing and waiting for glFinish command on all GLcontexts (for OpenGL and likewise for other APIs). The application will be also responsible for ensuring that any pending operation on the registered CUDA resource has completed prior to executing subsequent commands in other APIs accesing the same memory objects. This can be accomplished by calling cuCtxSynchronize or cuEventSynchronize (preferably).

The surface's intended usage is specified using `flags`, as follows:

  * CU_GRAPHICS_MAP_RESOURCE_FLAGS_NONE: Specifies no hints about how this resource will be used. It is therefore assumed that this resource will be read from and written to by CUDA. This is the default value.

  * CU_GRAPHICS_MAP_RESOURCE_FLAGS_READ_ONLY: Specifies that CUDA will not write to this resource.

  * CU_GRAPHICS_MAP_RESOURCE_FLAGS_WRITE_DISCARD: Specifies that CUDA will not read from this resource and will write over the entire contents of the resource, so none of the data previously stored in the resource will be preserved.


The EGLImageKHR is an object which can be used to create EGLImage target resource. It is defined as a void pointer. typedef void* EGLImageKHR

**See also:**

[cuGraphicsEGLRegisterImage](<group__CUDA__EGL.html#group__CUDA__EGL_1g9f9b026d175238be6f6e79048d6879c5> "Registers an EGL image."), [cuGraphicsUnregisterResource](<group__CUDA__GRAPHICS.html#group__CUDA__GRAPHICS_1ga7e5e97b74eaa13dfa6582e853e4c96d> "Unregisters a graphics resource for access by CUDA."), [cuGraphicsResourceSetMapFlags](<group__CUDA__GRAPHICS.html#group__CUDA__GRAPHICS_1gfe96aa7747f8b11d44a6fa6a851e1b39> "Set usage flags for mapping a graphics resource."), [cuGraphicsMapResources](<group__CUDA__GRAPHICS.html#group__CUDA__GRAPHICS_1gffcfd8e78d82cc4f6dd987e8bce4edb0> "Map graphics resources for access by CUDA."), [cuGraphicsUnmapResources](<group__CUDA__GRAPHICS.html#group__CUDA__GRAPHICS_1g8e9ff25d071375a0df1cb5aee924af32> "Unmap graphics resources."), [cudaGraphicsEGLRegisterImage](<../cuda-runtime-api/group__CUDART__EGL.html#group__CUDART__EGL_1g8813b57a44bdd30177666110530d1dcf>)

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuGraphicsResourceGetMappedEglFrame ( [CUeglFrame](<structCUeglFrame__v1.html#structCUeglFrame__v1>)*Â eglFrame, [CUgraphicsResource](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc0c4e1704647178d9c5ba3be46517dcd>)Â resource, unsigned int Â index, unsigned int Â mipLevel )


Get an eglFrame through which to access a registered EGL graphics resource.

######  Parameters

`eglFrame`
    \- Returned eglFrame.
`resource`
    \- Registered resource to access.
`index`
    \- Index for cubemap surfaces.
`mipLevel`
    \- Mipmap level for the subresource to access.

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_DEINITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9acf52f132faf29b473cdda6061f0f44a>), [CUDA_ERROR_NOT_INITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e98feb999f0af99b4a25ab26b3866f4df8>), [CUDA_ERROR_INVALID_CONTEXT](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a484e9af32c1e9893ff21f0e0191a12d>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>), [CUDA_ERROR_INVALID_HANDLE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e90fd2e63260c6317ba943af0f7e4b8d21>), [CUDA_ERROR_NOT_MAPPED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9e098433b926c9afdb6b6bdf191629447>)

###### Description

Returns in `*eglFrame` an eglFrame pointer through which the registered graphics resource `resource` may be accessed. This API can only be called for registered EGL graphics resources.

The CUeglFrame is defined as:


    â typedef struct CUeglFrame_st {
               union {
                   [CUarray](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gd550651524a56766b60f10f0e7628042>) pArray[[MAX_PLANES](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g4269718bae6e29c6059d666ec76df24b>)];
                   void*   pPitch[[MAX_PLANES](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g4269718bae6e29c6059d666ec76df24b>)];
               } frame;
               unsigned int width;
               unsigned int height;
               unsigned int depth;
               unsigned int pitch;
               unsigned int planeCount;
               unsigned int numChannels;
               [CUeglFrameType](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gec3f4a4e1a5785b1aa0fcc209cd47c38>) frameType;
               [CUeglColorFormat](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g38337000e43e400e77ad36c7e197a9f2>) eglColorFormat;
               [CUarray_format](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g9b009d9a6aa4c5765c8a00289b6068f9>) cuFormat;
           } [CUeglFrame](<structCUeglFrame__v1.html#structCUeglFrame__v1>);

If `resource` is not registered then [CUDA_ERROR_NOT_MAPPED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9e098433b926c9afdb6b6bdf191629447>) is returned. *

**See also:**

[cuGraphicsMapResources](<group__CUDA__GRAPHICS.html#group__CUDA__GRAPHICS_1gffcfd8e78d82cc4f6dd987e8bce4edb0> "Map graphics resources for access by CUDA."), [cuGraphicsSubResourceGetMappedArray](<group__CUDA__GRAPHICS.html#group__CUDA__GRAPHICS_1g61c55e987e54558cce547240d6123078> "Get an array through which to access a subresource of a mapped graphics resource."), [cuGraphicsResourceGetMappedPointer](<group__CUDA__GRAPHICS.html#group__CUDA__GRAPHICS_1g8a634cf4150d399f0018061580592457> "Get a device pointer through which to access a mapped graphics resource."), [cudaGraphicsResourceGetMappedEglFrame](<../cuda-runtime-api/group__CUDART__EGL.html#group__CUDART__EGL_1gdd6215655a241c047d6d4939e242202a>)

* * *


---

# Profiler Control

## 6.39.Â Profiler Control

This section describes the profiler control functions of the low-level CUDA driver application programming interface.

### Functions

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuProfilerStart](<#group__CUDA__PROFILER_1g8a5314de2292c2efac83ac7fcfa9190e>) ( void )
     Enable profiling.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuProfilerStop](<#group__CUDA__PROFILER_1g4d8edef6174fd90165e6ac838f320a5f>) ( void )
     Disable profiling.

### Functions

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuProfilerStart ( void )


Enable profiling.

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_INVALID_CONTEXT](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a484e9af32c1e9893ff21f0e0191a12d>)

###### Description

Enables profile collection by the active profiling tool for the current context. If profiling is already enabled, then [cuProfilerStart()](<group__CUDA__PROFILER.html#group__CUDA__PROFILER_1g8a5314de2292c2efac83ac7fcfa9190e> "Enable profiling.") has no effect.

cuProfilerStart and cuProfilerStop APIs are used to programmatically control the profiling granularity by allowing profiling to be done only on selective pieces of code.

Note:

Note that this function may also return error codes from previous, asynchronous launches.

**See also:**

[cuProfilerInitialize](<group__CUDA__PROFILER__DEPRECATED.html#group__CUDA__PROFILER__DEPRECATED_1gd15d4f964bf948988679232a54ce9fc1> "Initialize the profiling."), [cuProfilerStop](<group__CUDA__PROFILER.html#group__CUDA__PROFILER_1g4d8edef6174fd90165e6ac838f320a5f> "Disable profiling."), [cudaProfilerStart](<../cuda-runtime-api/group__CUDART__PROFILER.html#group__CUDART__PROFILER_1gf536d75bb382356e10e3b4e89f4a5374>)

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuProfilerStop ( void )


Disable profiling.

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_INVALID_CONTEXT](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a484e9af32c1e9893ff21f0e0191a12d>)

###### Description

Disables profile collection by the active profiling tool for the current context. If profiling is already disabled, then [cuProfilerStop()](<group__CUDA__PROFILER.html#group__CUDA__PROFILER_1g4d8edef6174fd90165e6ac838f320a5f> "Disable profiling.") has no effect.

cuProfilerStart and cuProfilerStop APIs are used to programmatically control the profiling granularity by allowing profiling to be done only on selective pieces of code.

Note:

Note that this function may also return error codes from previous, asynchronous launches.

**See also:**

[cuProfilerInitialize](<group__CUDA__PROFILER__DEPRECATED.html#group__CUDA__PROFILER__DEPRECATED_1gd15d4f964bf948988679232a54ce9fc1> "Initialize the profiling."), [cuProfilerStart](<group__CUDA__PROFILER.html#group__CUDA__PROFILER_1g8a5314de2292c2efac83ac7fcfa9190e> "Enable profiling."), [cudaProfilerStop](<../cuda-runtime-api/group__CUDART__PROFILER.html#group__CUDART__PROFILER_1g826922d9d1d0090d4a9a6b8b249cebb5>)

* * *


---

# Green Contexts

## 6.35.Â Green Contexts

This section describes the APIs for creation and manipulation of green contexts in the CUDA driver. Green contexts are a lightweight alternative to traditional contexts, that can be used to select a subset of device resources. This allows the developer to, for example, select SMs from distinct spatial partitions of the GPU and target them via CUDA stream operations, kernel launches, etc.

Here are the broad initial steps to follow to get started:

  * (1) Start with an initial set of resources. For SM resources, they can be fetched via [cuDeviceGetDevResource](<group__CUDA__GREEN__CONTEXTS.html#group__CUDA__GREEN__CONTEXTS_1g6115d21604653f4eafb257f725538ab6> "Get device resources."). In case of workqueues, a new configuration can be used or an existing one queried via the [cuDeviceGetDevResource](<group__CUDA__GREEN__CONTEXTS.html#group__CUDA__GREEN__CONTEXTS_1g6115d21604653f4eafb257f725538ab6> "Get device resources.") API.

  * (2) Modify these resources by either partitioning them (in case of SMs) or changing the configuration (in case of workqueues). To partition SMs, we recommend [cuDevSmResourceSplit](<group__CUDA__GREEN__CONTEXTS.html#group__CUDA__GREEN__CONTEXTS_1gc739e0a0b57766ee10437c89909865f3> "Splits a CU_DEV_RESOURCE_TYPE_SM resource into structured groups."). Changing the workqueue configuration can be done directly in place.

  * (3) Finalize the specification of resources by creating a descriptor via [cuDevResourceGenerateDesc](<group__CUDA__GREEN__CONTEXTS.html#group__CUDA__GREEN__CONTEXTS_1g1ea7743fd633d2e2dd92eb1c84c4fbc5> "Generate a resource descriptor.").

  * (4) Create a green context via [cuGreenCtxCreate](<group__CUDA__GREEN__CONTEXTS.html#group__CUDA__GREEN__CONTEXTS_1ga6da4f9959fd48d1f1a5cbedbec54e65> "Creates a green context with a specified set of resources."). This provisions the resource, such as workqueues (until this step it was only a configuration specification).

  * (5) Create a stream via [cuGreenCtxStreamCreate](<group__CUDA__GREEN__CONTEXTS.html#group__CUDA__GREEN__CONTEXTS_1g569b9e947b0f143f6ed9397a12046a8a> "Create a stream for use in the green context."), and use it throughout your application.


**SMs**

There are two possible partition operations - with cuDevSmResourceSplitByCount the partitions created have to follow default SM count granularity requirements, so it will often be rounded up and aligned to a default value. On the other hand, [cuDevSmResourceSplit](<group__CUDA__GREEN__CONTEXTS.html#group__CUDA__GREEN__CONTEXTS_1gc739e0a0b57766ee10437c89909865f3> "Splits a CU_DEV_RESOURCE_TYPE_SM resource into structured groups.") is explicit and allows for creation of non-equal groups. It will not round up automatically - instead it is the developerâs responsibility to query and set the correct values. These requirements can be queried with cuDeviceGetDevResource to determine the alignment granularity (sm.smCoscheduledAlignment). A general guideline on the default values for each compute architecture:

  * On Compute Architecture 7.X, 8.X, and all Tegra SoC:
    * The smCount must be a multiple of 2.

    * The alignment (and default value of coscheduledSmCount) is 2.

  * On Compute Architecture 9.0+:
    * The smCount must be a multiple of 8, or coscheduledSmCount if provided.

    * The alignment (and default value of coscheduledSmCount) is 8. While the maximum value for coscheduled SM count is 32 on all Compute Architecture 9.0+, it's recommended to follow cluster size requirements. The portable cluster size and the max cluster size should be used in order to benefit from this co-scheduling.


**Workqueues**

For `CU_DEV_RESOURCE_TYPE_WORKQUEUE_CONFIG`, the resource specifies the expected maximum number of concurrent stream-ordered workloads via the `wqConcurrencyLimit` field. The `sharingScope` field determines how workqueue resources are shared:

  * `CU_WORKQUEUE_SCOPE_DEVICE_CTX:` Use all shared workqueue resources across all contexts (default driver behavior).

  * `CU_WORKQUEUE_SCOPE_GREEN_CTX_BALANCED:` When possible, use non-overlapping workqueue resources with other balanced green contexts.


The maximum concurrency limit depends on CUDA_DEVICE_MAX_CONNECTIONS and can be queried from the primary context via [cuCtxGetDevResource](<group__CUDA__GREEN__CONTEXTS.html#group__CUDA__GREEN__CONTEXTS_1g00d5b66f04f0591f1c752adb1a924635> "Get context resources."). Configurations may exceed this concurrency limit, but the driver will not guarantee that work submission remains non-overlapping.

For `CU_DEV_RESOURCE_TYPE_WORKQUEUE`, the resource represents a pre-existing workqueue that can be retrieved from existing contexts or green contexts. This allows reusing workqueue resources across different green contexts.

**On Concurrency**

Even if the green contexts have disjoint SM partitions, it is not guaranteed that the kernels launched in them will run concurrently or have forward progress guarantees. This is due to other resources that could cause a dependency. Using a combination of disjoint SMs and CU_WORKQUEUE_SCOPE_GREEN_CTX_BALANCED workqueue configurations can provide the best chance of avoiding interference. More resources will be added in the future to provide stronger guarantees.

Additionally, there are two known scenarios, where its possible for the workload to run on more SMs than was provisioned (but never less).

  * On Volta+ MPS: When `CUDA_MPS_ACTIVE_THREAD_PERCENTAGE` is used, the set of SMs that are used for running kernels can be scaled up to the value of SMs used for the MPS client.

  * On Compute Architecture 9.x: When a module with dynamic parallelism (CDP) is loaded, all future kernels running under green contexts may use and share an additional set of 2 SMs.


### Classes

structÂ

[CU_DEV_SM_RESOURCE_GROUP_PARAMS](<structCU__DEV__SM__RESOURCE__GROUP__PARAMS.html#structCU__DEV__SM__RESOURCE__GROUP__PARAMS>)

     [](<structCU__DEV__SM__RESOURCE__GROUP__PARAMS.html#structCU__DEV__SM__RESOURCE__GROUP__PARAMS>)
structÂ

[CUdevResource](<structCUdevResource.html#structCUdevResource>)

     [](<structCUdevResource.html#structCUdevResource>)
structÂ

[CUdevSmResource](<structCUdevSmResource.html#structCUdevSmResource>)

     [](<structCUdevSmResource.html#structCUdevSmResource>)
structÂ

[CUdevWorkqueueConfigResource](<structCUdevWorkqueueConfigResource.html#structCUdevWorkqueueConfigResource>)

     [](<structCUdevWorkqueueConfigResource.html#structCUdevWorkqueueConfigResource>)
structÂ

[CUdevWorkqueueResource](<structCUdevWorkqueueResource.html#structCUdevWorkqueueResource>)

     [](<structCUdevWorkqueueResource.html#structCUdevWorkqueueResource>)

### Typedefs

typedef CUdevResourceDesc_st * Â [CUdevResourceDesc](<#group__CUDA__GREEN__CONTEXTS_1g2384245122e1ee00c24a867404b55c17>)


### Enumerations

enumÂ [CUdevResourceType](<#group__CUDA__GREEN__CONTEXTS_1g28def480400d3254367d891d58f1375b>)

enumÂ [CUdevWorkqueueConfigScope](<#group__CUDA__GREEN__CONTEXTS_1g69e1b41d5b36d10d679b4c3b55dfb7a0>)


### Functions

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuCtxFromGreenCtx](<#group__CUDA__GREEN__CONTEXTS_1gf0779ec72ce1d5d7eb003d7d9b25afcb>) ( [CUcontext](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gf9f5bd81658f866613785b3a0bb7d7d9>)*Â pContext, [CUgreenCtx](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g453cb79a1ceb13bec502a9c5f06a0268>)Â hCtx )
     Converts a green context into the primary context.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuCtxGetDevResource](<#group__CUDA__GREEN__CONTEXTS_1g00d5b66f04f0591f1c752adb1a924635>) ( [CUcontext](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gf9f5bd81658f866613785b3a0bb7d7d9>)Â hCtx, [CUdevResource](<structCUdevResource.html#structCUdevResource>)*Â resource, [CUdevResourceType](<group__CUDA__GREEN__CONTEXTS.html#group__CUDA__GREEN__CONTEXTS_1g28def480400d3254367d891d58f1375b>)Â type )
     Get context resources.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuDevResourceGenerateDesc](<#group__CUDA__GREEN__CONTEXTS_1g1ea7743fd633d2e2dd92eb1c84c4fbc5>) ( [CUdevResourceDesc](<group__CUDA__GREEN__CONTEXTS.html#group__CUDA__GREEN__CONTEXTS_1g2384245122e1ee00c24a867404b55c17>)*Â phDesc, [CUdevResource](<structCUdevResource.html#structCUdevResource>)*Â resources, unsigned int Â nbResources )
     Generate a resource descriptor.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuDevSmResourceSplit](<#group__CUDA__GREEN__CONTEXTS_1gc739e0a0b57766ee10437c89909865f3>) ( [CUdevResource](<structCUdevResource.html#structCUdevResource>)*Â result, unsigned int Â nbGroups, const [CUdevResource](<structCUdevResource.html#structCUdevResource>)*Â input, [CUdevResource](<structCUdevResource.html#structCUdevResource>)*Â remainder, unsigned int Â flags, [CU_DEV_SM_RESOURCE_GROUP_PARAMS](<structCU__DEV__SM__RESOURCE__GROUP__PARAMS.html#structCU__DEV__SM__RESOURCE__GROUP__PARAMS>)*Â groupParams )
     Splits a `CU_DEV_RESOURCE_TYPE_SM` resource into structured groups.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuDevSmResourceSplitByCount](<#group__CUDA__GREEN__CONTEXTS_1gf8359c74d7286ac32e5db253240d9a6c>) ( [CUdevResource](<structCUdevResource.html#structCUdevResource>)*Â result, unsigned int*Â nbGroups, const [CUdevResource](<structCUdevResource.html#structCUdevResource>)*Â input, [CUdevResource](<structCUdevResource.html#structCUdevResource>)*Â remainder, unsigned int Â flags, unsigned int Â minCount )
     Splits `CU_DEV_RESOURCE_TYPE_SM` resources.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuDeviceGetDevResource](<#group__CUDA__GREEN__CONTEXTS_1g6115d21604653f4eafb257f725538ab6>) ( [CUdevice](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g41ca2a24a242b36ef2ca77330b5fb72a>)Â device, [CUdevResource](<structCUdevResource.html#structCUdevResource>)*Â resource, [CUdevResourceType](<group__CUDA__GREEN__CONTEXTS.html#group__CUDA__GREEN__CONTEXTS_1g28def480400d3254367d891d58f1375b>)Â type )
     Get device resources.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuGreenCtxCreate](<#group__CUDA__GREEN__CONTEXTS_1ga6da4f9959fd48d1f1a5cbedbec54e65>) ( [CUgreenCtx](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g453cb79a1ceb13bec502a9c5f06a0268>)*Â phCtx, [CUdevResourceDesc](<group__CUDA__GREEN__CONTEXTS.html#group__CUDA__GREEN__CONTEXTS_1g2384245122e1ee00c24a867404b55c17>)Â desc, [CUdevice](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g41ca2a24a242b36ef2ca77330b5fb72a>)Â dev, unsigned int Â flags )
     Creates a green context with a specified set of resources.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuGreenCtxDestroy](<#group__CUDA__GREEN__CONTEXTS_1g7c37d959c2c030c13135366533eff57d>) ( [CUgreenCtx](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g453cb79a1ceb13bec502a9c5f06a0268>)Â hCtx )
     Destroys a green context.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuGreenCtxGetDevResource](<#group__CUDA__GREEN__CONTEXTS_1g301178535c06137ea8cc9becdbfb90b8>) ( [CUgreenCtx](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g453cb79a1ceb13bec502a9c5f06a0268>)Â hCtx, [CUdevResource](<structCUdevResource.html#structCUdevResource>)*Â resource, [CUdevResourceType](<group__CUDA__GREEN__CONTEXTS.html#group__CUDA__GREEN__CONTEXTS_1g28def480400d3254367d891d58f1375b>)Â type )
     Get green context resources.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuGreenCtxGetId](<#group__CUDA__GREEN__CONTEXTS_1g2e073a7cde154f4fee132f8efd879b9c>) ( [CUgreenCtx](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g453cb79a1ceb13bec502a9c5f06a0268>)Â greenCtx, unsigned long long*Â greenCtxId )
     Returns the unique Id associated with the green context supplied.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuGreenCtxRecordEvent](<#group__CUDA__GREEN__CONTEXTS_1g9dd087071cc217ad7ebda6df96d2ee40>) ( [CUgreenCtx](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g453cb79a1ceb13bec502a9c5f06a0268>)Â hCtx, [CUevent](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g6d740185cf0953636d4ae37f68d7559b>)Â hEvent )
     Records an event.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuGreenCtxStreamCreate](<#group__CUDA__GREEN__CONTEXTS_1g569b9e947b0f143f6ed9397a12046a8a>) ( [CUstream](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gb946c7f02e09efd788a204718015d88a>)*Â phStream, [CUgreenCtx](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g453cb79a1ceb13bec502a9c5f06a0268>)Â greenCtx, unsigned int Â flags, int Â priority )
     Create a stream for use in the green context.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuGreenCtxWaitEvent](<#group__CUDA__GREEN__CONTEXTS_1g6b26172117084fd024f1396fb66a8ffd>) ( [CUgreenCtx](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g453cb79a1ceb13bec502a9c5f06a0268>)Â hCtx, [CUevent](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g6d740185cf0953636d4ae37f68d7559b>)Â hEvent )
     Make a green context wait on an event.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuStreamGetDevResource](<#group__CUDA__GREEN__CONTEXTS_1g25acc306a4e2ba88d1eb8b7bd2b2b578>) ( [CUstream](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gb946c7f02e09efd788a204718015d88a>)Â hStream, [CUdevResource](<structCUdevResource.html#structCUdevResource>)*Â resource, [CUdevResourceType](<group__CUDA__GREEN__CONTEXTS.html#group__CUDA__GREEN__CONTEXTS_1g28def480400d3254367d891d58f1375b>)Â type )
     Get stream resources.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuStreamGetGreenCtx](<#group__CUDA__GREEN__CONTEXTS_1gee3222277e5a433a2b279500bf11b9fe>) ( [CUstream](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gb946c7f02e09efd788a204718015d88a>)Â hStream, [CUgreenCtx](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g453cb79a1ceb13bec502a9c5f06a0268>)*Â phCtx )
     Query the green context associated with a stream.

### Typedefs

typedef CUdevResourceDesc_st * CUdevResourceDesc


An opaque descriptor handle. The descriptor encapsulates multiple created and configured resources. Created via [cuDevResourceGenerateDesc](<group__CUDA__GREEN__CONTEXTS.html#group__CUDA__GREEN__CONTEXTS_1g1ea7743fd633d2e2dd92eb1c84c4fbc5> "Generate a resource descriptor.")

### Enumerations

enum CUdevResourceType


Type of resource

######  Values

CU_DEV_RESOURCE_TYPE_INVALID = 0

CU_DEV_RESOURCE_TYPE_SM = 1
    Streaming multiprocessors related information
CU_DEV_RESOURCE_TYPE_WORKQUEUE_CONFIG = 1000
    Workqueue configuration related information
CU_DEV_RESOURCE_TYPE_WORKQUEUE = 10000
    Pre-existing workqueue related information

enum CUdevWorkqueueConfigScope


Sharing scope for workqueues

######  Values

CU_WORKQUEUE_SCOPE_DEVICE_CTX = 0
    Use all shared workqueue resources across all contexts. Default driver behaviour.
CU_WORKQUEUE_SCOPE_GREEN_CTX_BALANCED = 1
    When possible, use non-overlapping workqueue resources with other balanced green contexts.

### Functions

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuCtxFromGreenCtx ( [CUcontext](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gf9f5bd81658f866613785b3a0bb7d7d9>)*Â pContext, [CUgreenCtx](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g453cb79a1ceb13bec502a9c5f06a0268>)Â hCtx )


Converts a green context into the primary context.

######  Parameters

`pContext`
    Returned primary context with green context resources
`hCtx`
    Green context to convert

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_DEINITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9acf52f132faf29b473cdda6061f0f44a>), [CUDA_ERROR_NOT_INITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e98feb999f0af99b4a25ab26b3866f4df8>), [CUDA_ERROR_INVALID_CONTEXT](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a484e9af32c1e9893ff21f0e0191a12d>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>)

###### Description

The API converts a green context into the primary context returned in `pContext`. It is important to note that the converted context `pContext` is a normal primary context but with the resources of the specified green context `hCtx`. Once converted, it can then be used to set the context current with [cuCtxSetCurrent](<group__CUDA__CTX.html#group__CUDA__CTX_1gbe562ee6258b4fcc272ca6478ca2a2f7> "Binds the specified CUDA context to the calling CPU thread.") or with any of the CUDA APIs that accept a CUcontext parameter.

Users are expected to call this API before calling any CUDA APIs that accept a CUcontext. Failing to do so will result in the APIs returning [CUDA_ERROR_INVALID_CONTEXT](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a484e9af32c1e9893ff21f0e0191a12d>).

**See also:**

[cuGreenCtxCreate](<group__CUDA__GREEN__CONTEXTS.html#group__CUDA__GREEN__CONTEXTS_1ga6da4f9959fd48d1f1a5cbedbec54e65> "Creates a green context with a specified set of resources.")

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuCtxGetDevResource ( [CUcontext](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gf9f5bd81658f866613785b3a0bb7d7d9>)Â hCtx, [CUdevResource](<structCUdevResource.html#structCUdevResource>)*Â resource, [CUdevResourceType](<group__CUDA__GREEN__CONTEXTS.html#group__CUDA__GREEN__CONTEXTS_1g28def480400d3254367d891d58f1375b>)Â type )


Get context resources.

######  Parameters

`hCtx`
    \- Context to get resource for
`resource`
    \- Output pointer to a [CUdevResource](<structCUdevResource.html#structCUdevResource>) structure
`type`
    \- Type of resource to retrieve

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_DEINITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9acf52f132faf29b473cdda6061f0f44a>), [CUDA_ERROR_NOT_INITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e98feb999f0af99b4a25ab26b3866f4df8>), [CUDA_ERROR_INVALID_RESOURCE_TYPE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e94ec23220911f54aa1e66d8bcf86ec7ba>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>), [CUDA_ERROR_INVALID_CONTEXT](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a484e9af32c1e9893ff21f0e0191a12d>)

###### Description

Get the `type` resources available to the context represented by `hCtx` Note: The API is not supported on 32-bit platforms.

**See also:**

[cuDevResourceGenerateDesc](<group__CUDA__GREEN__CONTEXTS.html#group__CUDA__GREEN__CONTEXTS_1g1ea7743fd633d2e2dd92eb1c84c4fbc5> "Generate a resource descriptor.")

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuDevResourceGenerateDesc ( [CUdevResourceDesc](<group__CUDA__GREEN__CONTEXTS.html#group__CUDA__GREEN__CONTEXTS_1g2384245122e1ee00c24a867404b55c17>)*Â phDesc, [CUdevResource](<structCUdevResource.html#structCUdevResource>)*Â resources, unsigned int Â nbResources )


Generate a resource descriptor.

######  Parameters

`phDesc`
    \- Output descriptor
`resources`
    \- Array of resources to be included in the descriptor
`nbResources`
    \- Number of resources passed in `resources`

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_DEINITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9acf52f132faf29b473cdda6061f0f44a>), [CUDA_ERROR_NOT_INITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e98feb999f0af99b4a25ab26b3866f4df8>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>), [CUDA_ERROR_INVALID_RESOURCE_TYPE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e94ec23220911f54aa1e66d8bcf86ec7ba>), [CUDA_ERROR_INVALID_RESOURCE_CONFIGURATION](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e958d93275e1fc7c5879c1789fd9bc74a5>)

###### Description

Generates a single resource descriptor with the set of resources specified in `resources`. The generated resource descriptor is necessary for the creation of green contexts via the [cuGreenCtxCreate](<group__CUDA__GREEN__CONTEXTS.html#group__CUDA__GREEN__CONTEXTS_1ga6da4f9959fd48d1f1a5cbedbec54e65> "Creates a green context with a specified set of resources.") API. Resources of the same type can be passed in, provided they meet the requirements as noted below.

A successful API call must have:

  * A valid output pointer for the `phDesc` descriptor as well as a valid array of `resources` pointers, with the array size passed in `nbResources`. If multiple resources are provided in `resources`, the device they came from must be the same, otherwise CUDA_ERROR_INVALID_RESOURCE_CONFIGURATION is returned. If multiple resources are provided in `resources` and they are of type [CU_DEV_RESOURCE_TYPE_SM](<group__CUDA__GREEN__CONTEXTS.html#group__CUDA__GREEN__CONTEXTS_1gg28def480400d3254367d891d58f1375b3ba3ec7d6c8814ce80b9a633ca2ff332>), they must be outputs (whether `result` or `remaining`) from the same split API instance and have the same smCoscheduledAlignment values, otherwise CUDA_ERROR_INVALID_RESOURCE_CONFIGURATION is returned.


Note: The API is not supported on 32-bit platforms.

**See also:**

[cuDevSmResourceSplitByCount](<group__CUDA__GREEN__CONTEXTS.html#group__CUDA__GREEN__CONTEXTS_1gf8359c74d7286ac32e5db253240d9a6c> "Splits CU_DEV_RESOURCE_TYPE_SM resources.")

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuDevSmResourceSplit ( [CUdevResource](<structCUdevResource.html#structCUdevResource>)*Â result, unsigned int Â nbGroups, const [CUdevResource](<structCUdevResource.html#structCUdevResource>)*Â input, [CUdevResource](<structCUdevResource.html#structCUdevResource>)*Â remainder, unsigned int Â flags, [CU_DEV_SM_RESOURCE_GROUP_PARAMS](<structCU__DEV__SM__RESOURCE__GROUP__PARAMS.html#structCU__DEV__SM__RESOURCE__GROUP__PARAMS>)*Â groupParams )


Splits a `CU_DEV_RESOURCE_TYPE_SM` resource into structured groups.

######  Parameters

`result`
    \- Output array of `[CUdevResource](<structCUdevResource.html#structCUdevResource>)` resources. Can be NULL, alongside an smCount of 0, for discovery purpose.
`nbGroups`
    \- Specifies the number of groups in `result` and `groupParams`
`input`
    \- Input SM resource to be split. Must be a valid `CU_DEV_RESOURCE_TYPE_SM` resource.
`remainder`
    \- If splitting the input resource leaves any SMs, the remainder is placed in here.
`flags`
    \- Flags specifying how the API should behave. The value should be 0 for now.
`groupParams`
    \- Description of how the SMs should be split and assigned to the corresponding result entry.

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_DEINITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9acf52f132faf29b473cdda6061f0f44a>), [CUDA_ERROR_NOT_INITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e98feb999f0af99b4a25ab26b3866f4df8>), [CUDA_ERROR_INVALID_DEVICE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e96f047e7215788ca96c81af92a04bfb6c>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>), [CUDA_ERROR_INVALID_RESOURCE_TYPE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e94ec23220911f54aa1e66d8bcf86ec7ba>), [CUDA_ERROR_INVALID_RESOURCE_CONFIGURATION](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e958d93275e1fc7c5879c1789fd9bc74a5>)

###### Description

This API will split a resource of [CU_DEV_RESOURCE_TYPE_SM](<group__CUDA__GREEN__CONTEXTS.html#group__CUDA__GREEN__CONTEXTS_1gg28def480400d3254367d891d58f1375b3ba3ec7d6c8814ce80b9a633ca2ff332>) into `nbGroups` structured device resource groups (the `result` array), as well as an optional `remainder`, according to a set of requirements specified in the `groupParams` array. The term âstructuredâ is a trait that specifies the `result` has SMs that are co-scheduled together. This co-scheduling can be specified via the `coscheduledSmCount` field of the `groupParams` structure, while the `smCount` will specify how many SMs are required in total for that result. The remainder is always âunstructuredâ, it does not have any set guarantees with respect to co-scheduling and those properties will need to either be queried via the occupancy set of APIs or further split into structured groups by this API.

The API has a discovery mode for use cases where it is difficult to know ahead of time what the SM count should be. Discovery happens when the `smCount` field of a given `groupParams` array entry is set to 0 - the smCount will be filled in by the API with the derived SM count according to the provided `groupParams` fields and constraints. Discovery can be used with both a valid result array and with a NULL `result` pointer value. The latter is useful in situations where the smCount will end up being zero, which is an invalid value to create a result entry with, but allowed for discovery purposes when the `result` is NULL.

The `groupParams` array is evaluated from index 0 to `nbGroups` \- 1. For each index in the `groupParams` array, the API will evaluate which SMs may be a good fit based on constraints and assign those SMs to `result`. This evaluation order is important to consider when using discovery mode, as it helps discover the remaining SMs.

For a valid call:

  * `result` should point to a `[CUdevResource](<structCUdevResource.html#structCUdevResource>)` array of size `nbGroups`, or alternatively, may be NULL, if the developer wishes for only the groupParams entries to be updated


  * `input` should be a valid [CU_DEV_RESOURCE_TYPE_SM](<group__CUDA__GREEN__CONTEXTS.html#group__CUDA__GREEN__CONTEXTS_1gg28def480400d3254367d891d58f1375b3ba3ec7d6c8814ce80b9a633ca2ff332>) resource that originates from querying the green context, device context, or device.


  * The `remainder` group may be NULL.


  * There are no API `flags` at this time, so the value passed in should be 0.


  * A [CU_DEV_SM_RESOURCE_GROUP_PARAMS](<structCU__DEV__SM__RESOURCE__GROUP__PARAMS.html#structCU__DEV__SM__RESOURCE__GROUP__PARAMS>) array of size `nbGroups`. Each entry must be zero-initialized.
    * `smCount:` must be either 0 or in the range of [2,inputSmCount] where inputSmCount is the amount of SMs the `input` resource has. `smCount` must be a multiple of 2, as well as a multiple of `coscheduledSmCount`. When assigning SMs to a group (and if results are expected by having the `result` parameter set), `smCount` cannot end up with 0 or a value less than `coscheduledSmCount` otherwise CUDA_ERROR_INVALID_RESOURCE_CONFIGURATION will be returned.

    * `coscheduledSmCount:` allows grouping SMs together in order to be able to launch clusters on Compute Architecture 9.0+. The default value may be queried from the deviceâs [CU_DEV_RESOURCE_TYPE_SM](<group__CUDA__GREEN__CONTEXTS.html#group__CUDA__GREEN__CONTEXTS_1gg28def480400d3254367d891d58f1375b3ba3ec7d6c8814ce80b9a633ca2ff332>) resource (8 on Compute Architecture 9.0+ and 2 otherwise). The maximum is 32 on Compute Architecture 9.0+ and 2 otherwise.

    * `preferredCoscheduledSmCount:` Attempts to merge `coscheduledSmCount` groups into larger groups, in order to make use of `preferredClusterDimensions` on Compute Architecture 10.0+. The default value is set to `coscheduledSmCount`.

    * `flags:`
      * `CU_DEV_SM_RESOURCE_SPLIT_BACKFILL:` lets `smCount` be a non-multiple of `coscheduledSmCount`, filling the difference between SM count and already assigned co-scheduled groupings with other SMs. This lets any resulting group behave similar to the `remainder` group for example.


**Example params and their effect:**

A groupParams array element is defined in the following order:


    â { .smCount, .coscheduledSmCount, .preferredCoscheduledSmCount, .flags, \/\* .reserved \*\/ }


    â// Example 1
          // Will discover how many SMs there are, that are co-scheduled in groups of smCoscheduledAlignment.
          // The rest is placed in the optional remainder.
          [CU_DEV_SM_RESOURCE_GROUP_PARAMS](<structCU__DEV__SM__RESOURCE__GROUP__PARAMS.html#structCU__DEV__SM__RESOURCE__GROUP__PARAMS>) params { 0, 0, 0, 0 };


    â// Example 2
          // Assuming the device has 10+ SMs, the result will have 10 SMs that are co-scheduled in groups of 2 SMs.
          // The rest is placed in the optional remainder.
          [CU_DEV_SM_RESOURCE_GROUP_PARAMS](<structCU__DEV__SM__RESOURCE__GROUP__PARAMS.html#structCU__DEV__SM__RESOURCE__GROUP__PARAMS>) params { 10, 2, 0, 0};
          // Setting the coscheduledSmCount to 2 guarantees that we can always have a valid result
          // as long as the SM count is less than or equal to the input resource SM count.


    â// Example 3
          // A single piece is split-off, but instead of assigning the rest to the remainder, a second group contains everything else
          // This assumes the device has 10+ SMs (8 of which are coscheduled in groups of 4),
          // otherwise the second group could end up with 0 SMs, which is not allowed.
          [CU_DEV_SM_RESOURCE_GROUP_PARAMS](<structCU__DEV__SM__RESOURCE__GROUP__PARAMS.html#structCU__DEV__SM__RESOURCE__GROUP__PARAMS>) params { {8, 4, 0, 0}, {0, 2, 0, CU_DEV_SM_RESOURCE_SPLIT_BACKFILL } }

The difference between a catch-all param group as the last entry and the remainder is in two aspects:

  * The remainder may be NULL / _TYPE_INVALID (if there are no SMs remaining), while a result group must always be valid.

  * The remainder does not have a structure, while the result group will always need to adhere to a structure of coscheduledSmCount (even if its just 2), and therefore must always have enough coscheduled SMs to cover that requirement (even with the `CU_DEV_SM_RESOURCE_SPLIT_BACKFILL` flag enabled).


Splitting an input into N groups, can be accomplished by repeatedly splitting off 1 group and re-splitting the remainder (a bisect operation). However, it's recommended to accomplish this with a single call wherever possible.

**See also:**

[cuGreenCtxGetDevResource](<group__CUDA__GREEN__CONTEXTS.html#group__CUDA__GREEN__CONTEXTS_1g301178535c06137ea8cc9becdbfb90b8> "Get green context resources."), [cuCtxGetDevResource](<group__CUDA__GREEN__CONTEXTS.html#group__CUDA__GREEN__CONTEXTS_1g00d5b66f04f0591f1c752adb1a924635> "Get context resources."), [cuDeviceGetDevResource](<group__CUDA__GREEN__CONTEXTS.html#group__CUDA__GREEN__CONTEXTS_1g6115d21604653f4eafb257f725538ab6> "Get device resources.")

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuDevSmResourceSplitByCount ( [CUdevResource](<structCUdevResource.html#structCUdevResource>)*Â result, unsigned int*Â nbGroups, const [CUdevResource](<structCUdevResource.html#structCUdevResource>)*Â input, [CUdevResource](<structCUdevResource.html#structCUdevResource>)*Â remainder, unsigned int Â flags, unsigned int Â minCount )


Splits `CU_DEV_RESOURCE_TYPE_SM` resources.

######  Parameters

`result`
    \- Output array of `[CUdevResource](<structCUdevResource.html#structCUdevResource>)` resources. Can be NULL to query the number of groups.
`nbGroups`
    \- This is a pointer, specifying the number of groups that would be or should be created as described below.
`input`
    \- Input SM resource to be split. Must be a valid `CU_DEV_RESOURCE_TYPE_SM` resource.
`remainder`
    \- If the input resource cannot be cleanly split among `nbGroups`, the remainder is placed in here. Can be ommitted (NULL) if the user does not need the remaining set.
`flags`
    \- Flags specifying how these partitions are used or which constraints to abide by when splitting the input. Zero is valid for default behavior.
`minCount`
    \- Minimum number of SMs required

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_DEINITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9acf52f132faf29b473cdda6061f0f44a>), [CUDA_ERROR_NOT_INITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e98feb999f0af99b4a25ab26b3866f4df8>), [CUDA_ERROR_INVALID_DEVICE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e96f047e7215788ca96c81af92a04bfb6c>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>), [CUDA_ERROR_INVALID_RESOURCE_TYPE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e94ec23220911f54aa1e66d8bcf86ec7ba>), [CUDA_ERROR_INVALID_RESOURCE_CONFIGURATION](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e958d93275e1fc7c5879c1789fd9bc74a5>)

###### Description

Splits `CU_DEV_RESOURCE_TYPE_SM` resources into `nbGroups`, adhering to the minimum SM count specified in `minCount` and the usage flags in `flags`. If `result` is NULL, the API simulates a split and provides the amount of groups that would be created in `nbGroups`. Otherwise, `nbGroups` must point to the amount of elements in `result` and on return, the API will overwrite `nbGroups` with the amount actually created. The groups are written to the array in `result`. `nbGroups` can be less than the total amount if a smaller number of groups is needed.

This API is used to spatially partition the input resource. The input resource needs to come from one of [cuDeviceGetDevResource](<group__CUDA__GREEN__CONTEXTS.html#group__CUDA__GREEN__CONTEXTS_1g6115d21604653f4eafb257f725538ab6> "Get device resources."), [cuCtxGetDevResource](<group__CUDA__GREEN__CONTEXTS.html#group__CUDA__GREEN__CONTEXTS_1g00d5b66f04f0591f1c752adb1a924635> "Get context resources."), or [cuGreenCtxGetDevResource](<group__CUDA__GREEN__CONTEXTS.html#group__CUDA__GREEN__CONTEXTS_1g301178535c06137ea8cc9becdbfb90b8> "Get green context resources."). A limitation of the API is that the output results cannot be split again without first creating a descriptor and a green context with that descriptor.

When creating the groups, the API will take into account the performance and functional characteristics of the input resource, and guarantee a split that will create a disjoint set of symmetrical partitions. This may lead to fewer groups created than purely dividing the total SM count by the `minCount` due to cluster requirements or alignment and granularity requirements for the minCount. These requirements can be queried with [cuDeviceGetDevResource](<group__CUDA__GREEN__CONTEXTS.html#group__CUDA__GREEN__CONTEXTS_1g6115d21604653f4eafb257f725538ab6> "Get device resources."), [cuCtxGetDevResource](<group__CUDA__GREEN__CONTEXTS.html#group__CUDA__GREEN__CONTEXTS_1g00d5b66f04f0591f1c752adb1a924635> "Get context resources."), and [cuGreenCtxGetDevResource](<group__CUDA__GREEN__CONTEXTS.html#group__CUDA__GREEN__CONTEXTS_1g301178535c06137ea8cc9becdbfb90b8> "Get green context resources.") for [CU_DEV_RESOURCE_TYPE_SM](<group__CUDA__GREEN__CONTEXTS.html#group__CUDA__GREEN__CONTEXTS_1gg28def480400d3254367d891d58f1375b3ba3ec7d6c8814ce80b9a633ca2ff332>), using the `minSmPartitionSize` and `smCoscheduledAlignment` fields to determine minimum partition size and alignment granularity, respectively.

The `remainder` set does not have the same functional or performance guarantees as the groups in `result`. Its use should be carefully planned and future partitions of the `remainder` set are discouraged.

The following flags are supported:

  * `CU_DEV_SM_RESOURCE_SPLIT_IGNORE_SM_COSCHEDULING` : Lower the minimum SM count and alignment, and treat each SM independent of its hierarchy. This allows more fine grained partitions but at the cost of advanced features (such as large clusters on compute capability 9.0+).

  * `CU_DEV_SM_RESOURCE_SPLIT_MAX_POTENTIAL_CLUSTER_SIZE` : Compute Capability 9.0+ only. Attempt to create groups that may allow for maximally sized thread clusters. This can be queried post green context creation using [cuOccupancyMaxPotentialClusterSize](<group__CUDA__OCCUPANCY.html#group__CUDA__OCCUPANCY_1gd6f60814c1e3440145115ade3730365f> "Given the kernel function \(func\) and launch configuration \(config\), return the maximum cluster size in *clusterSize.").


A successful API call must either have:

  * A valid array of `result` pointers of size passed in `nbGroups`, with `input` of type `CU_DEV_RESOURCE_TYPE_SM`. Value of `minCount` must be between 0 and the SM count specified in `input`. `remainder` may be NULL.

  * NULL passed in for `result`, with a valid integer pointer in `nbGroups` and `input` of type `CU_DEV_RESOURCE_TYPE_SM`. Value of `minCount` must be between 0 and the SM count specified in `input`. `remainder` may be NULL. This queries the number of groups that would be created by the API.


Note: The API is not supported on 32-bit platforms.

**See also:**

[cuGreenCtxGetDevResource](<group__CUDA__GREEN__CONTEXTS.html#group__CUDA__GREEN__CONTEXTS_1g301178535c06137ea8cc9becdbfb90b8> "Get green context resources."), [cuCtxGetDevResource](<group__CUDA__GREEN__CONTEXTS.html#group__CUDA__GREEN__CONTEXTS_1g00d5b66f04f0591f1c752adb1a924635> "Get context resources."), [cuDeviceGetDevResource](<group__CUDA__GREEN__CONTEXTS.html#group__CUDA__GREEN__CONTEXTS_1g6115d21604653f4eafb257f725538ab6> "Get device resources.")

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuDeviceGetDevResource ( [CUdevice](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g41ca2a24a242b36ef2ca77330b5fb72a>)Â device, [CUdevResource](<structCUdevResource.html#structCUdevResource>)*Â resource, [CUdevResourceType](<group__CUDA__GREEN__CONTEXTS.html#group__CUDA__GREEN__CONTEXTS_1g28def480400d3254367d891d58f1375b>)Â type )


Get device resources.

######  Parameters

`device`
    \- Device to get resource for
`resource`
    \- Output pointer to a [CUdevResource](<structCUdevResource.html#structCUdevResource>) structure
`type`
    \- Type of resource to retrieve

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_DEINITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9acf52f132faf29b473cdda6061f0f44a>), [CUDA_ERROR_NOT_INITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e98feb999f0af99b4a25ab26b3866f4df8>), [CUDA_ERROR_INVALID_RESOURCE_TYPE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e94ec23220911f54aa1e66d8bcf86ec7ba>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>), [CUDA_ERROR_INVALID_DEVICE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e96f047e7215788ca96c81af92a04bfb6c>)

###### Description

Get the `type` resources available to the `device`. This may often be the starting point for further partitioning or configuring of resources.

Note: The API is not supported on 32-bit platforms.

**See also:**

[cuDevResourceGenerateDesc](<group__CUDA__GREEN__CONTEXTS.html#group__CUDA__GREEN__CONTEXTS_1g1ea7743fd633d2e2dd92eb1c84c4fbc5> "Generate a resource descriptor.")

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuGreenCtxCreate ( [CUgreenCtx](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g453cb79a1ceb13bec502a9c5f06a0268>)*Â phCtx, [CUdevResourceDesc](<group__CUDA__GREEN__CONTEXTS.html#group__CUDA__GREEN__CONTEXTS_1g2384245122e1ee00c24a867404b55c17>)Â desc, [CUdevice](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g41ca2a24a242b36ef2ca77330b5fb72a>)Â dev, unsigned int Â flags )


Creates a green context with a specified set of resources.

######  Parameters

`phCtx`
    \- Pointer for the output handle to the green context
`desc`
    \- Descriptor generated via [cuDevResourceGenerateDesc](<group__CUDA__GREEN__CONTEXTS.html#group__CUDA__GREEN__CONTEXTS_1g1ea7743fd633d2e2dd92eb1c84c4fbc5> "Generate a resource descriptor.") which contains the set of resources to be used
`dev`
    \- Device on which to create the green context.
`flags`
    \- One of the supported green context creation flags. `CU_GREEN_CTX_DEFAULT_STREAM` is required.

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_DEINITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9acf52f132faf29b473cdda6061f0f44a>), [CUDA_ERROR_NOT_INITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e98feb999f0af99b4a25ab26b3866f4df8>), [CUDA_ERROR_INVALID_DEVICE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e96f047e7215788ca96c81af92a04bfb6c>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>), [CUDA_ERROR_NOT_SUPPORTED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e954756ae7ade0dfd09faeccb513dd831b>), [CUDA_ERROR_OUT_OF_MEMORY](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9264c50688ed110e8476b591befe60c02>)

###### Description

This API creates a green context with the resources specified in the descriptor `desc` and returns it in the handle represented by `phCtx`. This API will retain the primary context on device `dev`, which will is released when the green context is destroyed. It is advised to have the primary context active before calling this API to avoid the heavy cost of triggering primary context initialization and deinitialization multiple times.

The API does not set the green context current. In order to set it current, you need to explicitly set it current by first converting the green context to a CUcontext using [cuCtxFromGreenCtx](<group__CUDA__GREEN__CONTEXTS.html#group__CUDA__GREEN__CONTEXTS_1gf0779ec72ce1d5d7eb003d7d9b25afcb> "Converts a green context into the primary context.") and subsequently calling [cuCtxSetCurrent](<group__CUDA__CTX.html#group__CUDA__CTX_1gbe562ee6258b4fcc272ca6478ca2a2f7> "Binds the specified CUDA context to the calling CPU thread.") / [cuCtxPushCurrent](<group__CUDA__CTX.html#group__CUDA__CTX_1gb02d4c850eb16f861fe5a29682cc90ba> "Pushes a context on the current CPU thread."). It should be noted that a green context can be current to only one thread at a time. There is no internal synchronization to make API calls accessing the same green context from multiple threads work.

Note: The API is not supported on 32-bit platforms.

The supported flags are:

  * `CU_GREEN_CTX_DEFAULT_STREAM` : Creates a default stream to use inside the green context. Required.


**See also:**

[cuGreenCtxDestroy](<group__CUDA__GREEN__CONTEXTS.html#group__CUDA__GREEN__CONTEXTS_1g7c37d959c2c030c13135366533eff57d> "Destroys a green context."), [cuCtxFromGreenCtx](<group__CUDA__GREEN__CONTEXTS.html#group__CUDA__GREEN__CONTEXTS_1gf0779ec72ce1d5d7eb003d7d9b25afcb> "Converts a green context into the primary context."), [cuCtxSetCurrent](<group__CUDA__CTX.html#group__CUDA__CTX_1gbe562ee6258b4fcc272ca6478ca2a2f7> "Binds the specified CUDA context to the calling CPU thread."), [cuCtxPushCurrent](<group__CUDA__CTX.html#group__CUDA__CTX_1gb02d4c850eb16f861fe5a29682cc90ba> "Pushes a context on the current CPU thread."), [cuDevResourceGenerateDesc](<group__CUDA__GREEN__CONTEXTS.html#group__CUDA__GREEN__CONTEXTS_1g1ea7743fd633d2e2dd92eb1c84c4fbc5> "Generate a resource descriptor."), [cuDevicePrimaryCtxRetain](<group__CUDA__PRIMARY__CTX.html#group__CUDA__PRIMARY__CTX_1g9051f2d5c31501997a6cb0530290a300> "Retain the primary context on the GPU."), [cuCtxCreate](<group__CUDA__CTX.html#group__CUDA__CTX_1g77e9fb578caefca5ed15b4acebf35265> "Create a CUDA context.")

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuGreenCtxDestroy ( [CUgreenCtx](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g453cb79a1ceb13bec502a9c5f06a0268>)Â hCtx )


Destroys a green context.

######  Parameters

`hCtx`
    \- Green context to be destroyed

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_DEINITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9acf52f132faf29b473cdda6061f0f44a>), [CUDA_ERROR_NOT_INITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e98feb999f0af99b4a25ab26b3866f4df8>), [CUDA_ERROR_INVALID_CONTEXT](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a484e9af32c1e9893ff21f0e0191a12d>), [CUDA_ERROR_CONTEXT_IS_DESTROYED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9b27ac43f7ce8446f5c9636dd73fb2139>)

###### Description

Destroys the green context, releasing the primary context of the device that this green context was created for. Any resources provisioned for this green context (that were initially available via the resource descriptor) are released as well. The API does not destroy streams created via [cuGreenCtxStreamCreate](<group__CUDA__GREEN__CONTEXTS.html#group__CUDA__GREEN__CONTEXTS_1g569b9e947b0f143f6ed9397a12046a8a> "Create a stream for use in the green context."), [cuStreamCreate](<group__CUDA__STREAM.html#group__CUDA__STREAM_1ga581f0c5833e21ded8b5a56594e243f4> "Create a stream."), or [cuStreamCreateWithPriority](<group__CUDA__STREAM.html#group__CUDA__STREAM_1g95c1a8c7c3dacb13091692dd9c7f7471> "Create a stream with the given priority."). Users are expected to destroy these streams explicitly using [cuStreamDestroy](<group__CUDA__STREAM.html#group__CUDA__STREAM_1g244c8833de4596bcd31a06cdf21ee758> "Destroys a stream.") to avoid resource leaks. Once the green context is destroyed, any subsequent API calls involving these streams will return [CUDA_ERROR_STREAM_DETACHED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9aad337be88462a55bdcfcbff87d788c6>) with the exception of the following APIs:

  * [cuStreamDestroy](<group__CUDA__STREAM.html#group__CUDA__STREAM_1g244c8833de4596bcd31a06cdf21ee758> "Destroys a stream.").


Additionally, the API will invalidate all active captures on these streams.

**See also:**

[cuGreenCtxCreate](<group__CUDA__GREEN__CONTEXTS.html#group__CUDA__GREEN__CONTEXTS_1ga6da4f9959fd48d1f1a5cbedbec54e65> "Creates a green context with a specified set of resources."), [cuCtxDestroy](<group__CUDA__CTX.html#group__CUDA__CTX_1g27a365aebb0eb548166309f58a1e8b8e> "Destroy a CUDA context.")

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuGreenCtxGetDevResource ( [CUgreenCtx](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g453cb79a1ceb13bec502a9c5f06a0268>)Â hCtx, [CUdevResource](<structCUdevResource.html#structCUdevResource>)*Â resource, [CUdevResourceType](<group__CUDA__GREEN__CONTEXTS.html#group__CUDA__GREEN__CONTEXTS_1g28def480400d3254367d891d58f1375b>)Â type )


Get green context resources.

######  Parameters

`hCtx`
    \- Green context to get resource for
`resource`
    \- Output pointer to a [CUdevResource](<structCUdevResource.html#structCUdevResource>) structure
`type`
    \- Type of resource to retrieve

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>)[CUDA_ERROR_DEINITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9acf52f132faf29b473cdda6061f0f44a>), [CUDA_ERROR_NOT_INITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e98feb999f0af99b4a25ab26b3866f4df8>), [CUDA_ERROR_INVALID_CONTEXT](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a484e9af32c1e9893ff21f0e0191a12d>), [CUDA_ERROR_INVALID_RESOURCE_TYPE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e94ec23220911f54aa1e66d8bcf86ec7ba>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>)

###### Description

Get the `type` resources available to the green context represented by `hCtx`

**See also:**

[cuDevResourceGenerateDesc](<group__CUDA__GREEN__CONTEXTS.html#group__CUDA__GREEN__CONTEXTS_1g1ea7743fd633d2e2dd92eb1c84c4fbc5> "Generate a resource descriptor.")

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuGreenCtxGetId ( [CUgreenCtx](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g453cb79a1ceb13bec502a9c5f06a0268>)Â greenCtx, unsigned long long*Â greenCtxId )


Returns the unique Id associated with the green context supplied.

######  Parameters

`greenCtx`
    \- Green context for which to obtain the Id
`greenCtxId`
    \- Pointer to store the Id of the green context

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_CONTEXT_IS_DESTROYED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9b27ac43f7ce8446f5c9636dd73fb2139>), [CUDA_ERROR_DEINITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9acf52f132faf29b473cdda6061f0f44a>), [CUDA_ERROR_NOT_INITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e98feb999f0af99b4a25ab26b3866f4df8>), [CUDA_ERROR_INVALID_CONTEXT](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a484e9af32c1e9893ff21f0e0191a12d>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>)

###### Description

Returns in `greenCtxId` the unique Id which is associated with a given green context. The Id is unique for the life of the program for this instance of CUDA. If green context is supplied as NULL and the current context is set to a green context, the Id of the current green context is returned.

Note:

Note that this function may also return error codes from previous, asynchronous launches.

**See also:**

[cuGreenCtxCreate](<group__CUDA__GREEN__CONTEXTS.html#group__CUDA__GREEN__CONTEXTS_1ga6da4f9959fd48d1f1a5cbedbec54e65> "Creates a green context with a specified set of resources."), [cuGreenCtxDestroy](<group__CUDA__GREEN__CONTEXTS.html#group__CUDA__GREEN__CONTEXTS_1g7c37d959c2c030c13135366533eff57d> "Destroys a green context."), [cuCtxGetId](<group__CUDA__CTX.html#group__CUDA__CTX_1g32f492cd6c3f90af0d6935b294392db5> "Returns the unique Id associated with the context supplied.")

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuGreenCtxRecordEvent ( [CUgreenCtx](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g453cb79a1ceb13bec502a9c5f06a0268>)Â hCtx, [CUevent](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g6d740185cf0953636d4ae37f68d7559b>)Â hEvent )


Records an event.

######  Parameters

`hCtx`
    \- Green context to record event for
`hEvent`
    \- Event to record

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_DEINITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9acf52f132faf29b473cdda6061f0f44a>), [CUDA_ERROR_NOT_INITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e98feb999f0af99b4a25ab26b3866f4df8>), [CUDA_ERROR_INVALID_CONTEXT](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a484e9af32c1e9893ff21f0e0191a12d>), [CUDA_ERROR_INVALID_HANDLE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e90fd2e63260c6317ba943af0f7e4b8d21>), [CUDA_ERROR_STREAM_CAPTURE_UNSUPPORTED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9adf26f72a5e6589c7ade9af3b1b62e3d>)

###### Description

Captures in `hEvent` all the activities of the green context of `hCtx` at the time of this call. `hEvent` and `hCtx` must be from the same primary context otherwise [CUDA_ERROR_INVALID_HANDLE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e90fd2e63260c6317ba943af0f7e4b8d21>) is returned. Calls such as [cuEventQuery()](<group__CUDA__EVENT.html#group__CUDA__EVENT_1g6f0704d755066b0ee705749ae911deef> "Queries an event's status.") or [cuGreenCtxWaitEvent()](<group__CUDA__GREEN__CONTEXTS.html#group__CUDA__GREEN__CONTEXTS_1g6b26172117084fd024f1396fb66a8ffd> "Make a green context wait on an event.") will then examine or wait for completion of the work that was captured. Uses of `hCtx` after this call do not modify `hEvent`.

Note:

The API will return [CUDA_ERROR_STREAM_CAPTURE_UNSUPPORTED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9adf26f72a5e6589c7ade9af3b1b62e3d>) if the specified green context `hCtx` has a stream in the capture mode. In such a case, the call will invalidate all the conflicting captures.

**See also:**

[cuGreenCtxWaitEvent](<group__CUDA__GREEN__CONTEXTS.html#group__CUDA__GREEN__CONTEXTS_1g6b26172117084fd024f1396fb66a8ffd> "Make a green context wait on an event."), [cuEventRecord](<group__CUDA__EVENT.html#group__CUDA__EVENT_1g95424d3be52c4eb95d83861b70fb89d1> "Records an event."), [cuCtxRecordEvent](<group__CUDA__CTX.html#group__CUDA__CTX_1gf3ee63561a7a371fa9d4dc0e31f94afd> "Records an event."), [cuCtxWaitEvent](<group__CUDA__CTX.html#group__CUDA__CTX_1gcf64e420275a8141b1f12bfce3f478f9> "Make a context wait on an event.")

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuGreenCtxStreamCreate ( [CUstream](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gb946c7f02e09efd788a204718015d88a>)*Â phStream, [CUgreenCtx](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g453cb79a1ceb13bec502a9c5f06a0268>)Â greenCtx, unsigned int Â flags, int Â priority )


Create a stream for use in the green context.

######  Parameters

`phStream`
    \- Returned newly created stream
`greenCtx`
    \- Green context for which to create the stream for
`flags`
    \- Flags for stream creation. `CU_STREAM_NON_BLOCKING` must be specified.
`priority`
    \- Stream priority. Lower numbers represent higher priorities. See [cuCtxGetStreamPriorityRange](<group__CUDA__CTX.html#group__CUDA__CTX_1g137920ab61a71be6ce67605b9f294091> "Returns numerical values that correspond to the least and greatest stream priorities.") for more information about meaningful stream priorities that can be passed.

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_DEINITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9acf52f132faf29b473cdda6061f0f44a>), [CUDA_ERROR_NOT_INITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e98feb999f0af99b4a25ab26b3866f4df8>), [CUDA_ERROR_INVALID_CONTEXT](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a484e9af32c1e9893ff21f0e0191a12d>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>), [CUDA_ERROR_OUT_OF_MEMORY](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9264c50688ed110e8476b591befe60c02>)

###### Description

Creates a stream for use in the specified green context `greenCtx` and returns a handle in `phStream`. The stream can be destroyed by calling [cuStreamDestroy()](<group__CUDA__STREAM.html#group__CUDA__STREAM_1g244c8833de4596bcd31a06cdf21ee758> "Destroys a stream."). Note that the API ignores the context that is current to the calling thread and creates a stream in the specified green context `greenCtx`.

The supported values for `flags` are:

  * [CU_STREAM_NON_BLOCKING](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gg775cb4ffbb7adf91e190067d9ad1752a89727d1d315214a6301abe98b419aff6>): This must be specified. It indicates that work running in the created stream may run concurrently with work in the default stream, and that the created stream should perform no implicit synchronization with the default stream.


Specifying `priority` affects the scheduling priority of work in the stream. Priorities provide a hint to preferentially run work with higher priority when possible, but do not preempt already-running work or provide any other functional guarantee on execution order. `priority` follows a convention where lower numbers represent higher priorities. '0' represents default priority. The range of meaningful numerical priorities can be queried using [cuCtxGetStreamPriorityRange](<group__CUDA__CTX.html#group__CUDA__CTX_1g137920ab61a71be6ce67605b9f294091> "Returns numerical values that correspond to the least and greatest stream priorities."). If the specified priority is outside the numerical range returned by [cuCtxGetStreamPriorityRange](<group__CUDA__CTX.html#group__CUDA__CTX_1g137920ab61a71be6ce67605b9f294091> "Returns numerical values that correspond to the least and greatest stream priorities."), it will automatically be clamped to the lowest or the highest number in the range.

Note:

  * Note that this function may also return error codes from previous, asynchronous launches.

  * In the current implementation, only compute kernels launched in priority streams are affected by the stream's priority. Stream priorities have no effect on host-to-device and device-to-host memory operations.


**See also:**

[cuStreamDestroy](<group__CUDA__STREAM.html#group__CUDA__STREAM_1g244c8833de4596bcd31a06cdf21ee758> "Destroys a stream."), [cuGreenCtxCreate](<group__CUDA__GREEN__CONTEXTS.html#group__CUDA__GREEN__CONTEXTS_1ga6da4f9959fd48d1f1a5cbedbec54e65> "Creates a green context with a specified set of resources.")[cuStreamCreate](<group__CUDA__STREAM.html#group__CUDA__STREAM_1ga581f0c5833e21ded8b5a56594e243f4> "Create a stream."), [cuStreamGetPriority](<group__CUDA__STREAM.html#group__CUDA__STREAM_1g5bd5cb26915a2ecf1921807339488484> "Query the priority of a given stream."), [cuCtxGetStreamPriorityRange](<group__CUDA__CTX.html#group__CUDA__CTX_1g137920ab61a71be6ce67605b9f294091> "Returns numerical values that correspond to the least and greatest stream priorities."), [cuStreamGetFlags](<group__CUDA__STREAM.html#group__CUDA__STREAM_1g4d39786855a6bed01215c1907fbbfbb7> "Query the flags of a given stream."), [cuStreamGetDevice](<group__CUDA__STREAM.html#group__CUDA__STREAM_1g1198995e0a122783ede50814b8c7a29b> "Returns the device handle of the stream."), [cuStreamWaitEvent](<group__CUDA__STREAM.html#group__CUDA__STREAM_1g6a898b652dfc6aa1d5c8d97062618b2f> "Make a compute stream wait on an event."), [cuStreamQuery](<group__CUDA__STREAM.html#group__CUDA__STREAM_1g1b0d24bbe97fa68e4bc511fb6adfeb0b> "Determine status of a compute stream."), [cuStreamSynchronize](<group__CUDA__STREAM.html#group__CUDA__STREAM_1g15e49dd91ec15991eb7c0a741beb7dad> "Wait until a stream's tasks are completed."), [cuStreamAddCallback](<group__CUDA__STREAM.html#group__CUDA__STREAM_1g613d97a277d7640f4cb1c03bd51c2483> "Add a callback to a compute stream."), [cudaStreamCreateWithPriority](<../cuda-runtime-api/group__CUDART__STREAM.html#group__CUDART__STREAM_1ge2be9e9858849bf62ba4a8b66d1c3540>)

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuGreenCtxWaitEvent ( [CUgreenCtx](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g453cb79a1ceb13bec502a9c5f06a0268>)Â hCtx, [CUevent](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g6d740185cf0953636d4ae37f68d7559b>)Â hEvent )


Make a green context wait on an event.

######  Parameters

`hCtx`
    \- Green context to wait
`hEvent`
    \- Event to wait on

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_DEINITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9acf52f132faf29b473cdda6061f0f44a>), [CUDA_ERROR_NOT_INITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e98feb999f0af99b4a25ab26b3866f4df8>), [CUDA_ERROR_INVALID_CONTEXT](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a484e9af32c1e9893ff21f0e0191a12d>), [CUDA_ERROR_INVALID_HANDLE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e90fd2e63260c6317ba943af0f7e4b8d21>), [CUDA_ERROR_STREAM_CAPTURE_UNSUPPORTED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9adf26f72a5e6589c7ade9af3b1b62e3d>)

###### Description

Makes all future work submitted to green context `hCtx` wait for all work captured in `hEvent`. The synchronization will be performed on the device and will not block the calling CPU thread. See [cuGreenCtxRecordEvent()](<group__CUDA__GREEN__CONTEXTS.html#group__CUDA__GREEN__CONTEXTS_1g9dd087071cc217ad7ebda6df96d2ee40> "Records an event.") or [cuEventRecord()](<group__CUDA__EVENT.html#group__CUDA__EVENT_1g95424d3be52c4eb95d83861b70fb89d1> "Records an event."), for details on what is captured by an event.

Note:

  * `hEvent` may be from a different context or device than `hCtx`.

  * The API will return [CUDA_ERROR_STREAM_CAPTURE_UNSUPPORTED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9adf26f72a5e6589c7ade9af3b1b62e3d>) and invalidate the capture if the specified event `hEvent` is part of an ongoing capture sequence or if the specified green context `hCtx` has a stream in the capture mode.


**See also:**

[cuGreenCtxRecordEvent](<group__CUDA__GREEN__CONTEXTS.html#group__CUDA__GREEN__CONTEXTS_1g9dd087071cc217ad7ebda6df96d2ee40> "Records an event."), [cuStreamWaitEvent](<group__CUDA__STREAM.html#group__CUDA__STREAM_1g6a898b652dfc6aa1d5c8d97062618b2f> "Make a compute stream wait on an event."), [cuCtxRecordEvent](<group__CUDA__CTX.html#group__CUDA__CTX_1gf3ee63561a7a371fa9d4dc0e31f94afd> "Records an event."), [cuCtxWaitEvent](<group__CUDA__CTX.html#group__CUDA__CTX_1gcf64e420275a8141b1f12bfce3f478f9> "Make a context wait on an event.")

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuStreamGetDevResource ( [CUstream](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gb946c7f02e09efd788a204718015d88a>)Â hStream, [CUdevResource](<structCUdevResource.html#structCUdevResource>)*Â resource, [CUdevResourceType](<group__CUDA__GREEN__CONTEXTS.html#group__CUDA__GREEN__CONTEXTS_1g28def480400d3254367d891d58f1375b>)Â type )


Get stream resources.

######  Parameters

`hStream`
    \- Stream to get resource for
`resource`
    \- Output pointer to a [CUdevResource](<structCUdevResource.html#structCUdevResource>) structure
`type`
    \- Type of resource to retrieve

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_DEINITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9acf52f132faf29b473cdda6061f0f44a>), [CUDA_ERROR_NOT_INITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e98feb999f0af99b4a25ab26b3866f4df8>), [CUDA_ERROR_INVALID_RESOURCE_TYPE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e94ec23220911f54aa1e66d8bcf86ec7ba>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>), [CUDA_ERROR_INVALID_HANDLE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e90fd2e63260c6317ba943af0f7e4b8d21>)

###### Description

Get the `type` resources available to the `hStream` and store them in `resource`.

Note: The API will return [CUDA_ERROR_INVALID_RESOURCE_TYPE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e94ec23220911f54aa1e66d8bcf86ec7ba>) is `type` is `CU_DEV_RESOURCE_TYPE_WORKQUEUE_CONFIG` or `CU_DEV_RESOURCE_TYPE_WORKQUEUE`.

Note:

Note that this function may also return error codes from previous, asynchronous launches.

**See also:**

[cuGreenCtxCreate](<group__CUDA__GREEN__CONTEXTS.html#group__CUDA__GREEN__CONTEXTS_1ga6da4f9959fd48d1f1a5cbedbec54e65> "Creates a green context with a specified set of resources."), [cuGreenCtxStreamCreate](<group__CUDA__GREEN__CONTEXTS.html#group__CUDA__GREEN__CONTEXTS_1g569b9e947b0f143f6ed9397a12046a8a> "Create a stream for use in the green context."), [cuStreamCreate](<group__CUDA__STREAM.html#group__CUDA__STREAM_1ga581f0c5833e21ded8b5a56594e243f4> "Create a stream."), [cuDevSmResourceSplitByCount](<group__CUDA__GREEN__CONTEXTS.html#group__CUDA__GREEN__CONTEXTS_1gf8359c74d7286ac32e5db253240d9a6c> "Splits CU_DEV_RESOURCE_TYPE_SM resources."), [cuDevResourceGenerateDesc](<group__CUDA__GREEN__CONTEXTS.html#group__CUDA__GREEN__CONTEXTS_1g1ea7743fd633d2e2dd92eb1c84c4fbc5> "Generate a resource descriptor."), [cudaStreamGetDevResource](<../cuda-runtime-api/group__CUDART__EXECUTION__CONTEXT.html#group__CUDART__EXECUTION__CONTEXT_1g55c60bf05fec3cf837d96520c91b8396>)

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuStreamGetGreenCtx ( [CUstream](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gb946c7f02e09efd788a204718015d88a>)Â hStream, [CUgreenCtx](<group__CUDA__TYPES.html#group__CUDA__TYPES_1g453cb79a1ceb13bec502a9c5f06a0268>)*Â phCtx )


Query the green context associated with a stream.

######  Parameters

`hStream`
    \- Handle to the stream to be queried
`phCtx`
    \- Returned green context associated with the stream

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_DEINITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9acf52f132faf29b473cdda6061f0f44a>), [CUDA_ERROR_NOT_INITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e98feb999f0af99b4a25ab26b3866f4df8>), [CUDA_ERROR_INVALID_CONTEXT](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a484e9af32c1e9893ff21f0e0191a12d>), [CUDA_ERROR_INVALID_HANDLE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e90fd2e63260c6317ba943af0f7e4b8d21>),

###### Description

Returns the CUDA green context that the stream is associated with, or NULL if the stream is not associated with any green context.

The stream handle `hStream` can refer to any of the following:

  * a stream created via any of the CUDA driver APIs such as [cuStreamCreate](<group__CUDA__STREAM.html#group__CUDA__STREAM_1ga581f0c5833e21ded8b5a56594e243f4> "Create a stream."), [cuStreamCreateWithPriority](<group__CUDA__STREAM.html#group__CUDA__STREAM_1g95c1a8c7c3dacb13091692dd9c7f7471> "Create a stream with the given priority.") and [cuGreenCtxStreamCreate](<group__CUDA__GREEN__CONTEXTS.html#group__CUDA__GREEN__CONTEXTS_1g569b9e947b0f143f6ed9397a12046a8a> "Create a stream for use in the green context."), or their runtime API equivalents such as [cudaStreamCreate](<../cuda-runtime-api/group__CUDART__STREAM.html#group__CUDART__STREAM_1g6a3c4b819e6a994c26d0c4824a4c80da>), [cudaStreamCreateWithFlags](<../cuda-runtime-api/group__CUDART__STREAM.html#group__CUDART__STREAM_1gb1e32aff9f59119e4d0a9858991c4ad3>) and [cudaStreamCreateWithPriority](<../cuda-runtime-api/group__CUDART__STREAM.html#group__CUDART__STREAM_1ge2be9e9858849bf62ba4a8b66d1c3540>). If during stream creation the context that was active in the calling thread was obtained with cuCtxFromGreenCtx, that green context is returned in `phCtx`. Otherwise, `*phCtx` is set to NULL instead.

  * special stream such as the NULL stream or [CU_STREAM_LEGACY](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ga53e8210837f039dd6434a3a4c3324aa>). In that case if context that is active in the calling thread was obtained with cuCtxFromGreenCtx, that green context is returned. Otherwise, `*phCtx` is set to NULL instead.


Passing an invalid handle will result in undefined behavior.

Note:

Note that this function may also return error codes from previous, asynchronous launches.

**See also:**

[cuStreamDestroy](<group__CUDA__STREAM.html#group__CUDA__STREAM_1g244c8833de4596bcd31a06cdf21ee758> "Destroys a stream."), [cuStreamCreate](<group__CUDA__STREAM.html#group__CUDA__STREAM_1ga581f0c5833e21ded8b5a56594e243f4> "Create a stream."), [cuStreamCreateWithPriority](<group__CUDA__STREAM.html#group__CUDA__STREAM_1g95c1a8c7c3dacb13091692dd9c7f7471> "Create a stream with the given priority."), [cuStreamGetCtx](<group__CUDA__STREAM.html#group__CUDA__STREAM_1g1107907025eaa3387fdc590a9379a681> "Query the context associated with a stream."), [cuGreenCtxStreamCreate](<group__CUDA__GREEN__CONTEXTS.html#group__CUDA__GREEN__CONTEXTS_1g569b9e947b0f143f6ed9397a12046a8a> "Create a stream for use in the green context."), [cuStreamGetPriority](<group__CUDA__STREAM.html#group__CUDA__STREAM_1g5bd5cb26915a2ecf1921807339488484> "Query the priority of a given stream."), [cuStreamGetFlags](<group__CUDA__STREAM.html#group__CUDA__STREAM_1g4d39786855a6bed01215c1907fbbfbb7> "Query the flags of a given stream."), [cuStreamGetDevice](<group__CUDA__STREAM.html#group__CUDA__STREAM_1g1198995e0a122783ede50814b8c7a29b> "Returns the device handle of the stream."), [cuStreamWaitEvent](<group__CUDA__STREAM.html#group__CUDA__STREAM_1g6a898b652dfc6aa1d5c8d97062618b2f> "Make a compute stream wait on an event."), [cuStreamQuery](<group__CUDA__STREAM.html#group__CUDA__STREAM_1g1b0d24bbe97fa68e4bc511fb6adfeb0b> "Determine status of a compute stream."), [cuStreamSynchronize](<group__CUDA__STREAM.html#group__CUDA__STREAM_1g15e49dd91ec15991eb7c0a741beb7dad> "Wait until a stream's tasks are completed."), [cuStreamAddCallback](<group__CUDA__STREAM.html#group__CUDA__STREAM_1g613d97a277d7640f4cb1c03bd51c2483> "Add a callback to a compute stream."), [cudaStreamCreate](<../cuda-runtime-api/group__CUDART__STREAM.html#group__CUDART__STREAM_1g6a3c4b819e6a994c26d0c4824a4c80da>), [cudaStreamCreateWithFlags](<../cuda-runtime-api/group__CUDART__STREAM.html#group__CUDART__STREAM_1gb1e32aff9f59119e4d0a9858991c4ad3>)

* * *


---

# Coredump Attributes Control

## 6.34.Â Coredump Attributes Control API

This section describes the coredump attribute control functions of the low-level CUDA driver application programming interface.

### Enumerations

enumÂ [CUCoredumpGenerationFlags](<#group__CUDA__COREDUMP_1g516d6bb94a388c0efa9f50efa6d215c9>)

enumÂ [CUcoredumpSettings](<#group__CUDA__COREDUMP_1g9b1cc417bdebfe4230e6dba3ea3d5b62>)


### Functions

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuCoredumpGetAttribute](<#group__CUDA__COREDUMP_1g56d7eb4975c7eb8e2b4eb0713fd8cedd>) ( [CUcoredumpSettings](<group__CUDA__COREDUMP.html#group__CUDA__COREDUMP_1g9b1cc417bdebfe4230e6dba3ea3d5b62>)Â attrib, void*Â value, size_t*Â size )
     Allows caller to fetch a coredump attribute value for the current context.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuCoredumpGetAttributeGlobal](<#group__CUDA__COREDUMP_1g5cb5b7ddf41a2c3631eed8d00c4ae819>) ( [CUcoredumpSettings](<group__CUDA__COREDUMP.html#group__CUDA__COREDUMP_1g9b1cc417bdebfe4230e6dba3ea3d5b62>)Â attrib, void*Â value, size_t*Â size )
     Allows caller to fetch a coredump attribute value for the entire application.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuCoredumpSetAttribute](<#group__CUDA__COREDUMP_1g45b806050f3211e840eb3c8d91e93fcb>) ( [CUcoredumpSettings](<group__CUDA__COREDUMP.html#group__CUDA__COREDUMP_1g9b1cc417bdebfe4230e6dba3ea3d5b62>)Â attrib, void*Â value, size_t*Â size )
     Allows caller to set a coredump attribute value for the current context.
[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>)Â [cuCoredumpSetAttributeGlobal](<#group__CUDA__COREDUMP_1ga7645a8f68dd5379a03852b462727990>) ( [CUcoredumpSettings](<group__CUDA__COREDUMP.html#group__CUDA__COREDUMP_1g9b1cc417bdebfe4230e6dba3ea3d5b62>)Â attrib, void*Â value, size_t*Â size )
     Allows caller to set a coredump attribute value globally.

### Enumerations

enum CUCoredumpGenerationFlags


Flags for controlling coredump contents

######  Values

CU_COREDUMP_DEFAULT_FLAGS = 0

CU_COREDUMP_SKIP_NONRELOCATED_ELF_IMAGES = (1<<0)

CU_COREDUMP_SKIP_GLOBAL_MEMORY = (1<<1)

CU_COREDUMP_SKIP_SHARED_MEMORY = (1<<2)

CU_COREDUMP_SKIP_LOCAL_MEMORY = (1<<3)

CU_COREDUMP_SKIP_ABORT = (1<<4)

CU_COREDUMP_SKIP_CONSTBANK_MEMORY = (1<<5)

CU_COREDUMP_GZIP_COMPRESS = (1<<6)

CU_COREDUMP_LIGHTWEIGHT_FLAGS = CU_COREDUMP_SKIP_NONRELOCATED_ELF_IMAGES |CU_COREDUMP_SKIP_GLOBAL_MEMORY |CU_COREDUMP_SKIP_SHARED_MEMORY |CU_COREDUMP_SKIP_LOCAL_MEMORY |CU_COREDUMP_SKIP_CONSTBANK_MEMORY


enum CUcoredumpSettings


Flags for choosing a coredump attribute to get/set

######  Values

CU_COREDUMP_ENABLE_ON_EXCEPTION = 1

CU_COREDUMP_TRIGGER_HOST

CU_COREDUMP_LIGHTWEIGHT

CU_COREDUMP_ENABLE_USER_TRIGGER

CU_COREDUMP_FILE

CU_COREDUMP_PIPE

CU_COREDUMP_GENERATION_FLAGS

CU_COREDUMP_MAX


### Functions

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuCoredumpGetAttribute ( [CUcoredumpSettings](<group__CUDA__COREDUMP.html#group__CUDA__COREDUMP_1g9b1cc417bdebfe4230e6dba3ea3d5b62>)Â attrib, void*Â value, size_t*Â size )


Allows caller to fetch a coredump attribute value for the current context.

######  Parameters

`attrib`
    \- The enum defining which value to fetch.
`value`
    \- void* containing the requested data.
`size`
    \- The size of the memory region `value` points to.

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>), [CUDA_ERROR_NOT_PERMITTED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9e23d0197c490ec332a43e55b167968a3>), [CUDA_ERROR_DEINITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9acf52f132faf29b473cdda6061f0f44a>), [CUDA_ERROR_NOT_INITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e98feb999f0af99b4a25ab26b3866f4df8>), [CUDA_ERROR_INVALID_CONTEXT](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a484e9af32c1e9893ff21f0e0191a12d>), [CUDA_ERROR_CONTEXT_IS_DESTROYED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9b27ac43f7ce8446f5c9636dd73fb2139>)

###### Description

Returns in `*value` the requested value specified by `attrib`. It is up to the caller to ensure that the data type and size of `*value` matches the request.

If the caller calls this function with `*value` equal to NULL, the size of the memory region (in bytes) expected for `attrib` will be placed in `size`.

The supported attributes are:

  * CU_COREDUMP_ENABLE_ON_EXCEPTION: Bool where true means that GPU exceptions from this context will create a coredump at the location specified by CU_COREDUMP_FILE. The default value is false unless set to true globally or locally, or the CU_CTX_USER_COREDUMP_ENABLE flag was set during context creation.

  * CU_COREDUMP_TRIGGER_HOST: Bool where true means that the host CPU will also create a coredump. The default value is true unless set to false globally or or locally. This value is deprecated as of CUDA 12.5 - raise the CU_COREDUMP_SKIP_ABORT flag to disable host device abort() if needed.

  * CU_COREDUMP_LIGHTWEIGHT: Bool where true means that any resulting coredumps will not have a dump of GPU memory or non-reloc ELF images. The default value is false unless set to true globally or locally. This attribute is deprecated as of CUDA 12.5, please use CU_COREDUMP_GENERATION_FLAGS instead.

  * CU_COREDUMP_ENABLE_USER_TRIGGER: Bool where true means that a coredump can be created by writing to the system pipe specified by CU_COREDUMP_PIPE. The default value is false unless set to true globally or locally.

  * CU_COREDUMP_FILE: String of up to 1023 characters that defines the location where any coredumps generated by this context will be written. The default value is core.cuda.HOSTNAME.PID where HOSTNAME is the host name of the machine running the CUDA applications and PID is the process ID of the CUDA application.

  * CU_COREDUMP_PIPE: String of up to 1023 characters that defines the name of the pipe that will be monitored if user-triggered coredumps are enabled. The default value is corepipe.cuda.HOSTNAME.PID where HOSTNAME is the host name of the machine running the CUDA application and PID is the process ID of the CUDA application.

  * CU_COREDUMP_GENERATION_FLAGS: An integer with values to allow granular control the data contained in a coredump specified as a bitwise OR combination of the following values: + CU_COREDUMP_DEFAULT_FLAGS - if set by itself, coredump generation returns to its default settings of including all memory regions that it is able to access + CU_COREDUMP_SKIP_NONRELOCATED_ELF_IMAGES \- Coredump will not include the data from CUDA source modules that are not relocated at runtime. + CU_COREDUMP_SKIP_GLOBAL_MEMORY \- Coredump will not include device-side global data that does not belong to any context. + CU_COREDUMP_SKIP_SHARED_MEMORY \- Coredump will not include grid-scale shared memory for the warp that the dumped kernel belonged to. + CU_COREDUMP_SKIP_LOCAL_MEMORY \- Coredump will not include local memory from the kernel. + CU_COREDUMP_LIGHTWEIGHT_FLAGS - Enables all of the above options. Equiavlent to setting the CU_COREDUMP_LIGHTWEIGHT attribute to true. + CU_COREDUMP_SKIP_ABORT - If set, GPU exceptions will not raise an abort() in the host CPU process. Same functional goal as CU_COREDUMP_TRIGGER_HOST but better reflects the default behavior.


**See also:**

[cuCoredumpGetAttributeGlobal](<group__CUDA__COREDUMP.html#group__CUDA__COREDUMP_1g5cb5b7ddf41a2c3631eed8d00c4ae819> "Allows caller to fetch a coredump attribute value for the entire application."), [cuCoredumpSetAttribute](<group__CUDA__COREDUMP.html#group__CUDA__COREDUMP_1g45b806050f3211e840eb3c8d91e93fcb> "Allows caller to set a coredump attribute value for the current context."), [cuCoredumpSetAttributeGlobal](<group__CUDA__COREDUMP.html#group__CUDA__COREDUMP_1ga7645a8f68dd5379a03852b462727990> "Allows caller to set a coredump attribute value globally.")

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuCoredumpGetAttributeGlobal ( [CUcoredumpSettings](<group__CUDA__COREDUMP.html#group__CUDA__COREDUMP_1g9b1cc417bdebfe4230e6dba3ea3d5b62>)Â attrib, void*Â value, size_t*Â size )


Allows caller to fetch a coredump attribute value for the entire application.

######  Parameters

`attrib`
    \- The enum defining which value to fetch.
`value`
    \- void* containing the requested data.
`size`
    \- The size of the memory region `value` points to.

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>)

###### Description

Returns in `*value` the requested value specified by `attrib`. It is up to the caller to ensure that the data type and size of `*value` matches the request.

If the caller calls this function with `*value` equal to NULL, the size of the memory region (in bytes) expected for `attrib` will be placed in `size`.

The supported attributes are:

  * CU_COREDUMP_ENABLE_ON_EXCEPTION: Bool where true means that GPU exceptions from this context will create a coredump at the location specified by CU_COREDUMP_FILE. The default value is false.

  * CU_COREDUMP_TRIGGER_HOST: Bool where true means that the host CPU will also create a coredump. The default value is true unless set to false globally or or locally. This value is deprecated as of CUDA 12.5 - raise the CU_COREDUMP_SKIP_ABORT flag to disable host device abort() if needed.

  * CU_COREDUMP_LIGHTWEIGHT: Bool where true means that any resulting coredumps will not have a dump of GPU memory or non-reloc ELF images. The default value is false. This attribute is deprecated as of CUDA 12.5, please use CU_COREDUMP_GENERATION_FLAGS instead.

  * CU_COREDUMP_ENABLE_USER_TRIGGER: Bool where true means that a coredump can be created by writing to the system pipe specified by CU_COREDUMP_PIPE. The default value is false.

  * CU_COREDUMP_FILE: String of up to 1023 characters that defines the location where any coredumps generated by this context will be written. The default value is core.cuda.HOSTNAME.PID where HOSTNAME is the host name of the machine running the CUDA applications and PID is the process ID of the CUDA application.

  * CU_COREDUMP_PIPE: String of up to 1023 characters that defines the name of the pipe that will be monitored if user-triggered coredumps are enabled. The default value is corepipe.cuda.HOSTNAME.PID where HOSTNAME is the host name of the machine running the CUDA application and PID is the process ID of the CUDA application.

  * CU_COREDUMP_GENERATION_FLAGS: An integer with values to allow granular control the data contained in a coredump specified as a bitwise OR combination of the following values: + CU_COREDUMP_DEFAULT_FLAGS - if set by itself, coredump generation returns to its default settings of including all memory regions that it is able to access + CU_COREDUMP_SKIP_NONRELOCATED_ELF_IMAGES \- Coredump will not include the data from CUDA source modules that are not relocated at runtime. + CU_COREDUMP_SKIP_GLOBAL_MEMORY \- Coredump will not include device-side global data that does not belong to any context. + CU_COREDUMP_SKIP_SHARED_MEMORY \- Coredump will not include grid-scale shared memory for the warp that the dumped kernel belonged to. + CU_COREDUMP_SKIP_LOCAL_MEMORY \- Coredump will not include local memory from the kernel. + CU_COREDUMP_LIGHTWEIGHT_FLAGS - Enables all of the above options. Equiavlent to setting the CU_COREDUMP_LIGHTWEIGHT attribute to true. + CU_COREDUMP_SKIP_ABORT - If set, GPU exceptions will not raise an abort() in the host CPU process. Same functional goal as CU_COREDUMP_TRIGGER_HOST but better reflects the default behavior.


**See also:**

[cuCoredumpGetAttribute](<group__CUDA__COREDUMP.html#group__CUDA__COREDUMP_1g56d7eb4975c7eb8e2b4eb0713fd8cedd> "Allows caller to fetch a coredump attribute value for the current context."), [cuCoredumpSetAttribute](<group__CUDA__COREDUMP.html#group__CUDA__COREDUMP_1g45b806050f3211e840eb3c8d91e93fcb> "Allows caller to set a coredump attribute value for the current context."), [cuCoredumpSetAttributeGlobal](<group__CUDA__COREDUMP.html#group__CUDA__COREDUMP_1ga7645a8f68dd5379a03852b462727990> "Allows caller to set a coredump attribute value globally.")

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuCoredumpSetAttribute ( [CUcoredumpSettings](<group__CUDA__COREDUMP.html#group__CUDA__COREDUMP_1g9b1cc417bdebfe4230e6dba3ea3d5b62>)Â attrib, void*Â value, size_t*Â size )


Allows caller to set a coredump attribute value for the current context.

######  Parameters

`attrib`
    \- The enum defining which value to set.
`value`
    \- void* containing the requested data.
`size`
    \- The size of the memory region `value` points to.

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>), [CUDA_ERROR_NOT_PERMITTED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9e23d0197c490ec332a43e55b167968a3>), [CUDA_ERROR_DEINITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9acf52f132faf29b473cdda6061f0f44a>), [CUDA_ERROR_NOT_INITIALIZED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e98feb999f0af99b4a25ab26b3866f4df8>), [CUDA_ERROR_INVALID_CONTEXT](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a484e9af32c1e9893ff21f0e0191a12d>), [CUDA_ERROR_CONTEXT_IS_DESTROYED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9b27ac43f7ce8446f5c9636dd73fb2139>), [CUDA_ERROR_NOT_SUPPORTED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e954756ae7ade0dfd09faeccb513dd831b>)

###### Description

This function should be considered an alternate interface to the CUDA-GDB environment variables defined in this document: <https://docs.nvidia.com/cuda/cuda-gdb/index.html#gpu-coredump>

An important design decision to note is that any coredump environment variable values set before CUDA initializes will take permanent precedence over any values set with this function. This decision was made to ensure no change in behavior for any users that may be currently using these variables to get coredumps.

`*value` shall contain the requested value specified by `set`. It is up to the caller to ensure that the data type and size of `*value` matches the request.

If the caller calls this function with `*value` equal to NULL, the size of the memory region (in bytes) expected for `set` will be placed in `size`.

/note This function will return [CUDA_ERROR_NOT_SUPPORTED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e954756ae7ade0dfd09faeccb513dd831b>) if the caller attempts to set CU_COREDUMP_ENABLE_ON_EXCEPTION on a GPU of with Compute Capability < 6.0. [cuCoredumpSetAttributeGlobal](<group__CUDA__COREDUMP.html#group__CUDA__COREDUMP_1ga7645a8f68dd5379a03852b462727990> "Allows caller to set a coredump attribute value globally.") works on those platforms as an alternative.

/note CU_COREDUMP_ENABLE_USER_TRIGGER and CU_COREDUMP_PIPE cannot be set on a per-context basis.

The supported attributes are:

  * CU_COREDUMP_ENABLE_ON_EXCEPTION: Bool where true means that GPU exceptions from this context will create a coredump at the location specified by CU_COREDUMP_FILE. The default value is false.

  * CU_COREDUMP_TRIGGER_HOST: Bool where true means that the host CPU will also create a coredump. The default value is true unless set to false globally or or locally. This value is deprecated as of CUDA 12.5 - raise the CU_COREDUMP_SKIP_ABORT flag to disable host device abort() if needed.

  * CU_COREDUMP_LIGHTWEIGHT: Bool where true means that any resulting coredumps will not have a dump of GPU memory or non-reloc ELF images. The default value is false. This attribute is deprecated as of CUDA 12.5, please use CU_COREDUMP_GENERATION_FLAGS instead.

  * CU_COREDUMP_FILE: String of up to 1023 characters that defines the location where any coredumps generated by this context will be written. The default value is core.cuda.HOSTNAME.PID where HOSTNAME is the host name of the machine running the CUDA applications and PID is the process ID of the CUDA application.

  * CU_COREDUMP_GENERATION_FLAGS: An integer with values to allow granular control the data contained in a coredump specified as a bitwise OR combination of the following values: + CU_COREDUMP_DEFAULT_FLAGS - if set by itself, coredump generation returns to its default settings of including all memory regions that it is able to access + CU_COREDUMP_SKIP_NONRELOCATED_ELF_IMAGES \- Coredump will not include the data from CUDA source modules that are not relocated at runtime. + CU_COREDUMP_SKIP_GLOBAL_MEMORY \- Coredump will not include device-side global data that does not belong to any context. + CU_COREDUMP_SKIP_SHARED_MEMORY \- Coredump will not include grid-scale shared memory for the warp that the dumped kernel belonged to. + CU_COREDUMP_SKIP_LOCAL_MEMORY \- Coredump will not include local memory from the kernel. + CU_COREDUMP_LIGHTWEIGHT_FLAGS - Enables all of the above options. Equiavlent to setting the CU_COREDUMP_LIGHTWEIGHT attribute to true. + CU_COREDUMP_SKIP_ABORT - If set, GPU exceptions will not raise an abort() in the host CPU process. Same functional goal as CU_COREDUMP_TRIGGER_HOST but better reflects the default behavior.


**See also:**

[cuCoredumpGetAttributeGlobal](<group__CUDA__COREDUMP.html#group__CUDA__COREDUMP_1g5cb5b7ddf41a2c3631eed8d00c4ae819> "Allows caller to fetch a coredump attribute value for the entire application."), [cuCoredumpGetAttribute](<group__CUDA__COREDUMP.html#group__CUDA__COREDUMP_1g56d7eb4975c7eb8e2b4eb0713fd8cedd> "Allows caller to fetch a coredump attribute value for the current context."), [cuCoredumpSetAttributeGlobal](<group__CUDA__COREDUMP.html#group__CUDA__COREDUMP_1ga7645a8f68dd5379a03852b462727990> "Allows caller to set a coredump attribute value globally.")

[CUresult](<group__CUDA__TYPES.html#group__CUDA__TYPES_1gc6c391505e117393cc2558fff6bfc2e9>) cuCoredumpSetAttributeGlobal ( [CUcoredumpSettings](<group__CUDA__COREDUMP.html#group__CUDA__COREDUMP_1g9b1cc417bdebfe4230e6dba3ea3d5b62>)Â attrib, void*Â value, size_t*Â size )


Allows caller to set a coredump attribute value globally.

######  Parameters

`attrib`
    \- The enum defining which value to set.
`value`
    \- void* containing the requested data.
`size`
    \- The size of the memory region `value` points to.

###### Returns

[CUDA_SUCCESS](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9a0eed720f8a87cd1c5fd1c453bc7a03d>), [CUDA_ERROR_INVALID_VALUE](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e990696c86fcee1f536a1ec7d25867feeb>), [CUDA_ERROR_NOT_PERMITTED](<group__CUDA__TYPES.html#group__CUDA__TYPES_1ggc6c391505e117393cc2558fff6bfc2e9e23d0197c490ec332a43e55b167968a3>)

###### Description

This function should be considered an alternate interface to the CUDA-GDB environment variables defined in this document: <https://docs.nvidia.com/cuda/cuda-gdb/index.html#gpu-coredump>

An important design decision to note is that any coredump environment variable values set before CUDA initializes will take permanent precedence over any values set with this function. This decision was made to ensure no change in behavior for any users that may be currently using these variables to get coredumps.

`*value` shall contain the requested value specified by `set`. It is up to the caller to ensure that the data type and size of `*value` matches the request.

If the caller calls this function with `*value` equal to NULL, the size of the memory region (in bytes) expected for `set` will be placed in `size`.

The supported attributes are:

  * CU_COREDUMP_ENABLE_ON_EXCEPTION: Bool where true means that GPU exceptions from this context will create a coredump at the location specified by CU_COREDUMP_FILE. The default value is false.

  * CU_COREDUMP_TRIGGER_HOST: Bool where true means that the host CPU will also create a coredump. The default value is true unless set to false globally or or locally. This value is deprecated as of CUDA 12.5 - raise the CU_COREDUMP_SKIP_ABORT flag to disable host device abort() if needed.

  * CU_COREDUMP_LIGHTWEIGHT: Bool where true means that any resulting coredumps will not have a dump of GPU memory or non-reloc ELF images. The default value is false. This attribute is deprecated as of CUDA 12.5, please use CU_COREDUMP_GENERATION_FLAGS instead.

  * CU_COREDUMP_ENABLE_USER_TRIGGER: Bool where true means that a coredump can be created by writing to the system pipe specified by CU_COREDUMP_PIPE. The default value is false.

  * CU_COREDUMP_FILE: String of up to 1023 characters that defines the location where any coredumps generated by this context will be written. The default value is core.cuda.HOSTNAME.PID where HOSTNAME is the host name of the machine running the CUDA applications and PID is the process ID of the CUDA application.

  * CU_COREDUMP_PIPE: String of up to 1023 characters that defines the name of the pipe that will be monitored if user-triggered coredumps are enabled. This value may not be changed after CU_COREDUMP_ENABLE_USER_TRIGGER is set to true. The default value is corepipe.cuda.HOSTNAME.PID where HOSTNAME is the host name of the machine running the CUDA application and PID is the process ID of the CUDA application.

  * CU_COREDUMP_GENERATION_FLAGS: An integer with values to allow granular control the data contained in a coredump specified as a bitwise OR combination of the following values: + CU_COREDUMP_DEFAULT_FLAGS - if set by itself, coredump generation returns to its default settings of including all memory regions that it is able to access + CU_COREDUMP_SKIP_NONRELOCATED_ELF_IMAGES \- Coredump will not include the data from CUDA source modules that are not relocated at runtime. + CU_COREDUMP_SKIP_GLOBAL_MEMORY \- Coredump will not include device-side global data that does not belong to any context. + CU_COREDUMP_SKIP_SHARED_MEMORY \- Coredump will not include grid-scale shared memory for the warp that the dumped kernel belonged to. + CU_COREDUMP_SKIP_LOCAL_MEMORY \- Coredump will not include local memory from the kernel. + CU_COREDUMP_LIGHTWEIGHT_FLAGS - Enables all of the above options. Equiavlent to setting the CU_COREDUMP_LIGHTWEIGHT attribute to true. + CU_COREDUMP_SKIP_ABORT - If set, GPU exceptions will not raise an abort() in the host CPU process. Same functional goal as CU_COREDUMP_TRIGGER_HOST but better reflects the default behavior.


**See also:**

[cuCoredumpGetAttribute](<group__CUDA__COREDUMP.html#group__CUDA__COREDUMP_1g56d7eb4975c7eb8e2b4eb0713fd8cedd> "Allows caller to fetch a coredump attribute value for the current context."), [cuCoredumpGetAttributeGlobal](<group__CUDA__COREDUMP.html#group__CUDA__COREDUMP_1g5cb5b7ddf41a2c3631eed8d00c4ae819> "Allows caller to fetch a coredump attribute value for the entire application."), [cuCoredumpSetAttribute](<group__CUDA__COREDUMP.html#group__CUDA__COREDUMP_1g45b806050f3211e840eb3c8d91e93fcb> "Allows caller to set a coredump attribute value for the current context.")

* * *


---

# Data Structures

## 7.Â Data Structures

Here are the data structures with brief descriptions:

[CU_DEV_SM_RESOURCE_GROUP_PARAMS](<structCU__DEV__SM__RESOURCE__GROUP__PARAMS.html#structCU__DEV__SM__RESOURCE__GROUP__PARAMS>)

[CUaccessPolicyWindow_v1](<structCUaccessPolicyWindow__v1.html#structCUaccessPolicyWindow__v1>)

[CUarrayMapInfo_v1](<structCUarrayMapInfo__v1.html#structCUarrayMapInfo__v1>)

[CUasyncNotificationInfo](<structCUasyncNotificationInfo.html#structCUasyncNotificationInfo>)

[CUcheckpointCheckpointArgs](<structCUcheckpointCheckpointArgs.html#structCUcheckpointCheckpointArgs>)

[CUcheckpointGpuPair](<structCUcheckpointGpuPair.html#structCUcheckpointGpuPair>)

[CUcheckpointLockArgs](<structCUcheckpointLockArgs.html#structCUcheckpointLockArgs>)

[CUcheckpointRestoreArgs](<structCUcheckpointRestoreArgs.html#structCUcheckpointRestoreArgs>)

[CUcheckpointUnlockArgs](<structCUcheckpointUnlockArgs.html#structCUcheckpointUnlockArgs>)

[CUctxCigParam](<structCUctxCigParam.html#structCUctxCigParam>)

[CUctxCreateParams](<structCUctxCreateParams.html#structCUctxCreateParams>)

[CUDA_ARRAY3D_DESCRIPTOR_v2](<structCUDA__ARRAY3D__DESCRIPTOR__v2.html#structCUDA__ARRAY3D__DESCRIPTOR__v2>)

[CUDA_ARRAY_DESCRIPTOR_v2](<structCUDA__ARRAY__DESCRIPTOR__v2.html#structCUDA__ARRAY__DESCRIPTOR__v2>)

[CUDA_ARRAY_MEMORY_REQUIREMENTS_v1](<structCUDA__ARRAY__MEMORY__REQUIREMENTS__v1.html#structCUDA__ARRAY__MEMORY__REQUIREMENTS__v1>)

[CUDA_ARRAY_SPARSE_PROPERTIES_v1](<structCUDA__ARRAY__SPARSE__PROPERTIES__v1.html#structCUDA__ARRAY__SPARSE__PROPERTIES__v1>)

[CUDA_BATCH_MEM_OP_NODE_PARAMS_v1](<structCUDA__BATCH__MEM__OP__NODE__PARAMS__v1.html#structCUDA__BATCH__MEM__OP__NODE__PARAMS__v1>)

[CUDA_BATCH_MEM_OP_NODE_PARAMS_v2](<structCUDA__BATCH__MEM__OP__NODE__PARAMS__v2.html>)

[CUDA_CHILD_GRAPH_NODE_PARAMS](<structCUDA__CHILD__GRAPH__NODE__PARAMS.html#structCUDA__CHILD__GRAPH__NODE__PARAMS>)

[CUDA_CONDITIONAL_NODE_PARAMS](<structCUDA__CONDITIONAL__NODE__PARAMS.html#structCUDA__CONDITIONAL__NODE__PARAMS>)

[CUDA_EVENT_RECORD_NODE_PARAMS](<structCUDA__EVENT__RECORD__NODE__PARAMS.html#structCUDA__EVENT__RECORD__NODE__PARAMS>)

[CUDA_EVENT_WAIT_NODE_PARAMS](<structCUDA__EVENT__WAIT__NODE__PARAMS.html#structCUDA__EVENT__WAIT__NODE__PARAMS>)

[CUDA_EXT_SEM_SIGNAL_NODE_PARAMS_v1](<structCUDA__EXT__SEM__SIGNAL__NODE__PARAMS__v1.html#structCUDA__EXT__SEM__SIGNAL__NODE__PARAMS__v1>)

[CUDA_EXT_SEM_SIGNAL_NODE_PARAMS_v2](<structCUDA__EXT__SEM__SIGNAL__NODE__PARAMS__v2.html#structCUDA__EXT__SEM__SIGNAL__NODE__PARAMS__v2>)

[CUDA_EXT_SEM_WAIT_NODE_PARAMS_v1](<structCUDA__EXT__SEM__WAIT__NODE__PARAMS__v1.html#structCUDA__EXT__SEM__WAIT__NODE__PARAMS__v1>)

[CUDA_EXT_SEM_WAIT_NODE_PARAMS_v2](<structCUDA__EXT__SEM__WAIT__NODE__PARAMS__v2.html#structCUDA__EXT__SEM__WAIT__NODE__PARAMS__v2>)

[CUDA_EXTERNAL_MEMORY_BUFFER_DESC_v1](<structCUDA__EXTERNAL__MEMORY__BUFFER__DESC__v1.html#structCUDA__EXTERNAL__MEMORY__BUFFER__DESC__v1>)

[CUDA_EXTERNAL_MEMORY_HANDLE_DESC_v1](<structCUDA__EXTERNAL__MEMORY__HANDLE__DESC__v1.html#structCUDA__EXTERNAL__MEMORY__HANDLE__DESC__v1>)

[CUDA_EXTERNAL_MEMORY_MIPMAPPED_ARRAY_DESC_v1](<structCUDA__EXTERNAL__MEMORY__MIPMAPPED__ARRAY__DESC__v1.html#structCUDA__EXTERNAL__MEMORY__MIPMAPPED__ARRAY__DESC__v1>)

[CUDA_EXTERNAL_SEMAPHORE_HANDLE_DESC_v1](<structCUDA__EXTERNAL__SEMAPHORE__HANDLE__DESC__v1.html#structCUDA__EXTERNAL__SEMAPHORE__HANDLE__DESC__v1>)

[CUDA_EXTERNAL_SEMAPHORE_SIGNAL_PARAMS_v1](<structCUDA__EXTERNAL__SEMAPHORE__SIGNAL__PARAMS__v1.html#structCUDA__EXTERNAL__SEMAPHORE__SIGNAL__PARAMS__v1>)

[CUDA_EXTERNAL_SEMAPHORE_WAIT_PARAMS_v1](<structCUDA__EXTERNAL__SEMAPHORE__WAIT__PARAMS__v1.html#structCUDA__EXTERNAL__SEMAPHORE__WAIT__PARAMS__v1>)

[CUDA_GRAPH_INSTANTIATE_PARAMS](<structCUDA__GRAPH__INSTANTIATE__PARAMS.html#structCUDA__GRAPH__INSTANTIATE__PARAMS>)

[CUDA_HOST_NODE_PARAMS_v1](<structCUDA__HOST__NODE__PARAMS__v1.html#structCUDA__HOST__NODE__PARAMS__v1>)

[CUDA_HOST_NODE_PARAMS_v2](<structCUDA__HOST__NODE__PARAMS__v2.html#structCUDA__HOST__NODE__PARAMS__v2>)

[CUDA_KERNEL_NODE_PARAMS_v1](<structCUDA__KERNEL__NODE__PARAMS__v1.html#structCUDA__KERNEL__NODE__PARAMS__v1>)

[CUDA_KERNEL_NODE_PARAMS_v2](<structCUDA__KERNEL__NODE__PARAMS__v2.html#structCUDA__KERNEL__NODE__PARAMS__v2>)

[CUDA_KERNEL_NODE_PARAMS_v3](<structCUDA__KERNEL__NODE__PARAMS__v3.html#structCUDA__KERNEL__NODE__PARAMS__v3>)

[CUDA_LAUNCH_PARAMS_v1](<structCUDA__LAUNCH__PARAMS__v1.html#structCUDA__LAUNCH__PARAMS__v1>)

[CUDA_MEM_ALLOC_NODE_PARAMS_v1](<structCUDA__MEM__ALLOC__NODE__PARAMS__v1.html#structCUDA__MEM__ALLOC__NODE__PARAMS__v1>)

[CUDA_MEM_ALLOC_NODE_PARAMS_v2](<structCUDA__MEM__ALLOC__NODE__PARAMS__v2.html#structCUDA__MEM__ALLOC__NODE__PARAMS__v2>)

[CUDA_MEM_FREE_NODE_PARAMS](<structCUDA__MEM__FREE__NODE__PARAMS.html#structCUDA__MEM__FREE__NODE__PARAMS>)

[CUDA_MEMCPY2D_v2](<structCUDA__MEMCPY2D__v2.html#structCUDA__MEMCPY2D__v2>)

[CUDA_MEMCPY3D_PEER_v1](<structCUDA__MEMCPY3D__PEER__v1.html#structCUDA__MEMCPY3D__PEER__v1>)

[CUDA_MEMCPY3D_v2](<structCUDA__MEMCPY3D__v2.html#structCUDA__MEMCPY3D__v2>)

[CUDA_MEMCPY_NODE_PARAMS](<structCUDA__MEMCPY__NODE__PARAMS.html#structCUDA__MEMCPY__NODE__PARAMS>)

[CUDA_MEMSET_NODE_PARAMS_v1](<structCUDA__MEMSET__NODE__PARAMS__v1.html#structCUDA__MEMSET__NODE__PARAMS__v1>)

[CUDA_MEMSET_NODE_PARAMS_v2](<structCUDA__MEMSET__NODE__PARAMS__v2.html#structCUDA__MEMSET__NODE__PARAMS__v2>)

[CUDA_POINTER_ATTRIBUTE_P2P_TOKENS_v1](<structCUDA__POINTER__ATTRIBUTE__P2P__TOKENS__v1.html#structCUDA__POINTER__ATTRIBUTE__P2P__TOKENS__v1>)

[CUDA_RESOURCE_DESC_v1](<structCUDA__RESOURCE__DESC__v1.html#structCUDA__RESOURCE__DESC__v1>)

[CUDA_RESOURCE_VIEW_DESC_v1](<structCUDA__RESOURCE__VIEW__DESC__v1.html#structCUDA__RESOURCE__VIEW__DESC__v1>)

[CUDA_TEXTURE_DESC_v1](<structCUDA__TEXTURE__DESC__v1.html#structCUDA__TEXTURE__DESC__v1>)

[CUdevprop_v1](<structCUdevprop__v1.html#structCUdevprop__v1>)

[CUdevResource](<structCUdevResource.html#structCUdevResource>)

[CUdevSmResource](<structCUdevSmResource.html#structCUdevSmResource>)

[CUdevWorkqueueConfigResource](<structCUdevWorkqueueConfigResource.html#structCUdevWorkqueueConfigResource>)

[CUdevWorkqueueResource](<structCUdevWorkqueueResource.html#structCUdevWorkqueueResource>)

[CUeglFrame_v1](<structCUeglFrame__v1.html#structCUeglFrame__v1>)

[CUexecAffinityParam_v1](<structCUexecAffinityParam__v1.html#structCUexecAffinityParam__v1>)

[CUexecAffinitySmCount_v1](<structCUexecAffinitySmCount__v1.html#structCUexecAffinitySmCount__v1>)

[CUextent3D_v1](<structCUextent3D__v1.html#structCUextent3D__v1>)

[CUgraphEdgeData](<structCUgraphEdgeData.html#structCUgraphEdgeData>)

[CUgraphExecUpdateResultInfo_v1](<structCUgraphExecUpdateResultInfo__v1.html#structCUgraphExecUpdateResultInfo__v1>)

[CUgraphNodeParams](<structCUgraphNodeParams.html#structCUgraphNodeParams>)

[CUipcEventHandle_v1](<structCUipcEventHandle__v1.html#structCUipcEventHandle__v1>)

[CUipcMemHandle_v1](<structCUipcMemHandle__v1.html#structCUipcMemHandle__v1>)

[CUlaunchAttribute](<structCUlaunchAttribute.html#structCUlaunchAttribute>)

[CUlaunchAttributeValue](<unionCUlaunchAttributeValue.html#unionCUlaunchAttributeValue>)

[CUlaunchConfig](<structCUlaunchConfig.html#structCUlaunchConfig>)

[CUlaunchMemSyncDomainMap](<structCUlaunchMemSyncDomainMap.html#structCUlaunchMemSyncDomainMap>)

[CUmemAccessDesc_v1](<structCUmemAccessDesc__v1.html#structCUmemAccessDesc__v1>)

[CUmemAllocationProp_v1](<structCUmemAllocationProp__v1.html#structCUmemAllocationProp__v1>)

[CUmemcpy3DOperand_v1](<structCUmemcpy3DOperand__v1.html#structCUmemcpy3DOperand__v1>)

[CUmemcpyAttributes_v1](<structCUmemcpyAttributes__v1.html#structCUmemcpyAttributes__v1>)

[CUmemDecompressParams](<structCUmemDecompressParams.html#structCUmemDecompressParams> "Structure describing the parameters that compose a single decompression operation.")
    Structure describing the parameters that compose a single decompression operation
[CUmemFabricHandle_v1](<structCUmemFabricHandle__v1.html#structCUmemFabricHandle__v1>)

[CUmemLocation_v1](<structCUmemLocation__v1.html#structCUmemLocation__v1>)

[CUmemPoolProps_v1](<structCUmemPoolProps__v1.html#structCUmemPoolProps__v1>)

[CUmemPoolPtrExportData_v1](<structCUmemPoolPtrExportData__v1.html#structCUmemPoolPtrExportData__v1>)

[CUmulticastObjectProp_v1](<structCUmulticastObjectProp__v1.html#structCUmulticastObjectProp__v1>)

[CUoffset3D_v1](<structCUoffset3D__v1.html#structCUoffset3D__v1>)

[CUstreamBatchMemOpParams_v1](<unionCUstreamBatchMemOpParams__v1.html#unionCUstreamBatchMemOpParams__v1>)

[CUtensorMap](<structCUtensorMap.html#structCUtensorMap>)


* * *


---

