#!/usr/bin/env python3
"""Build submission.py by traversing the compile.py graph.

Expected inputs (relative to repo root by default):
  - compile.py graph (which reads cuda_lib/* by default)
  - ptx_lib/*.cuh

Use --compile to regenerate cuda_lib/* via compile.py.

This script only assembles submission.py; it does not run benchmarks.
"""

from __future__ import annotations

import argparse
import importlib.util
import re
import subprocess
import sys
from pathlib import Path
from typing import List

ROOT = Path(__file__).resolve().parent
REPO_ROOT = ROOT.parent
# ptx_lib lives at repo root (not nested under submission/)
PTX_LIB = REPO_ROOT / "ptx_lib"
COMPILER = ROOT / "compiler.py"

# Strip local ptx_lib includes since we inline headers into CUDA_SRC.
_PTX_INCLUDE_PREFIXES = (
    '#include "ptx_lib/',
    '#include "ptx_',
    '#include <ptx_',
    '#include "ptx_common.cuh"',
)


def _strip_ptx_includes(text: str) -> str:
    lines = []
    for line in text.splitlines():
        stripped = line.strip()
        if any(stripped.startswith(prefix) for prefix in _PTX_INCLUDE_PREFIXES):
            continue
        if stripped.startswith("#include") and "ptx_" in stripped and ".cuh" in stripped:
            continue
        lines.append(line)
    return "\n".join(lines)


def _read_text(path: Path) -> str:
    return path.read_text()


def _load_compiler(path: Path):
    if not path.exists():
        raise FileNotFoundError(f"compile.py not found: {path}")
    spec = importlib.util.spec_from_file_location("graph_compile", str(path))
    if spec is None or spec.loader is None:
        raise RuntimeError(f"Unable to load compiler module from {path}")
    module = importlib.util.module_from_spec(spec)
    sys.modules[spec.name] = module
    spec.loader.exec_module(module)
    return module


def _extract_ptx_functions(header_text: str) -> set[str]:
    names: set[str] = set()
    for line in header_text.splitlines():
        if "PTX_DEVICE" not in line and "__device__" not in line:
            continue
        m = re.search(r"\b([A-Za-z_][A-Za-z0-9_]*)\s*\(", line)
        if m:
            names.add(m.group(1))
    return names


def _select_ptx_headers(ptx_headers: list[Path], sources: list[str]) -> list[Path]:
    combined = "\n".join(sources)
    used_headers: list[Path] = []
    ptx_common = next((h for h in ptx_headers if h.name == "ptx_common.cuh"), None)
    for header in ptx_headers:
        if header.name == "ptx_common.cuh":
            continue
        names = _extract_ptx_functions(header.read_text())
        if any(re.search(rf"\b{re.escape(name)}\s*\(", combined) for name in names):
            used_headers.append(header)
    if used_headers and ptx_common is not None:
        return [ptx_common] + used_headers
    return used_headers if used_headers else ([ptx_common] if ptx_common else [])


def _collect_load_inline_nodes(nodes: List[object]) -> List[object]:
    collected: List[object] = []
    for node in nodes:
        kind = getattr(node, "kind", "")
        if kind == "LoadInline":
            collected.append(node)
        for child in getattr(node, "children", []) or []:
            collected.extend(_collect_load_inline_nodes([child]))
    return collected


def _emit_section_by_name(compiler, graph, section_name: str) -> str:
    return "".join(compiler._emit_nodes(graph.sections.get(section_name, []), indent=0))


def _build_cuda_src(
    header_paths: List[Path],
    device_text: str,
    host_text: str,
) -> str:
    selected_headers = _select_ptx_headers(header_paths, [device_text, host_text])
    parts: List[str] = []
    for header in selected_headers:
        parts.append(f"// ----- {header.name} -----\n")
        header_text = _strip_ptx_includes(_read_text(header))
        header_lines = []
        for line in header_text.splitlines():
            if line.strip().startswith("#pragma once"):
                continue
            header_lines.append(line)
        parts.append("\n".join(header_lines))
        if not parts[-1].endswith("\n"):
            parts.append("\n")
        parts.append("\n")

    parts.append("// ----- device.cuh -----\n")
    parts.append(_strip_ptx_includes(device_text))
    if not parts[-1].endswith("\n"):
        parts.append("\n")

    parts.append("// ----- host.cuh -----\n")
    parts.append(_strip_ptx_includes(host_text))
    if not parts[-1].endswith("\n"):
        parts.append("\n")
    return "".join(parts)


def _build_submission_from_graph(out_path: Path) -> None:
    if not PTX_LIB.exists():
        raise FileNotFoundError(f"ptx_lib not found: {PTX_LIB}")

    ptx_headers = sorted(PTX_LIB.glob("*.cuh"))
    if not ptx_headers:
        raise FileNotFoundError(f"No .cuh files found in {PTX_LIB}")

    parts: List[str] = []
    parts.append("# AUTO-GENERATED by run.py\n")
    parts.append("# Do not edit directly; edit cuda_lib/* and ptx_lib/*.cuh instead.\n\n")
    compiler = _load_compiler(COMPILER)
    graph = compiler.build_gemm1_graph()

    load_inline_nodes = _collect_load_inline_nodes(graph.sections.get("python", []))
    cuda_var_to_sections: dict[str, list[str]] = {}
    for node in load_inline_nodes:
        var = node.args.get("cuda_src_var", "CUDA_SRC")
        sections = node.args.get("sections") or ["device", "host"]
        if var in cuda_var_to_sections and cuda_var_to_sections[var] != sections:
            raise ValueError(f"Conflicting sections for {var}: {cuda_var_to_sections[var]} vs {sections}")
        cuda_var_to_sections[var] = sections
    if not cuda_var_to_sections:
        cuda_var_to_sections["CUDA_SRC"] = ["device", "host"]

    python_src = "".join(compiler._emit_nodes(graph.sections.get("python", []), indent=0))

    for var_name, sections in cuda_var_to_sections.items():
        device_chunks: List[str] = []
        host_chunks: List[str] = []
        for section in sections:
            section_text = _emit_section_by_name(compiler, graph, section)
            if section.startswith("device"):
                device_chunks.append(section_text)
            elif section.startswith("host"):
                host_chunks.append(section_text)
            else:
                device_chunks.append(section_text)
        device_src = "".join(device_chunks)
        host_src = "".join(host_chunks)
        cuda_src = _build_cuda_src(ptx_headers, device_src, host_src)
        parts.append(f"{var_name} = r'''\n")
        parts.append(cuda_src)
        parts.append("'''\n\n")

    # Append python snippet verbatim; it should reference CUDA_SRC
    parts.append(_strip_ptx_includes(python_src))
    if not parts[-1].endswith("\n"):
        parts.append("\n")

    out_path.write_text("".join(parts))


def main() -> int:
    parser = argparse.ArgumentParser(description="Build submission.py")
    parser.add_argument("--snippets-dir", default="cuda_lib", help="Unused (graph defines sources)")
    parser.add_argument("--python", default="python.py", help="Unused (graph defines sources)")
    parser.add_argument("--host", default="host.cuh", help="Unused (graph defines sources)")
    parser.add_argument("--device", default="device.cuh", help="Unused (graph defines sources)")
    parser.add_argument("--out", default="submission.py", help="Output submission.py path")
    parser.add_argument("--compile", action="store_true", help="Run compile.py to regenerate cuda_lib/*")
    parser.add_argument("--build-only", action="store_true", help="Only build submission.py")
    parser.add_argument("args", nargs=argparse.REMAINDER, help="Unused; kept for compatibility")
    args = parser.parse_args()

    out_path = (ROOT / args.out).resolve()

    if args.compile:
        if not COMPILER.exists():
            raise FileNotFoundError(f"compile.py not found: {COMPILER}")
        ret = subprocess.call([sys.executable, str(COMPILER)])
        if ret != 0:
            raise SystemExit(ret)

    _build_submission_from_graph(out_path)
    return 0


if __name__ == "__main__":
    raise SystemExit(main())
